// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package eth

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// AnchorBlocksBlockHashWitness is an auto generated low-level Go binding around an user-defined struct.
type AnchorBlocksBlockHashWitness struct {
	Left  []byte
	Right []byte
}

// BeaconBlockHeader is an auto generated low-level Go binding around an user-defined struct.
type BeaconBlockHeader struct {
	Slot          uint64
	ProposerIndex uint64
	ParentRoot    [32]byte
	StateRoot     [32]byte
	BodyRoot      [32]byte
}

// BrevisProofData is an auto generated low-level Go binding around an user-defined struct.
type BrevisProofData struct {
	CommitHash    [32]byte
	VkHash        [32]byte
	AppCommitHash [32]byte
	AppVkHash     [32]byte
	SmtRoot       [32]byte
}

// ExecutionPayload is an auto generated low-level Go binding around an user-defined struct.
type ExecutionPayload struct {
	StateRoot   LeafWithBranch
	BlockHash   LeafWithBranch
	BlockNumber LeafWithBranch
}

// HeaderWithExecution is an auto generated low-level Go binding around an user-defined struct.
type HeaderWithExecution struct {
	Beacon        BeaconBlockHeader
	Execution     ExecutionPayload
	ExecutionRoot LeafWithBranch
}

// HooksCalls is an auto generated low-level Go binding around an user-defined struct.
type HooksCalls struct {
	BeforeInitialize     bool
	AfterInitialize      bool
	BeforeModifyPosition bool
	AfterModifyPosition  bool
	BeforeSwap           bool
	AfterSwap            bool
	BeforeDonate         bool
	AfterDonate          bool
}

// IAvsSigsVerifierBN254G1Point is an auto generated low-level Go binding around an user-defined struct.
type IAvsSigsVerifierBN254G1Point struct {
	X *big.Int
	Y *big.Int
}

// IAvsSigsVerifierBN254G2Point is an auto generated low-level Go binding around an user-defined struct.
type IAvsSigsVerifierBN254G2Point struct {
	X [2]*big.Int
	Y [2]*big.Int
}

// IAvsSigsVerifierNonSignerStakesAndSignature is an auto generated low-level Go binding around an user-defined struct.
type IAvsSigsVerifierNonSignerStakesAndSignature struct {
	NonSignerQuorumBitmapIndices []uint32
	NonSignerPubkeys             []IAvsSigsVerifierBN254G1Point
	QuorumApks                   []IAvsSigsVerifierBN254G1Point
	ApkG2                        IAvsSigsVerifierBN254G2Point
	Sigma                        IAvsSigsVerifierBN254G1Point
	QuorumApkIndices             []uint32
	TotalStakeIndices            []uint32
	NonSignerStakeIndices        [][]uint32
}

// IAvsSigsVerifierSigInfo is an auto generated low-level Go binding around an user-defined struct.
type IAvsSigsVerifierSigInfo struct {
	BlockNum uint64
	Params   IAvsSigsVerifierNonSignerStakesAndSignature
}

// IBeaconVerifierProof is an auto generated low-level Go binding around an user-defined struct.
type IBeaconVerifierProof struct {
	A          [2]*big.Int
	B          [2][2]*big.Int
	C          [2]*big.Int
	Commitment [2]*big.Int
}

// IBlockChunksBlockHashWitness is an auto generated low-level Go binding around an user-defined struct.
type IBlockChunksBlockHashWitness struct {
	ChainId        uint64
	BlkNum         uint32
	ClaimedBlkHash [32]byte
	PrevHash       [32]byte
	NumFinal       uint32
	MerkleProof    [7][32]byte
}

// IBrevisTypesCallback is an auto generated low-level Go binding around an user-defined struct.
type IBrevisTypesCallback struct {
	Target common.Address
	Gas    uint64
}

// IBrevisTypesRequestDataHash is an auto generated low-level Go binding around an user-defined struct.
type IBrevisTypesRequestDataHash struct {
	Hashes [][32]byte
	Root   [32]byte
}

// IBvnSigsVerifierSigInfo is an auto generated low-level Go binding around an user-defined struct.
type IBvnSigsVerifierSigInfo struct {
	Sigs    [][]byte
	Signers []common.Address
	Powers  []*big.Int
}

// IPoolManagerModifyPositionParams is an auto generated low-level Go binding around an user-defined struct.
type IPoolManagerModifyPositionParams struct {
	TickLower      *big.Int
	TickUpper      *big.Int
	LiquidityDelta *big.Int
}

// IPoolManagerSwapParams is an auto generated low-level Go binding around an user-defined struct.
type IPoolManagerSwapParams struct {
	ZeroForOne        bool
	AmountSpecified   *big.Int
	SqrtPriceLimitX96 *big.Int
}

// IReceiptVerifierLogInfo is an auto generated low-level Go binding around an user-defined struct.
type IReceiptVerifierLogInfo struct {
	Addr   common.Address
	Topics [][32]byte
	Data   []byte
}

// IReceiptVerifierReceiptInfo is an auto generated low-level Go binding around an user-defined struct.
type IReceiptVerifierReceiptInfo struct {
	Success bool
	ChainId uint64
	BlkHash [32]byte
	BlkNum  uint32
	BlkTime uint64
	Logs    []IReceiptVerifierLogInfo
}

// ISMTSmtUpdate is an auto generated low-level Go binding around an user-defined struct.
type ISMTSmtUpdate struct {
	NewSmtRoot          [32]byte
	EndBlockNum         uint64
	EndBlockHash        [32]byte
	NextChunkMerkleRoot [32]byte
	Proof               [8]*big.Int
	Commit              [2]*big.Int
	KnowledgeProof      [2]*big.Int
}

// ISlotValueVerifierSlotInfo is an auto generated low-level Go binding around an user-defined struct.
type ISlotValueVerifierSlotInfo struct {
	ChainId     uint64
	AddrHash    [32]byte
	BlkHash     [32]byte
	SlotKeyHash [32]byte
	SlotValue   [32]byte
	BlkNum      uint32
}

// ITxVerifierTxInfo is an auto generated low-level Go binding around an user-defined struct.
type ITxVerifierTxInfo struct {
	ChainId   uint64
	Nonce     uint64
	GasTipCap *big.Int
	GasFeeCap *big.Int
	Gas       *big.Int
	To        common.Address
	Value     *big.Int
	Data      []byte
	From      common.Address
	BlkNum    uint32
	BlkHash   [32]byte
	BlkTime   uint64
}

// LeafWithBranch is an auto generated low-level Go binding around an user-defined struct.
type LeafWithBranch struct {
	Leaf   [32]byte
	Branch [][32]byte
}

// LightClientOptimisticUpdate is an auto generated low-level Go binding around an user-defined struct.
type LightClientOptimisticUpdate struct {
	AttestedHeader HeaderWithExecution
	SyncAggregate  SyncAggregate
	SignatureSlot  uint64
}

// LightClientUpdate is an auto generated low-level Go binding around an user-defined struct.
type LightClientUpdate struct {
	AttestedHeader                    HeaderWithExecution
	FinalizedHeader                   HeaderWithExecution
	FinalityBranch                    [][32]byte
	NextSyncCommitteeRoot             [32]byte
	NextSyncCommitteeBranch           [][32]byte
	NextSyncCommitteePoseidonRoot     [32]byte
	NextSyncCommitteeRootMappingProof IBeaconVerifierProof
	SyncAggregate                     SyncAggregate
	SignatureSlot                     uint64
}

// PoolKey is an auto generated low-level Go binding around an user-defined struct.
type PoolKey struct {
	Currency0   common.Address
	Currency1   common.Address
	Fee         *big.Int
	TickSpacing *big.Int
	Hooks       common.Address
}

// PositionInfo is an auto generated low-level Go binding around an user-defined struct.
type PositionInfo struct {
	Liquidity                *big.Int
	FeeGrowthInside0LastX128 *big.Int
	FeeGrowthInside1LastX128 *big.Int
}

// SyncAggregate is an auto generated low-level Go binding around an user-defined struct.
type SyncAggregate struct {
	Participation uint64
	PoseidonRoot  [32]byte
	Commitment    *big.Int
	Proof         IBeaconVerifierProof
}

// TxTxInfo is an auto generated low-level Go binding around an user-defined struct.
type TxTxInfo struct {
	ChainId   uint64
	Nonce     uint64
	GasTipCap *big.Int
	GasFeeCap *big.Int
	Gas       *big.Int
	To        common.Address
	Value     *big.Int
	Data      []byte
	From      common.Address
}

// AddressMetaData contains all meta data concerning the Address contract.
var AddressMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea264697066735822122084316ae7f90ab02dedc5c08bd3c2dea313dd1e29a325b4271a7f1a5bcf89953864736f6c63430008140033",
}

// AddressABI is the input ABI used to generate the binding from.
// Deprecated: Use AddressMetaData.ABI instead.
var AddressABI = AddressMetaData.ABI

// AddressBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use AddressMetaData.Bin instead.
var AddressBin = AddressMetaData.Bin

// DeployAddress deploys a new Ethereum contract, binding an instance of Address to it.
func DeployAddress(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Address, error) {
	parsed, err := AddressMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(AddressBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Address{AddressCaller: AddressCaller{contract: contract}, AddressTransactor: AddressTransactor{contract: contract}, AddressFilterer: AddressFilterer{contract: contract}}, nil
}

// Address is an auto generated Go binding around an Ethereum contract.
type Address struct {
	AddressCaller     // Read-only binding to the contract
	AddressTransactor // Write-only binding to the contract
	AddressFilterer   // Log filterer for contract events
}

// AddressCaller is an auto generated read-only Go binding around an Ethereum contract.
type AddressCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AddressTransactor is an auto generated write-only Go binding around an Ethereum contract.
type AddressTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AddressFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type AddressFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AddressSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type AddressSession struct {
	Contract     *Address          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// AddressCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type AddressCallerSession struct {
	Contract *AddressCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// AddressTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type AddressTransactorSession struct {
	Contract     *AddressTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// AddressRaw is an auto generated low-level Go binding around an Ethereum contract.
type AddressRaw struct {
	Contract *Address // Generic contract binding to access the raw methods on
}

// AddressCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type AddressCallerRaw struct {
	Contract *AddressCaller // Generic read-only contract binding to access the raw methods on
}

// AddressTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type AddressTransactorRaw struct {
	Contract *AddressTransactor // Generic write-only contract binding to access the raw methods on
}

// NewAddress creates a new instance of Address, bound to a specific deployed contract.
func NewAddress(address common.Address, backend bind.ContractBackend) (*Address, error) {
	contract, err := bindAddress(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Address{AddressCaller: AddressCaller{contract: contract}, AddressTransactor: AddressTransactor{contract: contract}, AddressFilterer: AddressFilterer{contract: contract}}, nil
}

// NewAddressCaller creates a new read-only instance of Address, bound to a specific deployed contract.
func NewAddressCaller(address common.Address, caller bind.ContractCaller) (*AddressCaller, error) {
	contract, err := bindAddress(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &AddressCaller{contract: contract}, nil
}

// NewAddressTransactor creates a new write-only instance of Address, bound to a specific deployed contract.
func NewAddressTransactor(address common.Address, transactor bind.ContractTransactor) (*AddressTransactor, error) {
	contract, err := bindAddress(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &AddressTransactor{contract: contract}, nil
}

// NewAddressFilterer creates a new log filterer instance of Address, bound to a specific deployed contract.
func NewAddressFilterer(address common.Address, filterer bind.ContractFilterer) (*AddressFilterer, error) {
	contract, err := bindAddress(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &AddressFilterer{contract: contract}, nil
}

// bindAddress binds a generic wrapper to an already deployed contract.
func bindAddress(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := AddressMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Address *AddressRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Address.Contract.AddressCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Address *AddressRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Address.Contract.AddressTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Address *AddressRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Address.Contract.AddressTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Address *AddressCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Address.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Address *AddressTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Address.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Address *AddressTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Address.Contract.contract.Transact(opts, method, params...)
}

// AnchorBlocksMetaData contains all meta data concerning the AnchorBlocks contract.
var AnchorBlocksMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lightClient\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"}],\"name\":\"AnchorBlockUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addPausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"addProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"blocks\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isActiveProver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestBlockNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lightClient\",\"outputs\":[{\"internalType\":\"contractIEthereumLightClient\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numPausers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numProvers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pauserList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"proposerIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"parentRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"bodyRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBeaconBlockHeader\",\"name\":\"beacon\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"stateRoot\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockHash\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockNumber\",\"type\":\"tuple\"}],\"internalType\":\"structExecutionPayload\",\"name\":\"execution\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"executionRoot\",\"type\":\"tuple\"}],\"internalType\":\"structHeaderWithExecution\",\"name\":\"attestedHeader\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"participation\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"poseidonRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"commitment\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commitment\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIBeaconVerifier.Proof\",\"name\":\"proof\",\"type\":\"tuple\"}],\"internalType\":\"structSyncAggregate\",\"name\":\"syncAggregate\",\"type\":\"tuple\"},{\"internalType\":\"uint64\",\"name\":\"signatureSlot\",\"type\":\"uint64\"}],\"internalType\":\"structLightClientOptimisticUpdate\",\"name\":\"hb\",\"type\":\"tuple\"}],\"name\":\"processUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"proposerIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"parentRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"bodyRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBeaconBlockHeader\",\"name\":\"beacon\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"stateRoot\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockHash\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockNumber\",\"type\":\"tuple\"}],\"internalType\":\"structExecutionPayload\",\"name\":\"execution\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"executionRoot\",\"type\":\"tuple\"}],\"internalType\":\"structHeaderWithExecution\",\"name\":\"attestedHeader\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"participation\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"poseidonRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"commitment\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commitment\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIBeaconVerifier.Proof\",\"name\":\"proof\",\"type\":\"tuple\"}],\"internalType\":\"structSyncAggregate\",\"name\":\"syncAggregate\",\"type\":\"tuple\"},{\"internalType\":\"uint64\",\"name\":\"signatureSlot\",\"type\":\"uint64\"}],\"internalType\":\"structLightClientOptimisticUpdate\",\"name\":\"hb\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"left\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"right\",\"type\":\"bytes\"}],\"internalType\":\"structAnchorBlocks.BlockHashWitness[]\",\"name\":\"chainProof\",\"type\":\"tuple[]\"}],\"name\":\"processUpdateWithChainProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proverStates\",\"outputs\":[{\"internalType\":\"enumBrevisAccess.ProverState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"provers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removePausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"removeProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lightClient\",\"type\":\"address\"}],\"name\":\"setLightClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x6080346101ac57601f6200202738819003918201601f1916830192916001600160401b038411838510176101b057808392604095865283396020928391810103126101ac57516001600160a01b038082169290918390036101ac575f918254855191339082167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08680a36001600160a81b0319163360ff60a01b1981169190911784558352600182528483205460ff1661016c5750600254680100000000000000008110156101585760018101806002558110156101445790847f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f89260028552828520019360018060a01b03199433868254161790553381526001835220600160ff198254161790558451338152a1600554161760055551611e629081620001c58239f35b634e487b7160e01b83526032600452602483fd5b634e487b7160e01b83526041600452602483fd5b60649162461bcd60e51b82526004820152601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152fd5b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe60406080815260049081361015610014575f80fd5b5f803560e01c8063158535ff14610d885780632e3466f614610cfa5780633e553bab14610ca75780633f4ba83a14610ba757806346fbf68e146109285780634f4fef1814610b8957806358a16b4414610b6a5780635c975abb14610b45578063677625f2146109b55780636b2c0f551461097e5780636ef8d66d1461096457806380f51c121461092857806382dc1ec4146108f15780638456cb59146107d75780638da5cb5b146107b1578063a036e79914610761578063b5700e6814610739578063e6c6fcec146106e9578063e79b7a5114610690578063ec64842e14610633578063f25b3f991461060b578063f2fde38b14610520578063fabc74f5146104c7578063fb8cfb51146101a0578063fbbea34c1461017d5763fd1190ea1461013b575f80fd5b3461017a57602036600319011261017a578235925483101561017a57506001600160a01b0361016b602093610e00565b92905490519260031b1c168152f35b80fd5b50903461019c578160031936011261019c576020906007549051908152f35b5080fd5b509190346104c35760603660031901126104c35767ffffffffffffffff9180358381116104bf576101d49036908301610fca565b91602480359460449283358281116104bb57366023820112156104bb5780860135906101ff82610ed8565b9161020c84519384610e9d565b808352602094868685019260051b840101923684116104b757878101925b8484106104415750505050503389526003835260ff828a20541696600388101561042f5760018098036103ee578151156103ad5761026790611310565b9190978151890398891161039b57808a928c925b6102d4575b50505003610296578761029388886117f7565b80f35b5162461bcd60e51b8152938401526012908301527f696e76616c696420636861696e50726f6f66000000000000000000000000000090820152606490fd5b909192815184101561039557896102eb85846118c2565b515151036103545761034c908761034361030587866118c2565b515192610335836103168a896118c2565b5101518b5194859361032b82860180996118d6565b90815201906118d6565b03601f198101835282610e9d565b519020936118a0565b91908161027b565b855162461bcd60e51b8152808b018890526010818a01527f696e76616c6964206c656674206c656e00000000000000000000000000000000818b0152606490fd5b92610280565b634e487b7160e01b8b5260118852858bfd5b825162461bcd60e51b81528088018590526014818701527f696e76616c69642070726f6f66206c656e67746800000000000000000000000081880152606490fd5b825162461bcd60e51b81528088018590526012818701527f6e6f7420696e76616c69642070726f766572000000000000000000000000000081880152606490fd5b634e487b7160e01b8a5260218752848afd5b83358381116104b35782018760231982360301126104b35787519161046583610e35565b8a8201358581116104ae5761047f908c3691850101611293565b83528b820135928584116104ae5761049f8b94938d869536920101611293565b8382015281520193019261022a565b508f80fd5b8e80fd5b8c80fd5b8880fd5b8480fd5b8280fd5b50903461019c57602036600319011261019c576001600160a01b036104ea6111ee565b168252600360205260ff8183205416905191600382101561050d57602083838152f35b634e487b7160e01b815260218452602490fd5b5091346104c35760203660031901126104c35761053b6111ee565b908354906001600160a01b03808316936105563386146118ff565b169384156105a257505073ffffffffffffffffffffffffffffffffffffffff1916821783557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b906020608492519162461bcd60e51b8352820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152fd5b5091346104c35760203660031901126104c35760209282913581526006845220549051908152f35b5082903461017a57602036600319011261017a576001600160a01b036106576111ee565b168152600360205260ff838220541691600383101561067d576020836001865191148152f35b634e487b7160e01b825260219052602490fd5b503461017a5761069f36611204565b906001600160a01b03916106b78383541633146118ff565b815b81518110156106e557806106db856106d46106e094866118c2565b5116611b8b565b6118a0565b6106b9565b8280f35b503461017a576106f836611204565b906001600160a01b03916107108383541633146118ff565b815b81518110156106e557806106db8561072d61073494866118c2565b51166119b5565b610712565b50903461019c578160031936011261019c576020906001600160a01b03600554169051908152f35b503461017a5761077036611204565b906001600160a01b03916107888383541633146118ff565b815b81518110156106e557806106db856107a56107ac94866118c2565b5116611c70565b61078a565b50903461019c578160031936011261019c576001600160a01b0360209254169051908152f35b509190346104c357826003193601126104c35733835260019160209083825261080560ff8487205416611969565b845460ff8160a01c166108af5760ff60a01b197401000000000000000000000000000000000000000091161785557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258828451338152a184845b610866578580f35b81548110156108ab57806001600160a01b036108846108a593610e00565b919054600392831b1c1688528452848720600260ff198254161790556118a0565b8461085e565b8580f35b50915162461bcd60e51b815291820152601060248201527f5061757361626c653a20706175736564000000000000000000000000000000006044820152606490fd5b503461017a57602036600319011261017a5761029361090e6111ee565b6109236001600160a01b0384541633146118ff565b611b8b565b50903461019c57602036600319011261019c5760ff816020936001600160a01b036109516111ee565b1681526001855220541690519015158152f35b503461017a578060031936011261017a5761029333611c70565b503461017a57602036600319011261017a5761029361099b6111ee565b6109b06001600160a01b0384541633146118ff565b611c70565b503461017a576109c436611204565b918154906001600160a01b03916109de33848316146118ff565b60ff9060a01c811615610b3d576002925b845b86518110156108ab5781610a0582896118c2565b511680875260039060209180835285878a20541681811015610b2a57610ae7578a5468010000000000000000811015610ad45782610a4c828e6001610a6c95019055610e00565b90919082549060031b916001600160a01b03809116831b921b1916179055565b81895280835286892090881015610ac157917fef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd03968491610abc949360ff19815416888b161790558751908152a16118a0565b6109f1565b634e487b7160e01b895260218b52602489fd5b634e487b7160e01b8a5260418c5260248afd5b865162461bcd60e51b8152808c01849052601160248201527f6163636f756e742069732070726f7665720000000000000000000000000000006044820152606490fd5b634e487b7160e01b8a5260218c5260248afd5b6001926109ef565b50903461019c578160031936011261019c5760ff6020925460a01c1690519015158152f35b50903461019c578160031936011261019c576020906002549051908152f35b5091346104c357826003193601126104c35760209250549051908152f35b50903461019c578160031936011261019c573382526001906020828152610bd360ff8386205416611969565b83549460ff8660a01c1615610c665760ff60a01b198495961686557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa828451338152a185935b610c21578580f35b80548410156108ab57610c60846001600160a01b03610c408897610e00565b919054600392831b1c16895284528488208660ff198254161790556118a0565b93610c19565b915162461bcd60e51b815291820152601460248201527f5061757361626c653a206e6f74207061757365640000000000000000000000006044820152606490fd5b503461017a57602036600319011261017a57610cc16111ee565b6001600160a01b0390610cd88284541633146118ff565b1673ffffffffffffffffffffffffffffffffffffffff19600554161760055580f35b50823461019c57602036600319011261019c57803567ffffffffffffffff81116104c357610d2e610d339136908401610fca565b611310565b918215610d45575090610293916117f7565b606490602086519162461bcd60e51b8352820152600f60248201527f656d70747920626c6f636b4861736800000000000000000000000000000000006044820152fd5b5091346104c35760203660031901126104c357359160025483101561017a57506001600160a01b0361016b6020935b600254811015610dec5760025f527f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace01905f90565b634e487b7160e01b5f52603260045260245ffd5b600454811015610dec5760045f527f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b01905f90565b6040810190811067ffffffffffffffff821117610e5157604052565b634e487b7160e01b5f52604160045260245ffd5b6060810190811067ffffffffffffffff821117610e5157604052565b6080810190811067ffffffffffffffff821117610e5157604052565b90601f8019910116810190811067ffffffffffffffff821117610e5157604052565b359067ffffffffffffffff82168203610ed457565b5f80fd5b67ffffffffffffffff8111610e515760051b60200190565b9190604083820312610ed45760405192610f0984610e35565b8381358152602091828101359067ffffffffffffffff8211610ed457019280601f85011215610ed4578335610f3d81610ed8565b94610f4b6040519687610e9d565b818652848087019260051b820101928311610ed45784809101915b838310610f7557505050500152565b8235815291810191859101610f66565b9080601f83011215610ed45760405191610f9e83610e35565b829060408101928311610ed457905b828210610fba5750505090565b8135815260209182019101610fad565b9190828103926101e08412610ed457604090815192610fe884610e65565b839582359067ffffffffffffffff91828111610ed45784019182840360e08112610ed45760a087519161101a83610e65565b12610ed45786519160a0830183811082821117610e5157885261103c85610ebf565b835260209461104c868201610ebf565b868501528881013589850152606093848201358582015260808201356080820152835260a0810135828111610ed45781018481890312610ed45789519061109282610e65565b8035848111610ed457896110a7918301610ef0565b825287810135848111610ed457896110c0918301610ef0565b888301528a81013590848211610ed4576110dc918a9101610ef0565b8a8201528684015260c0810135918211610ed4576110fc91879101610ef0565b8188015287526101a0601f19830112610ed45785519361111b85610e81565b611126848701610ebf565b8552868601358486015281860135878601526101408093607f190112610ed45786519261115284610e81565b61115f8260808901610f85565b84528160df88011215610ed457875161117781610e35565b8091880191838311610ed4578960c08a01915b8483106111d557505050826111b286948896946111c0946111d09c9a6101c09c9a0152610f85565b8a8501526101808701610f85565b8183015283015286015201610ebf565b910152565b88906111e18785610f85565b8152019101908a9061118a565b600435906001600160a01b0382168203610ed457565b602080600319830112610ed4576004359167ffffffffffffffff8311610ed45780602384011215610ed457826004013561123d81610ed8565b9361124b6040519586610e9d565b81855260248486019260051b820101928311610ed457602401905b828210611274575050505090565b81356001600160a01b0381168103610ed4578152908301908301611266565b81601f82011215610ed45780359067ffffffffffffffff8211610e5157604051926112c8601f8401601f191660200185610e9d565b82845260208383010111610ed457815f926020809301838601378301015290565b5f915b600283106112f957505050565b6001908251815260208091019201920191906112ec565b602091828201928351925f94600367ffffffffffffffff80965116028581169081036117e3576104001161179e57815191604094858401908151936080865101519887865196015195968b975b875189101561140f5760ff89116113fb576001808a1b156113e7578a918e9160198c1c8116036113cf5761139e6113a9916113988d8d6118c2565b5161194a565b8d51918280926118d6565b039060025afa156113c5576113bf8c51986118a0565b9761135d565b89513d8d823e3d90fd5b61139e6113a9916113e08d8d6118c2565b519061194a565b634e487b7160e01b8e52601260045260248efd5b634e487b7160e01b8d52601160045260248dfd5b92959a919497509295500361175a578501938685510151938151519887865196015195968b975b875189101561149e5760ff89116113fb576001808a1b156113e7578a918e9160168c1c81160361148d5761139e611471916113988d8d6118c2565b039060025afa156113c5576114878c51986118a0565b97611436565b61139e611471916113e08d8d6118c2565b92959a919497509295500361172a57859051015192515196858451940151939489955b85518710156115665760ff871161155257600180881b1561153e5788918c91601c8a1c81160361152d576114fc611507916113988b8b6118c2565b8b51918280926118d6565b039060025afa156115235761151d8a51966118a0565b956114c1565b87513d8b823e3d90fd5b6114fc611507916113e08b8b6118c2565b634e487b7160e01b8c52601260045260248cfd5b634e487b7160e01b8b52601160045260248bfd5b9295509297909350959495036116fa576001600160a01b0360055416818585015116928451519051823b156116f6579160608a9360808997949751978895631ee9fa5560e11b87526004870152878151166024870152878c8201511660448701528a8101516064870152838101516084870152015160a48501528581511660c48501528981015160e485015288810151610104850152015161160d610124840182516112e9565b80890151848a8a61016487015b600284106116cc57506102649593506116539250606091509361164687958201516101e48701906112e9565b01516102248401906112e9565b5afa80156116c25761169b575b50508290510190815101515184905b83821061167f5750505101515190565b600895861b60ff821617951c90611695906118a0565b9061166f565b81969296116116ae57825293825f611660565b634e487b7160e01b82526041600452602482fd5b84513d89823e3d90fd5b909192949650839597506116e381600195516112e9565b0193019101908693918a8a8e979561161a565b8980fd5b835162461bcd60e51b81526004810186905260096024820152683130b210383937b7b360b91b6044820152606490fd5b865162461bcd60e51b81526004810187905260096024820152683130b210383937b7b360b91b6044820152606490fd5b865162461bcd60e51b815260048101879052601360248201527f626164206578656320726f6f742070726f6f66000000000000000000000000006044820152606490fd5b60405162461bcd60e51b815260048101849052601260248201527f71756f72756d206e6f74207265616368656400000000000000000000000000006044820152606490fd5b634e487b7160e01b87526011600452602487fd5b90815f52600660205260405f205461185b57816040917fa9aaf84657c346a7eafe57cf0403ab0be7867b79a5fdd5e5ab3527fbfc739d85935f52600660205280835f20556007548211611852575b82519182526020820152a1565b81600755611845565b60405162461bcd60e51b815260206004820152601960248201527f626c6f636b206861736820616c726561647920657869737473000000000000006044820152606490fd5b5f1981146118ae5760010190565b634e487b7160e01b5f52601160045260245ffd5b8051821015610dec5760209160051b010190565b908151915f5b8381106118ec575050015f815290565b80602080928401015181850152016118dc565b1561190657565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b919060405192602084015260408301526040825261196782610e65565b565b1561197057565b60405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f74207061757365720000000000000000000000006044820152606490fd5b6001600160a01b03809116915f83815260039360209185835260409060ff828220541687811015611b775715611b33576004968754965f1990818901988911611b2057835b8a54811015611add578682611a0e83610e00565b905490871b1c1614611a2857611a23906118a0565b6119fa565b909192939495969798808210611ab8575b50505087548015611aa55797849392917fd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d98598990190611a8f611a7a83610e00565b6001600160a01b0382549160031b1b19169055565b55848252855220805460ff1916905551908152a1565b634e487b7160e01b845260318952602484fd5b611ad592611ac8610a4c92610e00565b905490871b1c1691610e00565b5f8080611a39565b855162461bcd60e51b8152808c01899052601060248201527f70726f766572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b634e487b7160e01b845260118a52602484fd5b815162461bcd60e51b815260048101859052601560248201527f6163636f756e74206973206e6f742070726f76657200000000000000000000006044820152606490fd5b634e487b7160e01b82526021600452602482fd5b6001600160a01b038116905f90828252600160205260ff604083205416611c2b5760025468010000000000000000811015611c1757602092611bfb7f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f89593610a4c84600160409601600255610db7565b8281526001845220600160ff19825416179055604051908152a1565b634e487b7160e01b83526041600452602483fd5b60405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152606490fd5b6001600160a01b03809116905f9282845260019060209382855260409360ff858820541615611de8576002805490915f1991828101908111611dd457908695949392918a975b611cff575b885162461bcd60e51b8152600481018b9052601060248201527f706175736572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b8399989799548a1015611dcb578185611d178c610db7565b929054600393841b1c1614611d405750611d378798999a979596976118a0565b97969594611cb6565b9293949796959991818310611da6575b5050505081548015611d9257918493917fcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e9899930190611a8f611a7a83610db7565b634e487b7160e01b89526031600452602489fd5b611dc293611db6610a4c93610db7565b9054911b1c1691610db7565b5f808080611d50565b87989950611cbb565b634e487b7160e01b8a52601160045260248afd5b845162461bcd60e51b815260048101879052601560248201527f4163636f756e74206973206e6f742070617573657200000000000000000000006044820152606490fdfea2646970667358221220b149c4ecf2689238de40f81d94b62eb901a24bad8004853dddb655e7c89320a964736f6c63430008140033",
}

// AnchorBlocksABI is the input ABI used to generate the binding from.
// Deprecated: Use AnchorBlocksMetaData.ABI instead.
var AnchorBlocksABI = AnchorBlocksMetaData.ABI

// AnchorBlocksBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use AnchorBlocksMetaData.Bin instead.
var AnchorBlocksBin = AnchorBlocksMetaData.Bin

// DeployAnchorBlocks deploys a new Ethereum contract, binding an instance of AnchorBlocks to it.
func DeployAnchorBlocks(auth *bind.TransactOpts, backend bind.ContractBackend, _lightClient common.Address) (common.Address, *types.Transaction, *AnchorBlocks, error) {
	parsed, err := AnchorBlocksMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(AnchorBlocksBin), backend, _lightClient)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &AnchorBlocks{AnchorBlocksCaller: AnchorBlocksCaller{contract: contract}, AnchorBlocksTransactor: AnchorBlocksTransactor{contract: contract}, AnchorBlocksFilterer: AnchorBlocksFilterer{contract: contract}}, nil
}

// AnchorBlocks is an auto generated Go binding around an Ethereum contract.
type AnchorBlocks struct {
	AnchorBlocksCaller     // Read-only binding to the contract
	AnchorBlocksTransactor // Write-only binding to the contract
	AnchorBlocksFilterer   // Log filterer for contract events
}

// AnchorBlocksCaller is an auto generated read-only Go binding around an Ethereum contract.
type AnchorBlocksCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AnchorBlocksTransactor is an auto generated write-only Go binding around an Ethereum contract.
type AnchorBlocksTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AnchorBlocksFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type AnchorBlocksFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AnchorBlocksSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type AnchorBlocksSession struct {
	Contract     *AnchorBlocks     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// AnchorBlocksCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type AnchorBlocksCallerSession struct {
	Contract *AnchorBlocksCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// AnchorBlocksTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type AnchorBlocksTransactorSession struct {
	Contract     *AnchorBlocksTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// AnchorBlocksRaw is an auto generated low-level Go binding around an Ethereum contract.
type AnchorBlocksRaw struct {
	Contract *AnchorBlocks // Generic contract binding to access the raw methods on
}

// AnchorBlocksCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type AnchorBlocksCallerRaw struct {
	Contract *AnchorBlocksCaller // Generic read-only contract binding to access the raw methods on
}

// AnchorBlocksTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type AnchorBlocksTransactorRaw struct {
	Contract *AnchorBlocksTransactor // Generic write-only contract binding to access the raw methods on
}

// NewAnchorBlocks creates a new instance of AnchorBlocks, bound to a specific deployed contract.
func NewAnchorBlocks(address common.Address, backend bind.ContractBackend) (*AnchorBlocks, error) {
	contract, err := bindAnchorBlocks(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &AnchorBlocks{AnchorBlocksCaller: AnchorBlocksCaller{contract: contract}, AnchorBlocksTransactor: AnchorBlocksTransactor{contract: contract}, AnchorBlocksFilterer: AnchorBlocksFilterer{contract: contract}}, nil
}

// NewAnchorBlocksCaller creates a new read-only instance of AnchorBlocks, bound to a specific deployed contract.
func NewAnchorBlocksCaller(address common.Address, caller bind.ContractCaller) (*AnchorBlocksCaller, error) {
	contract, err := bindAnchorBlocks(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &AnchorBlocksCaller{contract: contract}, nil
}

// NewAnchorBlocksTransactor creates a new write-only instance of AnchorBlocks, bound to a specific deployed contract.
func NewAnchorBlocksTransactor(address common.Address, transactor bind.ContractTransactor) (*AnchorBlocksTransactor, error) {
	contract, err := bindAnchorBlocks(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &AnchorBlocksTransactor{contract: contract}, nil
}

// NewAnchorBlocksFilterer creates a new log filterer instance of AnchorBlocks, bound to a specific deployed contract.
func NewAnchorBlocksFilterer(address common.Address, filterer bind.ContractFilterer) (*AnchorBlocksFilterer, error) {
	contract, err := bindAnchorBlocks(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &AnchorBlocksFilterer{contract: contract}, nil
}

// bindAnchorBlocks binds a generic wrapper to an already deployed contract.
func bindAnchorBlocks(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := AnchorBlocksMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AnchorBlocks *AnchorBlocksRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AnchorBlocks.Contract.AnchorBlocksCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AnchorBlocks *AnchorBlocksRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.AnchorBlocksTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AnchorBlocks *AnchorBlocksRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.AnchorBlocksTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AnchorBlocks *AnchorBlocksCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AnchorBlocks.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AnchorBlocks *AnchorBlocksTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AnchorBlocks *AnchorBlocksTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.contract.Transact(opts, method, params...)
}

// Blocks is a free data retrieval call binding the contract method 0xf25b3f99.
//
// Solidity: function blocks(uint256 ) view returns(bytes32)
func (_AnchorBlocks *AnchorBlocksCaller) Blocks(opts *bind.CallOpts, arg0 *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _AnchorBlocks.contract.Call(opts, &out, "blocks", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// Blocks is a free data retrieval call binding the contract method 0xf25b3f99.
//
// Solidity: function blocks(uint256 ) view returns(bytes32)
func (_AnchorBlocks *AnchorBlocksSession) Blocks(arg0 *big.Int) ([32]byte, error) {
	return _AnchorBlocks.Contract.Blocks(&_AnchorBlocks.CallOpts, arg0)
}

// Blocks is a free data retrieval call binding the contract method 0xf25b3f99.
//
// Solidity: function blocks(uint256 ) view returns(bytes32)
func (_AnchorBlocks *AnchorBlocksCallerSession) Blocks(arg0 *big.Int) ([32]byte, error) {
	return _AnchorBlocks.Contract.Blocks(&_AnchorBlocks.CallOpts, arg0)
}

// IsActiveProver is a free data retrieval call binding the contract method 0xec64842e.
//
// Solidity: function isActiveProver(address _account) view returns(bool)
func (_AnchorBlocks *AnchorBlocksCaller) IsActiveProver(opts *bind.CallOpts, _account common.Address) (bool, error) {
	var out []interface{}
	err := _AnchorBlocks.contract.Call(opts, &out, "isActiveProver", _account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsActiveProver is a free data retrieval call binding the contract method 0xec64842e.
//
// Solidity: function isActiveProver(address _account) view returns(bool)
func (_AnchorBlocks *AnchorBlocksSession) IsActiveProver(_account common.Address) (bool, error) {
	return _AnchorBlocks.Contract.IsActiveProver(&_AnchorBlocks.CallOpts, _account)
}

// IsActiveProver is a free data retrieval call binding the contract method 0xec64842e.
//
// Solidity: function isActiveProver(address _account) view returns(bool)
func (_AnchorBlocks *AnchorBlocksCallerSession) IsActiveProver(_account common.Address) (bool, error) {
	return _AnchorBlocks.Contract.IsActiveProver(&_AnchorBlocks.CallOpts, _account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_AnchorBlocks *AnchorBlocksCaller) IsPauser(opts *bind.CallOpts, account common.Address) (bool, error) {
	var out []interface{}
	err := _AnchorBlocks.contract.Call(opts, &out, "isPauser", account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_AnchorBlocks *AnchorBlocksSession) IsPauser(account common.Address) (bool, error) {
	return _AnchorBlocks.Contract.IsPauser(&_AnchorBlocks.CallOpts, account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_AnchorBlocks *AnchorBlocksCallerSession) IsPauser(account common.Address) (bool, error) {
	return _AnchorBlocks.Contract.IsPauser(&_AnchorBlocks.CallOpts, account)
}

// LatestBlockNum is a free data retrieval call binding the contract method 0xfbbea34c.
//
// Solidity: function latestBlockNum() view returns(uint256)
func (_AnchorBlocks *AnchorBlocksCaller) LatestBlockNum(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AnchorBlocks.contract.Call(opts, &out, "latestBlockNum")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// LatestBlockNum is a free data retrieval call binding the contract method 0xfbbea34c.
//
// Solidity: function latestBlockNum() view returns(uint256)
func (_AnchorBlocks *AnchorBlocksSession) LatestBlockNum() (*big.Int, error) {
	return _AnchorBlocks.Contract.LatestBlockNum(&_AnchorBlocks.CallOpts)
}

// LatestBlockNum is a free data retrieval call binding the contract method 0xfbbea34c.
//
// Solidity: function latestBlockNum() view returns(uint256)
func (_AnchorBlocks *AnchorBlocksCallerSession) LatestBlockNum() (*big.Int, error) {
	return _AnchorBlocks.Contract.LatestBlockNum(&_AnchorBlocks.CallOpts)
}

// LightClient is a free data retrieval call binding the contract method 0xb5700e68.
//
// Solidity: function lightClient() view returns(address)
func (_AnchorBlocks *AnchorBlocksCaller) LightClient(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _AnchorBlocks.contract.Call(opts, &out, "lightClient")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// LightClient is a free data retrieval call binding the contract method 0xb5700e68.
//
// Solidity: function lightClient() view returns(address)
func (_AnchorBlocks *AnchorBlocksSession) LightClient() (common.Address, error) {
	return _AnchorBlocks.Contract.LightClient(&_AnchorBlocks.CallOpts)
}

// LightClient is a free data retrieval call binding the contract method 0xb5700e68.
//
// Solidity: function lightClient() view returns(address)
func (_AnchorBlocks *AnchorBlocksCallerSession) LightClient() (common.Address, error) {
	return _AnchorBlocks.Contract.LightClient(&_AnchorBlocks.CallOpts)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_AnchorBlocks *AnchorBlocksCaller) NumPausers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AnchorBlocks.contract.Call(opts, &out, "numPausers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_AnchorBlocks *AnchorBlocksSession) NumPausers() (*big.Int, error) {
	return _AnchorBlocks.Contract.NumPausers(&_AnchorBlocks.CallOpts)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_AnchorBlocks *AnchorBlocksCallerSession) NumPausers() (*big.Int, error) {
	return _AnchorBlocks.Contract.NumPausers(&_AnchorBlocks.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_AnchorBlocks *AnchorBlocksCaller) NumProvers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AnchorBlocks.contract.Call(opts, &out, "numProvers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_AnchorBlocks *AnchorBlocksSession) NumProvers() (*big.Int, error) {
	return _AnchorBlocks.Contract.NumProvers(&_AnchorBlocks.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_AnchorBlocks *AnchorBlocksCallerSession) NumProvers() (*big.Int, error) {
	return _AnchorBlocks.Contract.NumProvers(&_AnchorBlocks.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_AnchorBlocks *AnchorBlocksCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _AnchorBlocks.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_AnchorBlocks *AnchorBlocksSession) Owner() (common.Address, error) {
	return _AnchorBlocks.Contract.Owner(&_AnchorBlocks.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_AnchorBlocks *AnchorBlocksCallerSession) Owner() (common.Address, error) {
	return _AnchorBlocks.Contract.Owner(&_AnchorBlocks.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_AnchorBlocks *AnchorBlocksCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _AnchorBlocks.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_AnchorBlocks *AnchorBlocksSession) Paused() (bool, error) {
	return _AnchorBlocks.Contract.Paused(&_AnchorBlocks.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_AnchorBlocks *AnchorBlocksCallerSession) Paused() (bool, error) {
	return _AnchorBlocks.Contract.Paused(&_AnchorBlocks.CallOpts)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_AnchorBlocks *AnchorBlocksCaller) PauserList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _AnchorBlocks.contract.Call(opts, &out, "pauserList", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_AnchorBlocks *AnchorBlocksSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _AnchorBlocks.Contract.PauserList(&_AnchorBlocks.CallOpts, arg0)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_AnchorBlocks *AnchorBlocksCallerSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _AnchorBlocks.Contract.PauserList(&_AnchorBlocks.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_AnchorBlocks *AnchorBlocksCaller) Pausers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _AnchorBlocks.contract.Call(opts, &out, "pausers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_AnchorBlocks *AnchorBlocksSession) Pausers(arg0 common.Address) (bool, error) {
	return _AnchorBlocks.Contract.Pausers(&_AnchorBlocks.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_AnchorBlocks *AnchorBlocksCallerSession) Pausers(arg0 common.Address) (bool, error) {
	return _AnchorBlocks.Contract.Pausers(&_AnchorBlocks.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_AnchorBlocks *AnchorBlocksCaller) ProverStates(opts *bind.CallOpts, arg0 common.Address) (uint8, error) {
	var out []interface{}
	err := _AnchorBlocks.contract.Call(opts, &out, "proverStates", arg0)

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_AnchorBlocks *AnchorBlocksSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _AnchorBlocks.Contract.ProverStates(&_AnchorBlocks.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_AnchorBlocks *AnchorBlocksCallerSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _AnchorBlocks.Contract.ProverStates(&_AnchorBlocks.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_AnchorBlocks *AnchorBlocksCaller) Provers(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _AnchorBlocks.contract.Call(opts, &out, "provers", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_AnchorBlocks *AnchorBlocksSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _AnchorBlocks.Contract.Provers(&_AnchorBlocks.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_AnchorBlocks *AnchorBlocksCallerSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _AnchorBlocks.Contract.Provers(&_AnchorBlocks.CallOpts, arg0)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_AnchorBlocks *AnchorBlocksTransactor) AddPauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.contract.Transact(opts, "addPauser", account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_AnchorBlocks *AnchorBlocksSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.AddPauser(&_AnchorBlocks.TransactOpts, account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_AnchorBlocks *AnchorBlocksTransactorSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.AddPauser(&_AnchorBlocks.TransactOpts, account)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_AnchorBlocks *AnchorBlocksTransactor) AddPausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.contract.Transact(opts, "addPausers", accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_AnchorBlocks *AnchorBlocksSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.AddPausers(&_AnchorBlocks.TransactOpts, accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_AnchorBlocks *AnchorBlocksTransactorSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.AddPausers(&_AnchorBlocks.TransactOpts, accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_AnchorBlocks *AnchorBlocksTransactor) AddProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.contract.Transact(opts, "addProvers", _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_AnchorBlocks *AnchorBlocksSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.AddProvers(&_AnchorBlocks.TransactOpts, _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_AnchorBlocks *AnchorBlocksTransactorSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.AddProvers(&_AnchorBlocks.TransactOpts, _accounts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_AnchorBlocks *AnchorBlocksTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AnchorBlocks.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_AnchorBlocks *AnchorBlocksSession) Pause() (*types.Transaction, error) {
	return _AnchorBlocks.Contract.Pause(&_AnchorBlocks.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_AnchorBlocks *AnchorBlocksTransactorSession) Pause() (*types.Transaction, error) {
	return _AnchorBlocks.Contract.Pause(&_AnchorBlocks.TransactOpts)
}

// ProcessUpdate is a paid mutator transaction binding the contract method 0x2e3466f6.
//
// Solidity: function processUpdate((((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])),(uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])),uint64) hb) returns()
func (_AnchorBlocks *AnchorBlocksTransactor) ProcessUpdate(opts *bind.TransactOpts, hb LightClientOptimisticUpdate) (*types.Transaction, error) {
	return _AnchorBlocks.contract.Transact(opts, "processUpdate", hb)
}

// ProcessUpdate is a paid mutator transaction binding the contract method 0x2e3466f6.
//
// Solidity: function processUpdate((((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])),(uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])),uint64) hb) returns()
func (_AnchorBlocks *AnchorBlocksSession) ProcessUpdate(hb LightClientOptimisticUpdate) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.ProcessUpdate(&_AnchorBlocks.TransactOpts, hb)
}

// ProcessUpdate is a paid mutator transaction binding the contract method 0x2e3466f6.
//
// Solidity: function processUpdate((((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])),(uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])),uint64) hb) returns()
func (_AnchorBlocks *AnchorBlocksTransactorSession) ProcessUpdate(hb LightClientOptimisticUpdate) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.ProcessUpdate(&_AnchorBlocks.TransactOpts, hb)
}

// ProcessUpdateWithChainProof is a paid mutator transaction binding the contract method 0xfb8cfb51.
//
// Solidity: function processUpdateWithChainProof((((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])),(uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])),uint64) hb, bytes32 blockHash, (bytes,bytes)[] chainProof) returns()
func (_AnchorBlocks *AnchorBlocksTransactor) ProcessUpdateWithChainProof(opts *bind.TransactOpts, hb LightClientOptimisticUpdate, blockHash [32]byte, chainProof []AnchorBlocksBlockHashWitness) (*types.Transaction, error) {
	return _AnchorBlocks.contract.Transact(opts, "processUpdateWithChainProof", hb, blockHash, chainProof)
}

// ProcessUpdateWithChainProof is a paid mutator transaction binding the contract method 0xfb8cfb51.
//
// Solidity: function processUpdateWithChainProof((((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])),(uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])),uint64) hb, bytes32 blockHash, (bytes,bytes)[] chainProof) returns()
func (_AnchorBlocks *AnchorBlocksSession) ProcessUpdateWithChainProof(hb LightClientOptimisticUpdate, blockHash [32]byte, chainProof []AnchorBlocksBlockHashWitness) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.ProcessUpdateWithChainProof(&_AnchorBlocks.TransactOpts, hb, blockHash, chainProof)
}

// ProcessUpdateWithChainProof is a paid mutator transaction binding the contract method 0xfb8cfb51.
//
// Solidity: function processUpdateWithChainProof((((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])),(uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])),uint64) hb, bytes32 blockHash, (bytes,bytes)[] chainProof) returns()
func (_AnchorBlocks *AnchorBlocksTransactorSession) ProcessUpdateWithChainProof(hb LightClientOptimisticUpdate, blockHash [32]byte, chainProof []AnchorBlocksBlockHashWitness) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.ProcessUpdateWithChainProof(&_AnchorBlocks.TransactOpts, hb, blockHash, chainProof)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_AnchorBlocks *AnchorBlocksTransactor) RemovePauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.contract.Transact(opts, "removePauser", account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_AnchorBlocks *AnchorBlocksSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.RemovePauser(&_AnchorBlocks.TransactOpts, account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_AnchorBlocks *AnchorBlocksTransactorSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.RemovePauser(&_AnchorBlocks.TransactOpts, account)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_AnchorBlocks *AnchorBlocksTransactor) RemovePausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.contract.Transact(opts, "removePausers", accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_AnchorBlocks *AnchorBlocksSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.RemovePausers(&_AnchorBlocks.TransactOpts, accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_AnchorBlocks *AnchorBlocksTransactorSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.RemovePausers(&_AnchorBlocks.TransactOpts, accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_AnchorBlocks *AnchorBlocksTransactor) RemoveProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.contract.Transact(opts, "removeProvers", _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_AnchorBlocks *AnchorBlocksSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.RemoveProvers(&_AnchorBlocks.TransactOpts, _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_AnchorBlocks *AnchorBlocksTransactorSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.RemoveProvers(&_AnchorBlocks.TransactOpts, _accounts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_AnchorBlocks *AnchorBlocksTransactor) RenouncePauser(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AnchorBlocks.contract.Transact(opts, "renouncePauser")
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_AnchorBlocks *AnchorBlocksSession) RenouncePauser() (*types.Transaction, error) {
	return _AnchorBlocks.Contract.RenouncePauser(&_AnchorBlocks.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_AnchorBlocks *AnchorBlocksTransactorSession) RenouncePauser() (*types.Transaction, error) {
	return _AnchorBlocks.Contract.RenouncePauser(&_AnchorBlocks.TransactOpts)
}

// SetLightClient is a paid mutator transaction binding the contract method 0x3e553bab.
//
// Solidity: function setLightClient(address _lightClient) returns()
func (_AnchorBlocks *AnchorBlocksTransactor) SetLightClient(opts *bind.TransactOpts, _lightClient common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.contract.Transact(opts, "setLightClient", _lightClient)
}

// SetLightClient is a paid mutator transaction binding the contract method 0x3e553bab.
//
// Solidity: function setLightClient(address _lightClient) returns()
func (_AnchorBlocks *AnchorBlocksSession) SetLightClient(_lightClient common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.SetLightClient(&_AnchorBlocks.TransactOpts, _lightClient)
}

// SetLightClient is a paid mutator transaction binding the contract method 0x3e553bab.
//
// Solidity: function setLightClient(address _lightClient) returns()
func (_AnchorBlocks *AnchorBlocksTransactorSession) SetLightClient(_lightClient common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.SetLightClient(&_AnchorBlocks.TransactOpts, _lightClient)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_AnchorBlocks *AnchorBlocksTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_AnchorBlocks *AnchorBlocksSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.TransferOwnership(&_AnchorBlocks.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_AnchorBlocks *AnchorBlocksTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _AnchorBlocks.Contract.TransferOwnership(&_AnchorBlocks.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_AnchorBlocks *AnchorBlocksTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AnchorBlocks.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_AnchorBlocks *AnchorBlocksSession) Unpause() (*types.Transaction, error) {
	return _AnchorBlocks.Contract.Unpause(&_AnchorBlocks.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_AnchorBlocks *AnchorBlocksTransactorSession) Unpause() (*types.Transaction, error) {
	return _AnchorBlocks.Contract.Unpause(&_AnchorBlocks.TransactOpts)
}

// AnchorBlocksAnchorBlockUpdatedIterator is returned from FilterAnchorBlockUpdated and is used to iterate over the raw logs and unpacked data for AnchorBlockUpdated events raised by the AnchorBlocks contract.
type AnchorBlocksAnchorBlockUpdatedIterator struct {
	Event *AnchorBlocksAnchorBlockUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AnchorBlocksAnchorBlockUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AnchorBlocksAnchorBlockUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AnchorBlocksAnchorBlockUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AnchorBlocksAnchorBlockUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AnchorBlocksAnchorBlockUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AnchorBlocksAnchorBlockUpdated represents a AnchorBlockUpdated event raised by the AnchorBlocks contract.
type AnchorBlocksAnchorBlockUpdated struct {
	BlockNum  *big.Int
	BlockHash [32]byte
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterAnchorBlockUpdated is a free log retrieval operation binding the contract event 0xa9aaf84657c346a7eafe57cf0403ab0be7867b79a5fdd5e5ab3527fbfc739d85.
//
// Solidity: event AnchorBlockUpdated(uint256 blockNum, bytes32 blockHash)
func (_AnchorBlocks *AnchorBlocksFilterer) FilterAnchorBlockUpdated(opts *bind.FilterOpts) (*AnchorBlocksAnchorBlockUpdatedIterator, error) {

	logs, sub, err := _AnchorBlocks.contract.FilterLogs(opts, "AnchorBlockUpdated")
	if err != nil {
		return nil, err
	}
	return &AnchorBlocksAnchorBlockUpdatedIterator{contract: _AnchorBlocks.contract, event: "AnchorBlockUpdated", logs: logs, sub: sub}, nil
}

// WatchAnchorBlockUpdated is a free log subscription operation binding the contract event 0xa9aaf84657c346a7eafe57cf0403ab0be7867b79a5fdd5e5ab3527fbfc739d85.
//
// Solidity: event AnchorBlockUpdated(uint256 blockNum, bytes32 blockHash)
func (_AnchorBlocks *AnchorBlocksFilterer) WatchAnchorBlockUpdated(opts *bind.WatchOpts, sink chan<- *AnchorBlocksAnchorBlockUpdated) (event.Subscription, error) {

	logs, sub, err := _AnchorBlocks.contract.WatchLogs(opts, "AnchorBlockUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AnchorBlocksAnchorBlockUpdated)
				if err := _AnchorBlocks.contract.UnpackLog(event, "AnchorBlockUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAnchorBlockUpdated is a log parse operation binding the contract event 0xa9aaf84657c346a7eafe57cf0403ab0be7867b79a5fdd5e5ab3527fbfc739d85.
//
// Solidity: event AnchorBlockUpdated(uint256 blockNum, bytes32 blockHash)
func (_AnchorBlocks *AnchorBlocksFilterer) ParseAnchorBlockUpdated(log types.Log) (*AnchorBlocksAnchorBlockUpdated, error) {
	event := new(AnchorBlocksAnchorBlockUpdated)
	if err := _AnchorBlocks.contract.UnpackLog(event, "AnchorBlockUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AnchorBlocksOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the AnchorBlocks contract.
type AnchorBlocksOwnershipTransferredIterator struct {
	Event *AnchorBlocksOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AnchorBlocksOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AnchorBlocksOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AnchorBlocksOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AnchorBlocksOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AnchorBlocksOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AnchorBlocksOwnershipTransferred represents a OwnershipTransferred event raised by the AnchorBlocks contract.
type AnchorBlocksOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_AnchorBlocks *AnchorBlocksFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*AnchorBlocksOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _AnchorBlocks.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &AnchorBlocksOwnershipTransferredIterator{contract: _AnchorBlocks.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_AnchorBlocks *AnchorBlocksFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *AnchorBlocksOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _AnchorBlocks.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AnchorBlocksOwnershipTransferred)
				if err := _AnchorBlocks.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_AnchorBlocks *AnchorBlocksFilterer) ParseOwnershipTransferred(log types.Log) (*AnchorBlocksOwnershipTransferred, error) {
	event := new(AnchorBlocksOwnershipTransferred)
	if err := _AnchorBlocks.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AnchorBlocksPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the AnchorBlocks contract.
type AnchorBlocksPausedIterator struct {
	Event *AnchorBlocksPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AnchorBlocksPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AnchorBlocksPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AnchorBlocksPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AnchorBlocksPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AnchorBlocksPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AnchorBlocksPaused represents a Paused event raised by the AnchorBlocks contract.
type AnchorBlocksPaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) FilterPaused(opts *bind.FilterOpts) (*AnchorBlocksPausedIterator, error) {

	logs, sub, err := _AnchorBlocks.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &AnchorBlocksPausedIterator{contract: _AnchorBlocks.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *AnchorBlocksPaused) (event.Subscription, error) {

	logs, sub, err := _AnchorBlocks.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AnchorBlocksPaused)
				if err := _AnchorBlocks.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) ParsePaused(log types.Log) (*AnchorBlocksPaused, error) {
	event := new(AnchorBlocksPaused)
	if err := _AnchorBlocks.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AnchorBlocksPauserAddedIterator is returned from FilterPauserAdded and is used to iterate over the raw logs and unpacked data for PauserAdded events raised by the AnchorBlocks contract.
type AnchorBlocksPauserAddedIterator struct {
	Event *AnchorBlocksPauserAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AnchorBlocksPauserAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AnchorBlocksPauserAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AnchorBlocksPauserAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AnchorBlocksPauserAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AnchorBlocksPauserAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AnchorBlocksPauserAdded represents a PauserAdded event raised by the AnchorBlocks contract.
type AnchorBlocksPauserAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserAdded is a free log retrieval operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) FilterPauserAdded(opts *bind.FilterOpts) (*AnchorBlocksPauserAddedIterator, error) {

	logs, sub, err := _AnchorBlocks.contract.FilterLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return &AnchorBlocksPauserAddedIterator{contract: _AnchorBlocks.contract, event: "PauserAdded", logs: logs, sub: sub}, nil
}

// WatchPauserAdded is a free log subscription operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) WatchPauserAdded(opts *bind.WatchOpts, sink chan<- *AnchorBlocksPauserAdded) (event.Subscription, error) {

	logs, sub, err := _AnchorBlocks.contract.WatchLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AnchorBlocksPauserAdded)
				if err := _AnchorBlocks.contract.UnpackLog(event, "PauserAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserAdded is a log parse operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) ParsePauserAdded(log types.Log) (*AnchorBlocksPauserAdded, error) {
	event := new(AnchorBlocksPauserAdded)
	if err := _AnchorBlocks.contract.UnpackLog(event, "PauserAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AnchorBlocksPauserRemovedIterator is returned from FilterPauserRemoved and is used to iterate over the raw logs and unpacked data for PauserRemoved events raised by the AnchorBlocks contract.
type AnchorBlocksPauserRemovedIterator struct {
	Event *AnchorBlocksPauserRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AnchorBlocksPauserRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AnchorBlocksPauserRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AnchorBlocksPauserRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AnchorBlocksPauserRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AnchorBlocksPauserRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AnchorBlocksPauserRemoved represents a PauserRemoved event raised by the AnchorBlocks contract.
type AnchorBlocksPauserRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserRemoved is a free log retrieval operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) FilterPauserRemoved(opts *bind.FilterOpts) (*AnchorBlocksPauserRemovedIterator, error) {

	logs, sub, err := _AnchorBlocks.contract.FilterLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return &AnchorBlocksPauserRemovedIterator{contract: _AnchorBlocks.contract, event: "PauserRemoved", logs: logs, sub: sub}, nil
}

// WatchPauserRemoved is a free log subscription operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) WatchPauserRemoved(opts *bind.WatchOpts, sink chan<- *AnchorBlocksPauserRemoved) (event.Subscription, error) {

	logs, sub, err := _AnchorBlocks.contract.WatchLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AnchorBlocksPauserRemoved)
				if err := _AnchorBlocks.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserRemoved is a log parse operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) ParsePauserRemoved(log types.Log) (*AnchorBlocksPauserRemoved, error) {
	event := new(AnchorBlocksPauserRemoved)
	if err := _AnchorBlocks.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AnchorBlocksProverAddedIterator is returned from FilterProverAdded and is used to iterate over the raw logs and unpacked data for ProverAdded events raised by the AnchorBlocks contract.
type AnchorBlocksProverAddedIterator struct {
	Event *AnchorBlocksProverAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AnchorBlocksProverAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AnchorBlocksProverAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AnchorBlocksProverAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AnchorBlocksProverAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AnchorBlocksProverAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AnchorBlocksProverAdded represents a ProverAdded event raised by the AnchorBlocks contract.
type AnchorBlocksProverAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverAdded is a free log retrieval operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) FilterProverAdded(opts *bind.FilterOpts) (*AnchorBlocksProverAddedIterator, error) {

	logs, sub, err := _AnchorBlocks.contract.FilterLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return &AnchorBlocksProverAddedIterator{contract: _AnchorBlocks.contract, event: "ProverAdded", logs: logs, sub: sub}, nil
}

// WatchProverAdded is a free log subscription operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) WatchProverAdded(opts *bind.WatchOpts, sink chan<- *AnchorBlocksProverAdded) (event.Subscription, error) {

	logs, sub, err := _AnchorBlocks.contract.WatchLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AnchorBlocksProverAdded)
				if err := _AnchorBlocks.contract.UnpackLog(event, "ProverAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverAdded is a log parse operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) ParseProverAdded(log types.Log) (*AnchorBlocksProverAdded, error) {
	event := new(AnchorBlocksProverAdded)
	if err := _AnchorBlocks.contract.UnpackLog(event, "ProverAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AnchorBlocksProverRemovedIterator is returned from FilterProverRemoved and is used to iterate over the raw logs and unpacked data for ProverRemoved events raised by the AnchorBlocks contract.
type AnchorBlocksProverRemovedIterator struct {
	Event *AnchorBlocksProverRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AnchorBlocksProverRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AnchorBlocksProverRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AnchorBlocksProverRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AnchorBlocksProverRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AnchorBlocksProverRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AnchorBlocksProverRemoved represents a ProverRemoved event raised by the AnchorBlocks contract.
type AnchorBlocksProverRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverRemoved is a free log retrieval operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) FilterProverRemoved(opts *bind.FilterOpts) (*AnchorBlocksProverRemovedIterator, error) {

	logs, sub, err := _AnchorBlocks.contract.FilterLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return &AnchorBlocksProverRemovedIterator{contract: _AnchorBlocks.contract, event: "ProverRemoved", logs: logs, sub: sub}, nil
}

// WatchProverRemoved is a free log subscription operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) WatchProverRemoved(opts *bind.WatchOpts, sink chan<- *AnchorBlocksProverRemoved) (event.Subscription, error) {

	logs, sub, err := _AnchorBlocks.contract.WatchLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AnchorBlocksProverRemoved)
				if err := _AnchorBlocks.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverRemoved is a log parse operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) ParseProverRemoved(log types.Log) (*AnchorBlocksProverRemoved, error) {
	event := new(AnchorBlocksProverRemoved)
	if err := _AnchorBlocks.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AnchorBlocksUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the AnchorBlocks contract.
type AnchorBlocksUnpausedIterator struct {
	Event *AnchorBlocksUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AnchorBlocksUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AnchorBlocksUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AnchorBlocksUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AnchorBlocksUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AnchorBlocksUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AnchorBlocksUnpaused represents a Unpaused event raised by the AnchorBlocks contract.
type AnchorBlocksUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) FilterUnpaused(opts *bind.FilterOpts) (*AnchorBlocksUnpausedIterator, error) {

	logs, sub, err := _AnchorBlocks.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &AnchorBlocksUnpausedIterator{contract: _AnchorBlocks.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *AnchorBlocksUnpaused) (event.Subscription, error) {

	logs, sub, err := _AnchorBlocks.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AnchorBlocksUnpaused)
				if err := _AnchorBlocks.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_AnchorBlocks *AnchorBlocksFilterer) ParseUnpaused(log types.Log) (*AnchorBlocksUnpaused, error) {
	event := new(AnchorBlocksUnpaused)
	if err := _AnchorBlocks.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BalanceDeltaLibraryMetaData contains all meta data concerning the BalanceDeltaLibrary contract.
var BalanceDeltaLibraryMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212206e3692eb33aea83cd795699c12f4f7b4a33bb1c36938a64e278e627d513cafc464736f6c63430008140033",
}

// BalanceDeltaLibraryABI is the input ABI used to generate the binding from.
// Deprecated: Use BalanceDeltaLibraryMetaData.ABI instead.
var BalanceDeltaLibraryABI = BalanceDeltaLibraryMetaData.ABI

// BalanceDeltaLibraryBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use BalanceDeltaLibraryMetaData.Bin instead.
var BalanceDeltaLibraryBin = BalanceDeltaLibraryMetaData.Bin

// DeployBalanceDeltaLibrary deploys a new Ethereum contract, binding an instance of BalanceDeltaLibrary to it.
func DeployBalanceDeltaLibrary(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *BalanceDeltaLibrary, error) {
	parsed, err := BalanceDeltaLibraryMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(BalanceDeltaLibraryBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &BalanceDeltaLibrary{BalanceDeltaLibraryCaller: BalanceDeltaLibraryCaller{contract: contract}, BalanceDeltaLibraryTransactor: BalanceDeltaLibraryTransactor{contract: contract}, BalanceDeltaLibraryFilterer: BalanceDeltaLibraryFilterer{contract: contract}}, nil
}

// BalanceDeltaLibrary is an auto generated Go binding around an Ethereum contract.
type BalanceDeltaLibrary struct {
	BalanceDeltaLibraryCaller     // Read-only binding to the contract
	BalanceDeltaLibraryTransactor // Write-only binding to the contract
	BalanceDeltaLibraryFilterer   // Log filterer for contract events
}

// BalanceDeltaLibraryCaller is an auto generated read-only Go binding around an Ethereum contract.
type BalanceDeltaLibraryCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BalanceDeltaLibraryTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BalanceDeltaLibraryTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BalanceDeltaLibraryFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BalanceDeltaLibraryFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BalanceDeltaLibrarySession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BalanceDeltaLibrarySession struct {
	Contract     *BalanceDeltaLibrary // Generic contract binding to set the session for
	CallOpts     bind.CallOpts        // Call options to use throughout this session
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// BalanceDeltaLibraryCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BalanceDeltaLibraryCallerSession struct {
	Contract *BalanceDeltaLibraryCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts              // Call options to use throughout this session
}

// BalanceDeltaLibraryTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BalanceDeltaLibraryTransactorSession struct {
	Contract     *BalanceDeltaLibraryTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts              // Transaction auth options to use throughout this session
}

// BalanceDeltaLibraryRaw is an auto generated low-level Go binding around an Ethereum contract.
type BalanceDeltaLibraryRaw struct {
	Contract *BalanceDeltaLibrary // Generic contract binding to access the raw methods on
}

// BalanceDeltaLibraryCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BalanceDeltaLibraryCallerRaw struct {
	Contract *BalanceDeltaLibraryCaller // Generic read-only contract binding to access the raw methods on
}

// BalanceDeltaLibraryTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BalanceDeltaLibraryTransactorRaw struct {
	Contract *BalanceDeltaLibraryTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBalanceDeltaLibrary creates a new instance of BalanceDeltaLibrary, bound to a specific deployed contract.
func NewBalanceDeltaLibrary(address common.Address, backend bind.ContractBackend) (*BalanceDeltaLibrary, error) {
	contract, err := bindBalanceDeltaLibrary(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BalanceDeltaLibrary{BalanceDeltaLibraryCaller: BalanceDeltaLibraryCaller{contract: contract}, BalanceDeltaLibraryTransactor: BalanceDeltaLibraryTransactor{contract: contract}, BalanceDeltaLibraryFilterer: BalanceDeltaLibraryFilterer{contract: contract}}, nil
}

// NewBalanceDeltaLibraryCaller creates a new read-only instance of BalanceDeltaLibrary, bound to a specific deployed contract.
func NewBalanceDeltaLibraryCaller(address common.Address, caller bind.ContractCaller) (*BalanceDeltaLibraryCaller, error) {
	contract, err := bindBalanceDeltaLibrary(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BalanceDeltaLibraryCaller{contract: contract}, nil
}

// NewBalanceDeltaLibraryTransactor creates a new write-only instance of BalanceDeltaLibrary, bound to a specific deployed contract.
func NewBalanceDeltaLibraryTransactor(address common.Address, transactor bind.ContractTransactor) (*BalanceDeltaLibraryTransactor, error) {
	contract, err := bindBalanceDeltaLibrary(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BalanceDeltaLibraryTransactor{contract: contract}, nil
}

// NewBalanceDeltaLibraryFilterer creates a new log filterer instance of BalanceDeltaLibrary, bound to a specific deployed contract.
func NewBalanceDeltaLibraryFilterer(address common.Address, filterer bind.ContractFilterer) (*BalanceDeltaLibraryFilterer, error) {
	contract, err := bindBalanceDeltaLibrary(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BalanceDeltaLibraryFilterer{contract: contract}, nil
}

// bindBalanceDeltaLibrary binds a generic wrapper to an already deployed contract.
func bindBalanceDeltaLibrary(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BalanceDeltaLibraryMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BalanceDeltaLibrary *BalanceDeltaLibraryRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BalanceDeltaLibrary.Contract.BalanceDeltaLibraryCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BalanceDeltaLibrary *BalanceDeltaLibraryRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BalanceDeltaLibrary.Contract.BalanceDeltaLibraryTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BalanceDeltaLibrary *BalanceDeltaLibraryRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BalanceDeltaLibrary.Contract.BalanceDeltaLibraryTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BalanceDeltaLibrary *BalanceDeltaLibraryCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BalanceDeltaLibrary.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BalanceDeltaLibrary *BalanceDeltaLibraryTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BalanceDeltaLibrary.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BalanceDeltaLibrary *BalanceDeltaLibraryTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BalanceDeltaLibrary.Contract.contract.Transact(opts, method, params...)
}

// BaseFactoryMetaData contains all meta data concerning the BaseFactory contract.
var BaseFactoryMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"TargetPrefix\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_FLAG_MASK\",\"outputs\":[{\"internalType\":\"uint160\",\"name\":\"\",\"type\":\"uint160\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIPoolManager\",\"name\":\"poolManager\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIPoolManager\",\"name\":\"poolManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startSalt\",\"type\":\"uint256\"}],\"name\":\"mineDeploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIPoolManager\",\"name\":\"poolManager\",\"type\":\"address\"}],\"name\":\"mineDeploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIPoolManager\",\"name\":\"poolManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startSalt\",\"type\":\"uint256\"}],\"name\":\"mineSalt\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// BaseFactoryABI is the input ABI used to generate the binding from.
// Deprecated: Use BaseFactoryMetaData.ABI instead.
var BaseFactoryABI = BaseFactoryMetaData.ABI

// BaseFactory is an auto generated Go binding around an Ethereum contract.
type BaseFactory struct {
	BaseFactoryCaller     // Read-only binding to the contract
	BaseFactoryTransactor // Write-only binding to the contract
	BaseFactoryFilterer   // Log filterer for contract events
}

// BaseFactoryCaller is an auto generated read-only Go binding around an Ethereum contract.
type BaseFactoryCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BaseFactoryTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BaseFactoryTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BaseFactoryFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BaseFactoryFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BaseFactorySession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BaseFactorySession struct {
	Contract     *BaseFactory      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BaseFactoryCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BaseFactoryCallerSession struct {
	Contract *BaseFactoryCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// BaseFactoryTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BaseFactoryTransactorSession struct {
	Contract     *BaseFactoryTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// BaseFactoryRaw is an auto generated low-level Go binding around an Ethereum contract.
type BaseFactoryRaw struct {
	Contract *BaseFactory // Generic contract binding to access the raw methods on
}

// BaseFactoryCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BaseFactoryCallerRaw struct {
	Contract *BaseFactoryCaller // Generic read-only contract binding to access the raw methods on
}

// BaseFactoryTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BaseFactoryTransactorRaw struct {
	Contract *BaseFactoryTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBaseFactory creates a new instance of BaseFactory, bound to a specific deployed contract.
func NewBaseFactory(address common.Address, backend bind.ContractBackend) (*BaseFactory, error) {
	contract, err := bindBaseFactory(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BaseFactory{BaseFactoryCaller: BaseFactoryCaller{contract: contract}, BaseFactoryTransactor: BaseFactoryTransactor{contract: contract}, BaseFactoryFilterer: BaseFactoryFilterer{contract: contract}}, nil
}

// NewBaseFactoryCaller creates a new read-only instance of BaseFactory, bound to a specific deployed contract.
func NewBaseFactoryCaller(address common.Address, caller bind.ContractCaller) (*BaseFactoryCaller, error) {
	contract, err := bindBaseFactory(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BaseFactoryCaller{contract: contract}, nil
}

// NewBaseFactoryTransactor creates a new write-only instance of BaseFactory, bound to a specific deployed contract.
func NewBaseFactoryTransactor(address common.Address, transactor bind.ContractTransactor) (*BaseFactoryTransactor, error) {
	contract, err := bindBaseFactory(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BaseFactoryTransactor{contract: contract}, nil
}

// NewBaseFactoryFilterer creates a new log filterer instance of BaseFactory, bound to a specific deployed contract.
func NewBaseFactoryFilterer(address common.Address, filterer bind.ContractFilterer) (*BaseFactoryFilterer, error) {
	contract, err := bindBaseFactory(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BaseFactoryFilterer{contract: contract}, nil
}

// bindBaseFactory binds a generic wrapper to an already deployed contract.
func bindBaseFactory(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BaseFactoryMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BaseFactory *BaseFactoryRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BaseFactory.Contract.BaseFactoryCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BaseFactory *BaseFactoryRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BaseFactory.Contract.BaseFactoryTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BaseFactory *BaseFactoryRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BaseFactory.Contract.BaseFactoryTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BaseFactory *BaseFactoryCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BaseFactory.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BaseFactory *BaseFactoryTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BaseFactory.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BaseFactory *BaseFactoryTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BaseFactory.Contract.contract.Transact(opts, method, params...)
}

// TargetPrefix is a free data retrieval call binding the contract method 0xa707b18a.
//
// Solidity: function TargetPrefix() view returns(address)
func (_BaseFactory *BaseFactoryCaller) TargetPrefix(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BaseFactory.contract.Call(opts, &out, "TargetPrefix")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// TargetPrefix is a free data retrieval call binding the contract method 0xa707b18a.
//
// Solidity: function TargetPrefix() view returns(address)
func (_BaseFactory *BaseFactorySession) TargetPrefix() (common.Address, error) {
	return _BaseFactory.Contract.TargetPrefix(&_BaseFactory.CallOpts)
}

// TargetPrefix is a free data retrieval call binding the contract method 0xa707b18a.
//
// Solidity: function TargetPrefix() view returns(address)
func (_BaseFactory *BaseFactoryCallerSession) TargetPrefix() (common.Address, error) {
	return _BaseFactory.Contract.TargetPrefix(&_BaseFactory.CallOpts)
}

// UNISWAPFLAGMASK is a free data retrieval call binding the contract method 0xc6f61463.
//
// Solidity: function UNISWAP_FLAG_MASK() view returns(uint160)
func (_BaseFactory *BaseFactoryCaller) UNISWAPFLAGMASK(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BaseFactory.contract.Call(opts, &out, "UNISWAP_FLAG_MASK")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// UNISWAPFLAGMASK is a free data retrieval call binding the contract method 0xc6f61463.
//
// Solidity: function UNISWAP_FLAG_MASK() view returns(uint160)
func (_BaseFactory *BaseFactorySession) UNISWAPFLAGMASK() (*big.Int, error) {
	return _BaseFactory.Contract.UNISWAPFLAGMASK(&_BaseFactory.CallOpts)
}

// UNISWAPFLAGMASK is a free data retrieval call binding the contract method 0xc6f61463.
//
// Solidity: function UNISWAP_FLAG_MASK() view returns(uint160)
func (_BaseFactory *BaseFactoryCallerSession) UNISWAPFLAGMASK() (*big.Int, error) {
	return _BaseFactory.Contract.UNISWAPFLAGMASK(&_BaseFactory.CallOpts)
}

// MineSalt is a free data retrieval call binding the contract method 0x635d4017.
//
// Solidity: function mineSalt(address poolManager, uint256 startSalt) view returns(bytes32 salt)
func (_BaseFactory *BaseFactoryCaller) MineSalt(opts *bind.CallOpts, poolManager common.Address, startSalt *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _BaseFactory.contract.Call(opts, &out, "mineSalt", poolManager, startSalt)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// MineSalt is a free data retrieval call binding the contract method 0x635d4017.
//
// Solidity: function mineSalt(address poolManager, uint256 startSalt) view returns(bytes32 salt)
func (_BaseFactory *BaseFactorySession) MineSalt(poolManager common.Address, startSalt *big.Int) ([32]byte, error) {
	return _BaseFactory.Contract.MineSalt(&_BaseFactory.CallOpts, poolManager, startSalt)
}

// MineSalt is a free data retrieval call binding the contract method 0x635d4017.
//
// Solidity: function mineSalt(address poolManager, uint256 startSalt) view returns(bytes32 salt)
func (_BaseFactory *BaseFactoryCallerSession) MineSalt(poolManager common.Address, startSalt *big.Int) ([32]byte, error) {
	return _BaseFactory.Contract.MineSalt(&_BaseFactory.CallOpts, poolManager, startSalt)
}

// Deploy is a paid mutator transaction binding the contract method 0x32c02a14.
//
// Solidity: function deploy(address poolManager, bytes32 salt) returns(address)
func (_BaseFactory *BaseFactoryTransactor) Deploy(opts *bind.TransactOpts, poolManager common.Address, salt [32]byte) (*types.Transaction, error) {
	return _BaseFactory.contract.Transact(opts, "deploy", poolManager, salt)
}

// Deploy is a paid mutator transaction binding the contract method 0x32c02a14.
//
// Solidity: function deploy(address poolManager, bytes32 salt) returns(address)
func (_BaseFactory *BaseFactorySession) Deploy(poolManager common.Address, salt [32]byte) (*types.Transaction, error) {
	return _BaseFactory.Contract.Deploy(&_BaseFactory.TransactOpts, poolManager, salt)
}

// Deploy is a paid mutator transaction binding the contract method 0x32c02a14.
//
// Solidity: function deploy(address poolManager, bytes32 salt) returns(address)
func (_BaseFactory *BaseFactoryTransactorSession) Deploy(poolManager common.Address, salt [32]byte) (*types.Transaction, error) {
	return _BaseFactory.Contract.Deploy(&_BaseFactory.TransactOpts, poolManager, salt)
}

// MineDeploy is a paid mutator transaction binding the contract method 0x21cde3ec.
//
// Solidity: function mineDeploy(address poolManager, uint256 startSalt) returns(address)
func (_BaseFactory *BaseFactoryTransactor) MineDeploy(opts *bind.TransactOpts, poolManager common.Address, startSalt *big.Int) (*types.Transaction, error) {
	return _BaseFactory.contract.Transact(opts, "mineDeploy", poolManager, startSalt)
}

// MineDeploy is a paid mutator transaction binding the contract method 0x21cde3ec.
//
// Solidity: function mineDeploy(address poolManager, uint256 startSalt) returns(address)
func (_BaseFactory *BaseFactorySession) MineDeploy(poolManager common.Address, startSalt *big.Int) (*types.Transaction, error) {
	return _BaseFactory.Contract.MineDeploy(&_BaseFactory.TransactOpts, poolManager, startSalt)
}

// MineDeploy is a paid mutator transaction binding the contract method 0x21cde3ec.
//
// Solidity: function mineDeploy(address poolManager, uint256 startSalt) returns(address)
func (_BaseFactory *BaseFactoryTransactorSession) MineDeploy(poolManager common.Address, startSalt *big.Int) (*types.Transaction, error) {
	return _BaseFactory.Contract.MineDeploy(&_BaseFactory.TransactOpts, poolManager, startSalt)
}

// MineDeploy0 is a paid mutator transaction binding the contract method 0x2e026a67.
//
// Solidity: function mineDeploy(address poolManager) returns(address)
func (_BaseFactory *BaseFactoryTransactor) MineDeploy0(opts *bind.TransactOpts, poolManager common.Address) (*types.Transaction, error) {
	return _BaseFactory.contract.Transact(opts, "mineDeploy0", poolManager)
}

// MineDeploy0 is a paid mutator transaction binding the contract method 0x2e026a67.
//
// Solidity: function mineDeploy(address poolManager) returns(address)
func (_BaseFactory *BaseFactorySession) MineDeploy0(poolManager common.Address) (*types.Transaction, error) {
	return _BaseFactory.Contract.MineDeploy0(&_BaseFactory.TransactOpts, poolManager)
}

// MineDeploy0 is a paid mutator transaction binding the contract method 0x2e026a67.
//
// Solidity: function mineDeploy(address poolManager) returns(address)
func (_BaseFactory *BaseFactoryTransactorSession) MineDeploy0(poolManager common.Address) (*types.Transaction, error) {
	return _BaseFactory.Contract.MineDeploy0(&_BaseFactory.TransactOpts, poolManager)
}

// BaseHookMetaData contains all meta data concerning the BaseHook contract.
var BaseHookMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hooks\",\"type\":\"address\"}],\"name\":\"HookAddressNotValid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HookNotImplemented\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPool\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LockFailure\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MustUseDynamicFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotPoolManager\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotSelf\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"afterDonate\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint160\",\"name\":\"\",\"type\":\"uint160\"},{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"afterInitialize\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"int256\",\"name\":\"liquidityDelta\",\"type\":\"int256\"}],\"internalType\":\"structIPoolManager.ModifyPositionParams\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"BalanceDelta\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"afterModifyPosition\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"zeroForOne\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"amountSpecified\",\"type\":\"int256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"structIPoolManager.SwapParams\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"BalanceDelta\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"afterSwap\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"beforeDonate\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint160\",\"name\":\"\",\"type\":\"uint160\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"beforeInitialize\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"int256\",\"name\":\"liquidityDelta\",\"type\":\"int256\"}],\"internalType\":\"structIPoolManager.ModifyPositionParams\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"beforeModifyPosition\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"zeroForOne\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"amountSpecified\",\"type\":\"int256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"structIPoolManager.SwapParams\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"beforeSwap\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHooksCalls\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"beforeInitialize\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"afterInitialize\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"beforeModifyPosition\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"afterModifyPosition\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"beforeSwap\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"afterSwap\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"beforeDonate\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"afterDonate\",\"type\":\"bool\"}],\"internalType\":\"structHooks.Calls\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"lockAcquired\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolManager\",\"outputs\":[{\"internalType\":\"contractIPoolManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// BaseHookABI is the input ABI used to generate the binding from.
// Deprecated: Use BaseHookMetaData.ABI instead.
var BaseHookABI = BaseHookMetaData.ABI

// BaseHook is an auto generated Go binding around an Ethereum contract.
type BaseHook struct {
	BaseHookCaller     // Read-only binding to the contract
	BaseHookTransactor // Write-only binding to the contract
	BaseHookFilterer   // Log filterer for contract events
}

// BaseHookCaller is an auto generated read-only Go binding around an Ethereum contract.
type BaseHookCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BaseHookTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BaseHookTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BaseHookFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BaseHookFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BaseHookSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BaseHookSession struct {
	Contract     *BaseHook         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BaseHookCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BaseHookCallerSession struct {
	Contract *BaseHookCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// BaseHookTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BaseHookTransactorSession struct {
	Contract     *BaseHookTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// BaseHookRaw is an auto generated low-level Go binding around an Ethereum contract.
type BaseHookRaw struct {
	Contract *BaseHook // Generic contract binding to access the raw methods on
}

// BaseHookCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BaseHookCallerRaw struct {
	Contract *BaseHookCaller // Generic read-only contract binding to access the raw methods on
}

// BaseHookTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BaseHookTransactorRaw struct {
	Contract *BaseHookTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBaseHook creates a new instance of BaseHook, bound to a specific deployed contract.
func NewBaseHook(address common.Address, backend bind.ContractBackend) (*BaseHook, error) {
	contract, err := bindBaseHook(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BaseHook{BaseHookCaller: BaseHookCaller{contract: contract}, BaseHookTransactor: BaseHookTransactor{contract: contract}, BaseHookFilterer: BaseHookFilterer{contract: contract}}, nil
}

// NewBaseHookCaller creates a new read-only instance of BaseHook, bound to a specific deployed contract.
func NewBaseHookCaller(address common.Address, caller bind.ContractCaller) (*BaseHookCaller, error) {
	contract, err := bindBaseHook(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BaseHookCaller{contract: contract}, nil
}

// NewBaseHookTransactor creates a new write-only instance of BaseHook, bound to a specific deployed contract.
func NewBaseHookTransactor(address common.Address, transactor bind.ContractTransactor) (*BaseHookTransactor, error) {
	contract, err := bindBaseHook(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BaseHookTransactor{contract: contract}, nil
}

// NewBaseHookFilterer creates a new log filterer instance of BaseHook, bound to a specific deployed contract.
func NewBaseHookFilterer(address common.Address, filterer bind.ContractFilterer) (*BaseHookFilterer, error) {
	contract, err := bindBaseHook(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BaseHookFilterer{contract: contract}, nil
}

// bindBaseHook binds a generic wrapper to an already deployed contract.
func bindBaseHook(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BaseHookMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BaseHook *BaseHookRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BaseHook.Contract.BaseHookCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BaseHook *BaseHookRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BaseHook.Contract.BaseHookTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BaseHook *BaseHookRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BaseHook.Contract.BaseHookTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BaseHook *BaseHookCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BaseHook.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BaseHook *BaseHookTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BaseHook.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BaseHook *BaseHookTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BaseHook.Contract.contract.Transact(opts, method, params...)
}

// GetHooksCalls is a free data retrieval call binding the contract method 0x612c39b7.
//
// Solidity: function getHooksCalls() pure returns((bool,bool,bool,bool,bool,bool,bool,bool))
func (_BaseHook *BaseHookCaller) GetHooksCalls(opts *bind.CallOpts) (HooksCalls, error) {
	var out []interface{}
	err := _BaseHook.contract.Call(opts, &out, "getHooksCalls")

	if err != nil {
		return *new(HooksCalls), err
	}

	out0 := *abi.ConvertType(out[0], new(HooksCalls)).(*HooksCalls)

	return out0, err

}

// GetHooksCalls is a free data retrieval call binding the contract method 0x612c39b7.
//
// Solidity: function getHooksCalls() pure returns((bool,bool,bool,bool,bool,bool,bool,bool))
func (_BaseHook *BaseHookSession) GetHooksCalls() (HooksCalls, error) {
	return _BaseHook.Contract.GetHooksCalls(&_BaseHook.CallOpts)
}

// GetHooksCalls is a free data retrieval call binding the contract method 0x612c39b7.
//
// Solidity: function getHooksCalls() pure returns((bool,bool,bool,bool,bool,bool,bool,bool))
func (_BaseHook *BaseHookCallerSession) GetHooksCalls() (HooksCalls, error) {
	return _BaseHook.Contract.GetHooksCalls(&_BaseHook.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BaseHook *BaseHookCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BaseHook.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BaseHook *BaseHookSession) Owner() (common.Address, error) {
	return _BaseHook.Contract.Owner(&_BaseHook.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BaseHook *BaseHookCallerSession) Owner() (common.Address, error) {
	return _BaseHook.Contract.Owner(&_BaseHook.CallOpts)
}

// PoolManager is a free data retrieval call binding the contract method 0xdc4c90d3.
//
// Solidity: function poolManager() view returns(address)
func (_BaseHook *BaseHookCaller) PoolManager(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BaseHook.contract.Call(opts, &out, "poolManager")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PoolManager is a free data retrieval call binding the contract method 0xdc4c90d3.
//
// Solidity: function poolManager() view returns(address)
func (_BaseHook *BaseHookSession) PoolManager() (common.Address, error) {
	return _BaseHook.Contract.PoolManager(&_BaseHook.CallOpts)
}

// PoolManager is a free data retrieval call binding the contract method 0xdc4c90d3.
//
// Solidity: function poolManager() view returns(address)
func (_BaseHook *BaseHookCallerSession) PoolManager() (common.Address, error) {
	return _BaseHook.Contract.PoolManager(&_BaseHook.CallOpts)
}

// AfterDonate is a paid mutator transaction binding the contract method 0xe1b4af69.
//
// Solidity: function afterDonate(address , (address,address,uint24,int24,address) , uint256 , uint256 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactor) AfterDonate(opts *bind.TransactOpts, arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.contract.Transact(opts, "afterDonate", arg0, arg1, arg2, arg3, arg4)
}

// AfterDonate is a paid mutator transaction binding the contract method 0xe1b4af69.
//
// Solidity: function afterDonate(address , (address,address,uint24,int24,address) , uint256 , uint256 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookSession) AfterDonate(arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.AfterDonate(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// AfterDonate is a paid mutator transaction binding the contract method 0xe1b4af69.
//
// Solidity: function afterDonate(address , (address,address,uint24,int24,address) , uint256 , uint256 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactorSession) AfterDonate(arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.AfterDonate(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// AfterInitialize is a paid mutator transaction binding the contract method 0xa910f80f.
//
// Solidity: function afterInitialize(address , (address,address,uint24,int24,address) , uint160 , int24 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactor) AfterInitialize(opts *bind.TransactOpts, arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.contract.Transact(opts, "afterInitialize", arg0, arg1, arg2, arg3, arg4)
}

// AfterInitialize is a paid mutator transaction binding the contract method 0xa910f80f.
//
// Solidity: function afterInitialize(address , (address,address,uint24,int24,address) , uint160 , int24 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookSession) AfterInitialize(arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.AfterInitialize(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// AfterInitialize is a paid mutator transaction binding the contract method 0xa910f80f.
//
// Solidity: function afterInitialize(address , (address,address,uint24,int24,address) , uint160 , int24 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactorSession) AfterInitialize(arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.AfterInitialize(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// AfterModifyPosition is a paid mutator transaction binding the contract method 0x30b7cdef.
//
// Solidity: function afterModifyPosition(address , (address,address,uint24,int24,address) , (int24,int24,int256) , int256 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactor) AfterModifyPosition(opts *bind.TransactOpts, arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerModifyPositionParams, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.contract.Transact(opts, "afterModifyPosition", arg0, arg1, arg2, arg3, arg4)
}

// AfterModifyPosition is a paid mutator transaction binding the contract method 0x30b7cdef.
//
// Solidity: function afterModifyPosition(address , (address,address,uint24,int24,address) , (int24,int24,int256) , int256 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookSession) AfterModifyPosition(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerModifyPositionParams, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.AfterModifyPosition(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// AfterModifyPosition is a paid mutator transaction binding the contract method 0x30b7cdef.
//
// Solidity: function afterModifyPosition(address , (address,address,uint24,int24,address) , (int24,int24,int256) , int256 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactorSession) AfterModifyPosition(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerModifyPositionParams, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.AfterModifyPosition(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// AfterSwap is a paid mutator transaction binding the contract method 0xb47b2fb1.
//
// Solidity: function afterSwap(address , (address,address,uint24,int24,address) , (bool,int256,uint160) , int256 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactor) AfterSwap(opts *bind.TransactOpts, arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerSwapParams, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.contract.Transact(opts, "afterSwap", arg0, arg1, arg2, arg3, arg4)
}

// AfterSwap is a paid mutator transaction binding the contract method 0xb47b2fb1.
//
// Solidity: function afterSwap(address , (address,address,uint24,int24,address) , (bool,int256,uint160) , int256 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookSession) AfterSwap(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerSwapParams, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.AfterSwap(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// AfterSwap is a paid mutator transaction binding the contract method 0xb47b2fb1.
//
// Solidity: function afterSwap(address , (address,address,uint24,int24,address) , (bool,int256,uint160) , int256 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactorSession) AfterSwap(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerSwapParams, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.AfterSwap(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// BeforeDonate is a paid mutator transaction binding the contract method 0xb6a8b0fa.
//
// Solidity: function beforeDonate(address , (address,address,uint24,int24,address) , uint256 , uint256 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactor) BeforeDonate(opts *bind.TransactOpts, arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.contract.Transact(opts, "beforeDonate", arg0, arg1, arg2, arg3, arg4)
}

// BeforeDonate is a paid mutator transaction binding the contract method 0xb6a8b0fa.
//
// Solidity: function beforeDonate(address , (address,address,uint24,int24,address) , uint256 , uint256 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookSession) BeforeDonate(arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.BeforeDonate(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// BeforeDonate is a paid mutator transaction binding the contract method 0xb6a8b0fa.
//
// Solidity: function beforeDonate(address , (address,address,uint24,int24,address) , uint256 , uint256 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactorSession) BeforeDonate(arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.BeforeDonate(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// BeforeInitialize is a paid mutator transaction binding the contract method 0x3440d820.
//
// Solidity: function beforeInitialize(address , (address,address,uint24,int24,address) , uint160 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactor) BeforeInitialize(opts *bind.TransactOpts, arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 []byte) (*types.Transaction, error) {
	return _BaseHook.contract.Transact(opts, "beforeInitialize", arg0, arg1, arg2, arg3)
}

// BeforeInitialize is a paid mutator transaction binding the contract method 0x3440d820.
//
// Solidity: function beforeInitialize(address , (address,address,uint24,int24,address) , uint160 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookSession) BeforeInitialize(arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.BeforeInitialize(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3)
}

// BeforeInitialize is a paid mutator transaction binding the contract method 0x3440d820.
//
// Solidity: function beforeInitialize(address , (address,address,uint24,int24,address) , uint160 , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactorSession) BeforeInitialize(arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.BeforeInitialize(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3)
}

// BeforeModifyPosition is a paid mutator transaction binding the contract method 0xfe9a6f45.
//
// Solidity: function beforeModifyPosition(address , (address,address,uint24,int24,address) , (int24,int24,int256) , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactor) BeforeModifyPosition(opts *bind.TransactOpts, arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerModifyPositionParams, arg3 []byte) (*types.Transaction, error) {
	return _BaseHook.contract.Transact(opts, "beforeModifyPosition", arg0, arg1, arg2, arg3)
}

// BeforeModifyPosition is a paid mutator transaction binding the contract method 0xfe9a6f45.
//
// Solidity: function beforeModifyPosition(address , (address,address,uint24,int24,address) , (int24,int24,int256) , bytes ) returns(bytes4)
func (_BaseHook *BaseHookSession) BeforeModifyPosition(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerModifyPositionParams, arg3 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.BeforeModifyPosition(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3)
}

// BeforeModifyPosition is a paid mutator transaction binding the contract method 0xfe9a6f45.
//
// Solidity: function beforeModifyPosition(address , (address,address,uint24,int24,address) , (int24,int24,int256) , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactorSession) BeforeModifyPosition(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerModifyPositionParams, arg3 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.BeforeModifyPosition(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3)
}

// BeforeSwap is a paid mutator transaction binding the contract method 0x575e24b4.
//
// Solidity: function beforeSwap(address , (address,address,uint24,int24,address) , (bool,int256,uint160) , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactor) BeforeSwap(opts *bind.TransactOpts, arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerSwapParams, arg3 []byte) (*types.Transaction, error) {
	return _BaseHook.contract.Transact(opts, "beforeSwap", arg0, arg1, arg2, arg3)
}

// BeforeSwap is a paid mutator transaction binding the contract method 0x575e24b4.
//
// Solidity: function beforeSwap(address , (address,address,uint24,int24,address) , (bool,int256,uint160) , bytes ) returns(bytes4)
func (_BaseHook *BaseHookSession) BeforeSwap(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerSwapParams, arg3 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.BeforeSwap(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3)
}

// BeforeSwap is a paid mutator transaction binding the contract method 0x575e24b4.
//
// Solidity: function beforeSwap(address , (address,address,uint24,int24,address) , (bool,int256,uint160) , bytes ) returns(bytes4)
func (_BaseHook *BaseHookTransactorSession) BeforeSwap(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerSwapParams, arg3 []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.BeforeSwap(&_BaseHook.TransactOpts, arg0, arg1, arg2, arg3)
}

// LockAcquired is a paid mutator transaction binding the contract method 0xab6291fe.
//
// Solidity: function lockAcquired(bytes data) returns(bytes)
func (_BaseHook *BaseHookTransactor) LockAcquired(opts *bind.TransactOpts, data []byte) (*types.Transaction, error) {
	return _BaseHook.contract.Transact(opts, "lockAcquired", data)
}

// LockAcquired is a paid mutator transaction binding the contract method 0xab6291fe.
//
// Solidity: function lockAcquired(bytes data) returns(bytes)
func (_BaseHook *BaseHookSession) LockAcquired(data []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.LockAcquired(&_BaseHook.TransactOpts, data)
}

// LockAcquired is a paid mutator transaction binding the contract method 0xab6291fe.
//
// Solidity: function lockAcquired(bytes data) returns(bytes)
func (_BaseHook *BaseHookTransactorSession) LockAcquired(data []byte) (*types.Transaction, error) {
	return _BaseHook.Contract.LockAcquired(&_BaseHook.TransactOpts, data)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_BaseHook *BaseHookTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BaseHook.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_BaseHook *BaseHookSession) RenounceOwnership() (*types.Transaction, error) {
	return _BaseHook.Contract.RenounceOwnership(&_BaseHook.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_BaseHook *BaseHookTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _BaseHook.Contract.RenounceOwnership(&_BaseHook.TransactOpts)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BaseHook *BaseHookTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _BaseHook.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BaseHook *BaseHookSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BaseHook.Contract.TransferOwnership(&_BaseHook.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BaseHook *BaseHookTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BaseHook.Contract.TransferOwnership(&_BaseHook.TransactOpts, newOwner)
}

// BaseHookOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the BaseHook contract.
type BaseHookOwnershipTransferredIterator struct {
	Event *BaseHookOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BaseHookOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BaseHookOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BaseHookOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BaseHookOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BaseHookOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BaseHookOwnershipTransferred represents a OwnershipTransferred event raised by the BaseHook contract.
type BaseHookOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BaseHook *BaseHookFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*BaseHookOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BaseHook.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &BaseHookOwnershipTransferredIterator{contract: _BaseHook.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BaseHook *BaseHookFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *BaseHookOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BaseHook.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BaseHookOwnershipTransferred)
				if err := _BaseHook.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BaseHook *BaseHookFilterer) ParseOwnershipTransferred(log types.Log) (*BaseHookOwnershipTransferred, error) {
	event := new(BaseHookOwnershipTransferred)
	if err := _BaseHook.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BeaconVerifierMetaData contains all meta data concerning the BeaconVerifier contract.
var BeaconVerifierMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commit\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[35]\",\"name\":\"input\",\"type\":\"uint256[35]\"}],\"name\":\"verifyBlsSigProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"r\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[33]\",\"name\":\"input\",\"type\":\"uint256[33]\"}],\"name\":\"verifyCommitteeRootMappingProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"r\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"signingRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"syncCommitteePoseidonRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"participation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commitment\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commitment\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIBeaconVerifier.Proof\",\"name\":\"p\",\"type\":\"tuple\"}],\"name\":\"verifySignatureProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sszRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"poseidonRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commitment\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIBeaconVerifier.Proof\",\"name\":\"p\",\"type\":\"tuple\"}],\"name\":\"verifySyncCommitteeRootMappingProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x6080806040523461001657613067908161001b8239f35b5f80fdfe60806040526004361015610011575f80fd5b5f803560e01c9081630cc26769146100575750806352356da0146100525780637a5387811461004d5763ab00dde614610048575f80fd5b610662565b6105dd565b61052b565b346100bc576105a03660031901126100bc5761007236610236565b9061007c36610331565b61008536610273565b9061008f366102b1565b923661016312156100bc5760206100b2868686866100ac3661015a565b93610ad1565b6040519015158152f35b80fd5b634e487b7160e01b5f52604160045260245ffd5b604051906080820182811067ffffffffffffffff8211176100f357604052565b6100bf565b604051906040820182811067ffffffffffffffff8211176100f357604052565b60405190610460820182811067ffffffffffffffff8211176100f357604052565b60405190610420820182811067ffffffffffffffff8211176100f357604052565b90610163610118565b91826105a491821161019057610144905b82821061018057505050565b8135815260209182019101610174565b5f80fd5b9061019d6100f8565b918261018491821161019057610144905b8282106101ba57505050565b81358152602091820191016101ae565b906101d36100f8565b91826101c491821161019057610184905b8282106101f057505050565b81358152602091820191016101e4565b906102096100f8565b918261014491821161019057610104905b82821061022657505050565b813581526020918201910161021a565b8060231215610190576102476100f8565b90816044918211610190576004905b8282106102635750505090565b8135815260209182019101610256565b8060e31215610190576102846100f8565b90816101049182116101905760c4905b8282106102a15750505090565b8135815260209182019101610294565b806101231215610190576102c36100f8565b908161014491821161019057610104905b8282106102e15750505090565b81358152602091820191016102d4565b9080601f83011215610190576103056100f8565b80926040810192831161019057905b8282106103215750505090565b8135815260209182019101610314565b8060631215610190576103426100f8565b908160c491808311610190576044915b838310610360575050505090565b602060409161036f84866102f1565b815201920191610352565b8060e312156101905761038b6100f8565b9081610144918083116101905760c4915b8383106103aa575050505090565b60206040916103b984866102f1565b81520192019161039c565b8060a31215610190576103d56100f8565b908161010491808311610190576084915b8383106103f4575050505090565b602060409161040384866102f1565b8152019201916103e6565b90610140608319830112610190576104246100d3565b918060a31215610190576104366100f8565b60c481838211610190576084905b8282106104905750505083526104598161037a565b60208401528061016312156101905761047181610194565b6040840152806101a3121561019057610489906101ca565b6060830152565b8135815260209182019101610444565b90610140604319830112610190576104b66100d3565b918060631215610190576104c86100f8565b608481838211610190576044905b82821061051b5750505083526104eb816103c4565b60208401528061012312156101905761050381610200565b60408401528061016312156101905761048990610194565b81358152602091820191016104d6565b34610190576101c0366003190112610190576105463661040e565b61054e610118565b906104603683375f6004355b602082106105b3576105af61059d858560443561040083015260243561042083015260643561044083015280519060208101516060604083015192015192610ad1565b60405190151581529081906020820190565b0390f35b8060ff6105d792166105cd6105c785610757565b87610779565b5260081c91610749565b9061055a565b3461019057610180366003190112610190576105f8366104a0565b610600610139565b906104203683375f6004355b60208210610638576105af61059d85856024356104008301528051906040602082015191015191611c65565b601f9082820391821161065d57610657916105cd60ff8316918761078f565b9061060c565b610735565b34610190576105203660031901126101905761067d36610236565b61068636610331565b9061069036610273565b91366101231215610190576106a3610139565b9283916105249336851161019057602095610104905b8682106106cc5750506100b29450611c65565b813581529087019087016106b9565b6106e36100d3565b906080368337565b604051906060820182811067ffffffffffffffff8211176100f3576040526060368337565b604051906020820182811067ffffffffffffffff8211176100f3576040526020368337565b634e487b7160e01b5f52601160045260245ffd5b5f19811461065d5760010190565b601f0390601f821161065d57565b634e487b7160e01b5f52603260045260245ffd5b90602381101561078a5760051b0190565b610765565b90602181101561078a5760051b0190565b6107a86100f8565b906107b16100f8565b604036823782526107c06100f8565b60403682376020830152565b6107d46100d3565b906107dd6100f8565b5f9081815281602082015283526107f26107a0565b60208401526107ff6100f8565b81815281602082015260408401526108156100f8565b9080825260208201526060830152565b1561082c57565b60405162461bcd60e51b815260206004820152601760248201527f76657269666965722d61582d6774652d7072696d652d710000000000000000006044820152606490fd5b1561087857565b60405162461bcd60e51b815260206004820152601760248201527f76657269666965722d61592d6774652d7072696d652d710000000000000000006044820152606490fd5b156108c457565b60405162461bcd60e51b815260206004820152601860248201527f76657269666965722d6258302d6774652d7072696d652d7100000000000000006044820152606490fd5b1561091057565b60405162461bcd60e51b815260206004820152601860248201527f76657269666965722d6259302d6774652d7072696d652d7100000000000000006044820152606490fd5b1561095c57565b60405162461bcd60e51b815260206004820152601860248201527f76657269666965722d6258312d6774652d7072696d652d7100000000000000006044820152606490fd5b156109a857565b60405162461bcd60e51b815260206004820152601860248201527f76657269666965722d6259312d6774652d7072696d652d7100000000000000006044820152606490fd5b156109f457565b60405162461bcd60e51b815260206004820152601760248201527f76657269666965722d63582d6774652d7072696d652d710000000000000000006044820152606490fd5b15610a4057565b60405162461bcd60e51b815260206004820152601760248201527f76657269666965722d63592d6774652d7072696d652d710000000000000000006044820152606490fd5b15610a8c57565b60405162461bcd60e51b815260206004820152601f60248201527f76657269666965722d6774652d736e61726b2d7363616c61722d6669656c64006044820152606490fd5b94939492919092610ae06107cc565b8151602080930151610af06100f8565b918252838201528152610b016100f8565b948051518652610b12815160200190565b5183870152610b3183610b236100f8565b920180515183525160200190565b5183820152610b3e6100f8565b95865282860152818101948552818351930151610b596100f8565b9384528284015260408101928352835193828101948551610b786100f8565b9182528482015260608301908152610c2c7f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47610bb78186515110610825565b610bc681878751015110610871565b610bd4818a515151106108bd565b610be481878b5101515110610909565b610bfb81610bf48b515160200190565b5110610955565b610c1481610c0d888c51015160200190565b51106109a1565b610c2181885151106109ed565b858751015110610a39565b5f5b602381106119685750906119419798939291610c486119e9565b96610c516100f8565b925f845261190884878101985f8a528199610c6a6106db565b918a610440610c776106eb565b927f2065b90c648581703a4ef82833653ae713aaf62c2dc4ef26b0a9bbbdf254b48a610ca16100f8565b955f87525f858801527f0da0d09dcc32c2d20c9905307190ffb91538db928804c70e7ed77639f2cee0fe8952527f2fcf362c494439bcae24ab0ab7dd0bd40825ed18725c1d11d25eeb863f24194884527f184edce371c121d112278a4d1239f9d65421fb00e688d7612320bb5f66e7409d8385017f1a7a0f4ef55687795fa98c4585fc66e26ddea1f6e161a837ef4a4f1ae9c8808b815282519460408701958652610d4e8a8a8a8a612c69565b7f159c9e6c6ad47c3114dd4bdc88dc34359cae49de8306c8f56c9ba9d56429755e87527f261a0e3bad2b8c7b4057a7708b68ddaa9684eaa9d458088e7a2fe7813e08d06082528301518552610da589898989612c69565b7f1243c2c01b1a238bd0937eed8a5eb5f962eae681000356540ae1cfb36e1e308b86527e816901d1be816971e5f7e84b32a92c58a9f8971ff921adc37884d47db225e2815260408301518552610dfd89898989612c69565b7f25ebb06beeca9f8b08c511a86423c8f8705f115fe942220b9f8e30d54b016e0686527f1a598b2d183a54a959959d562879ae4b48df2203151d223973543b7d9584c59e815260608301518552610e5689898989612c69565b7f0ede030d344e453627bd0d2e849cd89947ed04b1825b0d4f7d6a8bf8b6ca5bae86527f01e7b010c4ab8cfc4791d0886bb39e1e8785b51a2a2165514d1fe026b8de24ad815260808301518552610eaf89898989612c69565b7f1f81ffd062f9644e01e392d39b8de8e030afd731c770e58f96050ed1d36d553286527f0ac85a9509ed9a6e21c1e933b10794303a4b77d9fd1fb036e966fef320cb4dad815260a08301518552610f0889898989612c69565b7f2d46add97dc6a65ee2f3dd3ea61060bf9fd510929a701e4cec0913f8ab1cafe386527f1e8e47b54e79299b14dfe604a3c8ce10ee4cb2d09be71e23628c13888c29a254815260c08301518552610f6189898989612c69565b7f146a85b7d5644a318ee8d2a44d995f580695fb92ade1dc0bbfc84cb4010ac1c386527f1d3734ea6fc621a0710ba60b024e87e0442525b2c77aff46634f6c5c0035e073815260e08301518552610fba89898989612c69565b7f12664f87a4a89be5df17d8f4cb797e102a083e505835ddfa68bfff968ded011f86527f062c4ef046ea89c77def686012d175292e6cca3adb8dc9e0234bbbe4384e6b188152610100830151855261101489898989612c69565b7f22ecd52df7b85f6392fa550619d401fedebde3332b7c8857f3b26caac17f4b7986527f25696ccea69b88905a95af209f6daa0d638426ae494b1b5800d1bb32aa271c3c8152610120830151855261106e89898989612c69565b7ee5e920eb2bd31bc7480c75e93c11a2a8f421af3e287f37a87453a96b4dd6c086527f2b82a4685f51b881675e3e4958242a11585b1aa2211bef1ba101ade59d484fcb815261014083015185526110c789898989612c69565b7f1bb112783a4bd8e95decec6012a6b0c06d076f07806241e64d5bb279055ce2e386527f03aacbe5b76da6ffe5a38b5f74bb1defdf60afde8f7bed77c2103c7d6d285c458152610160830151855261112189898989612c69565b7e89a49d6c462af5737f4f74e89ee3fd5fcda9b129a6885f4402b7191ce06ecc86527f03670d5e8e16d0f9e9351a53b707cddd87f0df01f7e71f8ef942b35a63c54d808152610180830151855261117a89898989612c69565b7f148203b1cf918d850c2e4eb482623111d69a0d149273d88bd472cc2dc667788886527f09e3685cddd844c117894cf1560ee45625a29890eb111e539598ac6c8510b26f81526101a083015185526111d489898989612c69565b7f038bda99e81e5aee528c18e38ab4a8806508a531d1f22f6618919bffb81f59f686527f14ce622b4ba47284ea8c421b00498ea220fb6f88026998098cbb21d38d8e0b0a81526101c0830151855261122e89898989612c69565b7f0c1641e14f8c4509f0c675448654f877363c981ca8c18363b549cfb115737ea386527f0b8cc9ed761dfbad8b821e125c571ba83a857c405c10df3bdeb64fc9b3248e2a81526101e0830151855261128889898989612c69565b7f14c11b03d9e6d4e5c71174b991b0b1b63f5a8539d4449e10a08275be0454646586527f014e6374d23fc81a10b61fd108e7b0e59003f8d3ed87edd40a722aafbc1c2635815261020083015185526112e289898989612c69565b7f2a195965e3a4ebe550289af22bb4c1118e21dc2c74be94ad6455e8f6eb70c8c486527f12024e0b3b82946c93024f8e1159da64dc1d3c72c49929836a5f2577d5a0ed688152610220830151855261133c89898989612c69565b7f1f679e8223e56ae364c7fe5b1eb44e3b3c66cbf45645c364d308c505539047c986527f2c32d125628fae7d840d3f28e83a7fa88112f60ee52f5f86fba53c08e474ff698152610240830151855261139689898989612c69565b7f1b73d0bdb2a03d112f31e25b60799a767fb82a9d6418db824c632ffba80be47d86527f21b9840d5d347552e43ea2e7bd19560353b633a278b602c6074025ddb9f63a21815261026083015185526113f089898989612c69565b7f16b45c0468819f85893ab1c4877c4fe4f49c146b976419b48aa07a0f6cbfb2e286527f06b26b18879ce8c03298c0302e22e9be3407e4b50aa15e3153b0eea99ce024148152610280830151855261144a89898989612c69565b7f1fe6017431f3e3861894f3e1871a3627f3fc61c832f3e951b3e55c86c4b9615886527f2236d30c0a8738dcac59bc76c975d2ac9c9f1347adfc85c977fc196f4a963f5e81526102a083015185526114a489898989612c69565b7f2fd10aed9958e2d8257e4a70a742fa4774402f36a25babac21c8e0b5f661c12886527f0f8a616d021292af83c9631904c885899f5fe78a5489c14462c97f8472ce5bbf81526102c083015185526114fe89898989612c69565b7f280a41e1efcd026c87f851e0180aad3ac57df1f93286a57f53c400268d8752c386527f1633532825ddc9c0da04246a44b706dcfd57ae2f4c1bb69738ff8433d5b2a8bb81526102e0830151855261155889898989612c69565b7e027cbc9193ee97f7eec57e57cb0ff7347cc0b2586a1637f4ce954bea3ff97186527f1c897b0f8a07cbc7a4b69597227129b4a12ba68e1926ecc7a45a4ec4bdc5bf07815261030083015185526115b189898989612c69565b7f1b1da35eea8e3139d38e9db84386f59853a18040d1a2216b74679e08c191a01c86527f0bfab57806284de52685f6dda04330043efee9399c75b78e48b5b1d7cb80038e8152610320830151855261160b89898989612c69565b7f012154f85b76ea46de9dc3f61d7c053aa9a583e3e2e57d6a076db599b1326a2f86527f1d25427c48b7647c1efe27b5e7da3240ee333d288ebabeb8b45e30c113c6474e8152610340830151855261166589898989612c69565b7f111fb275c27d543c507e0c685728727d2344f736a345419dd396d083296211ed86527f01c636dbb603223ca61aee282e75c2ee554f6639e813f990cc7e045128e9ba6e815261036083015185526116bf89898989612c69565b7f0e3ef51ec2992fd4fd4e08d2fc6c02cb6586ec574edec92b74583bd38cc15cae86527f0eeb3ece8b4b83ce8946832b6dd7f35204669e47ccd8b1fc31cba6c71808f6898152610380830151855261171989898989612c69565b7f0a7e2bd7bb8aeb9e84739db84898a9115aa023c279d2df4536366e445e618b1e86527f0141bc992ed56ad3af847ed62afe254e174e6df8efbc36cf3314adad1244b42381526103a0830151855261177389898989612c69565b7f0f2ecde94b061c256edb823ac557ce52f907f612791c85a2e66fb888ce8a417b86527f1c09474255a3b4c33f9452b362e6352c65acb1406a454a1d4b212538d529ed9a81526103c083015185526117cd89898989612c69565b7f1a2a4a634641112a1b940ba3b089193dfde76611dc7a7c29538a0f93bbdaf83086527f1752d5a3839dedbad8cd819b7b86a82982d1c7663453d236c559353725c2901381526103e0830151855261182789898989612c69565b7f2e9b2e2e4921cd57e24d3215d41cfa43545b0fa8907380f2b4eca856b242ace086527f192ca02d2e86b7636626a919c871396ba8108cc7f2358ded277a32ed4ba10d4b8152610400830151855261188189898989612c69565b7f1266b7cbb61c28d580a6aa8e4a6b3455bf5c925fe9321c0b0afd01596c4a950586527f0f945b9129e6749912477338802d286af2f6aca2e71cdf199f387d570acf5f10815261042083015185526118db89898989612c69565b7f1be6c06af2b7182fc509c0c72a3874173c0e9b8ef208c89a6ffcbe343f74440a86525201519052612c69565b51159081159161195d575b50611944575b50506119259051612cba565b9451908451908501519160606040870151955196015196612ed3565b90565b519193506119259161195591612d8d565b92905f611919565b90505115155f611913565b806119a17f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f000000161199a6119a6948e610779565b5110610a85565b610749565b610c2e565b6119b36100d3565b906119bc6100f8565b5f81525f602082015282526119cf6107a0565b60208301526119dc6107a0565b60408301526104896107a0565b6119f16119ab565b906119fa6100f8565b7f3059a4f6581fbdcc0d5e847306a4862568fbf62d22d49958fc3902e4bc379ef381526020907f1dd7c04824ae7a26cbb4bb2e8e647030df4de01e51764344c9da30b1ac0317c8828201528352611a4f6100f8565b7f0f98f7aa65c680ca7cd4b7f95afc5f6827e95398c599befdd9a9eca741e46b6181527f0a6f18525c7167edf6945aa57ecf8e0dde824c50912f1fe71574e86908579b6882820152611a9f6100f8565b7f1d1dacfe7971320b875aa2dbcdafb33d4141ca0b0435904e1e2ead83b600d26b81527f1e0cdae1aa15580307c121c8518d1b513fb8bfc62718065a60e88eee79d0288d83820152611aef6100f8565b9182528282015281840152611b026100f8565b7f1887c867c4428fd8c7157ac7f5e81a19271ea37ac336aa87203e65bd77cdcad281527f10d21089c03935120870563d17d271a9165f3d541cf4b41a450b8c3741e8442382820152611b526100f8565b7f105ceb8102cb4bd76c903c3f045988d7407aab02a26e2b0ac08c58af1edec5a481527f0b32e41ba74a1a65c885129ca2c3c87475d584c75ebc553cb79d4468de6483a883820152611ba26100f8565b918252828201526040840152611bb66100f8565b907f04e9e06a4684b3f9cfea22a0b5d19239c957ba0b12a17f2d9dc9d1e63f9ae49482527f0ef0df2626365d3222024595b1cd400614d2db4a442bb59f5ab585b4717528f881830152611c076100f8565b907f239dd78f7b5dba6a6d81f994b3060a73e4d7602aeb8909fd9785a0f1e04367e382527f178fb89664e86e6758f974887c6d9d19cd52b518c16d799e75556a7ae9a2582981830152611c586100f8565b9283528201526060830152565b9091939293611c726107cc565b918051602080920151611c836100f8565b918252828201528352611c946100f8565b938051518552611ca5815160200190565b5182860152611cb682610b236100f8565b5182820152611cc36100f8565b94855281850152808301938452808251920151611cde6100f8565b9283528183015260408301918252611d847f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47611d1d8186515110610825565b611d2c81848751015110610871565b611d3a8187515151106108bd565b611d4a8184885101515110610909565b611d5a81610bf488515160200190565b611d6c81610c0d858951015160200190565b611d7981855151106109ed565b828451015110610a39565b5f5b602181106129b25750946119419495611925611da06129e9565b946129ac611dac6100f8565b80955f82528582015f8152611dbf6106db565b91611dc86106eb565b907f305c9c1aa4a3294d7d6f331d65dc097fd9b9011350a6065eed3d56ad4d48a5e2611df26100f8565b935f85525f8b8601527f2d704aa2e65d5ad168e2ebdd814a37bf7f58961077a78e2ce2eea371cf886b0e8752527f05595e70b8c63dfb8fe2f8adb49c225ee5e6f783b5736f3221d423194db5585d8252610400898301917e7f03a8f871280b33c0292e973247afd9cddfa419e978678bde69323baece8383527f0e4ddacfcf167969963d2bb01ca92fa86b4bfd92c37917bad4ab760f0279625081519360408601948552611ea289898989612c69565b7f2cbe10c7c83f6dbe1bc89736f5dc9a9b91e55be6941a4b99b058acd8001fb00486527f1500351867036612a9db15b6f7d4198993f31565af0610ed3fda8d92ffb5e67181528c8301518552611efa89898989612c69565b7f2ff215cfa1c7c99fc0b382d9d7225a0636ccd9a01be83959da430a3a25d4481f86527f2918236b7c008f70fc98cc3bcc41eb60fb8b85d02b4e83100de7a9a7eed34645815260408301518552611f5389898989612c69565b7f0943a399c312616b46deee38e49b364b3449d7bab638b580df78aece26ecedf186527f11c937747adbd7b45585d385c0174241e937dce9fa818ca66d00f550b3f3d128815260608301518552611fac89898989612c69565b7f05dd54c0736f8a8d838a097e3151776cc6f602439ecc7833d223dc6cc69d585186527ee6465472f5b3647daa18848088f62f4fe1e57c401172d39f45b827bcc898f781526080830151855261200489898989612c69565b7f0d64a91e0e28a2e96b12a3211ebd9f66d854efbc1bd17fccc28e33993722b96d86527f0b30126ec8f40991e90ef34a78e10acb9848fe65e84547e64346fbaebafc9a98815260a0830151855261205d89898989612c69565b7f08272a78392bca7c2597f09f39daf6f7129808e6a6b34a49239dbf2a264e4e3b86527f02ac17971af65a980f6ab150b8ebaf573008d90c0af4eeed28d50374e8eed16b815260c083015185526120b689898989612c69565b7f19e3f8ff1265325376056bd2155edf79762433ec7b24c2196701da40ff2e6b3186527f0b33297cf3ae84083dab64e559bccd29e271c3e7d9ba307b7d623d223d091ead815260e0830151855261210f89898989612c69565b7f01341f47e05793a19ea7b92ff3b84c73f7223d56104d070f246e00eb1db7967986527f052fb71e652150885399cfb863b33f0dc0dfe9b279d0bf29df0fc403810fdb178152610100830151855261216989898989612c69565b7f04e2785630031d901e87c72d18c1e526142d7b79ee5b4360f5f9373d385aa1be86527f13fdbcc7f866114bdd363bc99c54b3ea0921b9b5526e46885291a00f8f9feea7815261012083015185526121c389898989612c69565b7f0bc888012014ac70c1692250c46020392de91756724c6c890edbc8d860450b8086527f02ce5d7f6c5c1ec90a48c08531305543ef94f25d0d03f67124280afb560406d48152610140830151855261221d89898989612c69565b7f0aee169033d6ddce5c5dde351a6ce45eb60dc3018752274e14f68e3f19a5359686527f1481dacc3a815550ede26690b83395cb031c17fb4aca75baa0a74acc404233518152610160830151855261227789898989612c69565b7f1c24a404b575734133f0c03bbf71c74c5b03a34f1d0817662c7d9293eaecaad586527f10af37e497d439239dfdab04bce89b1eaeaa12bc5f327129816a7a3841863fdd815261018083015185526122d189898989612c69565b7f14a256de1a2c7bb25672a1acc5406b90543c8a3b8c7c6e0a1895f019171141a886527f08f0539c9fd5ef363053e6560e4769e20e56dd0a510c30dce8adab0230c5fdb181526101a0830151855261232b89898989612c69565b7f082d61eb34a0a6544527e7db6b9bd16a8f6488733c83bee559ec5378191c93ba86527f144b7ab9c8fd2fb71b51c102820f2b08303be60f9fdd313e68f412d3f027a82081526101c0830151855261238589898989612c69565b7f22510e5ce22c30374993b2a360ceed3bdc20bd64b8d14cb3baedf76ddbd8062386527f0c0c88dfbf63ebc976d642a63c3d22288c546570b101f0219b3e2f3af5bedcfb81526101e083015185526123df89898989612c69565b7f2c71d775cc194f6e13408a12a33cb48babccfee137654d1443371de1d0f30c0c86527f1ba219dea8d4ffd8339c1c10cda690451c10fb5058f36ce7e1407118d871cc808152610200830151855261243989898989612c69565b7f14e7d115c5cfbe3c075697f305b8660abf41c5725a40557d3e14c9703aef64c286527f0cbc84b02d09b3f498b122ab5819248195aea678e0a41e744967da6bd8d0ce118152610220830151855261249389898989612c69565b7f0332f7d5660e970f229a174367929acabfa2f9fdab763460fd7acebddd944dde86527f15be1ce817121a7c25340b8d9c50a584a179d3dffd489f54311a12f922a6942f815261024083015185526124ed89898989612c69565b7f0257933903a2e91846df829f8084008ddf5fc35dd8d4acdebd426bff0d97e2a386527f17e9653840e81e1a68076e0c5f8c89f61463791e918991df86c86f63dccd93918152610260830151855261254789898989612c69565b7f106f1170be9c02c979b3d6e1d43737530d6bfc444c16df873400384d39e393be86527f1c2b9f619d809bb543e712ac0ee22cc3c6aa99ae73c97246c9769c9c98713fc5815261028083015185526125a189898989612c69565b7f131eb8c00ed76432c870a74c71365748a51807c021e678beb083b0e7e8b5b61186527f2491a76ab72146d0aeb330815df908ad5dd6cd86201e97d220b63d0d8d0f3ac481526102a083015185526125fb89898989612c69565b7f2561f4abb9fabeeb813dcc6d4d487d8f6e36fdd18805e785cccdf2b0a2ff085786527f2e6269f87539d6b464a25b6bd4522d1e2b78c3918f48e79de55dd640261faa4281526102c0830151855261265589898989612c69565b7f2e485df27f23a93b97e296061758e7dd3d34c4722c6fd7ae249433c55d259adc86527f1614f76a407ac31a5acb91266c2c7f54166ee17112e69f0b5e5fad32dafe5f6581526102e083015185526126af89898989612c69565b7f153af4e0fe4af748819ca675d8781da95111510763de4bec8abf25bca637703b86527f0b1f5a812c51999ebc7ac97de6ab2409b894ad5fb02d45f0798acc2548344cb98152610300830151855261270989898989612c69565b7f2c69e0646f6bfc70dfd02cf64d0b781ab481cafbd190dba9ee603f8160c44dcd86527f126015936956b109beba47938f9808cd9eed7ba5fc4531e6f6f267cadb13f4f88152610320830151855261276389898989612c69565b7f22c6d8b6cf6965d431abf72b985b44f1d0831026a43d6dc8cbcb9ca85ab4a0bc86527f19fd6ce3da2b55331cdd361a63f29e95c52f07bcf9cbe355077e5141bf020d83815261034083015185526127bd89898989612c69565b7f0cc996a6a427bcf59dad5cb6a2da92164e142372347a8ca5b1b3b32d8b20a0ef86527f232f08e45f51e15d57617fc960278b4dd236ed78e9014d43950751ea862841f18152610360830151855261281789898989612c69565b7f1e03c25c13870ae3e127e009be017aa0f47c7b53fc8636bd519ad68f035aa55c86527f04d8795eee1d4bcb8a4042ed861d91024ec5ce76c4fdac892d0c0047987451998152610380830151855261287189898989612c69565b7f2690cf34bdf3837f3036c3c61e73f94f8026f6a6e9be13695cf81ccebbac7ca886527f0db77d728541f6ab723d2dc8389a97864f9e61349120d35d76c004579c3fc10881526103a083015185526128cb89898989612c69565b7f10f3808b8fb7eb5be9d22fa5e7b4599e94116d5803607ae38bd3c637c10224f286527f06cb766b59e904c5b47098c0f98af9c4444f614cf303f1c939fd24b6bd60cc9c81526103c0830151855261292589898989612c69565b7f1610f9fbade90d90feada79ae229d67175dee93355fbbf229133ce0d6e75e3a186527f1a3084c2af6e7f823d2044866e00b80af74b5586f26c9685943786f355712ddd81526103e0830151855261297f89898989612c69565b7f1b88a7f08e12e3e28b9b10c0c0cbfd8d7df8b8a8fae1840b33c1cd4d24c8b23c86525201519052612c69565b51612cba565b806119a17f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f000000161199a6129e4948b61078f565b611d86565b6129f16119ab565b906129fa6100f8565b7f0a3a3884405b8d1fe46693685f02ba163634fd63d14bf91b6a433825b9ed6b5a81526020907f111fc830b029cfb2c94e450b570cf3be3eac81076213c2dcb1e1059330c605bf828201528352612a4f6100f8565b7f23ab779b99bf99c421500d8fe70c4e84fc1ff6eefdf3e92d8f581d046cb3eab781527f1611f26f3d9d6b19c4a418d02f19f6796be688f08507bc59ee5f9862dd46fa5b82820152612a9f6100f8565b7f2d34a3d654ca9ea36195f8167d653fa7240b0af8acad4b224aed268f9d8756ff81527f178cda417a663a79267fba64b28caf8fc8484866bfe0f423cb8d3b7da164d7f983820152612aef6100f8565b9182528282015281840152612b026100f8565b7f1f682eee4eeb25b38c3bff07fad9aaeb8c1ae87a95472a7819a57fd8b37a6e1581527f0db20bc4434468f4ce7f5888da80c6013c5392645400eee1ddbb77b0696ea1a782820152612b526100f8565b7f01979b2d16e0fb974244f72e399fd4d24be132523f4aeb010c75f26b6452d53c81527f21900fdcdfde4102dbbcd9525e925c0f4ea5317aefc7a1c350753b5c9741ebd583820152612ba26100f8565b918252828201526040840152612bb66100f8565b907f04969a13dd24e7586c1e7e668f9be1cfab2bfb7baf9e48cd94428a55b4cfb89882527f3026f4334a515ea181839681e5a601e08615013a7355b0a0ad1c6ffce279eb1681830152612c076100f8565b907f0987e27c310f4a785adc7dfc5324848dc4b1b4957907733a04c889777c88a78582527f13c07cb3a59387f85f315e9b41060f8a993a3c3d22113439d63f9be212afc23481830152611c586100f8565b90600481101561078a5760051b0190565b90929160608460806107cf19946007865a01fa15612cb857600660c0926020606096865185528187015182860152805160408601520151868401525a01fa8015612cb857612cb690612d41565b565bfe5b5f6020612cc56100f8565b8281520152805190811580612d35575b15612cf0575050612ce46100f8565b5f81525f602082015290565b602001517f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4790819006810390811161065d57612d2a6100f8565b918252602082015290565b50602081015115612cd5565b15612d4857565b60405162461bcd60e51b815260206004820152601260248201527f70616972696e672d6164642d6661696c656400000000000000000000000000006044820152606490fd5b60609092919260c0612d9d6100f8565b915f83525f60208401526020839681612db46100d3565b936080368637805185520151828401528051604084015201518482015260066107cf195a01fa8015612cb857612cb690612d41565b60405190610320820182811067ffffffffffffffff8211176100f35760405260188252610300366020840137565b9060068202918083046006149015171561065d57565b906001820180921161065d57565b906002820180921161065d57565b906003820180921161065d57565b906004820180921161065d57565b906005820180921161065d57565b805182101561078a5760209160051b010190565b15612e8e57565b60405162461bcd60e51b815260206004820152601560248201527f70616972696e672d6f70636f64652d6661696c656400000000000000000000006044820152606490fd5b9491959692909396612ee36100d3565b95865260209788978888015260408701526060860152612f016100d3565b9384528584015260408301526060820152612f1a612de9565b915f5b60048110612f5557505050610300612f33610710565b9384920160086107cf195a01fa8015612cb857612f4f90612e87565b51151590565b6130279192939450612f6681612e17565b612f708285612c58565b5151612f7c8288612e73565b5286612f888386612c58565b510151612f9d612f9783612e2d565b88612e73565b52612fa88286612c58565b515151612fb7612f9783612e3b565b52612fcd612fc58387612c58565b515160200190565b51612fda612f9783612e49565b5286612fe68387612c58565b51015151612ff6612f9783612e57565b5261302161301b6130148961300b868a612c58565b51015160200190565b5192612e65565b87612e73565b52610749565b9084939291612f1d56fea26469706673582212200cbb34895528328b369fdbe0a71127c10fed5266fe321703b5d2f42c7a8f73ca64736f6c63430008140033",
}

// BeaconVerifierABI is the input ABI used to generate the binding from.
// Deprecated: Use BeaconVerifierMetaData.ABI instead.
var BeaconVerifierABI = BeaconVerifierMetaData.ABI

// BeaconVerifierBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use BeaconVerifierMetaData.Bin instead.
var BeaconVerifierBin = BeaconVerifierMetaData.Bin

// DeployBeaconVerifier deploys a new Ethereum contract, binding an instance of BeaconVerifier to it.
func DeployBeaconVerifier(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *BeaconVerifier, error) {
	parsed, err := BeaconVerifierMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(BeaconVerifierBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &BeaconVerifier{BeaconVerifierCaller: BeaconVerifierCaller{contract: contract}, BeaconVerifierTransactor: BeaconVerifierTransactor{contract: contract}, BeaconVerifierFilterer: BeaconVerifierFilterer{contract: contract}}, nil
}

// BeaconVerifier is an auto generated Go binding around an Ethereum contract.
type BeaconVerifier struct {
	BeaconVerifierCaller     // Read-only binding to the contract
	BeaconVerifierTransactor // Write-only binding to the contract
	BeaconVerifierFilterer   // Log filterer for contract events
}

// BeaconVerifierCaller is an auto generated read-only Go binding around an Ethereum contract.
type BeaconVerifierCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BeaconVerifierTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BeaconVerifierTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BeaconVerifierFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BeaconVerifierFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BeaconVerifierSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BeaconVerifierSession struct {
	Contract     *BeaconVerifier   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BeaconVerifierCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BeaconVerifierCallerSession struct {
	Contract *BeaconVerifierCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// BeaconVerifierTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BeaconVerifierTransactorSession struct {
	Contract     *BeaconVerifierTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// BeaconVerifierRaw is an auto generated low-level Go binding around an Ethereum contract.
type BeaconVerifierRaw struct {
	Contract *BeaconVerifier // Generic contract binding to access the raw methods on
}

// BeaconVerifierCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BeaconVerifierCallerRaw struct {
	Contract *BeaconVerifierCaller // Generic read-only contract binding to access the raw methods on
}

// BeaconVerifierTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BeaconVerifierTransactorRaw struct {
	Contract *BeaconVerifierTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBeaconVerifier creates a new instance of BeaconVerifier, bound to a specific deployed contract.
func NewBeaconVerifier(address common.Address, backend bind.ContractBackend) (*BeaconVerifier, error) {
	contract, err := bindBeaconVerifier(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BeaconVerifier{BeaconVerifierCaller: BeaconVerifierCaller{contract: contract}, BeaconVerifierTransactor: BeaconVerifierTransactor{contract: contract}, BeaconVerifierFilterer: BeaconVerifierFilterer{contract: contract}}, nil
}

// NewBeaconVerifierCaller creates a new read-only instance of BeaconVerifier, bound to a specific deployed contract.
func NewBeaconVerifierCaller(address common.Address, caller bind.ContractCaller) (*BeaconVerifierCaller, error) {
	contract, err := bindBeaconVerifier(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BeaconVerifierCaller{contract: contract}, nil
}

// NewBeaconVerifierTransactor creates a new write-only instance of BeaconVerifier, bound to a specific deployed contract.
func NewBeaconVerifierTransactor(address common.Address, transactor bind.ContractTransactor) (*BeaconVerifierTransactor, error) {
	contract, err := bindBeaconVerifier(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BeaconVerifierTransactor{contract: contract}, nil
}

// NewBeaconVerifierFilterer creates a new log filterer instance of BeaconVerifier, bound to a specific deployed contract.
func NewBeaconVerifierFilterer(address common.Address, filterer bind.ContractFilterer) (*BeaconVerifierFilterer, error) {
	contract, err := bindBeaconVerifier(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BeaconVerifierFilterer{contract: contract}, nil
}

// bindBeaconVerifier binds a generic wrapper to an already deployed contract.
func bindBeaconVerifier(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BeaconVerifierMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BeaconVerifier *BeaconVerifierRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BeaconVerifier.Contract.BeaconVerifierCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BeaconVerifier *BeaconVerifierRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BeaconVerifier.Contract.BeaconVerifierTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BeaconVerifier *BeaconVerifierRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BeaconVerifier.Contract.BeaconVerifierTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BeaconVerifier *BeaconVerifierCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BeaconVerifier.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BeaconVerifier *BeaconVerifierTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BeaconVerifier.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BeaconVerifier *BeaconVerifierTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BeaconVerifier.Contract.contract.Transact(opts, method, params...)
}

// VerifyBlsSigProof is a free data retrieval call binding the contract method 0x0cc26769.
//
// Solidity: function verifyBlsSigProof(uint256[2] a, uint256[2][2] b, uint256[2] c, uint256[2] commit, uint256[35] input) view returns(bool r)
func (_BeaconVerifier *BeaconVerifierCaller) VerifyBlsSigProof(opts *bind.CallOpts, a [2]*big.Int, b [2][2]*big.Int, c [2]*big.Int, commit [2]*big.Int, input [35]*big.Int) (bool, error) {
	var out []interface{}
	err := _BeaconVerifier.contract.Call(opts, &out, "verifyBlsSigProof", a, b, c, commit, input)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// VerifyBlsSigProof is a free data retrieval call binding the contract method 0x0cc26769.
//
// Solidity: function verifyBlsSigProof(uint256[2] a, uint256[2][2] b, uint256[2] c, uint256[2] commit, uint256[35] input) view returns(bool r)
func (_BeaconVerifier *BeaconVerifierSession) VerifyBlsSigProof(a [2]*big.Int, b [2][2]*big.Int, c [2]*big.Int, commit [2]*big.Int, input [35]*big.Int) (bool, error) {
	return _BeaconVerifier.Contract.VerifyBlsSigProof(&_BeaconVerifier.CallOpts, a, b, c, commit, input)
}

// VerifyBlsSigProof is a free data retrieval call binding the contract method 0x0cc26769.
//
// Solidity: function verifyBlsSigProof(uint256[2] a, uint256[2][2] b, uint256[2] c, uint256[2] commit, uint256[35] input) view returns(bool r)
func (_BeaconVerifier *BeaconVerifierCallerSession) VerifyBlsSigProof(a [2]*big.Int, b [2][2]*big.Int, c [2]*big.Int, commit [2]*big.Int, input [35]*big.Int) (bool, error) {
	return _BeaconVerifier.Contract.VerifyBlsSigProof(&_BeaconVerifier.CallOpts, a, b, c, commit, input)
}

// VerifyCommitteeRootMappingProof is a free data retrieval call binding the contract method 0xab00dde6.
//
// Solidity: function verifyCommitteeRootMappingProof(uint256[2] a, uint256[2][2] b, uint256[2] c, uint256[33] input) view returns(bool r)
func (_BeaconVerifier *BeaconVerifierCaller) VerifyCommitteeRootMappingProof(opts *bind.CallOpts, a [2]*big.Int, b [2][2]*big.Int, c [2]*big.Int, input [33]*big.Int) (bool, error) {
	var out []interface{}
	err := _BeaconVerifier.contract.Call(opts, &out, "verifyCommitteeRootMappingProof", a, b, c, input)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// VerifyCommitteeRootMappingProof is a free data retrieval call binding the contract method 0xab00dde6.
//
// Solidity: function verifyCommitteeRootMappingProof(uint256[2] a, uint256[2][2] b, uint256[2] c, uint256[33] input) view returns(bool r)
func (_BeaconVerifier *BeaconVerifierSession) VerifyCommitteeRootMappingProof(a [2]*big.Int, b [2][2]*big.Int, c [2]*big.Int, input [33]*big.Int) (bool, error) {
	return _BeaconVerifier.Contract.VerifyCommitteeRootMappingProof(&_BeaconVerifier.CallOpts, a, b, c, input)
}

// VerifyCommitteeRootMappingProof is a free data retrieval call binding the contract method 0xab00dde6.
//
// Solidity: function verifyCommitteeRootMappingProof(uint256[2] a, uint256[2][2] b, uint256[2] c, uint256[33] input) view returns(bool r)
func (_BeaconVerifier *BeaconVerifierCallerSession) VerifyCommitteeRootMappingProof(a [2]*big.Int, b [2][2]*big.Int, c [2]*big.Int, input [33]*big.Int) (bool, error) {
	return _BeaconVerifier.Contract.VerifyCommitteeRootMappingProof(&_BeaconVerifier.CallOpts, a, b, c, input)
}

// VerifySignatureProof is a free data retrieval call binding the contract method 0x52356da0.
//
// Solidity: function verifySignatureProof(bytes32 signingRoot, bytes32 syncCommitteePoseidonRoot, uint256 participation, uint256 commitment, (uint256[2],uint256[2][2],uint256[2],uint256[2]) p) view returns(bool)
func (_BeaconVerifier *BeaconVerifierCaller) VerifySignatureProof(opts *bind.CallOpts, signingRoot [32]byte, syncCommitteePoseidonRoot [32]byte, participation *big.Int, commitment *big.Int, p IBeaconVerifierProof) (bool, error) {
	var out []interface{}
	err := _BeaconVerifier.contract.Call(opts, &out, "verifySignatureProof", signingRoot, syncCommitteePoseidonRoot, participation, commitment, p)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// VerifySignatureProof is a free data retrieval call binding the contract method 0x52356da0.
//
// Solidity: function verifySignatureProof(bytes32 signingRoot, bytes32 syncCommitteePoseidonRoot, uint256 participation, uint256 commitment, (uint256[2],uint256[2][2],uint256[2],uint256[2]) p) view returns(bool)
func (_BeaconVerifier *BeaconVerifierSession) VerifySignatureProof(signingRoot [32]byte, syncCommitteePoseidonRoot [32]byte, participation *big.Int, commitment *big.Int, p IBeaconVerifierProof) (bool, error) {
	return _BeaconVerifier.Contract.VerifySignatureProof(&_BeaconVerifier.CallOpts, signingRoot, syncCommitteePoseidonRoot, participation, commitment, p)
}

// VerifySignatureProof is a free data retrieval call binding the contract method 0x52356da0.
//
// Solidity: function verifySignatureProof(bytes32 signingRoot, bytes32 syncCommitteePoseidonRoot, uint256 participation, uint256 commitment, (uint256[2],uint256[2][2],uint256[2],uint256[2]) p) view returns(bool)
func (_BeaconVerifier *BeaconVerifierCallerSession) VerifySignatureProof(signingRoot [32]byte, syncCommitteePoseidonRoot [32]byte, participation *big.Int, commitment *big.Int, p IBeaconVerifierProof) (bool, error) {
	return _BeaconVerifier.Contract.VerifySignatureProof(&_BeaconVerifier.CallOpts, signingRoot, syncCommitteePoseidonRoot, participation, commitment, p)
}

// VerifySyncCommitteeRootMappingProof is a free data retrieval call binding the contract method 0x7a538781.
//
// Solidity: function verifySyncCommitteeRootMappingProof(bytes32 sszRoot, bytes32 poseidonRoot, (uint256[2],uint256[2][2],uint256[2],uint256[2]) p) view returns(bool)
func (_BeaconVerifier *BeaconVerifierCaller) VerifySyncCommitteeRootMappingProof(opts *bind.CallOpts, sszRoot [32]byte, poseidonRoot [32]byte, p IBeaconVerifierProof) (bool, error) {
	var out []interface{}
	err := _BeaconVerifier.contract.Call(opts, &out, "verifySyncCommitteeRootMappingProof", sszRoot, poseidonRoot, p)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// VerifySyncCommitteeRootMappingProof is a free data retrieval call binding the contract method 0x7a538781.
//
// Solidity: function verifySyncCommitteeRootMappingProof(bytes32 sszRoot, bytes32 poseidonRoot, (uint256[2],uint256[2][2],uint256[2],uint256[2]) p) view returns(bool)
func (_BeaconVerifier *BeaconVerifierSession) VerifySyncCommitteeRootMappingProof(sszRoot [32]byte, poseidonRoot [32]byte, p IBeaconVerifierProof) (bool, error) {
	return _BeaconVerifier.Contract.VerifySyncCommitteeRootMappingProof(&_BeaconVerifier.CallOpts, sszRoot, poseidonRoot, p)
}

// VerifySyncCommitteeRootMappingProof is a free data retrieval call binding the contract method 0x7a538781.
//
// Solidity: function verifySyncCommitteeRootMappingProof(bytes32 sszRoot, bytes32 poseidonRoot, (uint256[2],uint256[2][2],uint256[2],uint256[2]) p) view returns(bool)
func (_BeaconVerifier *BeaconVerifierCallerSession) VerifySyncCommitteeRootMappingProof(sszRoot [32]byte, poseidonRoot [32]byte, p IBeaconVerifierProof) (bool, error) {
	return _BeaconVerifier.Contract.VerifySyncCommitteeRootMappingProof(&_BeaconVerifier.CallOpts, sszRoot, poseidonRoot, p)
}

// BitMathMetaData contains all meta data concerning the BitMath contract.
var BitMathMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212204fcad26d51f9e2fcbaefd77f37d42d8bc5270fb1a65cdf7f8e7f3e422596f97b64736f6c63430008140033",
}

// BitMathABI is the input ABI used to generate the binding from.
// Deprecated: Use BitMathMetaData.ABI instead.
var BitMathABI = BitMathMetaData.ABI

// BitMathBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use BitMathMetaData.Bin instead.
var BitMathBin = BitMathMetaData.Bin

// DeployBitMath deploys a new Ethereum contract, binding an instance of BitMath to it.
func DeployBitMath(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *BitMath, error) {
	parsed, err := BitMathMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(BitMathBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &BitMath{BitMathCaller: BitMathCaller{contract: contract}, BitMathTransactor: BitMathTransactor{contract: contract}, BitMathFilterer: BitMathFilterer{contract: contract}}, nil
}

// BitMath is an auto generated Go binding around an Ethereum contract.
type BitMath struct {
	BitMathCaller     // Read-only binding to the contract
	BitMathTransactor // Write-only binding to the contract
	BitMathFilterer   // Log filterer for contract events
}

// BitMathCaller is an auto generated read-only Go binding around an Ethereum contract.
type BitMathCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BitMathTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BitMathTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BitMathFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BitMathFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BitMathSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BitMathSession struct {
	Contract     *BitMath          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BitMathCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BitMathCallerSession struct {
	Contract *BitMathCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// BitMathTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BitMathTransactorSession struct {
	Contract     *BitMathTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// BitMathRaw is an auto generated low-level Go binding around an Ethereum contract.
type BitMathRaw struct {
	Contract *BitMath // Generic contract binding to access the raw methods on
}

// BitMathCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BitMathCallerRaw struct {
	Contract *BitMathCaller // Generic read-only contract binding to access the raw methods on
}

// BitMathTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BitMathTransactorRaw struct {
	Contract *BitMathTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBitMath creates a new instance of BitMath, bound to a specific deployed contract.
func NewBitMath(address common.Address, backend bind.ContractBackend) (*BitMath, error) {
	contract, err := bindBitMath(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BitMath{BitMathCaller: BitMathCaller{contract: contract}, BitMathTransactor: BitMathTransactor{contract: contract}, BitMathFilterer: BitMathFilterer{contract: contract}}, nil
}

// NewBitMathCaller creates a new read-only instance of BitMath, bound to a specific deployed contract.
func NewBitMathCaller(address common.Address, caller bind.ContractCaller) (*BitMathCaller, error) {
	contract, err := bindBitMath(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BitMathCaller{contract: contract}, nil
}

// NewBitMathTransactor creates a new write-only instance of BitMath, bound to a specific deployed contract.
func NewBitMathTransactor(address common.Address, transactor bind.ContractTransactor) (*BitMathTransactor, error) {
	contract, err := bindBitMath(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BitMathTransactor{contract: contract}, nil
}

// NewBitMathFilterer creates a new log filterer instance of BitMath, bound to a specific deployed contract.
func NewBitMathFilterer(address common.Address, filterer bind.ContractFilterer) (*BitMathFilterer, error) {
	contract, err := bindBitMath(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BitMathFilterer{contract: contract}, nil
}

// bindBitMath binds a generic wrapper to an already deployed contract.
func bindBitMath(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BitMathMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BitMath *BitMathRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BitMath.Contract.BitMathCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BitMath *BitMathRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BitMath.Contract.BitMathTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BitMath *BitMathRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BitMath.Contract.BitMathTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BitMath *BitMathCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BitMath.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BitMath *BitMathTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BitMath.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BitMath *BitMathTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BitMath.Contract.contract.Transact(opts, method, params...)
}

// BlockChunksMetaData contains all meta data concerning the BlockChunks contract.
var BlockChunksMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"UpdateAnchorBlockProvider\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"startBlockNumber\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"prevHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"numFinal\",\"type\":\"uint32\"}],\"name\":\"UpdateEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"UpdateVerifierAddress\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addPausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"addProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"anchorBlockProviders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"startBlockNumber\",\"type\":\"uint32\"}],\"name\":\"historicalRoots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isActiveProver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"claimedBlkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"prevHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"numFinal\",\"type\":\"uint32\"},{\"internalType\":\"bytes32[7]\",\"name\":\"merkleProof\",\"type\":\"bytes32[7]\"}],\"internalType\":\"structIBlockChunks.BlockHashWitness\",\"name\":\"witness\",\"type\":\"tuple\"}],\"name\":\"isBlockHashValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numPausers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numProvers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pauserList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proverStates\",\"outputs\":[{\"internalType\":\"enumBrevisAccess.ProverState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"provers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removePausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"removeProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_provider\",\"type\":\"address\"}],\"name\":\"updateAnchorBlockProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"nextRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"nextNumFinal\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"}],\"name\":\"updateOld\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"}],\"name\":\"updateRecent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_verifierAddress\",\"type\":\"address\"}],\"name\":\"updateVerifierAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"verifierAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x60808060405234610162575f8054909190336001600160a01b0382167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08580a36001600160a81b0319163360ff60a01b19811691909117835582526001602052604082205460ff166101205750600254906801000000000000000082101561010c5760018201806002558210156100f8576040916002825260208220013360018060a01b0319825416179055338152600160205220600160ff198254161790557f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f86020604051338152a1604051611de690816101678239f35b634e487b7160e01b81526032600452602490fd5b634e487b7160e01b81526041600452602490fd5b62461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152606490fd5b5f80fdfe60c06040526004361015610011575f80fd5b5f608060a0528060a05152803560e01c908163158535ff146112fd575080631d8441a1146112375780633f4ba83a1461111c57806346fbf68e1461077a5780634f4fef18146110fb57806350a26d4814610e7557806352cfc56014610c63578063544f73a414610a4857806358a16b4414610a275780635c975abb146109ff5780635d727e97146109b7578063677625f2146108135780636b2c0f55146107da5780636ef8d66d146107bd57806380f51c121461077a57806382dc1ec4146107415780638456cb591461060a5780638da5cb5b146105de578063a036e7991461058a578063b551a1871461052b578063e6c6fcec146104d7578063e79b7a5114610477578063ec4ffc52146103a7578063ec64842e1461033f578063f2fde38b1461024f578063f5cec6af14610207578063fabc74f5146101a25763fd1190ea1461015a575f80fd5b3461019b57602036600319011261019b5760043560045481101561019b576001600160a01b0361018b602092611374565b9190546040519260031b1c168152f35b60a0515180fd5b3461019b57602036600319011261019b576001600160a01b036101c36113da565b1660a0515152600360205260a0515160ff6040822054166040519060038110156101ef57602092508152f35b634e487b7160e01b8352602160045260a05151602490fd5b3461019b57602036600319011261019b5767ffffffffffffffff6102296113a9565b1660a0515152600560205260206001600160a01b03604060a05151205416604051908152f35b3461019b57602036600319011261019b576102686113da565b60a0515154906001600160a01b0380831691610285338414611501565b169081156102d4578173ffffffffffffffffffffffffffffffffffffffff1960a0515194161783557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608490fd5b3461019b57602036600319011261019b576001600160a01b036103606113da565b1660a0515152600360205260a0515160ff604082205416600381101561038e57602090600160405191148152f35b50634e487b7160e01b9052602160045260a05151602490fd5b3461019b57604036600319011261019b577ffd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f6103e16113a9565b6103e96113c4565b906001600160a01b036104038160a0515154163314611501565b67ffffffffffffffff821660a05151526005602052604060a051512090831673ffffffffffffffffffffffffffffffffffffffff1982541617905561046d604051928392839092916001600160a01b0360209167ffffffffffffffff604085019616845216910152565b0390a160a0515180f35b3461019b5761048536611470565b6001600160a01b039061049f8260a0515154163314611501565b60a051515b81518110156104d057806104c6846104bf6104cb94866118d9565b5116611b0f565b6118cb565b6104a4565b60a0515180f35b3461019b576104e536611470565b6001600160a01b03906104ff8260a0515154163314611501565b60a051515b81518110156104d057806104c68461051f61052694866118d9565b5116611939565b610504565b3461019b57604036600319011261019b576105446113a9565b6024359063ffffffff821680920361019b5767ffffffffffffffff1660a0515152600760205260a05151906040822091526020526020604060a051512054604051908152f35b3461019b5761059836611470565b6001600160a01b03906105b28260a0515154163314611501565b60a051515b81518110156104d057806104c6846105d26105d994866118d9565b5116611bf4565b6105b7565b3461019b5760a0515180600319360112610607576001600160a01b036020915416604051908152f35b80fd5b3461019b5760a051518060031936011261060757339052600160209080825261063c60ff604060a051512054166118ed565b60a051515460ff8160a01c166106fc5760ff60a01b197401000000000000000000000000000000000000000091161760a05151557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a25882604051338152a160a05151815b6106aa5760a0515180f35b6004548110156106f757806001600160a01b036106c96106f193611374565b919054600392831b1c1660a05151528452604060a0515120600260ff198254161790556118cb565b8161069f565b6104d0565b60405162461bcd60e51b815260048101849052601060248201527f5061757361626c653a20706175736564000000000000000000000000000000006044820152606490fd5b3461019b57602036600319011261019b576104d061075d6113da565b6107756001600160a01b0360a0515154163314611501565b611b0f565b3461019b57602036600319011261019b576001600160a01b0361079b6113da565b1660a05151526001602052602060ff604060a051512054166040519015158152f35b3461019b5760a0515180600319360112610607576104d033611bf4565b3461019b57602036600319011261019b576104d06107f66113da565b61080e6001600160a01b0360a0515154163314611501565b611bf4565b3461019b5761082136611470565b60a0515154906001600160a01b0361083c3382851614611501565b60a051519060ff809460a01c165f146109af576002915b83518110156104d0578161086782866118d9565b51168060a051515260039060209180835260a05151886040822054169082821015610938575061096a576004546801000000000000000081101561095057826108b98260016108d99401600455611374565b90919082549060031b916001600160a01b03809116831b921b1916179055565b8160a051515280835260a0515160408120918710156109385750917fef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd03968491610933949360ff198154168a8916179055604051908152a16118cb565b610853565b634e487b7160e01b9052602160045260a05151602490fd5b634e487b7160e01b60a05151526041600452602460a05151fd5b60405162461bcd60e51b815260048101849052601160248201527f6163636f756e742069732070726f7665720000000000000000000000000000006044820152606490fd5b600191610853565b3461019b57602036600319011261019b5767ffffffffffffffff6109d96113a9565b1660a0515152600660205260206001600160a01b03604060a05151205416604051908152f35b3461019b5760a05151806003193601126106075760ff6020915460a01c166040519015158152f35b3461019b5760a0515180600319360112610607576020600254604051908152f35b3461019b5761018036600319011261019b576044358015610c1e57607f610a6d6118a6565b1690610a8082610a7b6118a6565b611598565b6004359067ffffffffffffffff8216820361019b57610ac29167ffffffffffffffff165f52600760205263ffffffff60405f2091165f5260205260405f205490565b908115610bd9579060a05151915b60ff83166007811015610b735784811c600116610b4257610af0906118b9565b356040519060208201928352604082015260408152610b0e8161141e565b519020915b60ff809116908114610b285760010191610ad0565b634e487b7160e01b60a05151526011600452602460a05151fd5b610b4b906118b9565b35906040519060208201928352604082015260408152610b6a8161141e565b51902091610b13565b50906084359163ffffffff8316830361019b57610bbf610bcd602094604051928391878301956064358791604493918352602083015263ffffffff60e01b9060e01b1660408201520190565b03601f19810183528261144e565b51902014604051908152f35b60405162461bcd60e51b815260206004820152601a60248201527f626c6b20686973746f7279206e6f742073746f726564207965740000000000006044820152606490fd5b60405162461bcd60e51b815260206004820152601a60248201527f636c61696d6564426c6b48617368206e6f742070726573656e740000000000006044820152606490fd5b3461019b5760a05136600319011261019b57610c7d6113a9565b6044359063ffffffff90818316830361019b5767ffffffffffffffff9260643584811161019b57610cb29036906004016113f0565b9390913360a0515152600360205260a0515160ff60408220541690600382101561093857509582610d1893607f93610cf06001610d1f9a9b1461154c565b600182610cfd8c8a61180e565b939b819f939b929891610d128482161561160e565b85611598565b16146115c2565b160191838311610b28577fa946b3d79b3150fec8e4d9ccc6100de98308a472f1ba57d23aeda162bb86e33e9a61046d98610ddb610de694610de194610d8b610dbe988f67ffffffffffffffff165f52600760205263ffffffff60405f2091165f5260205260405f205490565b916040519889916020830193602435908591604493918352602083015263ffffffff60e01b9060e01b1660408201520190565b0397610dd2601f19998a810183528261144e565b5190201461165a565b8a6116f2565b6116a6565b6040805160208101868152918101879052600160e71b6060820152606492830181529091610e14908261144e565b51902091861660a0515152600760205260a05151604081209188169052602052604060a0515120556040519485948590949360809363ffffffff859467ffffffffffffffff60a0860199168552166020840152604083015260608201520152565b3461019b57604036600319011261019b57610e8e6113a9565b67ffffffffffffffff9060243582811161019b57610eb09036906004016113f0565b9190913360a0515152600360205260a0515160ff60408220541690600382101561093857506001610ee1911461154c565b610eeb818461180e565b9197929394909663ffffffff988989169360a05185018b8111610b28578b165f19019a808c11610b285780610f2492169b168b146115c2565b610f31607f8a161561160e565b84881660a051515260066020526001600160a01b0380604060a05151205416156110b657602090868a1660a051515260068252604060a051512054169a6024604051809d819363f25b3f9960e01b835260048301525afa998a156110a85760a051519a611062575b5061046d9695949392610fdb92610fd5610de1937fa946b3d79b3150fec8e4d9ccc6100de98308a472f1ba57d23aeda162bb86e33e9d1461165a565b896116f2565b6040805160208101858152918101869052600160e71b60608201526110038160648101610bbf565b51902091861660a0515152600760205260a0515190604082209152602052604060a0515120556040519485948590949360809363ffffffff859467ffffffffffffffff60a0860199168552166020840152604083015260608201520152565b91969594939299506020823d6020116110a0575b816110836020938361144e565b8101031261019b579051989495939492939192919061046d610f99565b3d9150611076565b6040513d60a05151823e3d90fd5b60405162461bcd60e51b815260206004820152601d60248201527f636861696e20616e63686f722070726f7669646572206e6f74207365740000006044820152606490fd5b3461019b5760a0515180600319360112610607576020600454604051908152f35b3461019b5760a051518060031936011261060757339052600160209080825261114e60ff604060a051512054166118ed565b60a051515460ff8160a01c16156111f25760ff60a01b191660a05151557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa82604051338152a160a05151815b6111a55760a0515180f35b6004548110156106f7576111ec816001600160a01b036111c58594611374565b919054600392831b1c1660a05151528552604060a05151208360ff198254161790556118cb565b9061119a565b60405162461bcd60e51b815260048101849052601460248201527f5061757361626c653a206e6f74207061757365640000000000000000000000006044820152606490fd5b3461019b57604036600319011261019b577f4b8c49e37c813f3cbe140bc7b6a5662bd14e48311b5864c106ca3f9c4a2bc02b6112716113a9565b6112796113c4565b906001600160a01b036112938160a0515154163314611501565b67ffffffffffffffff821660a05151526006602052604060a051512090831673ffffffffffffffffffffffffffffffffffffffff1982541617905561046d604051928392839092916001600160a01b0360209167ffffffffffffffff604085019616845216910152565b3461060757602036600319011261060757600435906002548210156106075760206001600160a01b0361018b845b6002548110156113605760025f527f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace01905f90565b634e487b7160e01b5f52603260045260245ffd5b6004548110156113605760045f527f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b01905f90565b6004359067ffffffffffffffff821682036113c057565b5f80fd5b602435906001600160a01b03821682036113c057565b600435906001600160a01b03821682036113c057565b9181601f840112156113c05782359167ffffffffffffffff83116113c057602083818601950101116113c057565b6060810190811067ffffffffffffffff82111761143a57604052565b634e487b7160e01b5f52604160045260245ffd5b90601f8019910116810190811067ffffffffffffffff82111761143a57604052565b6020806003198301126113c05767ffffffffffffffff916004358381116113c057816023820112156113c057806004013593841161143a578360051b90604051946114bd8584018761144e565b85526024848601928201019283116113c057602401905b8282106114e2575050505090565b81356001600160a01b03811681036113c05781529083019083016114d4565b1561150857565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b1561155357565b60405162461bcd60e51b815260206004820152601260248201527f6e6f7420696e76616c69642070726f76657200000000000000000000000000006044820152606490fd5b63ffffffff91821690821603919082116115ae57565b634e487b7160e01b5f52601160045260245ffd5b156115c957565b60405162461bcd60e51b815260206004820152600d60248201527f6e6565642031323820626c6b73000000000000000000000000000000000000006044820152606490fd5b1561161557565b60405162461bcd60e51b815260206004820152601460248201527f6e6565642073746172742066726f6d20313238780000000000000000000000006044820152606490fd5b1561166157565b60405162461bcd60e51b815260206004820152601360248201527f656e6448617368206e6f7420636f7272656374000000000000000000000000006044820152606490fd5b156116ad57565b60405162461bcd60e51b815260206004820152600f60248201527f70726f6f66206e6f742076616c696400000000000000000000000000000000006044820152606490fd5b67ffffffffffffffff16915f91838352602093600585526001600160a01b039081604086205416156117c95791839186938652600584526040862054169060446040518096819582946322bb937360e11b8452886004850152816024850152848401378181018301899052601f01601f191681010301915afa9283156117be57829361177f575b50505090565b9080929350813d83116117b7575b611797818361144e565b810103126117b3575190811515820361060757505f8080611779565b5080fd5b503d61178d565b6040513d84823e3d90fd5b60405162461bcd60e51b815260048101879052601660248201527f636861696e207665726966696572206e6f7420736574000000000000000000006044820152606490fd5b91909182610160116113c057610180928084116113c057608092610170830135841c610140840135851b1794826101a0116113c0576101c0908382116113c0576101b0850135861c90850135861b1794836101e0116113c05783610200116113c0576101f0850135811c91850135901b179282610220116113c05761021c81013560e01c92610240116113c05761023c013560e01c90565b60243563ffffffff811681036113c05790565b60078110156113605760051b60a40190565b5f1981146115ae5760010190565b80518210156113605760209160051b010190565b156118f457565b60405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f74207061757365720000000000000000000000006044820152606490fd5b6001600160a01b03809116915f83815260039360209185835260409060ff828220541687811015611afb5715611ab7576004968754965f1990818901988911611aa457835b8a54811015611a6157868261199283611374565b905490871b1c16146119ac576119a7906118cb565b61197e565b909192939495969798808210611a3c575b50505087548015611a295797849392917fd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d98598990190611a136119fe83611374565b6001600160a01b0382549160031b1b19169055565b55848252855220805460ff1916905551908152a1565b634e487b7160e01b845260318952602484fd5b611a5992611a4c6108b992611374565b905490871b1c1691611374565b5f80806119bd565b855162461bcd60e51b8152808c01899052601060248201527f70726f766572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b634e487b7160e01b845260118a52602484fd5b815162461bcd60e51b815260048101859052601560248201527f6163636f756e74206973206e6f742070726f76657200000000000000000000006044820152606490fd5b634e487b7160e01b82526021600452602482fd5b6001600160a01b038116905f90828252600160205260ff604083205416611baf5760025468010000000000000000811015611b9b57602092611b7f7f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f895936108b98460016040960160025561132b565b8281526001845220600160ff19825416179055604051908152a1565b634e487b7160e01b83526041600452602483fd5b60405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152606490fd5b6001600160a01b03809116905f9282845260019060209382855260409360ff858820541615611d6c576002805490915f1991828101908111611d5857908695949392918a975b611c83575b885162461bcd60e51b8152600481018b9052601060248201527f706175736572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b8399989799548a1015611d4f578185611c9b8c61132b565b929054600393841b1c1614611cc45750611cbb8798999a979596976118cb565b97969594611c3a565b9293949796959991818310611d2a575b5050505081548015611d1657918493917fcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e9899930190611a136119fe8361132b565b634e487b7160e01b89526031600452602489fd5b611d4693611d3a6108b99361132b565b9054911b1c169161132b565b5f808080611cd4565b87989950611c3f565b634e487b7160e01b8a52601160045260248afd5b845162461bcd60e51b815260048101879052601560248201527f4163636f756e74206973206e6f742070617573657200000000000000000000006044820152606490fdfea264697066735822122080a14f45ed8e88b776eb23a35a82f1792da5c771125188c9b1e136198e324d6664736f6c63430008140033",
}

// BlockChunksABI is the input ABI used to generate the binding from.
// Deprecated: Use BlockChunksMetaData.ABI instead.
var BlockChunksABI = BlockChunksMetaData.ABI

// BlockChunksBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use BlockChunksMetaData.Bin instead.
var BlockChunksBin = BlockChunksMetaData.Bin

// DeployBlockChunks deploys a new Ethereum contract, binding an instance of BlockChunks to it.
func DeployBlockChunks(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *BlockChunks, error) {
	parsed, err := BlockChunksMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(BlockChunksBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &BlockChunks{BlockChunksCaller: BlockChunksCaller{contract: contract}, BlockChunksTransactor: BlockChunksTransactor{contract: contract}, BlockChunksFilterer: BlockChunksFilterer{contract: contract}}, nil
}

// BlockChunks is an auto generated Go binding around an Ethereum contract.
type BlockChunks struct {
	BlockChunksCaller     // Read-only binding to the contract
	BlockChunksTransactor // Write-only binding to the contract
	BlockChunksFilterer   // Log filterer for contract events
}

// BlockChunksCaller is an auto generated read-only Go binding around an Ethereum contract.
type BlockChunksCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BlockChunksTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BlockChunksTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BlockChunksFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BlockChunksFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BlockChunksSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BlockChunksSession struct {
	Contract     *BlockChunks      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BlockChunksCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BlockChunksCallerSession struct {
	Contract *BlockChunksCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// BlockChunksTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BlockChunksTransactorSession struct {
	Contract     *BlockChunksTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// BlockChunksRaw is an auto generated low-level Go binding around an Ethereum contract.
type BlockChunksRaw struct {
	Contract *BlockChunks // Generic contract binding to access the raw methods on
}

// BlockChunksCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BlockChunksCallerRaw struct {
	Contract *BlockChunksCaller // Generic read-only contract binding to access the raw methods on
}

// BlockChunksTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BlockChunksTransactorRaw struct {
	Contract *BlockChunksTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBlockChunks creates a new instance of BlockChunks, bound to a specific deployed contract.
func NewBlockChunks(address common.Address, backend bind.ContractBackend) (*BlockChunks, error) {
	contract, err := bindBlockChunks(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BlockChunks{BlockChunksCaller: BlockChunksCaller{contract: contract}, BlockChunksTransactor: BlockChunksTransactor{contract: contract}, BlockChunksFilterer: BlockChunksFilterer{contract: contract}}, nil
}

// NewBlockChunksCaller creates a new read-only instance of BlockChunks, bound to a specific deployed contract.
func NewBlockChunksCaller(address common.Address, caller bind.ContractCaller) (*BlockChunksCaller, error) {
	contract, err := bindBlockChunks(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BlockChunksCaller{contract: contract}, nil
}

// NewBlockChunksTransactor creates a new write-only instance of BlockChunks, bound to a specific deployed contract.
func NewBlockChunksTransactor(address common.Address, transactor bind.ContractTransactor) (*BlockChunksTransactor, error) {
	contract, err := bindBlockChunks(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BlockChunksTransactor{contract: contract}, nil
}

// NewBlockChunksFilterer creates a new log filterer instance of BlockChunks, bound to a specific deployed contract.
func NewBlockChunksFilterer(address common.Address, filterer bind.ContractFilterer) (*BlockChunksFilterer, error) {
	contract, err := bindBlockChunks(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BlockChunksFilterer{contract: contract}, nil
}

// bindBlockChunks binds a generic wrapper to an already deployed contract.
func bindBlockChunks(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BlockChunksMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BlockChunks *BlockChunksRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BlockChunks.Contract.BlockChunksCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BlockChunks *BlockChunksRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BlockChunks.Contract.BlockChunksTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BlockChunks *BlockChunksRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BlockChunks.Contract.BlockChunksTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BlockChunks *BlockChunksCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BlockChunks.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BlockChunks *BlockChunksTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BlockChunks.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BlockChunks *BlockChunksTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BlockChunks.Contract.contract.Transact(opts, method, params...)
}

// AnchorBlockProviders is a free data retrieval call binding the contract method 0x5d727e97.
//
// Solidity: function anchorBlockProviders(uint64 ) view returns(address)
func (_BlockChunks *BlockChunksCaller) AnchorBlockProviders(opts *bind.CallOpts, arg0 uint64) (common.Address, error) {
	var out []interface{}
	err := _BlockChunks.contract.Call(opts, &out, "anchorBlockProviders", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// AnchorBlockProviders is a free data retrieval call binding the contract method 0x5d727e97.
//
// Solidity: function anchorBlockProviders(uint64 ) view returns(address)
func (_BlockChunks *BlockChunksSession) AnchorBlockProviders(arg0 uint64) (common.Address, error) {
	return _BlockChunks.Contract.AnchorBlockProviders(&_BlockChunks.CallOpts, arg0)
}

// AnchorBlockProviders is a free data retrieval call binding the contract method 0x5d727e97.
//
// Solidity: function anchorBlockProviders(uint64 ) view returns(address)
func (_BlockChunks *BlockChunksCallerSession) AnchorBlockProviders(arg0 uint64) (common.Address, error) {
	return _BlockChunks.Contract.AnchorBlockProviders(&_BlockChunks.CallOpts, arg0)
}

// HistoricalRoots is a free data retrieval call binding the contract method 0xb551a187.
//
// Solidity: function historicalRoots(uint64 chainId, uint32 startBlockNumber) view returns(bytes32)
func (_BlockChunks *BlockChunksCaller) HistoricalRoots(opts *bind.CallOpts, chainId uint64, startBlockNumber uint32) ([32]byte, error) {
	var out []interface{}
	err := _BlockChunks.contract.Call(opts, &out, "historicalRoots", chainId, startBlockNumber)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// HistoricalRoots is a free data retrieval call binding the contract method 0xb551a187.
//
// Solidity: function historicalRoots(uint64 chainId, uint32 startBlockNumber) view returns(bytes32)
func (_BlockChunks *BlockChunksSession) HistoricalRoots(chainId uint64, startBlockNumber uint32) ([32]byte, error) {
	return _BlockChunks.Contract.HistoricalRoots(&_BlockChunks.CallOpts, chainId, startBlockNumber)
}

// HistoricalRoots is a free data retrieval call binding the contract method 0xb551a187.
//
// Solidity: function historicalRoots(uint64 chainId, uint32 startBlockNumber) view returns(bytes32)
func (_BlockChunks *BlockChunksCallerSession) HistoricalRoots(chainId uint64, startBlockNumber uint32) ([32]byte, error) {
	return _BlockChunks.Contract.HistoricalRoots(&_BlockChunks.CallOpts, chainId, startBlockNumber)
}

// IsActiveProver is a free data retrieval call binding the contract method 0xec64842e.
//
// Solidity: function isActiveProver(address _account) view returns(bool)
func (_BlockChunks *BlockChunksCaller) IsActiveProver(opts *bind.CallOpts, _account common.Address) (bool, error) {
	var out []interface{}
	err := _BlockChunks.contract.Call(opts, &out, "isActiveProver", _account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsActiveProver is a free data retrieval call binding the contract method 0xec64842e.
//
// Solidity: function isActiveProver(address _account) view returns(bool)
func (_BlockChunks *BlockChunksSession) IsActiveProver(_account common.Address) (bool, error) {
	return _BlockChunks.Contract.IsActiveProver(&_BlockChunks.CallOpts, _account)
}

// IsActiveProver is a free data retrieval call binding the contract method 0xec64842e.
//
// Solidity: function isActiveProver(address _account) view returns(bool)
func (_BlockChunks *BlockChunksCallerSession) IsActiveProver(_account common.Address) (bool, error) {
	return _BlockChunks.Contract.IsActiveProver(&_BlockChunks.CallOpts, _account)
}

// IsBlockHashValid is a free data retrieval call binding the contract method 0x544f73a4.
//
// Solidity: function isBlockHashValid((uint64,uint32,bytes32,bytes32,uint32,bytes32[7]) witness) view returns(bool)
func (_BlockChunks *BlockChunksCaller) IsBlockHashValid(opts *bind.CallOpts, witness IBlockChunksBlockHashWitness) (bool, error) {
	var out []interface{}
	err := _BlockChunks.contract.Call(opts, &out, "isBlockHashValid", witness)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsBlockHashValid is a free data retrieval call binding the contract method 0x544f73a4.
//
// Solidity: function isBlockHashValid((uint64,uint32,bytes32,bytes32,uint32,bytes32[7]) witness) view returns(bool)
func (_BlockChunks *BlockChunksSession) IsBlockHashValid(witness IBlockChunksBlockHashWitness) (bool, error) {
	return _BlockChunks.Contract.IsBlockHashValid(&_BlockChunks.CallOpts, witness)
}

// IsBlockHashValid is a free data retrieval call binding the contract method 0x544f73a4.
//
// Solidity: function isBlockHashValid((uint64,uint32,bytes32,bytes32,uint32,bytes32[7]) witness) view returns(bool)
func (_BlockChunks *BlockChunksCallerSession) IsBlockHashValid(witness IBlockChunksBlockHashWitness) (bool, error) {
	return _BlockChunks.Contract.IsBlockHashValid(&_BlockChunks.CallOpts, witness)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BlockChunks *BlockChunksCaller) IsPauser(opts *bind.CallOpts, account common.Address) (bool, error) {
	var out []interface{}
	err := _BlockChunks.contract.Call(opts, &out, "isPauser", account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BlockChunks *BlockChunksSession) IsPauser(account common.Address) (bool, error) {
	return _BlockChunks.Contract.IsPauser(&_BlockChunks.CallOpts, account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BlockChunks *BlockChunksCallerSession) IsPauser(account common.Address) (bool, error) {
	return _BlockChunks.Contract.IsPauser(&_BlockChunks.CallOpts, account)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BlockChunks *BlockChunksCaller) NumPausers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BlockChunks.contract.Call(opts, &out, "numPausers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BlockChunks *BlockChunksSession) NumPausers() (*big.Int, error) {
	return _BlockChunks.Contract.NumPausers(&_BlockChunks.CallOpts)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BlockChunks *BlockChunksCallerSession) NumPausers() (*big.Int, error) {
	return _BlockChunks.Contract.NumPausers(&_BlockChunks.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BlockChunks *BlockChunksCaller) NumProvers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BlockChunks.contract.Call(opts, &out, "numProvers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BlockChunks *BlockChunksSession) NumProvers() (*big.Int, error) {
	return _BlockChunks.Contract.NumProvers(&_BlockChunks.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BlockChunks *BlockChunksCallerSession) NumProvers() (*big.Int, error) {
	return _BlockChunks.Contract.NumProvers(&_BlockChunks.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BlockChunks *BlockChunksCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BlockChunks.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BlockChunks *BlockChunksSession) Owner() (common.Address, error) {
	return _BlockChunks.Contract.Owner(&_BlockChunks.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BlockChunks *BlockChunksCallerSession) Owner() (common.Address, error) {
	return _BlockChunks.Contract.Owner(&_BlockChunks.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BlockChunks *BlockChunksCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _BlockChunks.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BlockChunks *BlockChunksSession) Paused() (bool, error) {
	return _BlockChunks.Contract.Paused(&_BlockChunks.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BlockChunks *BlockChunksCallerSession) Paused() (bool, error) {
	return _BlockChunks.Contract.Paused(&_BlockChunks.CallOpts)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BlockChunks *BlockChunksCaller) PauserList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _BlockChunks.contract.Call(opts, &out, "pauserList", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BlockChunks *BlockChunksSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _BlockChunks.Contract.PauserList(&_BlockChunks.CallOpts, arg0)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BlockChunks *BlockChunksCallerSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _BlockChunks.Contract.PauserList(&_BlockChunks.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BlockChunks *BlockChunksCaller) Pausers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _BlockChunks.contract.Call(opts, &out, "pausers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BlockChunks *BlockChunksSession) Pausers(arg0 common.Address) (bool, error) {
	return _BlockChunks.Contract.Pausers(&_BlockChunks.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BlockChunks *BlockChunksCallerSession) Pausers(arg0 common.Address) (bool, error) {
	return _BlockChunks.Contract.Pausers(&_BlockChunks.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BlockChunks *BlockChunksCaller) ProverStates(opts *bind.CallOpts, arg0 common.Address) (uint8, error) {
	var out []interface{}
	err := _BlockChunks.contract.Call(opts, &out, "proverStates", arg0)

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BlockChunks *BlockChunksSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _BlockChunks.Contract.ProverStates(&_BlockChunks.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BlockChunks *BlockChunksCallerSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _BlockChunks.Contract.ProverStates(&_BlockChunks.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BlockChunks *BlockChunksCaller) Provers(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _BlockChunks.contract.Call(opts, &out, "provers", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BlockChunks *BlockChunksSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _BlockChunks.Contract.Provers(&_BlockChunks.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BlockChunks *BlockChunksCallerSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _BlockChunks.Contract.Provers(&_BlockChunks.CallOpts, arg0)
}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_BlockChunks *BlockChunksCaller) VerifierAddresses(opts *bind.CallOpts, arg0 uint64) (common.Address, error) {
	var out []interface{}
	err := _BlockChunks.contract.Call(opts, &out, "verifierAddresses", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_BlockChunks *BlockChunksSession) VerifierAddresses(arg0 uint64) (common.Address, error) {
	return _BlockChunks.Contract.VerifierAddresses(&_BlockChunks.CallOpts, arg0)
}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_BlockChunks *BlockChunksCallerSession) VerifierAddresses(arg0 uint64) (common.Address, error) {
	return _BlockChunks.Contract.VerifierAddresses(&_BlockChunks.CallOpts, arg0)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BlockChunks *BlockChunksTransactor) AddPauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _BlockChunks.contract.Transact(opts, "addPauser", account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BlockChunks *BlockChunksSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.AddPauser(&_BlockChunks.TransactOpts, account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BlockChunks *BlockChunksTransactorSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.AddPauser(&_BlockChunks.TransactOpts, account)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BlockChunks *BlockChunksTransactor) AddPausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _BlockChunks.contract.Transact(opts, "addPausers", accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BlockChunks *BlockChunksSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.AddPausers(&_BlockChunks.TransactOpts, accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BlockChunks *BlockChunksTransactorSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.AddPausers(&_BlockChunks.TransactOpts, accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BlockChunks *BlockChunksTransactor) AddProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _BlockChunks.contract.Transact(opts, "addProvers", _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BlockChunks *BlockChunksSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.AddProvers(&_BlockChunks.TransactOpts, _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BlockChunks *BlockChunksTransactorSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.AddProvers(&_BlockChunks.TransactOpts, _accounts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BlockChunks *BlockChunksTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BlockChunks.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BlockChunks *BlockChunksSession) Pause() (*types.Transaction, error) {
	return _BlockChunks.Contract.Pause(&_BlockChunks.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BlockChunks *BlockChunksTransactorSession) Pause() (*types.Transaction, error) {
	return _BlockChunks.Contract.Pause(&_BlockChunks.TransactOpts)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BlockChunks *BlockChunksTransactor) RemovePauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _BlockChunks.contract.Transact(opts, "removePauser", account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BlockChunks *BlockChunksSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.RemovePauser(&_BlockChunks.TransactOpts, account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BlockChunks *BlockChunksTransactorSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.RemovePauser(&_BlockChunks.TransactOpts, account)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BlockChunks *BlockChunksTransactor) RemovePausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _BlockChunks.contract.Transact(opts, "removePausers", accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BlockChunks *BlockChunksSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.RemovePausers(&_BlockChunks.TransactOpts, accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BlockChunks *BlockChunksTransactorSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.RemovePausers(&_BlockChunks.TransactOpts, accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BlockChunks *BlockChunksTransactor) RemoveProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _BlockChunks.contract.Transact(opts, "removeProvers", _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BlockChunks *BlockChunksSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.RemoveProvers(&_BlockChunks.TransactOpts, _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BlockChunks *BlockChunksTransactorSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.RemoveProvers(&_BlockChunks.TransactOpts, _accounts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BlockChunks *BlockChunksTransactor) RenouncePauser(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BlockChunks.contract.Transact(opts, "renouncePauser")
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BlockChunks *BlockChunksSession) RenouncePauser() (*types.Transaction, error) {
	return _BlockChunks.Contract.RenouncePauser(&_BlockChunks.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BlockChunks *BlockChunksTransactorSession) RenouncePauser() (*types.Transaction, error) {
	return _BlockChunks.Contract.RenouncePauser(&_BlockChunks.TransactOpts)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BlockChunks *BlockChunksTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _BlockChunks.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BlockChunks *BlockChunksSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.TransferOwnership(&_BlockChunks.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BlockChunks *BlockChunksTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.TransferOwnership(&_BlockChunks.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BlockChunks *BlockChunksTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BlockChunks.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BlockChunks *BlockChunksSession) Unpause() (*types.Transaction, error) {
	return _BlockChunks.Contract.Unpause(&_BlockChunks.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BlockChunks *BlockChunksTransactorSession) Unpause() (*types.Transaction, error) {
	return _BlockChunks.Contract.Unpause(&_BlockChunks.TransactOpts)
}

// UpdateAnchorBlockProvider is a paid mutator transaction binding the contract method 0x1d8441a1.
//
// Solidity: function updateAnchorBlockProvider(uint64 _chainId, address _provider) returns()
func (_BlockChunks *BlockChunksTransactor) UpdateAnchorBlockProvider(opts *bind.TransactOpts, _chainId uint64, _provider common.Address) (*types.Transaction, error) {
	return _BlockChunks.contract.Transact(opts, "updateAnchorBlockProvider", _chainId, _provider)
}

// UpdateAnchorBlockProvider is a paid mutator transaction binding the contract method 0x1d8441a1.
//
// Solidity: function updateAnchorBlockProvider(uint64 _chainId, address _provider) returns()
func (_BlockChunks *BlockChunksSession) UpdateAnchorBlockProvider(_chainId uint64, _provider common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.UpdateAnchorBlockProvider(&_BlockChunks.TransactOpts, _chainId, _provider)
}

// UpdateAnchorBlockProvider is a paid mutator transaction binding the contract method 0x1d8441a1.
//
// Solidity: function updateAnchorBlockProvider(uint64 _chainId, address _provider) returns()
func (_BlockChunks *BlockChunksTransactorSession) UpdateAnchorBlockProvider(_chainId uint64, _provider common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.UpdateAnchorBlockProvider(&_BlockChunks.TransactOpts, _chainId, _provider)
}

// UpdateOld is a paid mutator transaction binding the contract method 0x52cfc560.
//
// Solidity: function updateOld(uint64 chainId, bytes32 nextRoot, uint32 nextNumFinal, bytes proofData) returns()
func (_BlockChunks *BlockChunksTransactor) UpdateOld(opts *bind.TransactOpts, chainId uint64, nextRoot [32]byte, nextNumFinal uint32, proofData []byte) (*types.Transaction, error) {
	return _BlockChunks.contract.Transact(opts, "updateOld", chainId, nextRoot, nextNumFinal, proofData)
}

// UpdateOld is a paid mutator transaction binding the contract method 0x52cfc560.
//
// Solidity: function updateOld(uint64 chainId, bytes32 nextRoot, uint32 nextNumFinal, bytes proofData) returns()
func (_BlockChunks *BlockChunksSession) UpdateOld(chainId uint64, nextRoot [32]byte, nextNumFinal uint32, proofData []byte) (*types.Transaction, error) {
	return _BlockChunks.Contract.UpdateOld(&_BlockChunks.TransactOpts, chainId, nextRoot, nextNumFinal, proofData)
}

// UpdateOld is a paid mutator transaction binding the contract method 0x52cfc560.
//
// Solidity: function updateOld(uint64 chainId, bytes32 nextRoot, uint32 nextNumFinal, bytes proofData) returns()
func (_BlockChunks *BlockChunksTransactorSession) UpdateOld(chainId uint64, nextRoot [32]byte, nextNumFinal uint32, proofData []byte) (*types.Transaction, error) {
	return _BlockChunks.Contract.UpdateOld(&_BlockChunks.TransactOpts, chainId, nextRoot, nextNumFinal, proofData)
}

// UpdateRecent is a paid mutator transaction binding the contract method 0x50a26d48.
//
// Solidity: function updateRecent(uint64 chainId, bytes proofData) returns()
func (_BlockChunks *BlockChunksTransactor) UpdateRecent(opts *bind.TransactOpts, chainId uint64, proofData []byte) (*types.Transaction, error) {
	return _BlockChunks.contract.Transact(opts, "updateRecent", chainId, proofData)
}

// UpdateRecent is a paid mutator transaction binding the contract method 0x50a26d48.
//
// Solidity: function updateRecent(uint64 chainId, bytes proofData) returns()
func (_BlockChunks *BlockChunksSession) UpdateRecent(chainId uint64, proofData []byte) (*types.Transaction, error) {
	return _BlockChunks.Contract.UpdateRecent(&_BlockChunks.TransactOpts, chainId, proofData)
}

// UpdateRecent is a paid mutator transaction binding the contract method 0x50a26d48.
//
// Solidity: function updateRecent(uint64 chainId, bytes proofData) returns()
func (_BlockChunks *BlockChunksTransactorSession) UpdateRecent(chainId uint64, proofData []byte) (*types.Transaction, error) {
	return _BlockChunks.Contract.UpdateRecent(&_BlockChunks.TransactOpts, chainId, proofData)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_BlockChunks *BlockChunksTransactor) UpdateVerifierAddress(opts *bind.TransactOpts, _chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _BlockChunks.contract.Transact(opts, "updateVerifierAddress", _chainId, _verifierAddress)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_BlockChunks *BlockChunksSession) UpdateVerifierAddress(_chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.UpdateVerifierAddress(&_BlockChunks.TransactOpts, _chainId, _verifierAddress)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_BlockChunks *BlockChunksTransactorSession) UpdateVerifierAddress(_chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _BlockChunks.Contract.UpdateVerifierAddress(&_BlockChunks.TransactOpts, _chainId, _verifierAddress)
}

// BlockChunksOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the BlockChunks contract.
type BlockChunksOwnershipTransferredIterator struct {
	Event *BlockChunksOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BlockChunksOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BlockChunksOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BlockChunksOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BlockChunksOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BlockChunksOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BlockChunksOwnershipTransferred represents a OwnershipTransferred event raised by the BlockChunks contract.
type BlockChunksOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BlockChunks *BlockChunksFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*BlockChunksOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BlockChunks.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &BlockChunksOwnershipTransferredIterator{contract: _BlockChunks.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BlockChunks *BlockChunksFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *BlockChunksOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BlockChunks.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BlockChunksOwnershipTransferred)
				if err := _BlockChunks.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BlockChunks *BlockChunksFilterer) ParseOwnershipTransferred(log types.Log) (*BlockChunksOwnershipTransferred, error) {
	event := new(BlockChunksOwnershipTransferred)
	if err := _BlockChunks.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BlockChunksPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the BlockChunks contract.
type BlockChunksPausedIterator struct {
	Event *BlockChunksPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BlockChunksPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BlockChunksPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BlockChunksPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BlockChunksPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BlockChunksPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BlockChunksPaused represents a Paused event raised by the BlockChunks contract.
type BlockChunksPaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BlockChunks *BlockChunksFilterer) FilterPaused(opts *bind.FilterOpts) (*BlockChunksPausedIterator, error) {

	logs, sub, err := _BlockChunks.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &BlockChunksPausedIterator{contract: _BlockChunks.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BlockChunks *BlockChunksFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *BlockChunksPaused) (event.Subscription, error) {

	logs, sub, err := _BlockChunks.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BlockChunksPaused)
				if err := _BlockChunks.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BlockChunks *BlockChunksFilterer) ParsePaused(log types.Log) (*BlockChunksPaused, error) {
	event := new(BlockChunksPaused)
	if err := _BlockChunks.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BlockChunksPauserAddedIterator is returned from FilterPauserAdded and is used to iterate over the raw logs and unpacked data for PauserAdded events raised by the BlockChunks contract.
type BlockChunksPauserAddedIterator struct {
	Event *BlockChunksPauserAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BlockChunksPauserAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BlockChunksPauserAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BlockChunksPauserAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BlockChunksPauserAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BlockChunksPauserAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BlockChunksPauserAdded represents a PauserAdded event raised by the BlockChunks contract.
type BlockChunksPauserAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserAdded is a free log retrieval operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BlockChunks *BlockChunksFilterer) FilterPauserAdded(opts *bind.FilterOpts) (*BlockChunksPauserAddedIterator, error) {

	logs, sub, err := _BlockChunks.contract.FilterLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return &BlockChunksPauserAddedIterator{contract: _BlockChunks.contract, event: "PauserAdded", logs: logs, sub: sub}, nil
}

// WatchPauserAdded is a free log subscription operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BlockChunks *BlockChunksFilterer) WatchPauserAdded(opts *bind.WatchOpts, sink chan<- *BlockChunksPauserAdded) (event.Subscription, error) {

	logs, sub, err := _BlockChunks.contract.WatchLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BlockChunksPauserAdded)
				if err := _BlockChunks.contract.UnpackLog(event, "PauserAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserAdded is a log parse operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BlockChunks *BlockChunksFilterer) ParsePauserAdded(log types.Log) (*BlockChunksPauserAdded, error) {
	event := new(BlockChunksPauserAdded)
	if err := _BlockChunks.contract.UnpackLog(event, "PauserAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BlockChunksPauserRemovedIterator is returned from FilterPauserRemoved and is used to iterate over the raw logs and unpacked data for PauserRemoved events raised by the BlockChunks contract.
type BlockChunksPauserRemovedIterator struct {
	Event *BlockChunksPauserRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BlockChunksPauserRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BlockChunksPauserRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BlockChunksPauserRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BlockChunksPauserRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BlockChunksPauserRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BlockChunksPauserRemoved represents a PauserRemoved event raised by the BlockChunks contract.
type BlockChunksPauserRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserRemoved is a free log retrieval operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BlockChunks *BlockChunksFilterer) FilterPauserRemoved(opts *bind.FilterOpts) (*BlockChunksPauserRemovedIterator, error) {

	logs, sub, err := _BlockChunks.contract.FilterLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return &BlockChunksPauserRemovedIterator{contract: _BlockChunks.contract, event: "PauserRemoved", logs: logs, sub: sub}, nil
}

// WatchPauserRemoved is a free log subscription operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BlockChunks *BlockChunksFilterer) WatchPauserRemoved(opts *bind.WatchOpts, sink chan<- *BlockChunksPauserRemoved) (event.Subscription, error) {

	logs, sub, err := _BlockChunks.contract.WatchLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BlockChunksPauserRemoved)
				if err := _BlockChunks.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserRemoved is a log parse operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BlockChunks *BlockChunksFilterer) ParsePauserRemoved(log types.Log) (*BlockChunksPauserRemoved, error) {
	event := new(BlockChunksPauserRemoved)
	if err := _BlockChunks.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BlockChunksProverAddedIterator is returned from FilterProverAdded and is used to iterate over the raw logs and unpacked data for ProverAdded events raised by the BlockChunks contract.
type BlockChunksProverAddedIterator struct {
	Event *BlockChunksProverAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BlockChunksProverAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BlockChunksProverAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BlockChunksProverAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BlockChunksProverAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BlockChunksProverAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BlockChunksProverAdded represents a ProverAdded event raised by the BlockChunks contract.
type BlockChunksProverAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverAdded is a free log retrieval operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BlockChunks *BlockChunksFilterer) FilterProverAdded(opts *bind.FilterOpts) (*BlockChunksProverAddedIterator, error) {

	logs, sub, err := _BlockChunks.contract.FilterLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return &BlockChunksProverAddedIterator{contract: _BlockChunks.contract, event: "ProverAdded", logs: logs, sub: sub}, nil
}

// WatchProverAdded is a free log subscription operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BlockChunks *BlockChunksFilterer) WatchProverAdded(opts *bind.WatchOpts, sink chan<- *BlockChunksProverAdded) (event.Subscription, error) {

	logs, sub, err := _BlockChunks.contract.WatchLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BlockChunksProverAdded)
				if err := _BlockChunks.contract.UnpackLog(event, "ProverAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverAdded is a log parse operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BlockChunks *BlockChunksFilterer) ParseProverAdded(log types.Log) (*BlockChunksProverAdded, error) {
	event := new(BlockChunksProverAdded)
	if err := _BlockChunks.contract.UnpackLog(event, "ProverAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BlockChunksProverRemovedIterator is returned from FilterProverRemoved and is used to iterate over the raw logs and unpacked data for ProverRemoved events raised by the BlockChunks contract.
type BlockChunksProverRemovedIterator struct {
	Event *BlockChunksProverRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BlockChunksProverRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BlockChunksProverRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BlockChunksProverRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BlockChunksProverRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BlockChunksProverRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BlockChunksProverRemoved represents a ProverRemoved event raised by the BlockChunks contract.
type BlockChunksProverRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverRemoved is a free log retrieval operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BlockChunks *BlockChunksFilterer) FilterProverRemoved(opts *bind.FilterOpts) (*BlockChunksProverRemovedIterator, error) {

	logs, sub, err := _BlockChunks.contract.FilterLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return &BlockChunksProverRemovedIterator{contract: _BlockChunks.contract, event: "ProverRemoved", logs: logs, sub: sub}, nil
}

// WatchProverRemoved is a free log subscription operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BlockChunks *BlockChunksFilterer) WatchProverRemoved(opts *bind.WatchOpts, sink chan<- *BlockChunksProverRemoved) (event.Subscription, error) {

	logs, sub, err := _BlockChunks.contract.WatchLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BlockChunksProverRemoved)
				if err := _BlockChunks.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverRemoved is a log parse operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BlockChunks *BlockChunksFilterer) ParseProverRemoved(log types.Log) (*BlockChunksProverRemoved, error) {
	event := new(BlockChunksProverRemoved)
	if err := _BlockChunks.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BlockChunksUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the BlockChunks contract.
type BlockChunksUnpausedIterator struct {
	Event *BlockChunksUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BlockChunksUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BlockChunksUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BlockChunksUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BlockChunksUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BlockChunksUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BlockChunksUnpaused represents a Unpaused event raised by the BlockChunks contract.
type BlockChunksUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BlockChunks *BlockChunksFilterer) FilterUnpaused(opts *bind.FilterOpts) (*BlockChunksUnpausedIterator, error) {

	logs, sub, err := _BlockChunks.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &BlockChunksUnpausedIterator{contract: _BlockChunks.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BlockChunks *BlockChunksFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *BlockChunksUnpaused) (event.Subscription, error) {

	logs, sub, err := _BlockChunks.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BlockChunksUnpaused)
				if err := _BlockChunks.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BlockChunks *BlockChunksFilterer) ParseUnpaused(log types.Log) (*BlockChunksUnpaused, error) {
	event := new(BlockChunksUnpaused)
	if err := _BlockChunks.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BlockChunksUpdateAnchorBlockProviderIterator is returned from FilterUpdateAnchorBlockProvider and is used to iterate over the raw logs and unpacked data for UpdateAnchorBlockProvider events raised by the BlockChunks contract.
type BlockChunksUpdateAnchorBlockProviderIterator struct {
	Event *BlockChunksUpdateAnchorBlockProvider // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BlockChunksUpdateAnchorBlockProviderIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BlockChunksUpdateAnchorBlockProvider)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BlockChunksUpdateAnchorBlockProvider)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BlockChunksUpdateAnchorBlockProviderIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BlockChunksUpdateAnchorBlockProviderIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BlockChunksUpdateAnchorBlockProvider represents a UpdateAnchorBlockProvider event raised by the BlockChunks contract.
type BlockChunksUpdateAnchorBlockProvider struct {
	ChainId    uint64
	NewAddress common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterUpdateAnchorBlockProvider is a free log retrieval operation binding the contract event 0x4b8c49e37c813f3cbe140bc7b6a5662bd14e48311b5864c106ca3f9c4a2bc02b.
//
// Solidity: event UpdateAnchorBlockProvider(uint64 chainId, address newAddress)
func (_BlockChunks *BlockChunksFilterer) FilterUpdateAnchorBlockProvider(opts *bind.FilterOpts) (*BlockChunksUpdateAnchorBlockProviderIterator, error) {

	logs, sub, err := _BlockChunks.contract.FilterLogs(opts, "UpdateAnchorBlockProvider")
	if err != nil {
		return nil, err
	}
	return &BlockChunksUpdateAnchorBlockProviderIterator{contract: _BlockChunks.contract, event: "UpdateAnchorBlockProvider", logs: logs, sub: sub}, nil
}

// WatchUpdateAnchorBlockProvider is a free log subscription operation binding the contract event 0x4b8c49e37c813f3cbe140bc7b6a5662bd14e48311b5864c106ca3f9c4a2bc02b.
//
// Solidity: event UpdateAnchorBlockProvider(uint64 chainId, address newAddress)
func (_BlockChunks *BlockChunksFilterer) WatchUpdateAnchorBlockProvider(opts *bind.WatchOpts, sink chan<- *BlockChunksUpdateAnchorBlockProvider) (event.Subscription, error) {

	logs, sub, err := _BlockChunks.contract.WatchLogs(opts, "UpdateAnchorBlockProvider")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BlockChunksUpdateAnchorBlockProvider)
				if err := _BlockChunks.contract.UnpackLog(event, "UpdateAnchorBlockProvider", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdateAnchorBlockProvider is a log parse operation binding the contract event 0x4b8c49e37c813f3cbe140bc7b6a5662bd14e48311b5864c106ca3f9c4a2bc02b.
//
// Solidity: event UpdateAnchorBlockProvider(uint64 chainId, address newAddress)
func (_BlockChunks *BlockChunksFilterer) ParseUpdateAnchorBlockProvider(log types.Log) (*BlockChunksUpdateAnchorBlockProvider, error) {
	event := new(BlockChunksUpdateAnchorBlockProvider)
	if err := _BlockChunks.contract.UnpackLog(event, "UpdateAnchorBlockProvider", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BlockChunksUpdateEventIterator is returned from FilterUpdateEvent and is used to iterate over the raw logs and unpacked data for UpdateEvent events raised by the BlockChunks contract.
type BlockChunksUpdateEventIterator struct {
	Event *BlockChunksUpdateEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BlockChunksUpdateEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BlockChunksUpdateEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BlockChunksUpdateEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BlockChunksUpdateEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BlockChunksUpdateEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BlockChunksUpdateEvent represents a UpdateEvent event raised by the BlockChunks contract.
type BlockChunksUpdateEvent struct {
	ChainId          uint64
	StartBlockNumber uint32
	PrevHash         [32]byte
	Root             [32]byte
	NumFinal         uint32
	Raw              types.Log // Blockchain specific contextual infos
}

// FilterUpdateEvent is a free log retrieval operation binding the contract event 0xa946b3d79b3150fec8e4d9ccc6100de98308a472f1ba57d23aeda162bb86e33e.
//
// Solidity: event UpdateEvent(uint64 chainId, uint32 startBlockNumber, bytes32 prevHash, bytes32 root, uint32 numFinal)
func (_BlockChunks *BlockChunksFilterer) FilterUpdateEvent(opts *bind.FilterOpts) (*BlockChunksUpdateEventIterator, error) {

	logs, sub, err := _BlockChunks.contract.FilterLogs(opts, "UpdateEvent")
	if err != nil {
		return nil, err
	}
	return &BlockChunksUpdateEventIterator{contract: _BlockChunks.contract, event: "UpdateEvent", logs: logs, sub: sub}, nil
}

// WatchUpdateEvent is a free log subscription operation binding the contract event 0xa946b3d79b3150fec8e4d9ccc6100de98308a472f1ba57d23aeda162bb86e33e.
//
// Solidity: event UpdateEvent(uint64 chainId, uint32 startBlockNumber, bytes32 prevHash, bytes32 root, uint32 numFinal)
func (_BlockChunks *BlockChunksFilterer) WatchUpdateEvent(opts *bind.WatchOpts, sink chan<- *BlockChunksUpdateEvent) (event.Subscription, error) {

	logs, sub, err := _BlockChunks.contract.WatchLogs(opts, "UpdateEvent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BlockChunksUpdateEvent)
				if err := _BlockChunks.contract.UnpackLog(event, "UpdateEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdateEvent is a log parse operation binding the contract event 0xa946b3d79b3150fec8e4d9ccc6100de98308a472f1ba57d23aeda162bb86e33e.
//
// Solidity: event UpdateEvent(uint64 chainId, uint32 startBlockNumber, bytes32 prevHash, bytes32 root, uint32 numFinal)
func (_BlockChunks *BlockChunksFilterer) ParseUpdateEvent(log types.Log) (*BlockChunksUpdateEvent, error) {
	event := new(BlockChunksUpdateEvent)
	if err := _BlockChunks.contract.UnpackLog(event, "UpdateEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BlockChunksUpdateVerifierAddressIterator is returned from FilterUpdateVerifierAddress and is used to iterate over the raw logs and unpacked data for UpdateVerifierAddress events raised by the BlockChunks contract.
type BlockChunksUpdateVerifierAddressIterator struct {
	Event *BlockChunksUpdateVerifierAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BlockChunksUpdateVerifierAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BlockChunksUpdateVerifierAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BlockChunksUpdateVerifierAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BlockChunksUpdateVerifierAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BlockChunksUpdateVerifierAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BlockChunksUpdateVerifierAddress represents a UpdateVerifierAddress event raised by the BlockChunks contract.
type BlockChunksUpdateVerifierAddress struct {
	ChainId    uint64
	NewAddress common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterUpdateVerifierAddress is a free log retrieval operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_BlockChunks *BlockChunksFilterer) FilterUpdateVerifierAddress(opts *bind.FilterOpts) (*BlockChunksUpdateVerifierAddressIterator, error) {

	logs, sub, err := _BlockChunks.contract.FilterLogs(opts, "UpdateVerifierAddress")
	if err != nil {
		return nil, err
	}
	return &BlockChunksUpdateVerifierAddressIterator{contract: _BlockChunks.contract, event: "UpdateVerifierAddress", logs: logs, sub: sub}, nil
}

// WatchUpdateVerifierAddress is a free log subscription operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_BlockChunks *BlockChunksFilterer) WatchUpdateVerifierAddress(opts *bind.WatchOpts, sink chan<- *BlockChunksUpdateVerifierAddress) (event.Subscription, error) {

	logs, sub, err := _BlockChunks.contract.WatchLogs(opts, "UpdateVerifierAddress")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BlockChunksUpdateVerifierAddress)
				if err := _BlockChunks.contract.UnpackLog(event, "UpdateVerifierAddress", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdateVerifierAddress is a log parse operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_BlockChunks *BlockChunksFilterer) ParseUpdateVerifierAddress(log types.Log) (*BlockChunksUpdateVerifierAddress, error) {
	event := new(BlockChunksUpdateVerifierAddress)
	if err := _BlockChunks.contract.UnpackLog(event, "UpdateVerifierAddress", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BlsSigVerifierMetaData contains all meta data concerning the BlsSigVerifier contract.
var BlsSigVerifierMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commit\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[35]\",\"name\":\"input\",\"type\":\"uint256[35]\"}],\"name\":\"verifyBlsSigProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"r\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x6080806040523461001657611bfb908161001b8239f35b5f80fdfe6040608081526004361015610012575f80fd5b5f803560e01c630cc2676914610026575f80fd5b346100c4576105a03660031901126100c45761004136610120565b9036606312156100c4576100536100db565b908160c4913683116100c457506044905b8282106100ab576100a786610096878761007d36610161565b6100863661019f565b916100903661021f565b93610651565b905190151581529081906020820190565b0390f35b602086916100b936856101df565b815201910190610064565b80fd5b634e487b7160e01b5f52604160045260245ffd5b604051906040820182811067ffffffffffffffff8211176100fb57604052565b6100c7565b604051906080820182811067ffffffffffffffff8211176100fb57604052565b806023121561015d576101316100db565b9081604491821161015d576004905b82821061014d5750505090565b8135815260209182019101610140565b5f80fd5b8060e3121561015d576101726100db565b908161010491821161015d5760c4905b82821061018f5750505090565b8135815260209182019101610182565b80610123121561015d576101b16100db565b908161014491821161015d57610104905b8282106101cf5750505090565b81358152602091820191016101c2565b9080601f8301121561015d576101f36100db565b80926040810192831161015d57905b82821061020f5750505090565b8135815260209182019101610202565b80610163121561015d5760405190610460820182811067ffffffffffffffff8211176100fb57604052816105a491821161015d57610144905b8282106102655750505090565b8135815260209182019101610258565b61027d610100565b906080368337565b604051906060820182811067ffffffffffffffff8211176100fb576040526060368337565b604051906020820182811067ffffffffffffffff8211176100fb576040526020368337565b6102d76100db565b906102e06100db565b604036823782526102ef6100db565b60403682376020830152565b610303610100565b9061030c6100db565b5f9081815281602082015283526103216102cf565b602084015261032e6100db565b81815281602082015260408401526103446100db565b9080825260208201526060830152565b634e487b7160e01b5f52603260045260245ffd5b1561036f57565b60405162461bcd60e51b815260206004820152601760248201527f76657269666965722d61582d6774652d7072696d652d710000000000000000006044820152606490fd5b156103bb57565b60405162461bcd60e51b815260206004820152601760248201527f76657269666965722d61592d6774652d7072696d652d710000000000000000006044820152606490fd5b1561040757565b60405162461bcd60e51b815260206004820152601860248201527f76657269666965722d6258302d6774652d7072696d652d7100000000000000006044820152606490fd5b1561045357565b60405162461bcd60e51b815260206004820152601860248201527f76657269666965722d6259302d6774652d7072696d652d7100000000000000006044820152606490fd5b1561049f57565b60405162461bcd60e51b815260206004820152601860248201527f76657269666965722d6258312d6774652d7072696d652d7100000000000000006044820152606490fd5b156104eb57565b60405162461bcd60e51b815260206004820152601860248201527f76657269666965722d6259312d6774652d7072696d652d7100000000000000006044820152606490fd5b1561053757565b60405162461bcd60e51b815260206004820152601760248201527f76657269666965722d63582d6774652d7072696d652d710000000000000000006044820152606490fd5b1561058357565b60405162461bcd60e51b815260206004820152601760248201527f76657269666965722d63592d6774652d7072696d652d710000000000000000006044820152606490fd5b634e487b7160e01b5f52601160045260245ffd5b5f1981146105ea5760010190565b6105c8565b9060238110156106005760051b0190565b610354565b1561060c57565b60405162461bcd60e51b815260206004820152601f60248201527f76657269666965722d6774652d736e61726b2d7363616c61722d6669656c64006044820152606490fd5b949394929190926106606102fb565b81516020809301516106706100db565b9182528382015281526106816100db565b948051518652610692815160200190565b51838701526106b1836106a36100db565b920180515183525160200190565b51838201526106be6100db565b958652828601528181019485528183519301516106d96100db565b93845282840152604081019283528351938281019485516106f86100db565b91825284820152606083019081526107ac7f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd476107378186515110610368565b610746818787510151106103b4565b610754818a51515110610400565b61076481878b510151511061044c565b61077b816107748b515160200190565b5110610498565b6107948161078d888c51015160200190565b51106104e4565b6107a18188515110610530565b85875101511061057c565b5f5b602381106114e85750906114c197989392916107c8611570565b966107d16100db565b925f845261148884878101985f8a5281996107ea610275565b918a6104406107f7610285565b927f2065b90c648581703a4ef82833653ae713aaf62c2dc4ef26b0a9bbbdf254b48a6108216100db565b955f87525f858801527f0da0d09dcc32c2d20c9905307190ffb91538db928804c70e7ed77639f2cee0fe8952527f2fcf362c494439bcae24ab0ab7dd0bd40825ed18725c1d11d25eeb863f24194884527f184edce371c121d112278a4d1239f9d65421fb00e688d7612320bb5f66e7409d8385017f1a7a0f4ef55687795fa98c4585fc66e26ddea1f6e161a837ef4a4f1ae9c8808b8152825194604087019586526108ce8a8a8a8a6117fd565b7f159c9e6c6ad47c3114dd4bdc88dc34359cae49de8306c8f56c9ba9d56429755e87527f261a0e3bad2b8c7b4057a7708b68ddaa9684eaa9d458088e7a2fe7813e08d06082528301518552610925898989896117fd565b7f1243c2c01b1a238bd0937eed8a5eb5f962eae681000356540ae1cfb36e1e308b86527e816901d1be816971e5f7e84b32a92c58a9f8971ff921adc37884d47db225e281526040830151855261097d898989896117fd565b7f25ebb06beeca9f8b08c511a86423c8f8705f115fe942220b9f8e30d54b016e0686527f1a598b2d183a54a959959d562879ae4b48df2203151d223973543b7d9584c59e8152606083015185526109d6898989896117fd565b7f0ede030d344e453627bd0d2e849cd89947ed04b1825b0d4f7d6a8bf8b6ca5bae86527f01e7b010c4ab8cfc4791d0886bb39e1e8785b51a2a2165514d1fe026b8de24ad815260808301518552610a2f898989896117fd565b7f1f81ffd062f9644e01e392d39b8de8e030afd731c770e58f96050ed1d36d553286527f0ac85a9509ed9a6e21c1e933b10794303a4b77d9fd1fb036e966fef320cb4dad815260a08301518552610a88898989896117fd565b7f2d46add97dc6a65ee2f3dd3ea61060bf9fd510929a701e4cec0913f8ab1cafe386527f1e8e47b54e79299b14dfe604a3c8ce10ee4cb2d09be71e23628c13888c29a254815260c08301518552610ae1898989896117fd565b7f146a85b7d5644a318ee8d2a44d995f580695fb92ade1dc0bbfc84cb4010ac1c386527f1d3734ea6fc621a0710ba60b024e87e0442525b2c77aff46634f6c5c0035e073815260e08301518552610b3a898989896117fd565b7f12664f87a4a89be5df17d8f4cb797e102a083e505835ddfa68bfff968ded011f86527f062c4ef046ea89c77def686012d175292e6cca3adb8dc9e0234bbbe4384e6b1881526101008301518552610b94898989896117fd565b7f22ecd52df7b85f6392fa550619d401fedebde3332b7c8857f3b26caac17f4b7986527f25696ccea69b88905a95af209f6daa0d638426ae494b1b5800d1bb32aa271c3c81526101208301518552610bee898989896117fd565b7ee5e920eb2bd31bc7480c75e93c11a2a8f421af3e287f37a87453a96b4dd6c086527f2b82a4685f51b881675e3e4958242a11585b1aa2211bef1ba101ade59d484fcb81526101408301518552610c47898989896117fd565b7f1bb112783a4bd8e95decec6012a6b0c06d076f07806241e64d5bb279055ce2e386527f03aacbe5b76da6ffe5a38b5f74bb1defdf60afde8f7bed77c2103c7d6d285c4581526101608301518552610ca1898989896117fd565b7e89a49d6c462af5737f4f74e89ee3fd5fcda9b129a6885f4402b7191ce06ecc86527f03670d5e8e16d0f9e9351a53b707cddd87f0df01f7e71f8ef942b35a63c54d8081526101808301518552610cfa898989896117fd565b7f148203b1cf918d850c2e4eb482623111d69a0d149273d88bd472cc2dc667788886527f09e3685cddd844c117894cf1560ee45625a29890eb111e539598ac6c8510b26f81526101a08301518552610d54898989896117fd565b7f038bda99e81e5aee528c18e38ab4a8806508a531d1f22f6618919bffb81f59f686527f14ce622b4ba47284ea8c421b00498ea220fb6f88026998098cbb21d38d8e0b0a81526101c08301518552610dae898989896117fd565b7f0c1641e14f8c4509f0c675448654f877363c981ca8c18363b549cfb115737ea386527f0b8cc9ed761dfbad8b821e125c571ba83a857c405c10df3bdeb64fc9b3248e2a81526101e08301518552610e08898989896117fd565b7f14c11b03d9e6d4e5c71174b991b0b1b63f5a8539d4449e10a08275be0454646586527f014e6374d23fc81a10b61fd108e7b0e59003f8d3ed87edd40a722aafbc1c263581526102008301518552610e62898989896117fd565b7f2a195965e3a4ebe550289af22bb4c1118e21dc2c74be94ad6455e8f6eb70c8c486527f12024e0b3b82946c93024f8e1159da64dc1d3c72c49929836a5f2577d5a0ed6881526102208301518552610ebc898989896117fd565b7f1f679e8223e56ae364c7fe5b1eb44e3b3c66cbf45645c364d308c505539047c986527f2c32d125628fae7d840d3f28e83a7fa88112f60ee52f5f86fba53c08e474ff6981526102408301518552610f16898989896117fd565b7f1b73d0bdb2a03d112f31e25b60799a767fb82a9d6418db824c632ffba80be47d86527f21b9840d5d347552e43ea2e7bd19560353b633a278b602c6074025ddb9f63a2181526102608301518552610f70898989896117fd565b7f16b45c0468819f85893ab1c4877c4fe4f49c146b976419b48aa07a0f6cbfb2e286527f06b26b18879ce8c03298c0302e22e9be3407e4b50aa15e3153b0eea99ce0241481526102808301518552610fca898989896117fd565b7f1fe6017431f3e3861894f3e1871a3627f3fc61c832f3e951b3e55c86c4b9615886527f2236d30c0a8738dcac59bc76c975d2ac9c9f1347adfc85c977fc196f4a963f5e81526102a08301518552611024898989896117fd565b7f2fd10aed9958e2d8257e4a70a742fa4774402f36a25babac21c8e0b5f661c12886527f0f8a616d021292af83c9631904c885899f5fe78a5489c14462c97f8472ce5bbf81526102c0830151855261107e898989896117fd565b7f280a41e1efcd026c87f851e0180aad3ac57df1f93286a57f53c400268d8752c386527f1633532825ddc9c0da04246a44b706dcfd57ae2f4c1bb69738ff8433d5b2a8bb81526102e083015185526110d8898989896117fd565b7e027cbc9193ee97f7eec57e57cb0ff7347cc0b2586a1637f4ce954bea3ff97186527f1c897b0f8a07cbc7a4b69597227129b4a12ba68e1926ecc7a45a4ec4bdc5bf0781526103008301518552611131898989896117fd565b7f1b1da35eea8e3139d38e9db84386f59853a18040d1a2216b74679e08c191a01c86527f0bfab57806284de52685f6dda04330043efee9399c75b78e48b5b1d7cb80038e8152610320830151855261118b898989896117fd565b7f012154f85b76ea46de9dc3f61d7c053aa9a583e3e2e57d6a076db599b1326a2f86527f1d25427c48b7647c1efe27b5e7da3240ee333d288ebabeb8b45e30c113c6474e815261034083015185526111e5898989896117fd565b7f111fb275c27d543c507e0c685728727d2344f736a345419dd396d083296211ed86527f01c636dbb603223ca61aee282e75c2ee554f6639e813f990cc7e045128e9ba6e8152610360830151855261123f898989896117fd565b7f0e3ef51ec2992fd4fd4e08d2fc6c02cb6586ec574edec92b74583bd38cc15cae86527f0eeb3ece8b4b83ce8946832b6dd7f35204669e47ccd8b1fc31cba6c71808f68981526103808301518552611299898989896117fd565b7f0a7e2bd7bb8aeb9e84739db84898a9115aa023c279d2df4536366e445e618b1e86527f0141bc992ed56ad3af847ed62afe254e174e6df8efbc36cf3314adad1244b42381526103a083015185526112f3898989896117fd565b7f0f2ecde94b061c256edb823ac557ce52f907f612791c85a2e66fb888ce8a417b86527f1c09474255a3b4c33f9452b362e6352c65acb1406a454a1d4b212538d529ed9a81526103c0830151855261134d898989896117fd565b7f1a2a4a634641112a1b940ba3b089193dfde76611dc7a7c29538a0f93bbdaf83086527f1752d5a3839dedbad8cd819b7b86a82982d1c7663453d236c559353725c2901381526103e083015185526113a7898989896117fd565b7f2e9b2e2e4921cd57e24d3215d41cfa43545b0fa8907380f2b4eca856b242ace086527f192ca02d2e86b7636626a919c871396ba8108cc7f2358ded277a32ed4ba10d4b81526104008301518552611401898989896117fd565b7f1266b7cbb61c28d580a6aa8e4a6b3455bf5c925fe9321c0b0afd01596c4a950586527f0f945b9129e6749912477338802d286af2f6aca2e71cdf199f387d570acf5f108152610420830151855261145b898989896117fd565b7f1be6c06af2b7182fc509c0c72a3874173c0e9b8ef208c89a6ffcbe343f74440a865252015190526117fd565b5115908115916114dd575b506114c4575b50506114a5905161184e565b9451908451908501519160606040870151955196015196611a67565b90565b519193506114a5916114d591611921565b92905f611499565b90505115155f611493565b806115217f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f000000161151a611526948e6105ef565b5110610605565b6105dc565b6107ae565b611533610100565b9061153c6100db565b5f81525f6020820152825261154f6102cf565b602083015261155c6102cf565b60408301526115696102cf565b6060830152565b61157861152b565b906115816100db565b7f3059a4f6581fbdcc0d5e847306a4862568fbf62d22d49958fc3902e4bc379ef381526020907f1dd7c04824ae7a26cbb4bb2e8e647030df4de01e51764344c9da30b1ac0317c88282015283526115d66100db565b7f0f98f7aa65c680ca7cd4b7f95afc5f6827e95398c599befdd9a9eca741e46b6181527f0a6f18525c7167edf6945aa57ecf8e0dde824c50912f1fe71574e86908579b68828201526116266100db565b7f1d1dacfe7971320b875aa2dbcdafb33d4141ca0b0435904e1e2ead83b600d26b81527f1e0cdae1aa15580307c121c8518d1b513fb8bfc62718065a60e88eee79d0288d838201526116766100db565b91825282820152818401526116896100db565b7f1887c867c4428fd8c7157ac7f5e81a19271ea37ac336aa87203e65bd77cdcad281527f10d21089c03935120870563d17d271a9165f3d541cf4b41a450b8c3741e84423828201526116d96100db565b7f105ceb8102cb4bd76c903c3f045988d7407aab02a26e2b0ac08c58af1edec5a481527f0b32e41ba74a1a65c885129ca2c3c87475d584c75ebc553cb79d4468de6483a8838201526117296100db565b91825282820152604084015261173d6100db565b907f04e9e06a4684b3f9cfea22a0b5d19239c957ba0b12a17f2d9dc9d1e63f9ae49482527f0ef0df2626365d3222024595b1cd400614d2db4a442bb59f5ab585b4717528f88183015261178e6100db565b907f239dd78f7b5dba6a6d81f994b3060a73e4d7602aeb8909fd9785a0f1e04367e382527f178fb89664e86e6758f974887c6d9d19cd52b518c16d799e75556a7ae9a25829818301526117df6100db565b9283528201526060830152565b9060048110156106005760051b0190565b90929160608460806107cf19946007865a01fa1561184c57600660c0926020606096865185528187015182860152805160408601520151868401525a01fa801561184c5761184a906118d5565b565bfe5b5f60206118596100db565b82815201528051908115806118c9575b156118845750506118786100db565b5f81525f602082015290565b602001517f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd479081900681039081116105ea576118be6100db565b918252602082015290565b50602081015115611869565b156118dc57565b60405162461bcd60e51b815260206004820152601260248201527f70616972696e672d6164642d6661696c656400000000000000000000000000006044820152606490fd5b60609092919260c06119316100db565b915f83525f60208401526020839681611948610100565b936080368637805185520151828401528051604084015201518482015260066107cf195a01fa801561184c5761184a906118d5565b60405190610320820182811067ffffffffffffffff8211176100fb5760405260188252610300366020840137565b906006820291808304600614901517156105ea57565b90600182018092116105ea57565b90600282018092116105ea57565b90600382018092116105ea57565b90600482018092116105ea57565b90600582018092116105ea57565b80518210156106005760209160051b010190565b15611a2257565b60405162461bcd60e51b815260206004820152601560248201527f70616972696e672d6f70636f64652d6661696c656400000000000000000000006044820152606490fd5b9491959692909396611a77610100565b95865260209788978888015260408701526060860152611a95610100565b9384528584015260408301526060820152611aae61197d565b915f5b60048110611ae957505050610300611ac76102aa565b9384920160086107cf195a01fa801561184c57611ae390611a1b565b51151590565b611bbb9192939450611afa816119ab565b611b0482856117ec565b5151611b108288611a07565b5286611b1c83866117ec565b510151611b31611b2b836119c1565b88611a07565b52611b3c82866117ec565b515151611b4b611b2b836119cf565b52611b61611b5983876117ec565b515160200190565b51611b6e611b2b836119dd565b5286611b7a83876117ec565b51015151611b8a611b2b836119eb565b52611bb5611baf611ba889611b9f868a6117ec565b51015160200190565b51926119f9565b87611a07565b526105dc565b9084939291611ab156fea2646970667358221220e833a0c088436d63f6d3aabad6596d0d3b45758163f05280c9ca8a164d05b11e64736f6c63430008140033",
}

// BlsSigVerifierABI is the input ABI used to generate the binding from.
// Deprecated: Use BlsSigVerifierMetaData.ABI instead.
var BlsSigVerifierABI = BlsSigVerifierMetaData.ABI

// BlsSigVerifierBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use BlsSigVerifierMetaData.Bin instead.
var BlsSigVerifierBin = BlsSigVerifierMetaData.Bin

// DeployBlsSigVerifier deploys a new Ethereum contract, binding an instance of BlsSigVerifier to it.
func DeployBlsSigVerifier(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *BlsSigVerifier, error) {
	parsed, err := BlsSigVerifierMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(BlsSigVerifierBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &BlsSigVerifier{BlsSigVerifierCaller: BlsSigVerifierCaller{contract: contract}, BlsSigVerifierTransactor: BlsSigVerifierTransactor{contract: contract}, BlsSigVerifierFilterer: BlsSigVerifierFilterer{contract: contract}}, nil
}

// BlsSigVerifier is an auto generated Go binding around an Ethereum contract.
type BlsSigVerifier struct {
	BlsSigVerifierCaller     // Read-only binding to the contract
	BlsSigVerifierTransactor // Write-only binding to the contract
	BlsSigVerifierFilterer   // Log filterer for contract events
}

// BlsSigVerifierCaller is an auto generated read-only Go binding around an Ethereum contract.
type BlsSigVerifierCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BlsSigVerifierTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BlsSigVerifierTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BlsSigVerifierFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BlsSigVerifierFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BlsSigVerifierSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BlsSigVerifierSession struct {
	Contract     *BlsSigVerifier   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BlsSigVerifierCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BlsSigVerifierCallerSession struct {
	Contract *BlsSigVerifierCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// BlsSigVerifierTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BlsSigVerifierTransactorSession struct {
	Contract     *BlsSigVerifierTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// BlsSigVerifierRaw is an auto generated low-level Go binding around an Ethereum contract.
type BlsSigVerifierRaw struct {
	Contract *BlsSigVerifier // Generic contract binding to access the raw methods on
}

// BlsSigVerifierCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BlsSigVerifierCallerRaw struct {
	Contract *BlsSigVerifierCaller // Generic read-only contract binding to access the raw methods on
}

// BlsSigVerifierTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BlsSigVerifierTransactorRaw struct {
	Contract *BlsSigVerifierTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBlsSigVerifier creates a new instance of BlsSigVerifier, bound to a specific deployed contract.
func NewBlsSigVerifier(address common.Address, backend bind.ContractBackend) (*BlsSigVerifier, error) {
	contract, err := bindBlsSigVerifier(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BlsSigVerifier{BlsSigVerifierCaller: BlsSigVerifierCaller{contract: contract}, BlsSigVerifierTransactor: BlsSigVerifierTransactor{contract: contract}, BlsSigVerifierFilterer: BlsSigVerifierFilterer{contract: contract}}, nil
}

// NewBlsSigVerifierCaller creates a new read-only instance of BlsSigVerifier, bound to a specific deployed contract.
func NewBlsSigVerifierCaller(address common.Address, caller bind.ContractCaller) (*BlsSigVerifierCaller, error) {
	contract, err := bindBlsSigVerifier(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BlsSigVerifierCaller{contract: contract}, nil
}

// NewBlsSigVerifierTransactor creates a new write-only instance of BlsSigVerifier, bound to a specific deployed contract.
func NewBlsSigVerifierTransactor(address common.Address, transactor bind.ContractTransactor) (*BlsSigVerifierTransactor, error) {
	contract, err := bindBlsSigVerifier(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BlsSigVerifierTransactor{contract: contract}, nil
}

// NewBlsSigVerifierFilterer creates a new log filterer instance of BlsSigVerifier, bound to a specific deployed contract.
func NewBlsSigVerifierFilterer(address common.Address, filterer bind.ContractFilterer) (*BlsSigVerifierFilterer, error) {
	contract, err := bindBlsSigVerifier(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BlsSigVerifierFilterer{contract: contract}, nil
}

// bindBlsSigVerifier binds a generic wrapper to an already deployed contract.
func bindBlsSigVerifier(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BlsSigVerifierMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BlsSigVerifier *BlsSigVerifierRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BlsSigVerifier.Contract.BlsSigVerifierCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BlsSigVerifier *BlsSigVerifierRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BlsSigVerifier.Contract.BlsSigVerifierTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BlsSigVerifier *BlsSigVerifierRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BlsSigVerifier.Contract.BlsSigVerifierTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BlsSigVerifier *BlsSigVerifierCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BlsSigVerifier.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BlsSigVerifier *BlsSigVerifierTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BlsSigVerifier.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BlsSigVerifier *BlsSigVerifierTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BlsSigVerifier.Contract.contract.Transact(opts, method, params...)
}

// VerifyBlsSigProof is a free data retrieval call binding the contract method 0x0cc26769.
//
// Solidity: function verifyBlsSigProof(uint256[2] a, uint256[2][2] b, uint256[2] c, uint256[2] commit, uint256[35] input) view returns(bool r)
func (_BlsSigVerifier *BlsSigVerifierCaller) VerifyBlsSigProof(opts *bind.CallOpts, a [2]*big.Int, b [2][2]*big.Int, c [2]*big.Int, commit [2]*big.Int, input [35]*big.Int) (bool, error) {
	var out []interface{}
	err := _BlsSigVerifier.contract.Call(opts, &out, "verifyBlsSigProof", a, b, c, commit, input)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// VerifyBlsSigProof is a free data retrieval call binding the contract method 0x0cc26769.
//
// Solidity: function verifyBlsSigProof(uint256[2] a, uint256[2][2] b, uint256[2] c, uint256[2] commit, uint256[35] input) view returns(bool r)
func (_BlsSigVerifier *BlsSigVerifierSession) VerifyBlsSigProof(a [2]*big.Int, b [2][2]*big.Int, c [2]*big.Int, commit [2]*big.Int, input [35]*big.Int) (bool, error) {
	return _BlsSigVerifier.Contract.VerifyBlsSigProof(&_BlsSigVerifier.CallOpts, a, b, c, commit, input)
}

// VerifyBlsSigProof is a free data retrieval call binding the contract method 0x0cc26769.
//
// Solidity: function verifyBlsSigProof(uint256[2] a, uint256[2][2] b, uint256[2] c, uint256[2] commit, uint256[35] input) view returns(bool r)
func (_BlsSigVerifier *BlsSigVerifierCallerSession) VerifyBlsSigProof(a [2]*big.Int, b [2][2]*big.Int, c [2]*big.Int, commit [2]*big.Int, input [35]*big.Int) (bool, error) {
	return _BlsSigVerifier.Contract.VerifyBlsSigProof(&_BlsSigVerifier.CallOpts, a, b, c, commit, input)
}

// BrevisMetaData contains all meta data concerning the Brevis contract.
var BrevisMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea2646970667358221220f6b091691cb1ed90ea0da339d13c153a01b4d06c770643a8c1f3528186f3e78a64736f6c63430008140033",
}

// BrevisABI is the input ABI used to generate the binding from.
// Deprecated: Use BrevisMetaData.ABI instead.
var BrevisABI = BrevisMetaData.ABI

// BrevisBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use BrevisMetaData.Bin instead.
var BrevisBin = BrevisMetaData.Bin

// DeployBrevis deploys a new Ethereum contract, binding an instance of Brevis to it.
func DeployBrevis(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Brevis, error) {
	parsed, err := BrevisMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(BrevisBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Brevis{BrevisCaller: BrevisCaller{contract: contract}, BrevisTransactor: BrevisTransactor{contract: contract}, BrevisFilterer: BrevisFilterer{contract: contract}}, nil
}

// Brevis is an auto generated Go binding around an Ethereum contract.
type Brevis struct {
	BrevisCaller     // Read-only binding to the contract
	BrevisTransactor // Write-only binding to the contract
	BrevisFilterer   // Log filterer for contract events
}

// BrevisCaller is an auto generated read-only Go binding around an Ethereum contract.
type BrevisCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BrevisTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BrevisFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BrevisSession struct {
	Contract     *Brevis           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BrevisCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BrevisCallerSession struct {
	Contract *BrevisCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// BrevisTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BrevisTransactorSession struct {
	Contract     *BrevisTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BrevisRaw is an auto generated low-level Go binding around an Ethereum contract.
type BrevisRaw struct {
	Contract *Brevis // Generic contract binding to access the raw methods on
}

// BrevisCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BrevisCallerRaw struct {
	Contract *BrevisCaller // Generic read-only contract binding to access the raw methods on
}

// BrevisTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BrevisTransactorRaw struct {
	Contract *BrevisTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBrevis creates a new instance of Brevis, bound to a specific deployed contract.
func NewBrevis(address common.Address, backend bind.ContractBackend) (*Brevis, error) {
	contract, err := bindBrevis(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Brevis{BrevisCaller: BrevisCaller{contract: contract}, BrevisTransactor: BrevisTransactor{contract: contract}, BrevisFilterer: BrevisFilterer{contract: contract}}, nil
}

// NewBrevisCaller creates a new read-only instance of Brevis, bound to a specific deployed contract.
func NewBrevisCaller(address common.Address, caller bind.ContractCaller) (*BrevisCaller, error) {
	contract, err := bindBrevis(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BrevisCaller{contract: contract}, nil
}

// NewBrevisTransactor creates a new write-only instance of Brevis, bound to a specific deployed contract.
func NewBrevisTransactor(address common.Address, transactor bind.ContractTransactor) (*BrevisTransactor, error) {
	contract, err := bindBrevis(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BrevisTransactor{contract: contract}, nil
}

// NewBrevisFilterer creates a new log filterer instance of Brevis, bound to a specific deployed contract.
func NewBrevisFilterer(address common.Address, filterer bind.ContractFilterer) (*BrevisFilterer, error) {
	contract, err := bindBrevis(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BrevisFilterer{contract: contract}, nil
}

// bindBrevis binds a generic wrapper to an already deployed contract.
func bindBrevis(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BrevisMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Brevis *BrevisRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Brevis.Contract.BrevisCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Brevis *BrevisRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Brevis.Contract.BrevisTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Brevis *BrevisRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Brevis.Contract.BrevisTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Brevis *BrevisCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Brevis.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Brevis *BrevisTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Brevis.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Brevis *BrevisTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Brevis.Contract.contract.Transact(opts, method, params...)
}

// BrevisAccessMetaData contains all meta data concerning the BrevisAccess contract.
var BrevisAccessMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addPausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"addProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isActiveProver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numPausers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numProvers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pauserList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proverStates\",\"outputs\":[{\"internalType\":\"enumBrevisAccess.ProverState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"provers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removePausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"removeProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// BrevisAccessABI is the input ABI used to generate the binding from.
// Deprecated: Use BrevisAccessMetaData.ABI instead.
var BrevisAccessABI = BrevisAccessMetaData.ABI

// BrevisAccess is an auto generated Go binding around an Ethereum contract.
type BrevisAccess struct {
	BrevisAccessCaller     // Read-only binding to the contract
	BrevisAccessTransactor // Write-only binding to the contract
	BrevisAccessFilterer   // Log filterer for contract events
}

// BrevisAccessCaller is an auto generated read-only Go binding around an Ethereum contract.
type BrevisAccessCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisAccessTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BrevisAccessTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisAccessFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BrevisAccessFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisAccessSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BrevisAccessSession struct {
	Contract     *BrevisAccess     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BrevisAccessCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BrevisAccessCallerSession struct {
	Contract *BrevisAccessCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// BrevisAccessTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BrevisAccessTransactorSession struct {
	Contract     *BrevisAccessTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// BrevisAccessRaw is an auto generated low-level Go binding around an Ethereum contract.
type BrevisAccessRaw struct {
	Contract *BrevisAccess // Generic contract binding to access the raw methods on
}

// BrevisAccessCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BrevisAccessCallerRaw struct {
	Contract *BrevisAccessCaller // Generic read-only contract binding to access the raw methods on
}

// BrevisAccessTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BrevisAccessTransactorRaw struct {
	Contract *BrevisAccessTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBrevisAccess creates a new instance of BrevisAccess, bound to a specific deployed contract.
func NewBrevisAccess(address common.Address, backend bind.ContractBackend) (*BrevisAccess, error) {
	contract, err := bindBrevisAccess(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BrevisAccess{BrevisAccessCaller: BrevisAccessCaller{contract: contract}, BrevisAccessTransactor: BrevisAccessTransactor{contract: contract}, BrevisAccessFilterer: BrevisAccessFilterer{contract: contract}}, nil
}

// NewBrevisAccessCaller creates a new read-only instance of BrevisAccess, bound to a specific deployed contract.
func NewBrevisAccessCaller(address common.Address, caller bind.ContractCaller) (*BrevisAccessCaller, error) {
	contract, err := bindBrevisAccess(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BrevisAccessCaller{contract: contract}, nil
}

// NewBrevisAccessTransactor creates a new write-only instance of BrevisAccess, bound to a specific deployed contract.
func NewBrevisAccessTransactor(address common.Address, transactor bind.ContractTransactor) (*BrevisAccessTransactor, error) {
	contract, err := bindBrevisAccess(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BrevisAccessTransactor{contract: contract}, nil
}

// NewBrevisAccessFilterer creates a new log filterer instance of BrevisAccess, bound to a specific deployed contract.
func NewBrevisAccessFilterer(address common.Address, filterer bind.ContractFilterer) (*BrevisAccessFilterer, error) {
	contract, err := bindBrevisAccess(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BrevisAccessFilterer{contract: contract}, nil
}

// bindBrevisAccess binds a generic wrapper to an already deployed contract.
func bindBrevisAccess(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BrevisAccessMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BrevisAccess *BrevisAccessRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BrevisAccess.Contract.BrevisAccessCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BrevisAccess *BrevisAccessRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisAccess.Contract.BrevisAccessTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BrevisAccess *BrevisAccessRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BrevisAccess.Contract.BrevisAccessTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BrevisAccess *BrevisAccessCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BrevisAccess.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BrevisAccess *BrevisAccessTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisAccess.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BrevisAccess *BrevisAccessTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BrevisAccess.Contract.contract.Transact(opts, method, params...)
}

// IsActiveProver is a free data retrieval call binding the contract method 0xec64842e.
//
// Solidity: function isActiveProver(address _account) view returns(bool)
func (_BrevisAccess *BrevisAccessCaller) IsActiveProver(opts *bind.CallOpts, _account common.Address) (bool, error) {
	var out []interface{}
	err := _BrevisAccess.contract.Call(opts, &out, "isActiveProver", _account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsActiveProver is a free data retrieval call binding the contract method 0xec64842e.
//
// Solidity: function isActiveProver(address _account) view returns(bool)
func (_BrevisAccess *BrevisAccessSession) IsActiveProver(_account common.Address) (bool, error) {
	return _BrevisAccess.Contract.IsActiveProver(&_BrevisAccess.CallOpts, _account)
}

// IsActiveProver is a free data retrieval call binding the contract method 0xec64842e.
//
// Solidity: function isActiveProver(address _account) view returns(bool)
func (_BrevisAccess *BrevisAccessCallerSession) IsActiveProver(_account common.Address) (bool, error) {
	return _BrevisAccess.Contract.IsActiveProver(&_BrevisAccess.CallOpts, _account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BrevisAccess *BrevisAccessCaller) IsPauser(opts *bind.CallOpts, account common.Address) (bool, error) {
	var out []interface{}
	err := _BrevisAccess.contract.Call(opts, &out, "isPauser", account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BrevisAccess *BrevisAccessSession) IsPauser(account common.Address) (bool, error) {
	return _BrevisAccess.Contract.IsPauser(&_BrevisAccess.CallOpts, account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BrevisAccess *BrevisAccessCallerSession) IsPauser(account common.Address) (bool, error) {
	return _BrevisAccess.Contract.IsPauser(&_BrevisAccess.CallOpts, account)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BrevisAccess *BrevisAccessCaller) NumPausers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BrevisAccess.contract.Call(opts, &out, "numPausers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BrevisAccess *BrevisAccessSession) NumPausers() (*big.Int, error) {
	return _BrevisAccess.Contract.NumPausers(&_BrevisAccess.CallOpts)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BrevisAccess *BrevisAccessCallerSession) NumPausers() (*big.Int, error) {
	return _BrevisAccess.Contract.NumPausers(&_BrevisAccess.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BrevisAccess *BrevisAccessCaller) NumProvers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BrevisAccess.contract.Call(opts, &out, "numProvers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BrevisAccess *BrevisAccessSession) NumProvers() (*big.Int, error) {
	return _BrevisAccess.Contract.NumProvers(&_BrevisAccess.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BrevisAccess *BrevisAccessCallerSession) NumProvers() (*big.Int, error) {
	return _BrevisAccess.Contract.NumProvers(&_BrevisAccess.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BrevisAccess *BrevisAccessCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BrevisAccess.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BrevisAccess *BrevisAccessSession) Owner() (common.Address, error) {
	return _BrevisAccess.Contract.Owner(&_BrevisAccess.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BrevisAccess *BrevisAccessCallerSession) Owner() (common.Address, error) {
	return _BrevisAccess.Contract.Owner(&_BrevisAccess.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BrevisAccess *BrevisAccessCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _BrevisAccess.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BrevisAccess *BrevisAccessSession) Paused() (bool, error) {
	return _BrevisAccess.Contract.Paused(&_BrevisAccess.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BrevisAccess *BrevisAccessCallerSession) Paused() (bool, error) {
	return _BrevisAccess.Contract.Paused(&_BrevisAccess.CallOpts)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BrevisAccess *BrevisAccessCaller) PauserList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _BrevisAccess.contract.Call(opts, &out, "pauserList", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BrevisAccess *BrevisAccessSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _BrevisAccess.Contract.PauserList(&_BrevisAccess.CallOpts, arg0)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BrevisAccess *BrevisAccessCallerSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _BrevisAccess.Contract.PauserList(&_BrevisAccess.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BrevisAccess *BrevisAccessCaller) Pausers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _BrevisAccess.contract.Call(opts, &out, "pausers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BrevisAccess *BrevisAccessSession) Pausers(arg0 common.Address) (bool, error) {
	return _BrevisAccess.Contract.Pausers(&_BrevisAccess.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BrevisAccess *BrevisAccessCallerSession) Pausers(arg0 common.Address) (bool, error) {
	return _BrevisAccess.Contract.Pausers(&_BrevisAccess.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BrevisAccess *BrevisAccessCaller) ProverStates(opts *bind.CallOpts, arg0 common.Address) (uint8, error) {
	var out []interface{}
	err := _BrevisAccess.contract.Call(opts, &out, "proverStates", arg0)

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BrevisAccess *BrevisAccessSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _BrevisAccess.Contract.ProverStates(&_BrevisAccess.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BrevisAccess *BrevisAccessCallerSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _BrevisAccess.Contract.ProverStates(&_BrevisAccess.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BrevisAccess *BrevisAccessCaller) Provers(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _BrevisAccess.contract.Call(opts, &out, "provers", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BrevisAccess *BrevisAccessSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _BrevisAccess.Contract.Provers(&_BrevisAccess.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BrevisAccess *BrevisAccessCallerSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _BrevisAccess.Contract.Provers(&_BrevisAccess.CallOpts, arg0)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BrevisAccess *BrevisAccessTransactor) AddPauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _BrevisAccess.contract.Transact(opts, "addPauser", account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BrevisAccess *BrevisAccessSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _BrevisAccess.Contract.AddPauser(&_BrevisAccess.TransactOpts, account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BrevisAccess *BrevisAccessTransactorSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _BrevisAccess.Contract.AddPauser(&_BrevisAccess.TransactOpts, account)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BrevisAccess *BrevisAccessTransactor) AddPausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAccess.contract.Transact(opts, "addPausers", accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BrevisAccess *BrevisAccessSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAccess.Contract.AddPausers(&_BrevisAccess.TransactOpts, accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BrevisAccess *BrevisAccessTransactorSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAccess.Contract.AddPausers(&_BrevisAccess.TransactOpts, accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BrevisAccess *BrevisAccessTransactor) AddProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAccess.contract.Transact(opts, "addProvers", _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BrevisAccess *BrevisAccessSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAccess.Contract.AddProvers(&_BrevisAccess.TransactOpts, _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BrevisAccess *BrevisAccessTransactorSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAccess.Contract.AddProvers(&_BrevisAccess.TransactOpts, _accounts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BrevisAccess *BrevisAccessTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisAccess.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BrevisAccess *BrevisAccessSession) Pause() (*types.Transaction, error) {
	return _BrevisAccess.Contract.Pause(&_BrevisAccess.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BrevisAccess *BrevisAccessTransactorSession) Pause() (*types.Transaction, error) {
	return _BrevisAccess.Contract.Pause(&_BrevisAccess.TransactOpts)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BrevisAccess *BrevisAccessTransactor) RemovePauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _BrevisAccess.contract.Transact(opts, "removePauser", account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BrevisAccess *BrevisAccessSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _BrevisAccess.Contract.RemovePauser(&_BrevisAccess.TransactOpts, account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BrevisAccess *BrevisAccessTransactorSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _BrevisAccess.Contract.RemovePauser(&_BrevisAccess.TransactOpts, account)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BrevisAccess *BrevisAccessTransactor) RemovePausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAccess.contract.Transact(opts, "removePausers", accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BrevisAccess *BrevisAccessSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAccess.Contract.RemovePausers(&_BrevisAccess.TransactOpts, accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BrevisAccess *BrevisAccessTransactorSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAccess.Contract.RemovePausers(&_BrevisAccess.TransactOpts, accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BrevisAccess *BrevisAccessTransactor) RemoveProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAccess.contract.Transact(opts, "removeProvers", _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BrevisAccess *BrevisAccessSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAccess.Contract.RemoveProvers(&_BrevisAccess.TransactOpts, _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BrevisAccess *BrevisAccessTransactorSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAccess.Contract.RemoveProvers(&_BrevisAccess.TransactOpts, _accounts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BrevisAccess *BrevisAccessTransactor) RenouncePauser(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisAccess.contract.Transact(opts, "renouncePauser")
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BrevisAccess *BrevisAccessSession) RenouncePauser() (*types.Transaction, error) {
	return _BrevisAccess.Contract.RenouncePauser(&_BrevisAccess.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BrevisAccess *BrevisAccessTransactorSession) RenouncePauser() (*types.Transaction, error) {
	return _BrevisAccess.Contract.RenouncePauser(&_BrevisAccess.TransactOpts)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BrevisAccess *BrevisAccessTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _BrevisAccess.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BrevisAccess *BrevisAccessSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BrevisAccess.Contract.TransferOwnership(&_BrevisAccess.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BrevisAccess *BrevisAccessTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BrevisAccess.Contract.TransferOwnership(&_BrevisAccess.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BrevisAccess *BrevisAccessTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisAccess.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BrevisAccess *BrevisAccessSession) Unpause() (*types.Transaction, error) {
	return _BrevisAccess.Contract.Unpause(&_BrevisAccess.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BrevisAccess *BrevisAccessTransactorSession) Unpause() (*types.Transaction, error) {
	return _BrevisAccess.Contract.Unpause(&_BrevisAccess.TransactOpts)
}

// BrevisAccessOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the BrevisAccess contract.
type BrevisAccessOwnershipTransferredIterator struct {
	Event *BrevisAccessOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAccessOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAccessOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAccessOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAccessOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAccessOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAccessOwnershipTransferred represents a OwnershipTransferred event raised by the BrevisAccess contract.
type BrevisAccessOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BrevisAccess *BrevisAccessFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*BrevisAccessOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BrevisAccess.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &BrevisAccessOwnershipTransferredIterator{contract: _BrevisAccess.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BrevisAccess *BrevisAccessFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *BrevisAccessOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BrevisAccess.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAccessOwnershipTransferred)
				if err := _BrevisAccess.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BrevisAccess *BrevisAccessFilterer) ParseOwnershipTransferred(log types.Log) (*BrevisAccessOwnershipTransferred, error) {
	event := new(BrevisAccessOwnershipTransferred)
	if err := _BrevisAccess.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAccessPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the BrevisAccess contract.
type BrevisAccessPausedIterator struct {
	Event *BrevisAccessPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAccessPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAccessPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAccessPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAccessPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAccessPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAccessPaused represents a Paused event raised by the BrevisAccess contract.
type BrevisAccessPaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BrevisAccess *BrevisAccessFilterer) FilterPaused(opts *bind.FilterOpts) (*BrevisAccessPausedIterator, error) {

	logs, sub, err := _BrevisAccess.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &BrevisAccessPausedIterator{contract: _BrevisAccess.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BrevisAccess *BrevisAccessFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *BrevisAccessPaused) (event.Subscription, error) {

	logs, sub, err := _BrevisAccess.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAccessPaused)
				if err := _BrevisAccess.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BrevisAccess *BrevisAccessFilterer) ParsePaused(log types.Log) (*BrevisAccessPaused, error) {
	event := new(BrevisAccessPaused)
	if err := _BrevisAccess.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAccessPauserAddedIterator is returned from FilterPauserAdded and is used to iterate over the raw logs and unpacked data for PauserAdded events raised by the BrevisAccess contract.
type BrevisAccessPauserAddedIterator struct {
	Event *BrevisAccessPauserAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAccessPauserAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAccessPauserAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAccessPauserAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAccessPauserAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAccessPauserAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAccessPauserAdded represents a PauserAdded event raised by the BrevisAccess contract.
type BrevisAccessPauserAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserAdded is a free log retrieval operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BrevisAccess *BrevisAccessFilterer) FilterPauserAdded(opts *bind.FilterOpts) (*BrevisAccessPauserAddedIterator, error) {

	logs, sub, err := _BrevisAccess.contract.FilterLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return &BrevisAccessPauserAddedIterator{contract: _BrevisAccess.contract, event: "PauserAdded", logs: logs, sub: sub}, nil
}

// WatchPauserAdded is a free log subscription operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BrevisAccess *BrevisAccessFilterer) WatchPauserAdded(opts *bind.WatchOpts, sink chan<- *BrevisAccessPauserAdded) (event.Subscription, error) {

	logs, sub, err := _BrevisAccess.contract.WatchLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAccessPauserAdded)
				if err := _BrevisAccess.contract.UnpackLog(event, "PauserAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserAdded is a log parse operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BrevisAccess *BrevisAccessFilterer) ParsePauserAdded(log types.Log) (*BrevisAccessPauserAdded, error) {
	event := new(BrevisAccessPauserAdded)
	if err := _BrevisAccess.contract.UnpackLog(event, "PauserAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAccessPauserRemovedIterator is returned from FilterPauserRemoved and is used to iterate over the raw logs and unpacked data for PauserRemoved events raised by the BrevisAccess contract.
type BrevisAccessPauserRemovedIterator struct {
	Event *BrevisAccessPauserRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAccessPauserRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAccessPauserRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAccessPauserRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAccessPauserRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAccessPauserRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAccessPauserRemoved represents a PauserRemoved event raised by the BrevisAccess contract.
type BrevisAccessPauserRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserRemoved is a free log retrieval operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BrevisAccess *BrevisAccessFilterer) FilterPauserRemoved(opts *bind.FilterOpts) (*BrevisAccessPauserRemovedIterator, error) {

	logs, sub, err := _BrevisAccess.contract.FilterLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return &BrevisAccessPauserRemovedIterator{contract: _BrevisAccess.contract, event: "PauserRemoved", logs: logs, sub: sub}, nil
}

// WatchPauserRemoved is a free log subscription operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BrevisAccess *BrevisAccessFilterer) WatchPauserRemoved(opts *bind.WatchOpts, sink chan<- *BrevisAccessPauserRemoved) (event.Subscription, error) {

	logs, sub, err := _BrevisAccess.contract.WatchLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAccessPauserRemoved)
				if err := _BrevisAccess.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserRemoved is a log parse operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BrevisAccess *BrevisAccessFilterer) ParsePauserRemoved(log types.Log) (*BrevisAccessPauserRemoved, error) {
	event := new(BrevisAccessPauserRemoved)
	if err := _BrevisAccess.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAccessProverAddedIterator is returned from FilterProverAdded and is used to iterate over the raw logs and unpacked data for ProverAdded events raised by the BrevisAccess contract.
type BrevisAccessProverAddedIterator struct {
	Event *BrevisAccessProverAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAccessProverAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAccessProverAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAccessProverAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAccessProverAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAccessProverAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAccessProverAdded represents a ProverAdded event raised by the BrevisAccess contract.
type BrevisAccessProverAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverAdded is a free log retrieval operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BrevisAccess *BrevisAccessFilterer) FilterProverAdded(opts *bind.FilterOpts) (*BrevisAccessProverAddedIterator, error) {

	logs, sub, err := _BrevisAccess.contract.FilterLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return &BrevisAccessProverAddedIterator{contract: _BrevisAccess.contract, event: "ProverAdded", logs: logs, sub: sub}, nil
}

// WatchProverAdded is a free log subscription operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BrevisAccess *BrevisAccessFilterer) WatchProverAdded(opts *bind.WatchOpts, sink chan<- *BrevisAccessProverAdded) (event.Subscription, error) {

	logs, sub, err := _BrevisAccess.contract.WatchLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAccessProverAdded)
				if err := _BrevisAccess.contract.UnpackLog(event, "ProverAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverAdded is a log parse operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BrevisAccess *BrevisAccessFilterer) ParseProverAdded(log types.Log) (*BrevisAccessProverAdded, error) {
	event := new(BrevisAccessProverAdded)
	if err := _BrevisAccess.contract.UnpackLog(event, "ProverAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAccessProverRemovedIterator is returned from FilterProverRemoved and is used to iterate over the raw logs and unpacked data for ProverRemoved events raised by the BrevisAccess contract.
type BrevisAccessProverRemovedIterator struct {
	Event *BrevisAccessProverRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAccessProverRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAccessProverRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAccessProverRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAccessProverRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAccessProverRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAccessProverRemoved represents a ProverRemoved event raised by the BrevisAccess contract.
type BrevisAccessProverRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverRemoved is a free log retrieval operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BrevisAccess *BrevisAccessFilterer) FilterProverRemoved(opts *bind.FilterOpts) (*BrevisAccessProverRemovedIterator, error) {

	logs, sub, err := _BrevisAccess.contract.FilterLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return &BrevisAccessProverRemovedIterator{contract: _BrevisAccess.contract, event: "ProverRemoved", logs: logs, sub: sub}, nil
}

// WatchProverRemoved is a free log subscription operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BrevisAccess *BrevisAccessFilterer) WatchProverRemoved(opts *bind.WatchOpts, sink chan<- *BrevisAccessProverRemoved) (event.Subscription, error) {

	logs, sub, err := _BrevisAccess.contract.WatchLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAccessProverRemoved)
				if err := _BrevisAccess.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverRemoved is a log parse operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BrevisAccess *BrevisAccessFilterer) ParseProverRemoved(log types.Log) (*BrevisAccessProverRemoved, error) {
	event := new(BrevisAccessProverRemoved)
	if err := _BrevisAccess.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAccessUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the BrevisAccess contract.
type BrevisAccessUnpausedIterator struct {
	Event *BrevisAccessUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAccessUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAccessUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAccessUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAccessUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAccessUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAccessUnpaused represents a Unpaused event raised by the BrevisAccess contract.
type BrevisAccessUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BrevisAccess *BrevisAccessFilterer) FilterUnpaused(opts *bind.FilterOpts) (*BrevisAccessUnpausedIterator, error) {

	logs, sub, err := _BrevisAccess.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &BrevisAccessUnpausedIterator{contract: _BrevisAccess.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BrevisAccess *BrevisAccessFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *BrevisAccessUnpaused) (event.Subscription, error) {

	logs, sub, err := _BrevisAccess.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAccessUnpaused)
				if err := _BrevisAccess.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BrevisAccess *BrevisAccessFilterer) ParseUnpaused(log types.Log) (*BrevisAccessUnpaused, error) {
	event := new(BrevisAccessUnpaused)
	if err := _BrevisAccess.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAggProofMetaData contains all meta data concerning the BrevisAggProof contract.
var BrevisAggProofMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"contractISMT\",\"name\":\"_smtContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64[]\",\"name\":\"chainIds\",\"type\":\"uint64[]\"},{\"indexed\":false,\"internalType\":\"contractIZkpVerifier[]\",\"name\":\"newAddresses\",\"type\":\"address[]\"}],\"name\":\"AggProofVerifierAddressesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"smtContract\",\"type\":\"address\"}],\"name\":\"SmtContractUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addPausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"addProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"aggProofVerifierAddress\",\"outputs\":[{\"internalType\":\"contractIZkpVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isActiveProver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"merkleRoots\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numPausers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numProvers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pauserList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proverStates\",\"outputs\":[{\"internalType\":\"enumBrevisAccess.ProverState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"provers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removePausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"removeProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"smtContract\",\"outputs\":[{\"internalType\":\"contractISMT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proofIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"_proofWithPubInputs\",\"type\":\"bytes\"}],\"name\":\"submitAggProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64[]\",\"name\":\"_chainIds\",\"type\":\"uint64[]\"},{\"internalType\":\"contractIZkpVerifier[]\",\"name\":\"_verifierAddresses\",\"type\":\"address[]\"}],\"name\":\"updateAggProofVerifierAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractISMT\",\"name\":\"_smtContract\",\"type\":\"address\"}],\"name\":\"updateSmtContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"commitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"vkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"smtRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBrevis.ProofData[]\",\"name\":\"_proofDataArray\",\"type\":\"tuple[]\"}],\"name\":\"validateAggProofData\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"commitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"vkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"smtRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBrevis.ProofData\",\"name\":\"_proofData\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint8\",\"name\":\"_nodeIndex\",\"type\":\"uint8\"}],\"name\":\"validateAggProofData\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x6080346101ac57601f62001fa438819003918201601f1916830192916001600160401b038411838510176101b057808392604095865283396020928391810103126101ac57516001600160a01b038082169290918390036101ac575f918254855191339082167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08680a36001600160a81b0319163360ff60a01b1981169190911784558352600182528483205460ff1661016c5750600254680100000000000000008110156101585760018101806002558110156101445790847f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f89260028552828520019360018060a01b03199433868254161790553381526001835220600160ff198254161790558451338152a1600554161760055551611ddf9081620001c58239f35b634e487b7160e01b83526032600452602483fd5b634e487b7160e01b83526041600452602483fd5b60649162461bcd60e51b82526004820152601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152fd5b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe60406080815260049081361015610014575f80fd5b5f91823560e01c80631396511e14611524578063158535ff146114f25780633221aec6146114ca5780633bda38a31461115a5780633f4ba83a1461105957806346fbf68e146109bc5780634f4fef181461103c57806358a16b441461101d5780635c975abb14610ff8578063677625f214610e675780636b2c0f5514610e305780636ef8d66d14610e165780637b1cc45014610be85780637dbafb11146109f857806380f51c12146109bc57806382dc1ec4146109825780638456cb59146108695780638da5cb5b14610843578063a036e799146107f3578063b4f7a72714610453578063ceae339014610412578063e6c6fcec146103c2578063e79b7a5114610369578063ec64842e1461030d578063f2fde38b14610223578063fabc74f5146101c5578063fd1190ea146101815763fe5a537714610152575f80fd5b3461017d57602036600319011261017d578160209360ff923581526006855220541690519015158152f35b8280fd5b5091346101c25760203660031901126101c257823592548310156101c257506001600160a01b036101b36020936115ec565b92905490519260031b1c168152f35b80fd5b5091903461021f57602036600319011261021f576001600160a01b036101e961163c565b168252600360205260ff8183205416905191600382101561020c57602083838152f35b634e487b7160e01b815260218452602490fd5b5080fd5b503461017d57602036600319011261017d5761023d61163c565b908354906001600160a01b0380831693610258338614611887565b169384156102a457505073ffffffffffffffffffffffffffffffffffffffff1916821783557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b906020608492519162461bcd60e51b8352820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152fd5b5082346101c25760203660031901126101c2576001600160a01b0361033061163c565b168152600360205260ff8382205416916003831015610356576020836001865191148152f35b634e487b7160e01b825260219052602490fd5b83346101c257610378366116a4565b906001600160a01b0391610390838354163314611887565b815b81518110156103be57806103b4856103ad6103b994866118d2565b5116611b08565b61177e565b610392565b8280f35b83346101c2576103d1366116a4565b906001600160a01b03916103e9838354163314611887565b815b81518110156103be57806103b48561040661040d94866118d2565b5116611932565b6103eb565b50503461021f57602036600319011261021f576001600160a01b038160209367ffffffffffffffff610442611621565b168152600785522054169051908152f35b50903461017d57606036600319011261017d5761046e611621565b9160249067ffffffffffffffff82358181116107ef576104919036908401611735565b906044948535948486116106dd57366023870112156106dd57858101358581116106e157368382890101116106e157338b526020976003895260ff8a8d2054169a60038c10156107dd576001809c0361079c5787168c52600789526001600160a01b038a8d205416801561075c57898986928f868f519586946322bb937360e11b8652868b87015282828701520187850137858784010152818581601f19601f8a011681010301915afa908115610752578d91610725575b50156106e55750806101a0116106e1576101c0116106dd5787519261020090818501858110888211176106cb578a52813686378b5b8681106106ac57505060109485811061065c575b50885194888601948c908c8b885b858510610647575050505050508452610220840194848610908611176106365750508286526101c48401359082519020036105f25750506101a401358452600690528220805460ff1916909117905580f35b907f70726f6f66496473206e6f7420726967687400000000000000000000000000006102646064938662461bcd60e51b855261022482015260126102448201520152fd5b634e487b7160e01b8a526041905288fd5b819084518152019201920191908b8e916105a0565b805b86811061066b5750610592565b5f19820182811161069a579061068461069592886117b0565b5161068f82896117b0565b5261177e565b61065e565b634e487b7160e01b8e5260118552858efd5b806106bb6106c69289856117a0565b3561068f82896117b0565b61057e565b634e487b7160e01b8d5260418452848dfd5b8980fd5b8a80fd5b7f70726f6f66206e6f742076616c696400000000000000000000000000000000009150600f6064948a8c519562461bcd60e51b8752860152840152820152fd5b61074591508a3d8c1161074b575b61073d8183611682565b810190611766565b5f610549565b503d610733565b8b513d8f823e3d90fd5b507f636861696e206167672070726f6f66207665726966696572206e6f7420736574915088606494818c519562461bcd60e51b8752860152840152820152fd5b507f6e6f7420696e76616c69642070726f7665720000000000000000000000000000915060126064948a8c519562461bcd60e51b8752860152840152820152fd5b634e487b7160e01b8d5260218452848dfd5b8680fd5b83346101c257610802366116a4565b906001600160a01b039161081a838354163314611887565b815b81518110156103be57806103b48561083761083e94866118d2565b5116611bed565b61081c565b50503461021f578160031936011261021f576001600160a01b0360209254169051908152f35b50903461017d578260031936011261017d5733835260019160209083825261089660ff84872054166118e6565b845460ff8160a01c166109405760ff60a01b197401000000000000000000000000000000000000000091161785557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258828451338152a184845b6108f7578580f35b815481101561093c57806001600160a01b03610915610936936115ec565b919054600392831b1c1688528452848720600260ff1982541617905561177e565b846108ef565b8580f35b50915162461bcd60e51b815291820152601060248201527f5061757361626c653a20706175736564000000000000000000000000000000006044820152606490fd5b83346101c25760203660031901126101c2576109b961099f61163c565b6109b46001600160a01b038454163314611887565b611b08565b80f35b50503461021f57602036600319011261021f5760ff816020936001600160a01b036109e561163c565b1681526001855220541690519015158152f35b5091903461021f578060031936011261021f5767ffffffffffffffff928035848111610be457610a2b9036908301611735565b91602435868111610be057610a439036908301611735565b9390966001600160a01b0392610a5d848954163314611887565b858303610b9d57509086949392945b818110610b295750808651968088019088525260608601929187905b828210610b005750505050602081858293038287015283815201959285905b838210610ad857867f4a5f8b4623084de3ef4b23e6c713416b50a966a1914aaf21175d206015e59d4e878a0388a180f35b90919293968735828116809103610afc578152830196830193929160010190610aa7565b8780fd5b90919294959385358281168091036106dd57815293959460209485019401929160010190610a88565b610b3b81868b989697989594956117a0565b35848116809103610b9957610b518285886117a0565b358381168091036106dd5789526007602052878920805473ffffffffffffffffffffffffffffffffffffffff19169091179055610b8d9061177e565b94939294919091610a6c565b8880fd5b606490602088519162461bcd60e51b8352820152601060248201527f6c656e677468206e6f74206d61746368000000000000000000000000000000006044820152fd5b8580fd5b8380fd5b5091903461021f5761012036600319011261021f57610c05611621565b9160a03660231901126101c25760c4359360e43567ffffffffffffffff811161017d57610c359036908301611735565b9095610104359660ff95868916809903610be05782865260209160068352610c6188838920541661183b565b600554825163080cdb0b60e11b815267ffffffffffffffff909a168a880190815260a435602082018190529a91859183916001600160a01b0316908290819060400103915afa908115610e0c5790610cc0918991610def575b506117d1565b815160248035858301908152602081019b909b5260443560408c015260643560608c015260843560808c01529990610d058160a084015b03601f198101835282611682565b5190209387945b89861688811015610da0578a91908d811c600116610d7157610d2f9089866117a0565b3585519087820192835286820152858152610d4981611652565b519020955b16898114610d5f5760010194610d0c565b634e487b7160e01b8952601188528a89fd5b610d7c9089866117a0565b359085519087820192835286820152858152610d9781611652565b51902095610d4e565b89898d8888868803610db0578480f35b5162461bcd60e51b815292830152600c908201527f696e76616c6964206461746100000000000000000000000000000000000000006044820152606490fd5b610e069150853d871161074b5761073d8183611682565b5f610cba565b83513d8a823e3d90fd5b83346101c257806003193601126101c2576109b933611bed565b83346101c25760203660031901126101c2576109b9610e4d61163c565b610e626001600160a01b038454163314611887565b611bed565b5091346101c257610e77366116a4565b918154906001600160a01b0391610e913384831614611887565b60ff9060a01c811615610ff0576002925b845b865181101561093c5781610eb882896118d2565b511680875260039060209180835285878a20541681811015610fdd57610f9a578a5468010000000000000000811015610f875782610eff828e6001610f1f950190556115ec565b90919082549060031b916001600160a01b03809116831b921b1916179055565b81895280835286892090881015610f7457917fef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd03968491610f6f949360ff19815416888b161790558751908152a161177e565b610ea4565b634e487b7160e01b895260218b52602489fd5b634e487b7160e01b8a5260418c5260248afd5b865162461bcd60e51b8152808c01849052601160248201527f6163636f756e742069732070726f7665720000000000000000000000000000006044820152606490fd5b634e487b7160e01b8a5260218c5260248afd5b600192610ea2565b50503461021f578160031936011261021f5760ff6020925460a01c1690519015158152f35b50503461021f578160031936011261021f576020906002549051908152f35b503461017d578260031936011261017d5760209250549051908152f35b5091903461021f578160031936011261021f57338252600190602082815261108660ff83862054166118e6565b83549460ff8660a01c16156111195760ff60a01b198495961686557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa828451338152a185935b6110d4578580f35b805484101561093c57611113846001600160a01b036110f388976115ec565b919054600392831b1c16895284528488208660ff1982541617905561177e565b936110cc565b915162461bcd60e51b815291820152601460248201527f5061757361626c653a206e6f74207061757365640000000000000000000000006044820152606490fd5b503461017d578160031936011261017d57611173611621565b90602480359167ffffffffffffffff938484116107ef57366023850112156107ef578382013590858211610afc578385019484369160a08502010111610afc57601094858311611488578751966103e090818901908111898210176114765789939293523688376005546001600160a01b03169089805b85811061135f575050505050838110611312575b5085835b61122357866109b960ff886103c0890151845260066020528320541661183b565b919486949193965b5f198801888111611300578110156112e35761125061124a828661182e565b8461181d565b5161125b828661182e565b906001918281018091116112d1576112b29161127a6112ac928861181d565b51865190602082019283528782015286815261129581611652565b51902092846112a48d8a61182e565b911c9061182e565b8561181d565b52600281018091111561122b57634e487b7160e01b8652601185528686fd5b634e487b7160e01b8952601188528989fd5b509491866112f591979492959761182e565b9260011c9283611202565b634e487b7160e01b8752601186528787fd5b5f19810190808211905b85811061132a5750506111fe565b8161134d576113489061133d848961181d565b5161068f828a61181d565b61131c565b634e487b7160e01b8952601184528489fd5b60808b6113a8858a84611373878d8d6117c1565b013584518094819263080cdb0b60e11b8352602095869584016020909392919367ffffffffffffffff60408201951681520152565b03818b5afa95861561146b5761144d96611440936113cb929161145457506117d1565b610cf76113d9868c8c6117c1565b35946113e6878d8d6117c1565b0135938a8c60606114148a876113fd8286886117c1565b0135938661140c8383896117c1565b0135956117c1565b0135925196879586019889939160a0959391855260208501526040840152606083015260808201520190565b51902061068f828c61181d565b8a906111ea565b610e069150833d851161074b5761073d8183611682565b8351903d90823e3d90fd5b634e487b7160e01b8b5260418652868bfd5b875162461bcd60e51b8152602081860152600c818701527f73697a65206578636565647300000000000000000000000000000000000000006044820152606490fd5b50503461021f578160031936011261021f576020906001600160a01b03600554169051908152f35b503461017d57602036600319011261017d5735916002548310156101c257506001600160a01b036101b36020936115a3565b503461017d57602036600319011261017d57356001600160a01b0390818116809103610be4577f674c535cde998bcb47d0688f644df545597c7d6edb95643cb21c82c2d490ff7f9261157c6020938654163314611887565b8173ffffffffffffffffffffffffffffffffffffffff19600554161760055551908152a180f35b6002548110156115d85760025f527f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace01905f90565b634e487b7160e01b5f52603260045260245ffd5b6004548110156115d85760045f527f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b01905f90565b6004359067ffffffffffffffff8216820361163857565b5f80fd5b600435906001600160a01b038216820361163857565b6060810190811067ffffffffffffffff82111761166e57604052565b634e487b7160e01b5f52604160045260245ffd5b90601f8019910116810190811067ffffffffffffffff82111761166e57604052565b6020806003198301126116385767ffffffffffffffff91600435838111611638578160238201121561163857806004013593841161166e578360051b90604051946116f185840187611682565b855260248486019282010192831161163857602401905b828210611716575050505090565b81356001600160a01b0381168103611638578152908301908301611708565b9181601f840112156116385782359167ffffffffffffffff8311611638576020808501948460051b01011161163857565b90816020910312611638575180151581036116385790565b5f19811461178c5760010190565b634e487b7160e01b5f52601160045260245ffd5b91908110156115d85760051b0190565b9060108110156115d85760051b0190565b91908110156115d85760a0020190565b156117d857565b60405162461bcd60e51b815260206004820152601060248201527f696e76616c696420736d7420726f6f74000000000000000000000000000000006044820152606490fd5b90601f8110156115d85760051b0190565b9190820180921161178c57565b1561184257565b60405162461bcd60e51b815260206004820152601660248201527f6d65726b6c6520726f6f74206e6f7420657869737473000000000000000000006044820152606490fd5b1561188e57565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b80518210156115d85760209160051b010190565b156118ed57565b60405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f74207061757365720000000000000000000000006044820152606490fd5b6001600160a01b03809116915f83815260039360209185835260409060ff828220541687811015611af45715611ab0576004968754965f1990818901988911611a9d57835b8a54811015611a5a57868261198b836115ec565b905490871b1c16146119a5576119a09061177e565b611977565b909192939495969798808210611a35575b50505087548015611a225797849392917fd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d98598990190611a0c6119f7836115ec565b6001600160a01b0382549160031b1b19169055565b55848252855220805460ff1916905551908152a1565b634e487b7160e01b845260318952602484fd5b611a5292611a45610eff926115ec565b905490871b1c16916115ec565b5f80806119b6565b855162461bcd60e51b8152808c01899052601060248201527f70726f766572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b634e487b7160e01b845260118a52602484fd5b815162461bcd60e51b815260048101859052601560248201527f6163636f756e74206973206e6f742070726f76657200000000000000000000006044820152606490fd5b634e487b7160e01b82526021600452602482fd5b6001600160a01b038116905f90828252600160205260ff604083205416611ba85760025468010000000000000000811015611b9457602092611b787f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f89593610eff846001604096016002556115a3565b8281526001845220600160ff19825416179055604051908152a1565b634e487b7160e01b83526041600452602483fd5b60405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152606490fd5b6001600160a01b03809116905f9282845260019060209382855260409360ff858820541615611d65576002805490915f1991828101908111611d5157908695949392918a975b611c7c575b885162461bcd60e51b8152600481018b9052601060248201527f706175736572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b8399989799548a1015611d48578185611c948c6115a3565b929054600393841b1c1614611cbd5750611cb48798999a9795969761177e565b97969594611c33565b9293949796959991818310611d23575b5050505081548015611d0f57918493917fcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e9899930190611a0c6119f7836115a3565b634e487b7160e01b89526031600452602489fd5b611d3f93611d33610eff936115a3565b9054911b1c16916115a3565b5f808080611ccd565b87989950611c38565b634e487b7160e01b8a52601160045260248afd5b845162461bcd60e51b815260048101879052601560248201527f4163636f756e74206973206e6f742070617573657200000000000000000000006044820152606490fdfea26469706673582212206a180fd0f1893b73b292e2653497b5f778edfa24f5fd35c74e6e5260ef2be40864736f6c63430008140033",
}

// BrevisAggProofABI is the input ABI used to generate the binding from.
// Deprecated: Use BrevisAggProofMetaData.ABI instead.
var BrevisAggProofABI = BrevisAggProofMetaData.ABI

// BrevisAggProofBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use BrevisAggProofMetaData.Bin instead.
var BrevisAggProofBin = BrevisAggProofMetaData.Bin

// DeployBrevisAggProof deploys a new Ethereum contract, binding an instance of BrevisAggProof to it.
func DeployBrevisAggProof(auth *bind.TransactOpts, backend bind.ContractBackend, _smtContract common.Address) (common.Address, *types.Transaction, *BrevisAggProof, error) {
	parsed, err := BrevisAggProofMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(BrevisAggProofBin), backend, _smtContract)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &BrevisAggProof{BrevisAggProofCaller: BrevisAggProofCaller{contract: contract}, BrevisAggProofTransactor: BrevisAggProofTransactor{contract: contract}, BrevisAggProofFilterer: BrevisAggProofFilterer{contract: contract}}, nil
}

// BrevisAggProof is an auto generated Go binding around an Ethereum contract.
type BrevisAggProof struct {
	BrevisAggProofCaller     // Read-only binding to the contract
	BrevisAggProofTransactor // Write-only binding to the contract
	BrevisAggProofFilterer   // Log filterer for contract events
}

// BrevisAggProofCaller is an auto generated read-only Go binding around an Ethereum contract.
type BrevisAggProofCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisAggProofTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BrevisAggProofTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisAggProofFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BrevisAggProofFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisAggProofSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BrevisAggProofSession struct {
	Contract     *BrevisAggProof   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BrevisAggProofCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BrevisAggProofCallerSession struct {
	Contract *BrevisAggProofCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// BrevisAggProofTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BrevisAggProofTransactorSession struct {
	Contract     *BrevisAggProofTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// BrevisAggProofRaw is an auto generated low-level Go binding around an Ethereum contract.
type BrevisAggProofRaw struct {
	Contract *BrevisAggProof // Generic contract binding to access the raw methods on
}

// BrevisAggProofCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BrevisAggProofCallerRaw struct {
	Contract *BrevisAggProofCaller // Generic read-only contract binding to access the raw methods on
}

// BrevisAggProofTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BrevisAggProofTransactorRaw struct {
	Contract *BrevisAggProofTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBrevisAggProof creates a new instance of BrevisAggProof, bound to a specific deployed contract.
func NewBrevisAggProof(address common.Address, backend bind.ContractBackend) (*BrevisAggProof, error) {
	contract, err := bindBrevisAggProof(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BrevisAggProof{BrevisAggProofCaller: BrevisAggProofCaller{contract: contract}, BrevisAggProofTransactor: BrevisAggProofTransactor{contract: contract}, BrevisAggProofFilterer: BrevisAggProofFilterer{contract: contract}}, nil
}

// NewBrevisAggProofCaller creates a new read-only instance of BrevisAggProof, bound to a specific deployed contract.
func NewBrevisAggProofCaller(address common.Address, caller bind.ContractCaller) (*BrevisAggProofCaller, error) {
	contract, err := bindBrevisAggProof(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BrevisAggProofCaller{contract: contract}, nil
}

// NewBrevisAggProofTransactor creates a new write-only instance of BrevisAggProof, bound to a specific deployed contract.
func NewBrevisAggProofTransactor(address common.Address, transactor bind.ContractTransactor) (*BrevisAggProofTransactor, error) {
	contract, err := bindBrevisAggProof(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BrevisAggProofTransactor{contract: contract}, nil
}

// NewBrevisAggProofFilterer creates a new log filterer instance of BrevisAggProof, bound to a specific deployed contract.
func NewBrevisAggProofFilterer(address common.Address, filterer bind.ContractFilterer) (*BrevisAggProofFilterer, error) {
	contract, err := bindBrevisAggProof(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BrevisAggProofFilterer{contract: contract}, nil
}

// bindBrevisAggProof binds a generic wrapper to an already deployed contract.
func bindBrevisAggProof(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BrevisAggProofMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BrevisAggProof *BrevisAggProofRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BrevisAggProof.Contract.BrevisAggProofCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BrevisAggProof *BrevisAggProofRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.BrevisAggProofTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BrevisAggProof *BrevisAggProofRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.BrevisAggProofTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BrevisAggProof *BrevisAggProofCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BrevisAggProof.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BrevisAggProof *BrevisAggProofTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BrevisAggProof *BrevisAggProofTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.contract.Transact(opts, method, params...)
}

// AggProofVerifierAddress is a free data retrieval call binding the contract method 0xceae3390.
//
// Solidity: function aggProofVerifierAddress(uint64 ) view returns(address)
func (_BrevisAggProof *BrevisAggProofCaller) AggProofVerifierAddress(opts *bind.CallOpts, arg0 uint64) (common.Address, error) {
	var out []interface{}
	err := _BrevisAggProof.contract.Call(opts, &out, "aggProofVerifierAddress", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// AggProofVerifierAddress is a free data retrieval call binding the contract method 0xceae3390.
//
// Solidity: function aggProofVerifierAddress(uint64 ) view returns(address)
func (_BrevisAggProof *BrevisAggProofSession) AggProofVerifierAddress(arg0 uint64) (common.Address, error) {
	return _BrevisAggProof.Contract.AggProofVerifierAddress(&_BrevisAggProof.CallOpts, arg0)
}

// AggProofVerifierAddress is a free data retrieval call binding the contract method 0xceae3390.
//
// Solidity: function aggProofVerifierAddress(uint64 ) view returns(address)
func (_BrevisAggProof *BrevisAggProofCallerSession) AggProofVerifierAddress(arg0 uint64) (common.Address, error) {
	return _BrevisAggProof.Contract.AggProofVerifierAddress(&_BrevisAggProof.CallOpts, arg0)
}

// IsActiveProver is a free data retrieval call binding the contract method 0xec64842e.
//
// Solidity: function isActiveProver(address _account) view returns(bool)
func (_BrevisAggProof *BrevisAggProofCaller) IsActiveProver(opts *bind.CallOpts, _account common.Address) (bool, error) {
	var out []interface{}
	err := _BrevisAggProof.contract.Call(opts, &out, "isActiveProver", _account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsActiveProver is a free data retrieval call binding the contract method 0xec64842e.
//
// Solidity: function isActiveProver(address _account) view returns(bool)
func (_BrevisAggProof *BrevisAggProofSession) IsActiveProver(_account common.Address) (bool, error) {
	return _BrevisAggProof.Contract.IsActiveProver(&_BrevisAggProof.CallOpts, _account)
}

// IsActiveProver is a free data retrieval call binding the contract method 0xec64842e.
//
// Solidity: function isActiveProver(address _account) view returns(bool)
func (_BrevisAggProof *BrevisAggProofCallerSession) IsActiveProver(_account common.Address) (bool, error) {
	return _BrevisAggProof.Contract.IsActiveProver(&_BrevisAggProof.CallOpts, _account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BrevisAggProof *BrevisAggProofCaller) IsPauser(opts *bind.CallOpts, account common.Address) (bool, error) {
	var out []interface{}
	err := _BrevisAggProof.contract.Call(opts, &out, "isPauser", account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BrevisAggProof *BrevisAggProofSession) IsPauser(account common.Address) (bool, error) {
	return _BrevisAggProof.Contract.IsPauser(&_BrevisAggProof.CallOpts, account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BrevisAggProof *BrevisAggProofCallerSession) IsPauser(account common.Address) (bool, error) {
	return _BrevisAggProof.Contract.IsPauser(&_BrevisAggProof.CallOpts, account)
}

// MerkleRoots is a free data retrieval call binding the contract method 0xfe5a5377.
//
// Solidity: function merkleRoots(bytes32 ) view returns(bool)
func (_BrevisAggProof *BrevisAggProofCaller) MerkleRoots(opts *bind.CallOpts, arg0 [32]byte) (bool, error) {
	var out []interface{}
	err := _BrevisAggProof.contract.Call(opts, &out, "merkleRoots", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// MerkleRoots is a free data retrieval call binding the contract method 0xfe5a5377.
//
// Solidity: function merkleRoots(bytes32 ) view returns(bool)
func (_BrevisAggProof *BrevisAggProofSession) MerkleRoots(arg0 [32]byte) (bool, error) {
	return _BrevisAggProof.Contract.MerkleRoots(&_BrevisAggProof.CallOpts, arg0)
}

// MerkleRoots is a free data retrieval call binding the contract method 0xfe5a5377.
//
// Solidity: function merkleRoots(bytes32 ) view returns(bool)
func (_BrevisAggProof *BrevisAggProofCallerSession) MerkleRoots(arg0 [32]byte) (bool, error) {
	return _BrevisAggProof.Contract.MerkleRoots(&_BrevisAggProof.CallOpts, arg0)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BrevisAggProof *BrevisAggProofCaller) NumPausers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BrevisAggProof.contract.Call(opts, &out, "numPausers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BrevisAggProof *BrevisAggProofSession) NumPausers() (*big.Int, error) {
	return _BrevisAggProof.Contract.NumPausers(&_BrevisAggProof.CallOpts)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BrevisAggProof *BrevisAggProofCallerSession) NumPausers() (*big.Int, error) {
	return _BrevisAggProof.Contract.NumPausers(&_BrevisAggProof.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BrevisAggProof *BrevisAggProofCaller) NumProvers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BrevisAggProof.contract.Call(opts, &out, "numProvers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BrevisAggProof *BrevisAggProofSession) NumProvers() (*big.Int, error) {
	return _BrevisAggProof.Contract.NumProvers(&_BrevisAggProof.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BrevisAggProof *BrevisAggProofCallerSession) NumProvers() (*big.Int, error) {
	return _BrevisAggProof.Contract.NumProvers(&_BrevisAggProof.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BrevisAggProof *BrevisAggProofCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BrevisAggProof.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BrevisAggProof *BrevisAggProofSession) Owner() (common.Address, error) {
	return _BrevisAggProof.Contract.Owner(&_BrevisAggProof.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BrevisAggProof *BrevisAggProofCallerSession) Owner() (common.Address, error) {
	return _BrevisAggProof.Contract.Owner(&_BrevisAggProof.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BrevisAggProof *BrevisAggProofCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _BrevisAggProof.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BrevisAggProof *BrevisAggProofSession) Paused() (bool, error) {
	return _BrevisAggProof.Contract.Paused(&_BrevisAggProof.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BrevisAggProof *BrevisAggProofCallerSession) Paused() (bool, error) {
	return _BrevisAggProof.Contract.Paused(&_BrevisAggProof.CallOpts)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BrevisAggProof *BrevisAggProofCaller) PauserList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _BrevisAggProof.contract.Call(opts, &out, "pauserList", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BrevisAggProof *BrevisAggProofSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _BrevisAggProof.Contract.PauserList(&_BrevisAggProof.CallOpts, arg0)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BrevisAggProof *BrevisAggProofCallerSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _BrevisAggProof.Contract.PauserList(&_BrevisAggProof.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BrevisAggProof *BrevisAggProofCaller) Pausers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _BrevisAggProof.contract.Call(opts, &out, "pausers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BrevisAggProof *BrevisAggProofSession) Pausers(arg0 common.Address) (bool, error) {
	return _BrevisAggProof.Contract.Pausers(&_BrevisAggProof.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BrevisAggProof *BrevisAggProofCallerSession) Pausers(arg0 common.Address) (bool, error) {
	return _BrevisAggProof.Contract.Pausers(&_BrevisAggProof.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BrevisAggProof *BrevisAggProofCaller) ProverStates(opts *bind.CallOpts, arg0 common.Address) (uint8, error) {
	var out []interface{}
	err := _BrevisAggProof.contract.Call(opts, &out, "proverStates", arg0)

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BrevisAggProof *BrevisAggProofSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _BrevisAggProof.Contract.ProverStates(&_BrevisAggProof.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BrevisAggProof *BrevisAggProofCallerSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _BrevisAggProof.Contract.ProverStates(&_BrevisAggProof.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BrevisAggProof *BrevisAggProofCaller) Provers(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _BrevisAggProof.contract.Call(opts, &out, "provers", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BrevisAggProof *BrevisAggProofSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _BrevisAggProof.Contract.Provers(&_BrevisAggProof.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BrevisAggProof *BrevisAggProofCallerSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _BrevisAggProof.Contract.Provers(&_BrevisAggProof.CallOpts, arg0)
}

// SmtContract is a free data retrieval call binding the contract method 0x3221aec6.
//
// Solidity: function smtContract() view returns(address)
func (_BrevisAggProof *BrevisAggProofCaller) SmtContract(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BrevisAggProof.contract.Call(opts, &out, "smtContract")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SmtContract is a free data retrieval call binding the contract method 0x3221aec6.
//
// Solidity: function smtContract() view returns(address)
func (_BrevisAggProof *BrevisAggProofSession) SmtContract() (common.Address, error) {
	return _BrevisAggProof.Contract.SmtContract(&_BrevisAggProof.CallOpts)
}

// SmtContract is a free data retrieval call binding the contract method 0x3221aec6.
//
// Solidity: function smtContract() view returns(address)
func (_BrevisAggProof *BrevisAggProofCallerSession) SmtContract() (common.Address, error) {
	return _BrevisAggProof.Contract.SmtContract(&_BrevisAggProof.CallOpts)
}

// ValidateAggProofData is a free data retrieval call binding the contract method 0x3bda38a3.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray) view returns()
func (_BrevisAggProof *BrevisAggProofCaller) ValidateAggProofData(opts *bind.CallOpts, _chainId uint64, _proofDataArray []BrevisProofData) error {
	var out []interface{}
	err := _BrevisAggProof.contract.Call(opts, &out, "validateAggProofData", _chainId, _proofDataArray)

	if err != nil {
		return err
	}

	return err

}

// ValidateAggProofData is a free data retrieval call binding the contract method 0x3bda38a3.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray) view returns()
func (_BrevisAggProof *BrevisAggProofSession) ValidateAggProofData(_chainId uint64, _proofDataArray []BrevisProofData) error {
	return _BrevisAggProof.Contract.ValidateAggProofData(&_BrevisAggProof.CallOpts, _chainId, _proofDataArray)
}

// ValidateAggProofData is a free data retrieval call binding the contract method 0x3bda38a3.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray) view returns()
func (_BrevisAggProof *BrevisAggProofCallerSession) ValidateAggProofData(_chainId uint64, _proofDataArray []BrevisProofData) error {
	return _BrevisAggProof.Contract.ValidateAggProofData(&_BrevisAggProof.CallOpts, _chainId, _proofDataArray)
}

// ValidateAggProofData0 is a free data retrieval call binding the contract method 0x7b1cc450.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32) _proofData, bytes32 _merkleRoot, bytes32[] _merkleProof, uint8 _nodeIndex) view returns()
func (_BrevisAggProof *BrevisAggProofCaller) ValidateAggProofData0(opts *bind.CallOpts, _chainId uint64, _proofData BrevisProofData, _merkleRoot [32]byte, _merkleProof [][32]byte, _nodeIndex uint8) error {
	var out []interface{}
	err := _BrevisAggProof.contract.Call(opts, &out, "validateAggProofData0", _chainId, _proofData, _merkleRoot, _merkleProof, _nodeIndex)

	if err != nil {
		return err
	}

	return err

}

// ValidateAggProofData0 is a free data retrieval call binding the contract method 0x7b1cc450.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32) _proofData, bytes32 _merkleRoot, bytes32[] _merkleProof, uint8 _nodeIndex) view returns()
func (_BrevisAggProof *BrevisAggProofSession) ValidateAggProofData0(_chainId uint64, _proofData BrevisProofData, _merkleRoot [32]byte, _merkleProof [][32]byte, _nodeIndex uint8) error {
	return _BrevisAggProof.Contract.ValidateAggProofData0(&_BrevisAggProof.CallOpts, _chainId, _proofData, _merkleRoot, _merkleProof, _nodeIndex)
}

// ValidateAggProofData0 is a free data retrieval call binding the contract method 0x7b1cc450.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32) _proofData, bytes32 _merkleRoot, bytes32[] _merkleProof, uint8 _nodeIndex) view returns()
func (_BrevisAggProof *BrevisAggProofCallerSession) ValidateAggProofData0(_chainId uint64, _proofData BrevisProofData, _merkleRoot [32]byte, _merkleProof [][32]byte, _nodeIndex uint8) error {
	return _BrevisAggProof.Contract.ValidateAggProofData0(&_BrevisAggProof.CallOpts, _chainId, _proofData, _merkleRoot, _merkleProof, _nodeIndex)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BrevisAggProof *BrevisAggProofTransactor) AddPauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.contract.Transact(opts, "addPauser", account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BrevisAggProof *BrevisAggProofSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.AddPauser(&_BrevisAggProof.TransactOpts, account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BrevisAggProof *BrevisAggProofTransactorSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.AddPauser(&_BrevisAggProof.TransactOpts, account)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BrevisAggProof *BrevisAggProofTransactor) AddPausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.contract.Transact(opts, "addPausers", accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BrevisAggProof *BrevisAggProofSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.AddPausers(&_BrevisAggProof.TransactOpts, accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BrevisAggProof *BrevisAggProofTransactorSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.AddPausers(&_BrevisAggProof.TransactOpts, accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BrevisAggProof *BrevisAggProofTransactor) AddProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.contract.Transact(opts, "addProvers", _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BrevisAggProof *BrevisAggProofSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.AddProvers(&_BrevisAggProof.TransactOpts, _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BrevisAggProof *BrevisAggProofTransactorSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.AddProvers(&_BrevisAggProof.TransactOpts, _accounts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BrevisAggProof *BrevisAggProofTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisAggProof.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BrevisAggProof *BrevisAggProofSession) Pause() (*types.Transaction, error) {
	return _BrevisAggProof.Contract.Pause(&_BrevisAggProof.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BrevisAggProof *BrevisAggProofTransactorSession) Pause() (*types.Transaction, error) {
	return _BrevisAggProof.Contract.Pause(&_BrevisAggProof.TransactOpts)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BrevisAggProof *BrevisAggProofTransactor) RemovePauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.contract.Transact(opts, "removePauser", account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BrevisAggProof *BrevisAggProofSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.RemovePauser(&_BrevisAggProof.TransactOpts, account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BrevisAggProof *BrevisAggProofTransactorSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.RemovePauser(&_BrevisAggProof.TransactOpts, account)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BrevisAggProof *BrevisAggProofTransactor) RemovePausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.contract.Transact(opts, "removePausers", accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BrevisAggProof *BrevisAggProofSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.RemovePausers(&_BrevisAggProof.TransactOpts, accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BrevisAggProof *BrevisAggProofTransactorSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.RemovePausers(&_BrevisAggProof.TransactOpts, accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BrevisAggProof *BrevisAggProofTransactor) RemoveProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.contract.Transact(opts, "removeProvers", _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BrevisAggProof *BrevisAggProofSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.RemoveProvers(&_BrevisAggProof.TransactOpts, _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BrevisAggProof *BrevisAggProofTransactorSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.RemoveProvers(&_BrevisAggProof.TransactOpts, _accounts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BrevisAggProof *BrevisAggProofTransactor) RenouncePauser(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisAggProof.contract.Transact(opts, "renouncePauser")
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BrevisAggProof *BrevisAggProofSession) RenouncePauser() (*types.Transaction, error) {
	return _BrevisAggProof.Contract.RenouncePauser(&_BrevisAggProof.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BrevisAggProof *BrevisAggProofTransactorSession) RenouncePauser() (*types.Transaction, error) {
	return _BrevisAggProof.Contract.RenouncePauser(&_BrevisAggProof.TransactOpts)
}

// SubmitAggProof is a paid mutator transaction binding the contract method 0xb4f7a727.
//
// Solidity: function submitAggProof(uint64 _chainId, bytes32[] _proofIds, bytes _proofWithPubInputs) returns()
func (_BrevisAggProof *BrevisAggProofTransactor) SubmitAggProof(opts *bind.TransactOpts, _chainId uint64, _proofIds [][32]byte, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _BrevisAggProof.contract.Transact(opts, "submitAggProof", _chainId, _proofIds, _proofWithPubInputs)
}

// SubmitAggProof is a paid mutator transaction binding the contract method 0xb4f7a727.
//
// Solidity: function submitAggProof(uint64 _chainId, bytes32[] _proofIds, bytes _proofWithPubInputs) returns()
func (_BrevisAggProof *BrevisAggProofSession) SubmitAggProof(_chainId uint64, _proofIds [][32]byte, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.SubmitAggProof(&_BrevisAggProof.TransactOpts, _chainId, _proofIds, _proofWithPubInputs)
}

// SubmitAggProof is a paid mutator transaction binding the contract method 0xb4f7a727.
//
// Solidity: function submitAggProof(uint64 _chainId, bytes32[] _proofIds, bytes _proofWithPubInputs) returns()
func (_BrevisAggProof *BrevisAggProofTransactorSession) SubmitAggProof(_chainId uint64, _proofIds [][32]byte, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.SubmitAggProof(&_BrevisAggProof.TransactOpts, _chainId, _proofIds, _proofWithPubInputs)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BrevisAggProof *BrevisAggProofTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BrevisAggProof *BrevisAggProofSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.TransferOwnership(&_BrevisAggProof.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BrevisAggProof *BrevisAggProofTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.TransferOwnership(&_BrevisAggProof.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BrevisAggProof *BrevisAggProofTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisAggProof.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BrevisAggProof *BrevisAggProofSession) Unpause() (*types.Transaction, error) {
	return _BrevisAggProof.Contract.Unpause(&_BrevisAggProof.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BrevisAggProof *BrevisAggProofTransactorSession) Unpause() (*types.Transaction, error) {
	return _BrevisAggProof.Contract.Unpause(&_BrevisAggProof.TransactOpts)
}

// UpdateAggProofVerifierAddresses is a paid mutator transaction binding the contract method 0x7dbafb11.
//
// Solidity: function updateAggProofVerifierAddresses(uint64[] _chainIds, address[] _verifierAddresses) returns()
func (_BrevisAggProof *BrevisAggProofTransactor) UpdateAggProofVerifierAddresses(opts *bind.TransactOpts, _chainIds []uint64, _verifierAddresses []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.contract.Transact(opts, "updateAggProofVerifierAddresses", _chainIds, _verifierAddresses)
}

// UpdateAggProofVerifierAddresses is a paid mutator transaction binding the contract method 0x7dbafb11.
//
// Solidity: function updateAggProofVerifierAddresses(uint64[] _chainIds, address[] _verifierAddresses) returns()
func (_BrevisAggProof *BrevisAggProofSession) UpdateAggProofVerifierAddresses(_chainIds []uint64, _verifierAddresses []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.UpdateAggProofVerifierAddresses(&_BrevisAggProof.TransactOpts, _chainIds, _verifierAddresses)
}

// UpdateAggProofVerifierAddresses is a paid mutator transaction binding the contract method 0x7dbafb11.
//
// Solidity: function updateAggProofVerifierAddresses(uint64[] _chainIds, address[] _verifierAddresses) returns()
func (_BrevisAggProof *BrevisAggProofTransactorSession) UpdateAggProofVerifierAddresses(_chainIds []uint64, _verifierAddresses []common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.UpdateAggProofVerifierAddresses(&_BrevisAggProof.TransactOpts, _chainIds, _verifierAddresses)
}

// UpdateSmtContract is a paid mutator transaction binding the contract method 0x1396511e.
//
// Solidity: function updateSmtContract(address _smtContract) returns()
func (_BrevisAggProof *BrevisAggProofTransactor) UpdateSmtContract(opts *bind.TransactOpts, _smtContract common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.contract.Transact(opts, "updateSmtContract", _smtContract)
}

// UpdateSmtContract is a paid mutator transaction binding the contract method 0x1396511e.
//
// Solidity: function updateSmtContract(address _smtContract) returns()
func (_BrevisAggProof *BrevisAggProofSession) UpdateSmtContract(_smtContract common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.UpdateSmtContract(&_BrevisAggProof.TransactOpts, _smtContract)
}

// UpdateSmtContract is a paid mutator transaction binding the contract method 0x1396511e.
//
// Solidity: function updateSmtContract(address _smtContract) returns()
func (_BrevisAggProof *BrevisAggProofTransactorSession) UpdateSmtContract(_smtContract common.Address) (*types.Transaction, error) {
	return _BrevisAggProof.Contract.UpdateSmtContract(&_BrevisAggProof.TransactOpts, _smtContract)
}

// BrevisAggProofAggProofVerifierAddressesUpdatedIterator is returned from FilterAggProofVerifierAddressesUpdated and is used to iterate over the raw logs and unpacked data for AggProofVerifierAddressesUpdated events raised by the BrevisAggProof contract.
type BrevisAggProofAggProofVerifierAddressesUpdatedIterator struct {
	Event *BrevisAggProofAggProofVerifierAddressesUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAggProofAggProofVerifierAddressesUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAggProofAggProofVerifierAddressesUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAggProofAggProofVerifierAddressesUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAggProofAggProofVerifierAddressesUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAggProofAggProofVerifierAddressesUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAggProofAggProofVerifierAddressesUpdated represents a AggProofVerifierAddressesUpdated event raised by the BrevisAggProof contract.
type BrevisAggProofAggProofVerifierAddressesUpdated struct {
	ChainIds     []uint64
	NewAddresses []common.Address
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterAggProofVerifierAddressesUpdated is a free log retrieval operation binding the contract event 0x4a5f8b4623084de3ef4b23e6c713416b50a966a1914aaf21175d206015e59d4e.
//
// Solidity: event AggProofVerifierAddressesUpdated(uint64[] chainIds, address[] newAddresses)
func (_BrevisAggProof *BrevisAggProofFilterer) FilterAggProofVerifierAddressesUpdated(opts *bind.FilterOpts) (*BrevisAggProofAggProofVerifierAddressesUpdatedIterator, error) {

	logs, sub, err := _BrevisAggProof.contract.FilterLogs(opts, "AggProofVerifierAddressesUpdated")
	if err != nil {
		return nil, err
	}
	return &BrevisAggProofAggProofVerifierAddressesUpdatedIterator{contract: _BrevisAggProof.contract, event: "AggProofVerifierAddressesUpdated", logs: logs, sub: sub}, nil
}

// WatchAggProofVerifierAddressesUpdated is a free log subscription operation binding the contract event 0x4a5f8b4623084de3ef4b23e6c713416b50a966a1914aaf21175d206015e59d4e.
//
// Solidity: event AggProofVerifierAddressesUpdated(uint64[] chainIds, address[] newAddresses)
func (_BrevisAggProof *BrevisAggProofFilterer) WatchAggProofVerifierAddressesUpdated(opts *bind.WatchOpts, sink chan<- *BrevisAggProofAggProofVerifierAddressesUpdated) (event.Subscription, error) {

	logs, sub, err := _BrevisAggProof.contract.WatchLogs(opts, "AggProofVerifierAddressesUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAggProofAggProofVerifierAddressesUpdated)
				if err := _BrevisAggProof.contract.UnpackLog(event, "AggProofVerifierAddressesUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAggProofVerifierAddressesUpdated is a log parse operation binding the contract event 0x4a5f8b4623084de3ef4b23e6c713416b50a966a1914aaf21175d206015e59d4e.
//
// Solidity: event AggProofVerifierAddressesUpdated(uint64[] chainIds, address[] newAddresses)
func (_BrevisAggProof *BrevisAggProofFilterer) ParseAggProofVerifierAddressesUpdated(log types.Log) (*BrevisAggProofAggProofVerifierAddressesUpdated, error) {
	event := new(BrevisAggProofAggProofVerifierAddressesUpdated)
	if err := _BrevisAggProof.contract.UnpackLog(event, "AggProofVerifierAddressesUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAggProofOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the BrevisAggProof contract.
type BrevisAggProofOwnershipTransferredIterator struct {
	Event *BrevisAggProofOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAggProofOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAggProofOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAggProofOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAggProofOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAggProofOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAggProofOwnershipTransferred represents a OwnershipTransferred event raised by the BrevisAggProof contract.
type BrevisAggProofOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BrevisAggProof *BrevisAggProofFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*BrevisAggProofOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BrevisAggProof.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &BrevisAggProofOwnershipTransferredIterator{contract: _BrevisAggProof.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BrevisAggProof *BrevisAggProofFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *BrevisAggProofOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BrevisAggProof.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAggProofOwnershipTransferred)
				if err := _BrevisAggProof.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BrevisAggProof *BrevisAggProofFilterer) ParseOwnershipTransferred(log types.Log) (*BrevisAggProofOwnershipTransferred, error) {
	event := new(BrevisAggProofOwnershipTransferred)
	if err := _BrevisAggProof.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAggProofPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the BrevisAggProof contract.
type BrevisAggProofPausedIterator struct {
	Event *BrevisAggProofPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAggProofPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAggProofPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAggProofPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAggProofPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAggProofPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAggProofPaused represents a Paused event raised by the BrevisAggProof contract.
type BrevisAggProofPaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) FilterPaused(opts *bind.FilterOpts) (*BrevisAggProofPausedIterator, error) {

	logs, sub, err := _BrevisAggProof.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &BrevisAggProofPausedIterator{contract: _BrevisAggProof.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *BrevisAggProofPaused) (event.Subscription, error) {

	logs, sub, err := _BrevisAggProof.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAggProofPaused)
				if err := _BrevisAggProof.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) ParsePaused(log types.Log) (*BrevisAggProofPaused, error) {
	event := new(BrevisAggProofPaused)
	if err := _BrevisAggProof.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAggProofPauserAddedIterator is returned from FilterPauserAdded and is used to iterate over the raw logs and unpacked data for PauserAdded events raised by the BrevisAggProof contract.
type BrevisAggProofPauserAddedIterator struct {
	Event *BrevisAggProofPauserAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAggProofPauserAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAggProofPauserAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAggProofPauserAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAggProofPauserAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAggProofPauserAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAggProofPauserAdded represents a PauserAdded event raised by the BrevisAggProof contract.
type BrevisAggProofPauserAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserAdded is a free log retrieval operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) FilterPauserAdded(opts *bind.FilterOpts) (*BrevisAggProofPauserAddedIterator, error) {

	logs, sub, err := _BrevisAggProof.contract.FilterLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return &BrevisAggProofPauserAddedIterator{contract: _BrevisAggProof.contract, event: "PauserAdded", logs: logs, sub: sub}, nil
}

// WatchPauserAdded is a free log subscription operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) WatchPauserAdded(opts *bind.WatchOpts, sink chan<- *BrevisAggProofPauserAdded) (event.Subscription, error) {

	logs, sub, err := _BrevisAggProof.contract.WatchLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAggProofPauserAdded)
				if err := _BrevisAggProof.contract.UnpackLog(event, "PauserAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserAdded is a log parse operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) ParsePauserAdded(log types.Log) (*BrevisAggProofPauserAdded, error) {
	event := new(BrevisAggProofPauserAdded)
	if err := _BrevisAggProof.contract.UnpackLog(event, "PauserAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAggProofPauserRemovedIterator is returned from FilterPauserRemoved and is used to iterate over the raw logs and unpacked data for PauserRemoved events raised by the BrevisAggProof contract.
type BrevisAggProofPauserRemovedIterator struct {
	Event *BrevisAggProofPauserRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAggProofPauserRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAggProofPauserRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAggProofPauserRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAggProofPauserRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAggProofPauserRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAggProofPauserRemoved represents a PauserRemoved event raised by the BrevisAggProof contract.
type BrevisAggProofPauserRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserRemoved is a free log retrieval operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) FilterPauserRemoved(opts *bind.FilterOpts) (*BrevisAggProofPauserRemovedIterator, error) {

	logs, sub, err := _BrevisAggProof.contract.FilterLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return &BrevisAggProofPauserRemovedIterator{contract: _BrevisAggProof.contract, event: "PauserRemoved", logs: logs, sub: sub}, nil
}

// WatchPauserRemoved is a free log subscription operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) WatchPauserRemoved(opts *bind.WatchOpts, sink chan<- *BrevisAggProofPauserRemoved) (event.Subscription, error) {

	logs, sub, err := _BrevisAggProof.contract.WatchLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAggProofPauserRemoved)
				if err := _BrevisAggProof.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserRemoved is a log parse operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) ParsePauserRemoved(log types.Log) (*BrevisAggProofPauserRemoved, error) {
	event := new(BrevisAggProofPauserRemoved)
	if err := _BrevisAggProof.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAggProofProverAddedIterator is returned from FilterProverAdded and is used to iterate over the raw logs and unpacked data for ProverAdded events raised by the BrevisAggProof contract.
type BrevisAggProofProverAddedIterator struct {
	Event *BrevisAggProofProverAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAggProofProverAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAggProofProverAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAggProofProverAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAggProofProverAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAggProofProverAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAggProofProverAdded represents a ProverAdded event raised by the BrevisAggProof contract.
type BrevisAggProofProverAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverAdded is a free log retrieval operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) FilterProverAdded(opts *bind.FilterOpts) (*BrevisAggProofProverAddedIterator, error) {

	logs, sub, err := _BrevisAggProof.contract.FilterLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return &BrevisAggProofProverAddedIterator{contract: _BrevisAggProof.contract, event: "ProverAdded", logs: logs, sub: sub}, nil
}

// WatchProverAdded is a free log subscription operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) WatchProverAdded(opts *bind.WatchOpts, sink chan<- *BrevisAggProofProverAdded) (event.Subscription, error) {

	logs, sub, err := _BrevisAggProof.contract.WatchLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAggProofProverAdded)
				if err := _BrevisAggProof.contract.UnpackLog(event, "ProverAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverAdded is a log parse operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) ParseProverAdded(log types.Log) (*BrevisAggProofProverAdded, error) {
	event := new(BrevisAggProofProverAdded)
	if err := _BrevisAggProof.contract.UnpackLog(event, "ProverAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAggProofProverRemovedIterator is returned from FilterProverRemoved and is used to iterate over the raw logs and unpacked data for ProverRemoved events raised by the BrevisAggProof contract.
type BrevisAggProofProverRemovedIterator struct {
	Event *BrevisAggProofProverRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAggProofProverRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAggProofProverRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAggProofProverRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAggProofProverRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAggProofProverRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAggProofProverRemoved represents a ProverRemoved event raised by the BrevisAggProof contract.
type BrevisAggProofProverRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverRemoved is a free log retrieval operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) FilterProverRemoved(opts *bind.FilterOpts) (*BrevisAggProofProverRemovedIterator, error) {

	logs, sub, err := _BrevisAggProof.contract.FilterLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return &BrevisAggProofProverRemovedIterator{contract: _BrevisAggProof.contract, event: "ProverRemoved", logs: logs, sub: sub}, nil
}

// WatchProverRemoved is a free log subscription operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) WatchProverRemoved(opts *bind.WatchOpts, sink chan<- *BrevisAggProofProverRemoved) (event.Subscription, error) {

	logs, sub, err := _BrevisAggProof.contract.WatchLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAggProofProverRemoved)
				if err := _BrevisAggProof.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverRemoved is a log parse operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) ParseProverRemoved(log types.Log) (*BrevisAggProofProverRemoved, error) {
	event := new(BrevisAggProofProverRemoved)
	if err := _BrevisAggProof.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAggProofSmtContractUpdatedIterator is returned from FilterSmtContractUpdated and is used to iterate over the raw logs and unpacked data for SmtContractUpdated events raised by the BrevisAggProof contract.
type BrevisAggProofSmtContractUpdatedIterator struct {
	Event *BrevisAggProofSmtContractUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAggProofSmtContractUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAggProofSmtContractUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAggProofSmtContractUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAggProofSmtContractUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAggProofSmtContractUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAggProofSmtContractUpdated represents a SmtContractUpdated event raised by the BrevisAggProof contract.
type BrevisAggProofSmtContractUpdated struct {
	SmtContract common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterSmtContractUpdated is a free log retrieval operation binding the contract event 0x674c535cde998bcb47d0688f644df545597c7d6edb95643cb21c82c2d490ff7f.
//
// Solidity: event SmtContractUpdated(address smtContract)
func (_BrevisAggProof *BrevisAggProofFilterer) FilterSmtContractUpdated(opts *bind.FilterOpts) (*BrevisAggProofSmtContractUpdatedIterator, error) {

	logs, sub, err := _BrevisAggProof.contract.FilterLogs(opts, "SmtContractUpdated")
	if err != nil {
		return nil, err
	}
	return &BrevisAggProofSmtContractUpdatedIterator{contract: _BrevisAggProof.contract, event: "SmtContractUpdated", logs: logs, sub: sub}, nil
}

// WatchSmtContractUpdated is a free log subscription operation binding the contract event 0x674c535cde998bcb47d0688f644df545597c7d6edb95643cb21c82c2d490ff7f.
//
// Solidity: event SmtContractUpdated(address smtContract)
func (_BrevisAggProof *BrevisAggProofFilterer) WatchSmtContractUpdated(opts *bind.WatchOpts, sink chan<- *BrevisAggProofSmtContractUpdated) (event.Subscription, error) {

	logs, sub, err := _BrevisAggProof.contract.WatchLogs(opts, "SmtContractUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAggProofSmtContractUpdated)
				if err := _BrevisAggProof.contract.UnpackLog(event, "SmtContractUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSmtContractUpdated is a log parse operation binding the contract event 0x674c535cde998bcb47d0688f644df545597c7d6edb95643cb21c82c2d490ff7f.
//
// Solidity: event SmtContractUpdated(address smtContract)
func (_BrevisAggProof *BrevisAggProofFilterer) ParseSmtContractUpdated(log types.Log) (*BrevisAggProofSmtContractUpdated, error) {
	event := new(BrevisAggProofSmtContractUpdated)
	if err := _BrevisAggProof.contract.UnpackLog(event, "SmtContractUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAggProofUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the BrevisAggProof contract.
type BrevisAggProofUnpausedIterator struct {
	Event *BrevisAggProofUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisAggProofUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisAggProofUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisAggProofUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisAggProofUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisAggProofUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisAggProofUnpaused represents a Unpaused event raised by the BrevisAggProof contract.
type BrevisAggProofUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) FilterUnpaused(opts *bind.FilterOpts) (*BrevisAggProofUnpausedIterator, error) {

	logs, sub, err := _BrevisAggProof.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &BrevisAggProofUnpausedIterator{contract: _BrevisAggProof.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *BrevisAggProofUnpaused) (event.Subscription, error) {

	logs, sub, err := _BrevisAggProof.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisAggProofUnpaused)
				if err := _BrevisAggProof.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BrevisAggProof *BrevisAggProofFilterer) ParseUnpaused(log types.Log) (*BrevisAggProofUnpaused, error) {
	event := new(BrevisAggProofUnpaused)
	if err := _BrevisAggProof.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisAppMetaData contains all meta data concerning the BrevisApp contract.
var BrevisAppMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"_appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_appCircuitOutput\",\"type\":\"bytes\"}],\"name\":\"applyBrevisOpResult\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_proofIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint64[]\",\"name\":\"_nonces\",\"type\":\"uint64[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_appVkHashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_appCommitHashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_appCircuitOutputs\",\"type\":\"bytes[]\"}],\"name\":\"applyBrevisOpResults\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_appVkHashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_appCircuitOutputs\",\"type\":\"bytes[]\"}],\"name\":\"brevisBatchCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_appCircuitOutput\",\"type\":\"bytes\"}],\"name\":\"brevisCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"brevisOpConfig\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"challengeWindow\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"sigOption\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"brevisRequest\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// BrevisAppABI is the input ABI used to generate the binding from.
// Deprecated: Use BrevisAppMetaData.ABI instead.
var BrevisAppABI = BrevisAppMetaData.ABI

// BrevisApp is an auto generated Go binding around an Ethereum contract.
type BrevisApp struct {
	BrevisAppCaller     // Read-only binding to the contract
	BrevisAppTransactor // Write-only binding to the contract
	BrevisAppFilterer   // Log filterer for contract events
}

// BrevisAppCaller is an auto generated read-only Go binding around an Ethereum contract.
type BrevisAppCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisAppTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BrevisAppTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisAppFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BrevisAppFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisAppSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BrevisAppSession struct {
	Contract     *BrevisApp        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BrevisAppCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BrevisAppCallerSession struct {
	Contract *BrevisAppCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// BrevisAppTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BrevisAppTransactorSession struct {
	Contract     *BrevisAppTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// BrevisAppRaw is an auto generated low-level Go binding around an Ethereum contract.
type BrevisAppRaw struct {
	Contract *BrevisApp // Generic contract binding to access the raw methods on
}

// BrevisAppCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BrevisAppCallerRaw struct {
	Contract *BrevisAppCaller // Generic read-only contract binding to access the raw methods on
}

// BrevisAppTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BrevisAppTransactorRaw struct {
	Contract *BrevisAppTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBrevisApp creates a new instance of BrevisApp, bound to a specific deployed contract.
func NewBrevisApp(address common.Address, backend bind.ContractBackend) (*BrevisApp, error) {
	contract, err := bindBrevisApp(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BrevisApp{BrevisAppCaller: BrevisAppCaller{contract: contract}, BrevisAppTransactor: BrevisAppTransactor{contract: contract}, BrevisAppFilterer: BrevisAppFilterer{contract: contract}}, nil
}

// NewBrevisAppCaller creates a new read-only instance of BrevisApp, bound to a specific deployed contract.
func NewBrevisAppCaller(address common.Address, caller bind.ContractCaller) (*BrevisAppCaller, error) {
	contract, err := bindBrevisApp(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BrevisAppCaller{contract: contract}, nil
}

// NewBrevisAppTransactor creates a new write-only instance of BrevisApp, bound to a specific deployed contract.
func NewBrevisAppTransactor(address common.Address, transactor bind.ContractTransactor) (*BrevisAppTransactor, error) {
	contract, err := bindBrevisApp(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BrevisAppTransactor{contract: contract}, nil
}

// NewBrevisAppFilterer creates a new log filterer instance of BrevisApp, bound to a specific deployed contract.
func NewBrevisAppFilterer(address common.Address, filterer bind.ContractFilterer) (*BrevisAppFilterer, error) {
	contract, err := bindBrevisApp(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BrevisAppFilterer{contract: contract}, nil
}

// bindBrevisApp binds a generic wrapper to an already deployed contract.
func bindBrevisApp(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BrevisAppMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BrevisApp *BrevisAppRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BrevisApp.Contract.BrevisAppCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BrevisApp *BrevisAppRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisApp.Contract.BrevisAppTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BrevisApp *BrevisAppRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BrevisApp.Contract.BrevisAppTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BrevisApp *BrevisAppCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BrevisApp.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BrevisApp *BrevisAppTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisApp.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BrevisApp *BrevisAppTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BrevisApp.Contract.contract.Transact(opts, method, params...)
}

// BrevisOpConfig is a free data retrieval call binding the contract method 0xc1bde0e1.
//
// Solidity: function brevisOpConfig() view returns(uint64 challengeWindow, uint8 sigOption)
func (_BrevisApp *BrevisAppCaller) BrevisOpConfig(opts *bind.CallOpts) (struct {
	ChallengeWindow uint64
	SigOption       uint8
}, error) {
	var out []interface{}
	err := _BrevisApp.contract.Call(opts, &out, "brevisOpConfig")

	outstruct := new(struct {
		ChallengeWindow uint64
		SigOption       uint8
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.ChallengeWindow = *abi.ConvertType(out[0], new(uint64)).(*uint64)
	outstruct.SigOption = *abi.ConvertType(out[1], new(uint8)).(*uint8)

	return *outstruct, err

}

// BrevisOpConfig is a free data retrieval call binding the contract method 0xc1bde0e1.
//
// Solidity: function brevisOpConfig() view returns(uint64 challengeWindow, uint8 sigOption)
func (_BrevisApp *BrevisAppSession) BrevisOpConfig() (struct {
	ChallengeWindow uint64
	SigOption       uint8
}, error) {
	return _BrevisApp.Contract.BrevisOpConfig(&_BrevisApp.CallOpts)
}

// BrevisOpConfig is a free data retrieval call binding the contract method 0xc1bde0e1.
//
// Solidity: function brevisOpConfig() view returns(uint64 challengeWindow, uint8 sigOption)
func (_BrevisApp *BrevisAppCallerSession) BrevisOpConfig() (struct {
	ChallengeWindow uint64
	SigOption       uint8
}, error) {
	return _BrevisApp.Contract.BrevisOpConfig(&_BrevisApp.CallOpts)
}

// BrevisRequest is a free data retrieval call binding the contract method 0x38931a31.
//
// Solidity: function brevisRequest() view returns(address)
func (_BrevisApp *BrevisAppCaller) BrevisRequest(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BrevisApp.contract.Call(opts, &out, "brevisRequest")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// BrevisRequest is a free data retrieval call binding the contract method 0x38931a31.
//
// Solidity: function brevisRequest() view returns(address)
func (_BrevisApp *BrevisAppSession) BrevisRequest() (common.Address, error) {
	return _BrevisApp.Contract.BrevisRequest(&_BrevisApp.CallOpts)
}

// BrevisRequest is a free data retrieval call binding the contract method 0x38931a31.
//
// Solidity: function brevisRequest() view returns(address)
func (_BrevisApp *BrevisAppCallerSession) BrevisRequest() (common.Address, error) {
	return _BrevisApp.Contract.BrevisRequest(&_BrevisApp.CallOpts)
}

// ApplyBrevisOpResult is a paid mutator transaction binding the contract method 0x718f6ccd.
//
// Solidity: function applyBrevisOpResult(bytes32 _proofId, uint64 _nonce, bytes32 _appVkHash, bytes32 _appCommitHash, bytes _appCircuitOutput) returns()
func (_BrevisApp *BrevisAppTransactor) ApplyBrevisOpResult(opts *bind.TransactOpts, _proofId [32]byte, _nonce uint64, _appVkHash [32]byte, _appCommitHash [32]byte, _appCircuitOutput []byte) (*types.Transaction, error) {
	return _BrevisApp.contract.Transact(opts, "applyBrevisOpResult", _proofId, _nonce, _appVkHash, _appCommitHash, _appCircuitOutput)
}

// ApplyBrevisOpResult is a paid mutator transaction binding the contract method 0x718f6ccd.
//
// Solidity: function applyBrevisOpResult(bytes32 _proofId, uint64 _nonce, bytes32 _appVkHash, bytes32 _appCommitHash, bytes _appCircuitOutput) returns()
func (_BrevisApp *BrevisAppSession) ApplyBrevisOpResult(_proofId [32]byte, _nonce uint64, _appVkHash [32]byte, _appCommitHash [32]byte, _appCircuitOutput []byte) (*types.Transaction, error) {
	return _BrevisApp.Contract.ApplyBrevisOpResult(&_BrevisApp.TransactOpts, _proofId, _nonce, _appVkHash, _appCommitHash, _appCircuitOutput)
}

// ApplyBrevisOpResult is a paid mutator transaction binding the contract method 0x718f6ccd.
//
// Solidity: function applyBrevisOpResult(bytes32 _proofId, uint64 _nonce, bytes32 _appVkHash, bytes32 _appCommitHash, bytes _appCircuitOutput) returns()
func (_BrevisApp *BrevisAppTransactorSession) ApplyBrevisOpResult(_proofId [32]byte, _nonce uint64, _appVkHash [32]byte, _appCommitHash [32]byte, _appCircuitOutput []byte) (*types.Transaction, error) {
	return _BrevisApp.Contract.ApplyBrevisOpResult(&_BrevisApp.TransactOpts, _proofId, _nonce, _appVkHash, _appCommitHash, _appCircuitOutput)
}

// ApplyBrevisOpResults is a paid mutator transaction binding the contract method 0x34801657.
//
// Solidity: function applyBrevisOpResults(bytes32[] _proofIds, uint64[] _nonces, bytes32[] _appVkHashes, bytes32[] _appCommitHashes, bytes[] _appCircuitOutputs) returns()
func (_BrevisApp *BrevisAppTransactor) ApplyBrevisOpResults(opts *bind.TransactOpts, _proofIds [][32]byte, _nonces []uint64, _appVkHashes [][32]byte, _appCommitHashes [][32]byte, _appCircuitOutputs [][]byte) (*types.Transaction, error) {
	return _BrevisApp.contract.Transact(opts, "applyBrevisOpResults", _proofIds, _nonces, _appVkHashes, _appCommitHashes, _appCircuitOutputs)
}

// ApplyBrevisOpResults is a paid mutator transaction binding the contract method 0x34801657.
//
// Solidity: function applyBrevisOpResults(bytes32[] _proofIds, uint64[] _nonces, bytes32[] _appVkHashes, bytes32[] _appCommitHashes, bytes[] _appCircuitOutputs) returns()
func (_BrevisApp *BrevisAppSession) ApplyBrevisOpResults(_proofIds [][32]byte, _nonces []uint64, _appVkHashes [][32]byte, _appCommitHashes [][32]byte, _appCircuitOutputs [][]byte) (*types.Transaction, error) {
	return _BrevisApp.Contract.ApplyBrevisOpResults(&_BrevisApp.TransactOpts, _proofIds, _nonces, _appVkHashes, _appCommitHashes, _appCircuitOutputs)
}

// ApplyBrevisOpResults is a paid mutator transaction binding the contract method 0x34801657.
//
// Solidity: function applyBrevisOpResults(bytes32[] _proofIds, uint64[] _nonces, bytes32[] _appVkHashes, bytes32[] _appCommitHashes, bytes[] _appCircuitOutputs) returns()
func (_BrevisApp *BrevisAppTransactorSession) ApplyBrevisOpResults(_proofIds [][32]byte, _nonces []uint64, _appVkHashes [][32]byte, _appCommitHashes [][32]byte, _appCircuitOutputs [][]byte) (*types.Transaction, error) {
	return _BrevisApp.Contract.ApplyBrevisOpResults(&_BrevisApp.TransactOpts, _proofIds, _nonces, _appVkHashes, _appCommitHashes, _appCircuitOutputs)
}

// BrevisBatchCallback is a paid mutator transaction binding the contract method 0x3bca02fc.
//
// Solidity: function brevisBatchCallback(bytes32[] _appVkHashes, bytes[] _appCircuitOutputs) returns()
func (_BrevisApp *BrevisAppTransactor) BrevisBatchCallback(opts *bind.TransactOpts, _appVkHashes [][32]byte, _appCircuitOutputs [][]byte) (*types.Transaction, error) {
	return _BrevisApp.contract.Transact(opts, "brevisBatchCallback", _appVkHashes, _appCircuitOutputs)
}

// BrevisBatchCallback is a paid mutator transaction binding the contract method 0x3bca02fc.
//
// Solidity: function brevisBatchCallback(bytes32[] _appVkHashes, bytes[] _appCircuitOutputs) returns()
func (_BrevisApp *BrevisAppSession) BrevisBatchCallback(_appVkHashes [][32]byte, _appCircuitOutputs [][]byte) (*types.Transaction, error) {
	return _BrevisApp.Contract.BrevisBatchCallback(&_BrevisApp.TransactOpts, _appVkHashes, _appCircuitOutputs)
}

// BrevisBatchCallback is a paid mutator transaction binding the contract method 0x3bca02fc.
//
// Solidity: function brevisBatchCallback(bytes32[] _appVkHashes, bytes[] _appCircuitOutputs) returns()
func (_BrevisApp *BrevisAppTransactorSession) BrevisBatchCallback(_appVkHashes [][32]byte, _appCircuitOutputs [][]byte) (*types.Transaction, error) {
	return _BrevisApp.Contract.BrevisBatchCallback(&_BrevisApp.TransactOpts, _appVkHashes, _appCircuitOutputs)
}

// BrevisCallback is a paid mutator transaction binding the contract method 0x79d6b6a2.
//
// Solidity: function brevisCallback(bytes32 _appVkHash, bytes _appCircuitOutput) returns()
func (_BrevisApp *BrevisAppTransactor) BrevisCallback(opts *bind.TransactOpts, _appVkHash [32]byte, _appCircuitOutput []byte) (*types.Transaction, error) {
	return _BrevisApp.contract.Transact(opts, "brevisCallback", _appVkHash, _appCircuitOutput)
}

// BrevisCallback is a paid mutator transaction binding the contract method 0x79d6b6a2.
//
// Solidity: function brevisCallback(bytes32 _appVkHash, bytes _appCircuitOutput) returns()
func (_BrevisApp *BrevisAppSession) BrevisCallback(_appVkHash [32]byte, _appCircuitOutput []byte) (*types.Transaction, error) {
	return _BrevisApp.Contract.BrevisCallback(&_BrevisApp.TransactOpts, _appVkHash, _appCircuitOutput)
}

// BrevisCallback is a paid mutator transaction binding the contract method 0x79d6b6a2.
//
// Solidity: function brevisCallback(bytes32 _appVkHash, bytes _appCircuitOutput) returns()
func (_BrevisApp *BrevisAppTransactorSession) BrevisCallback(_appVkHash [32]byte, _appCircuitOutput []byte) (*types.Transaction, error) {
	return _BrevisApp.Contract.BrevisCallback(&_BrevisApp.TransactOpts, _appVkHash, _appCircuitOutput)
}

// BrevisDisputeMetaData contains all meta data concerning the BrevisDispute contract.
var BrevisDisputeMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"contractBrevisRequest\",\"name\":\"_brevisRequest\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"proofId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"enumIBrevisTypes.DisputeStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"AskFor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"ChallengeWindowUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"proofId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"name\":\"DataAvailabilityProofPosted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"proofId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"name\":\"DataValidityProofProofPosted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amtAskForData\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amtAskForProof\",\"type\":\"uint256\"}],\"name\":\"DisputeDepositsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"proofId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"done\",\"type\":\"bool\"}],\"name\":\"RequestDataPosted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"ResponseTimeoutUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"askForDataAvailabilityProof\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"askForDataValidityProof\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"askForRequestData\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"challengeWindow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositAskForData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositAskForProof\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"disputes\",\"outputs\":[{\"internalType\":\"enumIBrevisTypes.DisputeStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes32[]\",\"name\":\"hashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"internalType\":\"structIBrevisTypes.RequestDataHash\",\"name\":\"requestDataHash\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"responseDeadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChallengeWindow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_requestKey\",\"type\":\"bytes32\"}],\"name\":\"getDisputeStatus\",\"outputs\":[{\"internalType\":\"enumIBrevisTypes.DisputeStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_requestKey\",\"type\":\"bytes32\"}],\"name\":\"getResponseDeadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"postDataAvailabilityProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"}],\"name\":\"postDataValidityProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes[]\",\"name\":\"_data\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_done\",\"type\":\"bool\"}],\"name\":\"postRequestData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"responseTimeout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_challengeWindow\",\"type\":\"uint256\"}],\"name\":\"setChallengeWindow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amtAskForData\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amtAskForProof\",\"type\":\"uint256\"}],\"name\":\"setDisputeDeposits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_responseTimeout\",\"type\":\"uint256\"}],\"name\":\"setResponseTimeout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x60a0346100c557601f611c8238819003918201601f19168301916001600160401b038311848410176100c9578084926020946040528339810103126100c557516001600160a01b03811681036100c557608052604051611ba490816100de823960805181818161015001528181610390015281816105ce01528181610661015281816106d40152818161078a0152818161080a0152818161085a01528181610b7701528181610d9601528181610ec4015281816114020152818161150501526118750152f35b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe6080806040526004361015610012575f80fd5b5f90813560e01c90816301c1aa0d146118435750806311be19971461170c578063239fd760146116df5780632b256c681461149857806334fc1d2b1461147a57806369dc1903146113ce5780636a50c71e146113b1578063861a1412146113b157806395b4086114610e3e5780639bdf046914610d5e578063a17ed96c14610d40578063ac225f5414610b08578063b2ec247614610ad4578063c5d129141461055c578063d3c22a3a14610323578063eab8d3a7146100f95763f4a5b35d146100d9575f80fd5b346100f657806003193601126100f6576020600354604051908152f35b80fd5b50346100f65760603660031901126100f65760043590610117611941565b9167ffffffffffffffff60443581811161031f57610139903690600401611958565b5050604051637632421760e11b81523360048201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031694602092909183816024818a5afa9081156102e7579061019f9187916102f2575b50611a97565b60405183810185815260c084901b6001600160c01b0319166020820152602491606091906101da81602884015b03601f1981018352826118fe565b5190209760405192838092639d86698560e01b82528b60048301525afa9081156102e75786916102b7575b5086865260048452604086209060098110156102a3576005149081610273575b50956102537fa38ccf08432b738adb9d381dbd7ae7ad1aac98357a2a14233bf755a2aa898e2e959697611b03565b86526004835260408620600460ff1982541617905560405191168152a280f35b60ff9150541695600787101561028f5795600314610253610225565b634e487b7160e01b86526021600452602486fd5b634e487b7160e01b87526021600452602487fd5b6102d8915060603d81116102e0575b6102d081836118fe565b8101906119d2565b50505f610205565b503d6102c6565b6040513d88823e3d90fd5b6103129150853d8711610318575b61030a81836118fe565b810190611a7f565b5f610199565b503d610300565b8380fd5b5060403660031901126100f65760043561033b611941565b6103486003543411611986565b6040516020810190610377816101cc858786906028926001600160c01b031991835260c01b1660208201520190565b519020604051639d86698560e01b8152600481018290527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169185606083602481875afa93841561054f5781938295610528575b506103f46103ed835467ffffffffffffffff809816611a12565b4210611a33565b803b15610524578180916044604051809481936319d43eb560e01b8352886004840152600560248401525af1801561051957610501575b505260046020526040852090600981101561028f57600514806104ea575b917f305b29c3917a30a5ca5ffefad1a2fd5b6468f8bf644b95831f9097c61e4c7ab69391610478606094611b03565b600360ff1982541617815561048f60015442611a12565b6003820155805474ffffffffffffffffffffffffffffffffffffffff0019163360081b74ffffffffffffffffffffffffffffffffffffffff00161781556004349101556040519116815260036020820152336040820152a280f35b5060ff815416600781101561028f57600214610449565b61050a906118ea565b61051557855f61042b565b8580fd5b6040513d84823e3d90fd5b5080fd5b90945061054491935060603d81116102e0576102d081836118fe565b50929092935f6103d3565b50604051903d90823e3d90fd5b50346100f65760803660031901126100f657610576611941565b60443567ffffffffffffffff81168103610ad05760643567ffffffffffffffff811161031f576105aa903690600401611958565b90604051637632421760e11b81523360048201526020816024816001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000165afa80156102e757610606918791610ab75750611a97565b604051610635816101cc8760043560208401906028926001600160c01b031991835260c01b1660208201520190565b602081519101209160405193639d86698560e01b85528360048601526060856024816001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000165afa948515610972578795610a94575b50838752600460205260408720946009811015610a80579060058893921480610a62575b6106be90611b03565b60405163063fad5560e51b8152906020826004817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165afa918215610a57578492610a12575b506060936001600160a01b0367ffffffffffffffff926107506040519889978896879463e044095360e01b8652166004850152604060248501526044840191611ae3565b0393165af18015610a075785869287926109c2575b506004350361097d5760405163c2eaa93160e01b8152600481018490526020816024817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165afa90811561097257879161093c575b506040519160208301938452604083015260408252606082019282841067ffffffffffffffff851117610928578360405282519020036108e757505083906001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163b1561052457604051906319d43eb560e01b82526004820152600260248201528181604481836001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000165af18015610519576108cf575b5050600660ff1982541617905567ffffffffffffffff604051911681527f8474e871e3a8323ba71f5ce5c3c9da0d547fd033dd9274cce4380339a9cdccc6602060043592a280f35b6108d8906118ea565b6108e357825f610887565b8280fd5b907f696e76616c69642070726f6f663a20617070486173680000000000000000000060a460649362461bcd60e51b8452602085820152601660848201520152fd5b634e487b7160e01b5f52604160045260245ffd5b90506020813d60201161096a575b81610957602093836118fe565b8101031261096657515f6107c2565b8680fd5b3d915061094a565b6040513d89823e3d90fd5b60405162461bcd60e51b815260206004820152601660248201527f696e76616c69642070726f6f663a2070726f6f664964000000000000000000006044820152606490fd5b925050506060813d6060116109ff575b816109df606093836118fe565b810103126109fb5780516020820151604090920151905f610765565b8480fd5b3d91506109d2565b6040513d87823e3d90fd5b9091506020813d602011610a4f575b81610a2e602093836118fe565b8101031261031f57516001600160a01b038116810361031f5790606061070c565b3d9150610a21565b6040513d86823e3d90fd5b5090915060ff8554166007811015610a8057879291906005146106b5565b634e487b7160e01b88526021600452602488fd5b610aae91955060603d6060116102e0576102d081836118fe565b5050935f610691565b610312915060203d6020116103185761030a81836118fe565b5f80fd5b50346100f65760203660031901126100f65760ff6040602092600435815260048452205416610b066040518092611920565bf35b5060403660031901126100f657600435610b20611941565b610b2d6002543411611986565b6040516020810190610b5c816101cc858786906028926001600160c01b031991835260c01b1660208201520190565b519020604051639d86698560e01b81526004810182905291907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316606084602481845afa9384156102e75786908795610d1c575b5060098110156102a357600403610cd7578590610be46103ed835467ffffffffffffffff809816611a12565b803b15610524578180916044604051809481936319d43eb560e01b8352886004840152600560248401525af1801561051957610cbf575b5092606092917f305b29c3917a30a5ca5ffefad1a2fd5b6468f8bf644b95831f9097c61e4c7ab69452600460205260408620600160ff19825416178155610c6460015442611a12565b6003820155805474ffffffffffffffffffffffffffffffffffffffff0019163360081b74ffffffffffffffffffffffffffffffffffffffff00161781556004349101556040519116815260016020820152336040820152a280f35b610ccb909392936118ea565b6109fb5790845f610c1b565b60405162461bcd60e51b815260206004820152601a60248201527f6e6f7420696e20612064697370757461626c65207374617475730000000000006044820152606490fd5b9050610d3791945060603d81116102e0576102d081836118fe565b5093905f610bb8565b50346100f657806003193601126100f6576020600154604051908152f35b50346100f65760403660031901126100f65760043560243560405191638da5cb5b60e01b83526001600160a01b0391602084600481867f0000000000000000000000000000000000000000000000000000000000000000165afa938415610a07577f56ca37d8947ac20c2d621aba1b4f339d6293d1bd4183930bcaf29dbf41e26af294604094610df8928892610e0e575b50163314611a97565b816002558060035582519182526020820152a180f35b610e3091925060203d8111610e37575b610e2881836118fe565b810190611b4f565b905f610def565b503d610e1e565b50346100f65760a03660031901126100f657610e58611941565b67ffffffffffffffff60443511610524573660236044350112156105245767ffffffffffffffff6044356004013511610524573660246044356004013560051b6044350101116105245760843515156084350361052457604051637632421760e11b81523360048201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690602081602481855afa8015610a5757610f0c918591610ab75750611a97565b602460606040516020810190610f41816101cc8860043586906028926001600160c01b031991835260c01b1660208201520190565b5190209260405192838092639d86698560e01b82528660048301525afa908115610a57578491611391575b50600981101561137d576005036113385780835260046020526040832060ff8154166007811015611324576001036112df5760643560018201540361129a57835b60443560040135811061113057506084356110bb575b50506040519067ffffffffffffffff60808301911682526080602083015260443560040135905260a081019060a06044356004013560051b8201019160246044350190845b604435600401358110611057575050507f635ae6660d964e1393ed692ae764226ddeb8878df97a22e762559a7485f348749060643560408201526084351515606082015280600435930390a280f35b909193609f1984820301835284356042196044353603018112156109665760443501906044602483013592019167ffffffffffffffff81116110b75780360383136110b7576110ac6020928392600195611ae3565b960193019101611008565b8780fd5b60405160208101908160018401546001850188526020882090885b81811061111a57505050906110f7816002949303601f1981018352826118fe565b5190209101558252600460205260408220805460ff191660021790555f80610fc3565b82548452602090930192600192830192016110d6565b60421960443536030160248260051b60443501013512156109fb5767ffffffffffffffff6024808360051b604435010135604435010135116109fb5760448035600583901b81016024908101359091019081013536039101136109fb576040516111b66020601f19601f6024808760051b604435010135604435010135011601826118fe565b6024600583901b6044803591820183013590910191820135808452602084019392369101909101116109665760448035600585901b810160249081013590910190810135910183378660206024808660051b604435010135604435010135830101525190206001830154680100000000000000008110156112865760018101806001860155811015611272576001840187526020872001555f19811461125e57600101610fad565b634e487b7160e01b85526011600452602485fd5b634e487b7160e01b87526032600452602487fd5b634e487b7160e01b87526041600452602487fd5b60405162461bcd60e51b815260206004820152600d60248201527f696e76616c696420696e646578000000000000000000000000000000000000006044820152606490fd5b60405162461bcd60e51b815260206004820152601660248201527f696e76616c6964206469737075746520737461747573000000000000000000006044820152606490fd5b634e487b7160e01b85526021600452602485fd5b60405162461bcd60e51b815260206004820152601660248201527f696e76616c6964207265717565737420737461747573000000000000000000006044820152606490fd5b634e487b7160e01b84526021600452602484fd5b6113a9915060603d81116102e0576102d081836118fe565b50505f610f6c565b50346100f657806003193601126100f65760209054604051908152f35b50346100f65760203660031901126100f657604051638da5cb5b60e01b81526001600160a01b0360048035906020908490817f000000000000000000000000000000000000000000000000000000000000000086165afa928315610a57577f86fe7fc31f35681a1ed77325f0cf24935a5d25b1861e7ce9ceed9cb67f22227093604093611464928792610e0e5750163314611a97565b600154908060015582519182526020820152a180f35b50346100f657806003193601126100f6576020600254604051908152f35b5060403660031901126100f6576004356114b0611941565b6114bd6003543411611986565b60405160208101906114ec816101cc858786906028926001600160c01b031991835260c01b1660208201520190565b519020604051639d86698560e01b8152600481018290527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169185606083602481875afa93841561054f57819382956116b8575b506115626103ed835467ffffffffffffffff809816611a12565b803b156105245781906044604051809481936319d43eb560e01b8352876004840152600560248401525af18015610972576116a5575b50855260046020526040852090600981101561028f576004811490811561165c575b50917f305b29c3917a30a5ca5ffefad1a2fd5b6468f8bf644b95831f9097c61e4c7ab693916115ea606094611b03565b600560ff1982541617815561160160015442611a12565b6003820155805474ffffffffffffffffffffffffffffffffffffffff0019163360081b74ffffffffffffffffffffffffffffffffffffffff00161781556004349101556040519116815260056020820152336040820152a280f35b60059150148061168d575b7f305b29c3917a30a5ca5ffefad1a2fd5b6468f8bf644b95831f9097c61e4c7ab66115ba565b5060ff815416600781101561028f5760051415611667565b6116b1909691966118ea565b945f611598565b9094506116d491935060603d81116102e0576102d081836118fe565b50929092935f611548565b50346100f65760203660031901126100f65760036040602092600435815260048452200154604051908152f35b50346100f65760208060031936011261052457600435825260048152604082209182549160019384810160405190604082019082821067ffffffffffffffff83111761182f5781604096939596528054808352606086019184528684209089855b82811061181c57505050506117899085603f19910301826118fe565b835260028201549084840191825260046003840154930154936001600160a01b03604051976117bb8960ff8316611920565b60081c168688015260a0604088015260e08701905195604060a089015286518092528061010089019701925b82811061180957505050508495505160c0850152606084015260808301520390f35b83518852968101969281019289016117e7565b835485529389019392810192810161176d565b634e487b7160e01b86526041600452602486fd5b90503461052457602036600319011261052457600435638da5cb5b60e01b82526001600160a01b0390602083600481857f0000000000000000000000000000000000000000000000000000000000000000165afa928315610a57577fedb9338f4b0faf2b899d2d7f54b90753d2a8ebb34936e381edb91b091c3e45a7936040936118d6928792610e0e5750163314611a97565b83549080855582519182526020820152a180f35b67ffffffffffffffff811161092857604052565b90601f8019910116810190811067ffffffffffffffff82111761092857604052565b90600782101561192d5752565b634e487b7160e01b5f52602160045260245ffd5b6024359067ffffffffffffffff82168203610ad057565b9181601f84011215610ad05782359167ffffffffffffffff8311610ad05760208381860195010111610ad057565b1561198d57565b60405162461bcd60e51b815260206004820152601460248201527f696e73756666696369656e74206465706f7369740000000000000000000000006044820152606490fd5b90816060910312610ad05780516009811015610ad05791602082015167ffffffffffffffff81168103610ad05760409092015160ff81168103610ad05790565b91908201809211611a1f57565b634e487b7160e01b5f52601160045260245ffd5b15611a3a57565b60405162461bcd60e51b815260206004820152601560248201527f70617373206368616c6c656e67652077696e646f7700000000000000000000006044820152606490fd5b90816020910312610ad057518015158103610ad05790565b15611a9e57565b60405162461bcd60e51b815260206004820152601260248201527f6e6f7420696e76616c69642070726f76657200000000000000000000000000006044820152606490fd5b908060209392818452848401375f828201840152601f01601f1916010190565b15611b0a57565b60405162461bcd60e51b815260206004820152600e60248201527f696e76616c6964207374617465730000000000000000000000000000000000006044820152606490fd5b90816020910312610ad057516001600160a01b0381168103610ad0579056fea26469706673582212207d847730461433edd6de4cc5eb3ff93baa558a92f07dabcb6bb7ae5014cdbde764736f6c63430008140033",
}

// BrevisDisputeABI is the input ABI used to generate the binding from.
// Deprecated: Use BrevisDisputeMetaData.ABI instead.
var BrevisDisputeABI = BrevisDisputeMetaData.ABI

// BrevisDisputeBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use BrevisDisputeMetaData.Bin instead.
var BrevisDisputeBin = BrevisDisputeMetaData.Bin

// DeployBrevisDispute deploys a new Ethereum contract, binding an instance of BrevisDispute to it.
func DeployBrevisDispute(auth *bind.TransactOpts, backend bind.ContractBackend, _brevisRequest common.Address) (common.Address, *types.Transaction, *BrevisDispute, error) {
	parsed, err := BrevisDisputeMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(BrevisDisputeBin), backend, _brevisRequest)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &BrevisDispute{BrevisDisputeCaller: BrevisDisputeCaller{contract: contract}, BrevisDisputeTransactor: BrevisDisputeTransactor{contract: contract}, BrevisDisputeFilterer: BrevisDisputeFilterer{contract: contract}}, nil
}

// BrevisDispute is an auto generated Go binding around an Ethereum contract.
type BrevisDispute struct {
	BrevisDisputeCaller     // Read-only binding to the contract
	BrevisDisputeTransactor // Write-only binding to the contract
	BrevisDisputeFilterer   // Log filterer for contract events
}

// BrevisDisputeCaller is an auto generated read-only Go binding around an Ethereum contract.
type BrevisDisputeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisDisputeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BrevisDisputeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisDisputeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BrevisDisputeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisDisputeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BrevisDisputeSession struct {
	Contract     *BrevisDispute    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BrevisDisputeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BrevisDisputeCallerSession struct {
	Contract *BrevisDisputeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// BrevisDisputeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BrevisDisputeTransactorSession struct {
	Contract     *BrevisDisputeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// BrevisDisputeRaw is an auto generated low-level Go binding around an Ethereum contract.
type BrevisDisputeRaw struct {
	Contract *BrevisDispute // Generic contract binding to access the raw methods on
}

// BrevisDisputeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BrevisDisputeCallerRaw struct {
	Contract *BrevisDisputeCaller // Generic read-only contract binding to access the raw methods on
}

// BrevisDisputeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BrevisDisputeTransactorRaw struct {
	Contract *BrevisDisputeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBrevisDispute creates a new instance of BrevisDispute, bound to a specific deployed contract.
func NewBrevisDispute(address common.Address, backend bind.ContractBackend) (*BrevisDispute, error) {
	contract, err := bindBrevisDispute(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BrevisDispute{BrevisDisputeCaller: BrevisDisputeCaller{contract: contract}, BrevisDisputeTransactor: BrevisDisputeTransactor{contract: contract}, BrevisDisputeFilterer: BrevisDisputeFilterer{contract: contract}}, nil
}

// NewBrevisDisputeCaller creates a new read-only instance of BrevisDispute, bound to a specific deployed contract.
func NewBrevisDisputeCaller(address common.Address, caller bind.ContractCaller) (*BrevisDisputeCaller, error) {
	contract, err := bindBrevisDispute(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BrevisDisputeCaller{contract: contract}, nil
}

// NewBrevisDisputeTransactor creates a new write-only instance of BrevisDispute, bound to a specific deployed contract.
func NewBrevisDisputeTransactor(address common.Address, transactor bind.ContractTransactor) (*BrevisDisputeTransactor, error) {
	contract, err := bindBrevisDispute(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BrevisDisputeTransactor{contract: contract}, nil
}

// NewBrevisDisputeFilterer creates a new log filterer instance of BrevisDispute, bound to a specific deployed contract.
func NewBrevisDisputeFilterer(address common.Address, filterer bind.ContractFilterer) (*BrevisDisputeFilterer, error) {
	contract, err := bindBrevisDispute(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BrevisDisputeFilterer{contract: contract}, nil
}

// bindBrevisDispute binds a generic wrapper to an already deployed contract.
func bindBrevisDispute(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BrevisDisputeMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BrevisDispute *BrevisDisputeRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BrevisDispute.Contract.BrevisDisputeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BrevisDispute *BrevisDisputeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisDispute.Contract.BrevisDisputeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BrevisDispute *BrevisDisputeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BrevisDispute.Contract.BrevisDisputeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BrevisDispute *BrevisDisputeCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BrevisDispute.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BrevisDispute *BrevisDisputeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisDispute.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BrevisDispute *BrevisDisputeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BrevisDispute.Contract.contract.Transact(opts, method, params...)
}

// ChallengeWindow is a free data retrieval call binding the contract method 0x861a1412.
//
// Solidity: function challengeWindow() view returns(uint256)
func (_BrevisDispute *BrevisDisputeCaller) ChallengeWindow(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BrevisDispute.contract.Call(opts, &out, "challengeWindow")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// ChallengeWindow is a free data retrieval call binding the contract method 0x861a1412.
//
// Solidity: function challengeWindow() view returns(uint256)
func (_BrevisDispute *BrevisDisputeSession) ChallengeWindow() (*big.Int, error) {
	return _BrevisDispute.Contract.ChallengeWindow(&_BrevisDispute.CallOpts)
}

// ChallengeWindow is a free data retrieval call binding the contract method 0x861a1412.
//
// Solidity: function challengeWindow() view returns(uint256)
func (_BrevisDispute *BrevisDisputeCallerSession) ChallengeWindow() (*big.Int, error) {
	return _BrevisDispute.Contract.ChallengeWindow(&_BrevisDispute.CallOpts)
}

// DepositAskForData is a free data retrieval call binding the contract method 0x34fc1d2b.
//
// Solidity: function depositAskForData() view returns(uint256)
func (_BrevisDispute *BrevisDisputeCaller) DepositAskForData(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BrevisDispute.contract.Call(opts, &out, "depositAskForData")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DepositAskForData is a free data retrieval call binding the contract method 0x34fc1d2b.
//
// Solidity: function depositAskForData() view returns(uint256)
func (_BrevisDispute *BrevisDisputeSession) DepositAskForData() (*big.Int, error) {
	return _BrevisDispute.Contract.DepositAskForData(&_BrevisDispute.CallOpts)
}

// DepositAskForData is a free data retrieval call binding the contract method 0x34fc1d2b.
//
// Solidity: function depositAskForData() view returns(uint256)
func (_BrevisDispute *BrevisDisputeCallerSession) DepositAskForData() (*big.Int, error) {
	return _BrevisDispute.Contract.DepositAskForData(&_BrevisDispute.CallOpts)
}

// DepositAskForProof is a free data retrieval call binding the contract method 0xf4a5b35d.
//
// Solidity: function depositAskForProof() view returns(uint256)
func (_BrevisDispute *BrevisDisputeCaller) DepositAskForProof(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BrevisDispute.contract.Call(opts, &out, "depositAskForProof")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DepositAskForProof is a free data retrieval call binding the contract method 0xf4a5b35d.
//
// Solidity: function depositAskForProof() view returns(uint256)
func (_BrevisDispute *BrevisDisputeSession) DepositAskForProof() (*big.Int, error) {
	return _BrevisDispute.Contract.DepositAskForProof(&_BrevisDispute.CallOpts)
}

// DepositAskForProof is a free data retrieval call binding the contract method 0xf4a5b35d.
//
// Solidity: function depositAskForProof() view returns(uint256)
func (_BrevisDispute *BrevisDisputeCallerSession) DepositAskForProof() (*big.Int, error) {
	return _BrevisDispute.Contract.DepositAskForProof(&_BrevisDispute.CallOpts)
}

// Disputes is a free data retrieval call binding the contract method 0x11be1997.
//
// Solidity: function disputes(bytes32 ) view returns(uint8 status, address challenger, (bytes32[],bytes32) requestDataHash, uint256 responseDeadline, uint256 deposit)
func (_BrevisDispute *BrevisDisputeCaller) Disputes(opts *bind.CallOpts, arg0 [32]byte) (struct {
	Status           uint8
	Challenger       common.Address
	RequestDataHash  IBrevisTypesRequestDataHash
	ResponseDeadline *big.Int
	Deposit          *big.Int
}, error) {
	var out []interface{}
	err := _BrevisDispute.contract.Call(opts, &out, "disputes", arg0)

	outstruct := new(struct {
		Status           uint8
		Challenger       common.Address
		RequestDataHash  IBrevisTypesRequestDataHash
		ResponseDeadline *big.Int
		Deposit          *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Status = *abi.ConvertType(out[0], new(uint8)).(*uint8)
	outstruct.Challenger = *abi.ConvertType(out[1], new(common.Address)).(*common.Address)
	outstruct.RequestDataHash = *abi.ConvertType(out[2], new(IBrevisTypesRequestDataHash)).(*IBrevisTypesRequestDataHash)
	outstruct.ResponseDeadline = *abi.ConvertType(out[3], new(*big.Int)).(**big.Int)
	outstruct.Deposit = *abi.ConvertType(out[4], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// Disputes is a free data retrieval call binding the contract method 0x11be1997.
//
// Solidity: function disputes(bytes32 ) view returns(uint8 status, address challenger, (bytes32[],bytes32) requestDataHash, uint256 responseDeadline, uint256 deposit)
func (_BrevisDispute *BrevisDisputeSession) Disputes(arg0 [32]byte) (struct {
	Status           uint8
	Challenger       common.Address
	RequestDataHash  IBrevisTypesRequestDataHash
	ResponseDeadline *big.Int
	Deposit          *big.Int
}, error) {
	return _BrevisDispute.Contract.Disputes(&_BrevisDispute.CallOpts, arg0)
}

// Disputes is a free data retrieval call binding the contract method 0x11be1997.
//
// Solidity: function disputes(bytes32 ) view returns(uint8 status, address challenger, (bytes32[],bytes32) requestDataHash, uint256 responseDeadline, uint256 deposit)
func (_BrevisDispute *BrevisDisputeCallerSession) Disputes(arg0 [32]byte) (struct {
	Status           uint8
	Challenger       common.Address
	RequestDataHash  IBrevisTypesRequestDataHash
	ResponseDeadline *big.Int
	Deposit          *big.Int
}, error) {
	return _BrevisDispute.Contract.Disputes(&_BrevisDispute.CallOpts, arg0)
}

// GetChallengeWindow is a free data retrieval call binding the contract method 0x6a50c71e.
//
// Solidity: function getChallengeWindow() view returns(uint256)
func (_BrevisDispute *BrevisDisputeCaller) GetChallengeWindow(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BrevisDispute.contract.Call(opts, &out, "getChallengeWindow")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetChallengeWindow is a free data retrieval call binding the contract method 0x6a50c71e.
//
// Solidity: function getChallengeWindow() view returns(uint256)
func (_BrevisDispute *BrevisDisputeSession) GetChallengeWindow() (*big.Int, error) {
	return _BrevisDispute.Contract.GetChallengeWindow(&_BrevisDispute.CallOpts)
}

// GetChallengeWindow is a free data retrieval call binding the contract method 0x6a50c71e.
//
// Solidity: function getChallengeWindow() view returns(uint256)
func (_BrevisDispute *BrevisDisputeCallerSession) GetChallengeWindow() (*big.Int, error) {
	return _BrevisDispute.Contract.GetChallengeWindow(&_BrevisDispute.CallOpts)
}

// GetDisputeStatus is a free data retrieval call binding the contract method 0xb2ec2476.
//
// Solidity: function getDisputeStatus(bytes32 _requestKey) view returns(uint8)
func (_BrevisDispute *BrevisDisputeCaller) GetDisputeStatus(opts *bind.CallOpts, _requestKey [32]byte) (uint8, error) {
	var out []interface{}
	err := _BrevisDispute.contract.Call(opts, &out, "getDisputeStatus", _requestKey)

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// GetDisputeStatus is a free data retrieval call binding the contract method 0xb2ec2476.
//
// Solidity: function getDisputeStatus(bytes32 _requestKey) view returns(uint8)
func (_BrevisDispute *BrevisDisputeSession) GetDisputeStatus(_requestKey [32]byte) (uint8, error) {
	return _BrevisDispute.Contract.GetDisputeStatus(&_BrevisDispute.CallOpts, _requestKey)
}

// GetDisputeStatus is a free data retrieval call binding the contract method 0xb2ec2476.
//
// Solidity: function getDisputeStatus(bytes32 _requestKey) view returns(uint8)
func (_BrevisDispute *BrevisDisputeCallerSession) GetDisputeStatus(_requestKey [32]byte) (uint8, error) {
	return _BrevisDispute.Contract.GetDisputeStatus(&_BrevisDispute.CallOpts, _requestKey)
}

// GetResponseDeadline is a free data retrieval call binding the contract method 0x239fd760.
//
// Solidity: function getResponseDeadline(bytes32 _requestKey) view returns(uint256)
func (_BrevisDispute *BrevisDisputeCaller) GetResponseDeadline(opts *bind.CallOpts, _requestKey [32]byte) (*big.Int, error) {
	var out []interface{}
	err := _BrevisDispute.contract.Call(opts, &out, "getResponseDeadline", _requestKey)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetResponseDeadline is a free data retrieval call binding the contract method 0x239fd760.
//
// Solidity: function getResponseDeadline(bytes32 _requestKey) view returns(uint256)
func (_BrevisDispute *BrevisDisputeSession) GetResponseDeadline(_requestKey [32]byte) (*big.Int, error) {
	return _BrevisDispute.Contract.GetResponseDeadline(&_BrevisDispute.CallOpts, _requestKey)
}

// GetResponseDeadline is a free data retrieval call binding the contract method 0x239fd760.
//
// Solidity: function getResponseDeadline(bytes32 _requestKey) view returns(uint256)
func (_BrevisDispute *BrevisDisputeCallerSession) GetResponseDeadline(_requestKey [32]byte) (*big.Int, error) {
	return _BrevisDispute.Contract.GetResponseDeadline(&_BrevisDispute.CallOpts, _requestKey)
}

// ResponseTimeout is a free data retrieval call binding the contract method 0xa17ed96c.
//
// Solidity: function responseTimeout() view returns(uint256)
func (_BrevisDispute *BrevisDisputeCaller) ResponseTimeout(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BrevisDispute.contract.Call(opts, &out, "responseTimeout")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// ResponseTimeout is a free data retrieval call binding the contract method 0xa17ed96c.
//
// Solidity: function responseTimeout() view returns(uint256)
func (_BrevisDispute *BrevisDisputeSession) ResponseTimeout() (*big.Int, error) {
	return _BrevisDispute.Contract.ResponseTimeout(&_BrevisDispute.CallOpts)
}

// ResponseTimeout is a free data retrieval call binding the contract method 0xa17ed96c.
//
// Solidity: function responseTimeout() view returns(uint256)
func (_BrevisDispute *BrevisDisputeCallerSession) ResponseTimeout() (*big.Int, error) {
	return _BrevisDispute.Contract.ResponseTimeout(&_BrevisDispute.CallOpts)
}

// AskForDataAvailabilityProof is a paid mutator transaction binding the contract method 0xd3c22a3a.
//
// Solidity: function askForDataAvailabilityProof(bytes32 _proofId, uint64 _nonce) payable returns()
func (_BrevisDispute *BrevisDisputeTransactor) AskForDataAvailabilityProof(opts *bind.TransactOpts, _proofId [32]byte, _nonce uint64) (*types.Transaction, error) {
	return _BrevisDispute.contract.Transact(opts, "askForDataAvailabilityProof", _proofId, _nonce)
}

// AskForDataAvailabilityProof is a paid mutator transaction binding the contract method 0xd3c22a3a.
//
// Solidity: function askForDataAvailabilityProof(bytes32 _proofId, uint64 _nonce) payable returns()
func (_BrevisDispute *BrevisDisputeSession) AskForDataAvailabilityProof(_proofId [32]byte, _nonce uint64) (*types.Transaction, error) {
	return _BrevisDispute.Contract.AskForDataAvailabilityProof(&_BrevisDispute.TransactOpts, _proofId, _nonce)
}

// AskForDataAvailabilityProof is a paid mutator transaction binding the contract method 0xd3c22a3a.
//
// Solidity: function askForDataAvailabilityProof(bytes32 _proofId, uint64 _nonce) payable returns()
func (_BrevisDispute *BrevisDisputeTransactorSession) AskForDataAvailabilityProof(_proofId [32]byte, _nonce uint64) (*types.Transaction, error) {
	return _BrevisDispute.Contract.AskForDataAvailabilityProof(&_BrevisDispute.TransactOpts, _proofId, _nonce)
}

// AskForDataValidityProof is a paid mutator transaction binding the contract method 0x2b256c68.
//
// Solidity: function askForDataValidityProof(bytes32 _proofId, uint64 _nonce) payable returns()
func (_BrevisDispute *BrevisDisputeTransactor) AskForDataValidityProof(opts *bind.TransactOpts, _proofId [32]byte, _nonce uint64) (*types.Transaction, error) {
	return _BrevisDispute.contract.Transact(opts, "askForDataValidityProof", _proofId, _nonce)
}

// AskForDataValidityProof is a paid mutator transaction binding the contract method 0x2b256c68.
//
// Solidity: function askForDataValidityProof(bytes32 _proofId, uint64 _nonce) payable returns()
func (_BrevisDispute *BrevisDisputeSession) AskForDataValidityProof(_proofId [32]byte, _nonce uint64) (*types.Transaction, error) {
	return _BrevisDispute.Contract.AskForDataValidityProof(&_BrevisDispute.TransactOpts, _proofId, _nonce)
}

// AskForDataValidityProof is a paid mutator transaction binding the contract method 0x2b256c68.
//
// Solidity: function askForDataValidityProof(bytes32 _proofId, uint64 _nonce) payable returns()
func (_BrevisDispute *BrevisDisputeTransactorSession) AskForDataValidityProof(_proofId [32]byte, _nonce uint64) (*types.Transaction, error) {
	return _BrevisDispute.Contract.AskForDataValidityProof(&_BrevisDispute.TransactOpts, _proofId, _nonce)
}

// AskForRequestData is a paid mutator transaction binding the contract method 0xac225f54.
//
// Solidity: function askForRequestData(bytes32 _proofId, uint64 _nonce) payable returns()
func (_BrevisDispute *BrevisDisputeTransactor) AskForRequestData(opts *bind.TransactOpts, _proofId [32]byte, _nonce uint64) (*types.Transaction, error) {
	return _BrevisDispute.contract.Transact(opts, "askForRequestData", _proofId, _nonce)
}

// AskForRequestData is a paid mutator transaction binding the contract method 0xac225f54.
//
// Solidity: function askForRequestData(bytes32 _proofId, uint64 _nonce) payable returns()
func (_BrevisDispute *BrevisDisputeSession) AskForRequestData(_proofId [32]byte, _nonce uint64) (*types.Transaction, error) {
	return _BrevisDispute.Contract.AskForRequestData(&_BrevisDispute.TransactOpts, _proofId, _nonce)
}

// AskForRequestData is a paid mutator transaction binding the contract method 0xac225f54.
//
// Solidity: function askForRequestData(bytes32 _proofId, uint64 _nonce) payable returns()
func (_BrevisDispute *BrevisDisputeTransactorSession) AskForRequestData(_proofId [32]byte, _nonce uint64) (*types.Transaction, error) {
	return _BrevisDispute.Contract.AskForRequestData(&_BrevisDispute.TransactOpts, _proofId, _nonce)
}

// PostDataAvailabilityProof is a paid mutator transaction binding the contract method 0xeab8d3a7.
//
// Solidity: function postDataAvailabilityProof(bytes32 _proofId, uint64 _nonce, bytes ) returns()
func (_BrevisDispute *BrevisDisputeTransactor) PostDataAvailabilityProof(opts *bind.TransactOpts, _proofId [32]byte, _nonce uint64, arg2 []byte) (*types.Transaction, error) {
	return _BrevisDispute.contract.Transact(opts, "postDataAvailabilityProof", _proofId, _nonce, arg2)
}

// PostDataAvailabilityProof is a paid mutator transaction binding the contract method 0xeab8d3a7.
//
// Solidity: function postDataAvailabilityProof(bytes32 _proofId, uint64 _nonce, bytes ) returns()
func (_BrevisDispute *BrevisDisputeSession) PostDataAvailabilityProof(_proofId [32]byte, _nonce uint64, arg2 []byte) (*types.Transaction, error) {
	return _BrevisDispute.Contract.PostDataAvailabilityProof(&_BrevisDispute.TransactOpts, _proofId, _nonce, arg2)
}

// PostDataAvailabilityProof is a paid mutator transaction binding the contract method 0xeab8d3a7.
//
// Solidity: function postDataAvailabilityProof(bytes32 _proofId, uint64 _nonce, bytes ) returns()
func (_BrevisDispute *BrevisDisputeTransactorSession) PostDataAvailabilityProof(_proofId [32]byte, _nonce uint64, arg2 []byte) (*types.Transaction, error) {
	return _BrevisDispute.Contract.PostDataAvailabilityProof(&_BrevisDispute.TransactOpts, _proofId, _nonce, arg2)
}

// PostDataValidityProof is a paid mutator transaction binding the contract method 0xc5d12914.
//
// Solidity: function postDataValidityProof(bytes32 _proofId, uint64 _nonce, uint64 _chainId, bytes _proof) returns()
func (_BrevisDispute *BrevisDisputeTransactor) PostDataValidityProof(opts *bind.TransactOpts, _proofId [32]byte, _nonce uint64, _chainId uint64, _proof []byte) (*types.Transaction, error) {
	return _BrevisDispute.contract.Transact(opts, "postDataValidityProof", _proofId, _nonce, _chainId, _proof)
}

// PostDataValidityProof is a paid mutator transaction binding the contract method 0xc5d12914.
//
// Solidity: function postDataValidityProof(bytes32 _proofId, uint64 _nonce, uint64 _chainId, bytes _proof) returns()
func (_BrevisDispute *BrevisDisputeSession) PostDataValidityProof(_proofId [32]byte, _nonce uint64, _chainId uint64, _proof []byte) (*types.Transaction, error) {
	return _BrevisDispute.Contract.PostDataValidityProof(&_BrevisDispute.TransactOpts, _proofId, _nonce, _chainId, _proof)
}

// PostDataValidityProof is a paid mutator transaction binding the contract method 0xc5d12914.
//
// Solidity: function postDataValidityProof(bytes32 _proofId, uint64 _nonce, uint64 _chainId, bytes _proof) returns()
func (_BrevisDispute *BrevisDisputeTransactorSession) PostDataValidityProof(_proofId [32]byte, _nonce uint64, _chainId uint64, _proof []byte) (*types.Transaction, error) {
	return _BrevisDispute.Contract.PostDataValidityProof(&_BrevisDispute.TransactOpts, _proofId, _nonce, _chainId, _proof)
}

// PostRequestData is a paid mutator transaction binding the contract method 0x95b40861.
//
// Solidity: function postRequestData(bytes32 _proofId, uint64 _nonce, bytes[] _data, uint256 _index, bool _done) returns()
func (_BrevisDispute *BrevisDisputeTransactor) PostRequestData(opts *bind.TransactOpts, _proofId [32]byte, _nonce uint64, _data [][]byte, _index *big.Int, _done bool) (*types.Transaction, error) {
	return _BrevisDispute.contract.Transact(opts, "postRequestData", _proofId, _nonce, _data, _index, _done)
}

// PostRequestData is a paid mutator transaction binding the contract method 0x95b40861.
//
// Solidity: function postRequestData(bytes32 _proofId, uint64 _nonce, bytes[] _data, uint256 _index, bool _done) returns()
func (_BrevisDispute *BrevisDisputeSession) PostRequestData(_proofId [32]byte, _nonce uint64, _data [][]byte, _index *big.Int, _done bool) (*types.Transaction, error) {
	return _BrevisDispute.Contract.PostRequestData(&_BrevisDispute.TransactOpts, _proofId, _nonce, _data, _index, _done)
}

// PostRequestData is a paid mutator transaction binding the contract method 0x95b40861.
//
// Solidity: function postRequestData(bytes32 _proofId, uint64 _nonce, bytes[] _data, uint256 _index, bool _done) returns()
func (_BrevisDispute *BrevisDisputeTransactorSession) PostRequestData(_proofId [32]byte, _nonce uint64, _data [][]byte, _index *big.Int, _done bool) (*types.Transaction, error) {
	return _BrevisDispute.Contract.PostRequestData(&_BrevisDispute.TransactOpts, _proofId, _nonce, _data, _index, _done)
}

// SetChallengeWindow is a paid mutator transaction binding the contract method 0x01c1aa0d.
//
// Solidity: function setChallengeWindow(uint256 _challengeWindow) returns()
func (_BrevisDispute *BrevisDisputeTransactor) SetChallengeWindow(opts *bind.TransactOpts, _challengeWindow *big.Int) (*types.Transaction, error) {
	return _BrevisDispute.contract.Transact(opts, "setChallengeWindow", _challengeWindow)
}

// SetChallengeWindow is a paid mutator transaction binding the contract method 0x01c1aa0d.
//
// Solidity: function setChallengeWindow(uint256 _challengeWindow) returns()
func (_BrevisDispute *BrevisDisputeSession) SetChallengeWindow(_challengeWindow *big.Int) (*types.Transaction, error) {
	return _BrevisDispute.Contract.SetChallengeWindow(&_BrevisDispute.TransactOpts, _challengeWindow)
}

// SetChallengeWindow is a paid mutator transaction binding the contract method 0x01c1aa0d.
//
// Solidity: function setChallengeWindow(uint256 _challengeWindow) returns()
func (_BrevisDispute *BrevisDisputeTransactorSession) SetChallengeWindow(_challengeWindow *big.Int) (*types.Transaction, error) {
	return _BrevisDispute.Contract.SetChallengeWindow(&_BrevisDispute.TransactOpts, _challengeWindow)
}

// SetDisputeDeposits is a paid mutator transaction binding the contract method 0x9bdf0469.
//
// Solidity: function setDisputeDeposits(uint256 _amtAskForData, uint256 _amtAskForProof) returns()
func (_BrevisDispute *BrevisDisputeTransactor) SetDisputeDeposits(opts *bind.TransactOpts, _amtAskForData *big.Int, _amtAskForProof *big.Int) (*types.Transaction, error) {
	return _BrevisDispute.contract.Transact(opts, "setDisputeDeposits", _amtAskForData, _amtAskForProof)
}

// SetDisputeDeposits is a paid mutator transaction binding the contract method 0x9bdf0469.
//
// Solidity: function setDisputeDeposits(uint256 _amtAskForData, uint256 _amtAskForProof) returns()
func (_BrevisDispute *BrevisDisputeSession) SetDisputeDeposits(_amtAskForData *big.Int, _amtAskForProof *big.Int) (*types.Transaction, error) {
	return _BrevisDispute.Contract.SetDisputeDeposits(&_BrevisDispute.TransactOpts, _amtAskForData, _amtAskForProof)
}

// SetDisputeDeposits is a paid mutator transaction binding the contract method 0x9bdf0469.
//
// Solidity: function setDisputeDeposits(uint256 _amtAskForData, uint256 _amtAskForProof) returns()
func (_BrevisDispute *BrevisDisputeTransactorSession) SetDisputeDeposits(_amtAskForData *big.Int, _amtAskForProof *big.Int) (*types.Transaction, error) {
	return _BrevisDispute.Contract.SetDisputeDeposits(&_BrevisDispute.TransactOpts, _amtAskForData, _amtAskForProof)
}

// SetResponseTimeout is a paid mutator transaction binding the contract method 0x69dc1903.
//
// Solidity: function setResponseTimeout(uint256 _responseTimeout) returns()
func (_BrevisDispute *BrevisDisputeTransactor) SetResponseTimeout(opts *bind.TransactOpts, _responseTimeout *big.Int) (*types.Transaction, error) {
	return _BrevisDispute.contract.Transact(opts, "setResponseTimeout", _responseTimeout)
}

// SetResponseTimeout is a paid mutator transaction binding the contract method 0x69dc1903.
//
// Solidity: function setResponseTimeout(uint256 _responseTimeout) returns()
func (_BrevisDispute *BrevisDisputeSession) SetResponseTimeout(_responseTimeout *big.Int) (*types.Transaction, error) {
	return _BrevisDispute.Contract.SetResponseTimeout(&_BrevisDispute.TransactOpts, _responseTimeout)
}

// SetResponseTimeout is a paid mutator transaction binding the contract method 0x69dc1903.
//
// Solidity: function setResponseTimeout(uint256 _responseTimeout) returns()
func (_BrevisDispute *BrevisDisputeTransactorSession) SetResponseTimeout(_responseTimeout *big.Int) (*types.Transaction, error) {
	return _BrevisDispute.Contract.SetResponseTimeout(&_BrevisDispute.TransactOpts, _responseTimeout)
}

// BrevisDisputeAskForIterator is returned from FilterAskFor and is used to iterate over the raw logs and unpacked data for AskFor events raised by the BrevisDispute contract.
type BrevisDisputeAskForIterator struct {
	Event *BrevisDisputeAskFor // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisDisputeAskForIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisDisputeAskFor)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisDisputeAskFor)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisDisputeAskForIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisDisputeAskForIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisDisputeAskFor represents a AskFor event raised by the BrevisDispute contract.
type BrevisDisputeAskFor struct {
	ProofId [32]byte
	Nonce   uint64
	Status  uint8
	From    common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterAskFor is a free log retrieval operation binding the contract event 0x305b29c3917a30a5ca5ffefad1a2fd5b6468f8bf644b95831f9097c61e4c7ab6.
//
// Solidity: event AskFor(bytes32 indexed proofId, uint64 nonce, uint8 status, address from)
func (_BrevisDispute *BrevisDisputeFilterer) FilterAskFor(opts *bind.FilterOpts, proofId [][32]byte) (*BrevisDisputeAskForIterator, error) {

	var proofIdRule []interface{}
	for _, proofIdItem := range proofId {
		proofIdRule = append(proofIdRule, proofIdItem)
	}

	logs, sub, err := _BrevisDispute.contract.FilterLogs(opts, "AskFor", proofIdRule)
	if err != nil {
		return nil, err
	}
	return &BrevisDisputeAskForIterator{contract: _BrevisDispute.contract, event: "AskFor", logs: logs, sub: sub}, nil
}

// WatchAskFor is a free log subscription operation binding the contract event 0x305b29c3917a30a5ca5ffefad1a2fd5b6468f8bf644b95831f9097c61e4c7ab6.
//
// Solidity: event AskFor(bytes32 indexed proofId, uint64 nonce, uint8 status, address from)
func (_BrevisDispute *BrevisDisputeFilterer) WatchAskFor(opts *bind.WatchOpts, sink chan<- *BrevisDisputeAskFor, proofId [][32]byte) (event.Subscription, error) {

	var proofIdRule []interface{}
	for _, proofIdItem := range proofId {
		proofIdRule = append(proofIdRule, proofIdItem)
	}

	logs, sub, err := _BrevisDispute.contract.WatchLogs(opts, "AskFor", proofIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisDisputeAskFor)
				if err := _BrevisDispute.contract.UnpackLog(event, "AskFor", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAskFor is a log parse operation binding the contract event 0x305b29c3917a30a5ca5ffefad1a2fd5b6468f8bf644b95831f9097c61e4c7ab6.
//
// Solidity: event AskFor(bytes32 indexed proofId, uint64 nonce, uint8 status, address from)
func (_BrevisDispute *BrevisDisputeFilterer) ParseAskFor(log types.Log) (*BrevisDisputeAskFor, error) {
	event := new(BrevisDisputeAskFor)
	if err := _BrevisDispute.contract.UnpackLog(event, "AskFor", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisDisputeChallengeWindowUpdatedIterator is returned from FilterChallengeWindowUpdated and is used to iterate over the raw logs and unpacked data for ChallengeWindowUpdated events raised by the BrevisDispute contract.
type BrevisDisputeChallengeWindowUpdatedIterator struct {
	Event *BrevisDisputeChallengeWindowUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisDisputeChallengeWindowUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisDisputeChallengeWindowUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisDisputeChallengeWindowUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisDisputeChallengeWindowUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisDisputeChallengeWindowUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisDisputeChallengeWindowUpdated represents a ChallengeWindowUpdated event raised by the BrevisDispute contract.
type BrevisDisputeChallengeWindowUpdated struct {
	From *big.Int
	To   *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterChallengeWindowUpdated is a free log retrieval operation binding the contract event 0xedb9338f4b0faf2b899d2d7f54b90753d2a8ebb34936e381edb91b091c3e45a7.
//
// Solidity: event ChallengeWindowUpdated(uint256 from, uint256 to)
func (_BrevisDispute *BrevisDisputeFilterer) FilterChallengeWindowUpdated(opts *bind.FilterOpts) (*BrevisDisputeChallengeWindowUpdatedIterator, error) {

	logs, sub, err := _BrevisDispute.contract.FilterLogs(opts, "ChallengeWindowUpdated")
	if err != nil {
		return nil, err
	}
	return &BrevisDisputeChallengeWindowUpdatedIterator{contract: _BrevisDispute.contract, event: "ChallengeWindowUpdated", logs: logs, sub: sub}, nil
}

// WatchChallengeWindowUpdated is a free log subscription operation binding the contract event 0xedb9338f4b0faf2b899d2d7f54b90753d2a8ebb34936e381edb91b091c3e45a7.
//
// Solidity: event ChallengeWindowUpdated(uint256 from, uint256 to)
func (_BrevisDispute *BrevisDisputeFilterer) WatchChallengeWindowUpdated(opts *bind.WatchOpts, sink chan<- *BrevisDisputeChallengeWindowUpdated) (event.Subscription, error) {

	logs, sub, err := _BrevisDispute.contract.WatchLogs(opts, "ChallengeWindowUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisDisputeChallengeWindowUpdated)
				if err := _BrevisDispute.contract.UnpackLog(event, "ChallengeWindowUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseChallengeWindowUpdated is a log parse operation binding the contract event 0xedb9338f4b0faf2b899d2d7f54b90753d2a8ebb34936e381edb91b091c3e45a7.
//
// Solidity: event ChallengeWindowUpdated(uint256 from, uint256 to)
func (_BrevisDispute *BrevisDisputeFilterer) ParseChallengeWindowUpdated(log types.Log) (*BrevisDisputeChallengeWindowUpdated, error) {
	event := new(BrevisDisputeChallengeWindowUpdated)
	if err := _BrevisDispute.contract.UnpackLog(event, "ChallengeWindowUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisDisputeDataAvailabilityProofPostedIterator is returned from FilterDataAvailabilityProofPosted and is used to iterate over the raw logs and unpacked data for DataAvailabilityProofPosted events raised by the BrevisDispute contract.
type BrevisDisputeDataAvailabilityProofPostedIterator struct {
	Event *BrevisDisputeDataAvailabilityProofPosted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisDisputeDataAvailabilityProofPostedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisDisputeDataAvailabilityProofPosted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisDisputeDataAvailabilityProofPosted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisDisputeDataAvailabilityProofPostedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisDisputeDataAvailabilityProofPostedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisDisputeDataAvailabilityProofPosted represents a DataAvailabilityProofPosted event raised by the BrevisDispute contract.
type BrevisDisputeDataAvailabilityProofPosted struct {
	ProofId [32]byte
	Nonce   uint64
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterDataAvailabilityProofPosted is a free log retrieval operation binding the contract event 0xa38ccf08432b738adb9d381dbd7ae7ad1aac98357a2a14233bf755a2aa898e2e.
//
// Solidity: event DataAvailabilityProofPosted(bytes32 indexed proofId, uint64 nonce)
func (_BrevisDispute *BrevisDisputeFilterer) FilterDataAvailabilityProofPosted(opts *bind.FilterOpts, proofId [][32]byte) (*BrevisDisputeDataAvailabilityProofPostedIterator, error) {

	var proofIdRule []interface{}
	for _, proofIdItem := range proofId {
		proofIdRule = append(proofIdRule, proofIdItem)
	}

	logs, sub, err := _BrevisDispute.contract.FilterLogs(opts, "DataAvailabilityProofPosted", proofIdRule)
	if err != nil {
		return nil, err
	}
	return &BrevisDisputeDataAvailabilityProofPostedIterator{contract: _BrevisDispute.contract, event: "DataAvailabilityProofPosted", logs: logs, sub: sub}, nil
}

// WatchDataAvailabilityProofPosted is a free log subscription operation binding the contract event 0xa38ccf08432b738adb9d381dbd7ae7ad1aac98357a2a14233bf755a2aa898e2e.
//
// Solidity: event DataAvailabilityProofPosted(bytes32 indexed proofId, uint64 nonce)
func (_BrevisDispute *BrevisDisputeFilterer) WatchDataAvailabilityProofPosted(opts *bind.WatchOpts, sink chan<- *BrevisDisputeDataAvailabilityProofPosted, proofId [][32]byte) (event.Subscription, error) {

	var proofIdRule []interface{}
	for _, proofIdItem := range proofId {
		proofIdRule = append(proofIdRule, proofIdItem)
	}

	logs, sub, err := _BrevisDispute.contract.WatchLogs(opts, "DataAvailabilityProofPosted", proofIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisDisputeDataAvailabilityProofPosted)
				if err := _BrevisDispute.contract.UnpackLog(event, "DataAvailabilityProofPosted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDataAvailabilityProofPosted is a log parse operation binding the contract event 0xa38ccf08432b738adb9d381dbd7ae7ad1aac98357a2a14233bf755a2aa898e2e.
//
// Solidity: event DataAvailabilityProofPosted(bytes32 indexed proofId, uint64 nonce)
func (_BrevisDispute *BrevisDisputeFilterer) ParseDataAvailabilityProofPosted(log types.Log) (*BrevisDisputeDataAvailabilityProofPosted, error) {
	event := new(BrevisDisputeDataAvailabilityProofPosted)
	if err := _BrevisDispute.contract.UnpackLog(event, "DataAvailabilityProofPosted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisDisputeDataValidityProofProofPostedIterator is returned from FilterDataValidityProofProofPosted and is used to iterate over the raw logs and unpacked data for DataValidityProofProofPosted events raised by the BrevisDispute contract.
type BrevisDisputeDataValidityProofProofPostedIterator struct {
	Event *BrevisDisputeDataValidityProofProofPosted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisDisputeDataValidityProofProofPostedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisDisputeDataValidityProofProofPosted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisDisputeDataValidityProofProofPosted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisDisputeDataValidityProofProofPostedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisDisputeDataValidityProofProofPostedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisDisputeDataValidityProofProofPosted represents a DataValidityProofProofPosted event raised by the BrevisDispute contract.
type BrevisDisputeDataValidityProofProofPosted struct {
	ProofId [32]byte
	Nonce   uint64
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterDataValidityProofProofPosted is a free log retrieval operation binding the contract event 0x8474e871e3a8323ba71f5ce5c3c9da0d547fd033dd9274cce4380339a9cdccc6.
//
// Solidity: event DataValidityProofProofPosted(bytes32 indexed proofId, uint64 nonce)
func (_BrevisDispute *BrevisDisputeFilterer) FilterDataValidityProofProofPosted(opts *bind.FilterOpts, proofId [][32]byte) (*BrevisDisputeDataValidityProofProofPostedIterator, error) {

	var proofIdRule []interface{}
	for _, proofIdItem := range proofId {
		proofIdRule = append(proofIdRule, proofIdItem)
	}

	logs, sub, err := _BrevisDispute.contract.FilterLogs(opts, "DataValidityProofProofPosted", proofIdRule)
	if err != nil {
		return nil, err
	}
	return &BrevisDisputeDataValidityProofProofPostedIterator{contract: _BrevisDispute.contract, event: "DataValidityProofProofPosted", logs: logs, sub: sub}, nil
}

// WatchDataValidityProofProofPosted is a free log subscription operation binding the contract event 0x8474e871e3a8323ba71f5ce5c3c9da0d547fd033dd9274cce4380339a9cdccc6.
//
// Solidity: event DataValidityProofProofPosted(bytes32 indexed proofId, uint64 nonce)
func (_BrevisDispute *BrevisDisputeFilterer) WatchDataValidityProofProofPosted(opts *bind.WatchOpts, sink chan<- *BrevisDisputeDataValidityProofProofPosted, proofId [][32]byte) (event.Subscription, error) {

	var proofIdRule []interface{}
	for _, proofIdItem := range proofId {
		proofIdRule = append(proofIdRule, proofIdItem)
	}

	logs, sub, err := _BrevisDispute.contract.WatchLogs(opts, "DataValidityProofProofPosted", proofIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisDisputeDataValidityProofProofPosted)
				if err := _BrevisDispute.contract.UnpackLog(event, "DataValidityProofProofPosted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDataValidityProofProofPosted is a log parse operation binding the contract event 0x8474e871e3a8323ba71f5ce5c3c9da0d547fd033dd9274cce4380339a9cdccc6.
//
// Solidity: event DataValidityProofProofPosted(bytes32 indexed proofId, uint64 nonce)
func (_BrevisDispute *BrevisDisputeFilterer) ParseDataValidityProofProofPosted(log types.Log) (*BrevisDisputeDataValidityProofProofPosted, error) {
	event := new(BrevisDisputeDataValidityProofProofPosted)
	if err := _BrevisDispute.contract.UnpackLog(event, "DataValidityProofProofPosted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisDisputeDisputeDepositsUpdatedIterator is returned from FilterDisputeDepositsUpdated and is used to iterate over the raw logs and unpacked data for DisputeDepositsUpdated events raised by the BrevisDispute contract.
type BrevisDisputeDisputeDepositsUpdatedIterator struct {
	Event *BrevisDisputeDisputeDepositsUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisDisputeDisputeDepositsUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisDisputeDisputeDepositsUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisDisputeDisputeDepositsUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisDisputeDisputeDepositsUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisDisputeDisputeDepositsUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisDisputeDisputeDepositsUpdated represents a DisputeDepositsUpdated event raised by the BrevisDispute contract.
type BrevisDisputeDisputeDepositsUpdated struct {
	AmtAskForData  *big.Int
	AmtAskForProof *big.Int
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterDisputeDepositsUpdated is a free log retrieval operation binding the contract event 0x56ca37d8947ac20c2d621aba1b4f339d6293d1bd4183930bcaf29dbf41e26af2.
//
// Solidity: event DisputeDepositsUpdated(uint256 amtAskForData, uint256 amtAskForProof)
func (_BrevisDispute *BrevisDisputeFilterer) FilterDisputeDepositsUpdated(opts *bind.FilterOpts) (*BrevisDisputeDisputeDepositsUpdatedIterator, error) {

	logs, sub, err := _BrevisDispute.contract.FilterLogs(opts, "DisputeDepositsUpdated")
	if err != nil {
		return nil, err
	}
	return &BrevisDisputeDisputeDepositsUpdatedIterator{contract: _BrevisDispute.contract, event: "DisputeDepositsUpdated", logs: logs, sub: sub}, nil
}

// WatchDisputeDepositsUpdated is a free log subscription operation binding the contract event 0x56ca37d8947ac20c2d621aba1b4f339d6293d1bd4183930bcaf29dbf41e26af2.
//
// Solidity: event DisputeDepositsUpdated(uint256 amtAskForData, uint256 amtAskForProof)
func (_BrevisDispute *BrevisDisputeFilterer) WatchDisputeDepositsUpdated(opts *bind.WatchOpts, sink chan<- *BrevisDisputeDisputeDepositsUpdated) (event.Subscription, error) {

	logs, sub, err := _BrevisDispute.contract.WatchLogs(opts, "DisputeDepositsUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisDisputeDisputeDepositsUpdated)
				if err := _BrevisDispute.contract.UnpackLog(event, "DisputeDepositsUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDisputeDepositsUpdated is a log parse operation binding the contract event 0x56ca37d8947ac20c2d621aba1b4f339d6293d1bd4183930bcaf29dbf41e26af2.
//
// Solidity: event DisputeDepositsUpdated(uint256 amtAskForData, uint256 amtAskForProof)
func (_BrevisDispute *BrevisDisputeFilterer) ParseDisputeDepositsUpdated(log types.Log) (*BrevisDisputeDisputeDepositsUpdated, error) {
	event := new(BrevisDisputeDisputeDepositsUpdated)
	if err := _BrevisDispute.contract.UnpackLog(event, "DisputeDepositsUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisDisputeRequestDataPostedIterator is returned from FilterRequestDataPosted and is used to iterate over the raw logs and unpacked data for RequestDataPosted events raised by the BrevisDispute contract.
type BrevisDisputeRequestDataPostedIterator struct {
	Event *BrevisDisputeRequestDataPosted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisDisputeRequestDataPostedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisDisputeRequestDataPosted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisDisputeRequestDataPosted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisDisputeRequestDataPostedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisDisputeRequestDataPostedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisDisputeRequestDataPosted represents a RequestDataPosted event raised by the BrevisDispute contract.
type BrevisDisputeRequestDataPosted struct {
	ProofId [32]byte
	Nonce   uint64
	Data    [][]byte
	Index   *big.Int
	Done    bool
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRequestDataPosted is a free log retrieval operation binding the contract event 0x635ae6660d964e1393ed692ae764226ddeb8878df97a22e762559a7485f34874.
//
// Solidity: event RequestDataPosted(bytes32 indexed proofId, uint64 nonce, bytes[] data, uint256 index, bool done)
func (_BrevisDispute *BrevisDisputeFilterer) FilterRequestDataPosted(opts *bind.FilterOpts, proofId [][32]byte) (*BrevisDisputeRequestDataPostedIterator, error) {

	var proofIdRule []interface{}
	for _, proofIdItem := range proofId {
		proofIdRule = append(proofIdRule, proofIdItem)
	}

	logs, sub, err := _BrevisDispute.contract.FilterLogs(opts, "RequestDataPosted", proofIdRule)
	if err != nil {
		return nil, err
	}
	return &BrevisDisputeRequestDataPostedIterator{contract: _BrevisDispute.contract, event: "RequestDataPosted", logs: logs, sub: sub}, nil
}

// WatchRequestDataPosted is a free log subscription operation binding the contract event 0x635ae6660d964e1393ed692ae764226ddeb8878df97a22e762559a7485f34874.
//
// Solidity: event RequestDataPosted(bytes32 indexed proofId, uint64 nonce, bytes[] data, uint256 index, bool done)
func (_BrevisDispute *BrevisDisputeFilterer) WatchRequestDataPosted(opts *bind.WatchOpts, sink chan<- *BrevisDisputeRequestDataPosted, proofId [][32]byte) (event.Subscription, error) {

	var proofIdRule []interface{}
	for _, proofIdItem := range proofId {
		proofIdRule = append(proofIdRule, proofIdItem)
	}

	logs, sub, err := _BrevisDispute.contract.WatchLogs(opts, "RequestDataPosted", proofIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisDisputeRequestDataPosted)
				if err := _BrevisDispute.contract.UnpackLog(event, "RequestDataPosted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestDataPosted is a log parse operation binding the contract event 0x635ae6660d964e1393ed692ae764226ddeb8878df97a22e762559a7485f34874.
//
// Solidity: event RequestDataPosted(bytes32 indexed proofId, uint64 nonce, bytes[] data, uint256 index, bool done)
func (_BrevisDispute *BrevisDisputeFilterer) ParseRequestDataPosted(log types.Log) (*BrevisDisputeRequestDataPosted, error) {
	event := new(BrevisDisputeRequestDataPosted)
	if err := _BrevisDispute.contract.UnpackLog(event, "RequestDataPosted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisDisputeResponseTimeoutUpdatedIterator is returned from FilterResponseTimeoutUpdated and is used to iterate over the raw logs and unpacked data for ResponseTimeoutUpdated events raised by the BrevisDispute contract.
type BrevisDisputeResponseTimeoutUpdatedIterator struct {
	Event *BrevisDisputeResponseTimeoutUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisDisputeResponseTimeoutUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisDisputeResponseTimeoutUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisDisputeResponseTimeoutUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisDisputeResponseTimeoutUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisDisputeResponseTimeoutUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisDisputeResponseTimeoutUpdated represents a ResponseTimeoutUpdated event raised by the BrevisDispute contract.
type BrevisDisputeResponseTimeoutUpdated struct {
	From *big.Int
	To   *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterResponseTimeoutUpdated is a free log retrieval operation binding the contract event 0x86fe7fc31f35681a1ed77325f0cf24935a5d25b1861e7ce9ceed9cb67f222270.
//
// Solidity: event ResponseTimeoutUpdated(uint256 from, uint256 to)
func (_BrevisDispute *BrevisDisputeFilterer) FilterResponseTimeoutUpdated(opts *bind.FilterOpts) (*BrevisDisputeResponseTimeoutUpdatedIterator, error) {

	logs, sub, err := _BrevisDispute.contract.FilterLogs(opts, "ResponseTimeoutUpdated")
	if err != nil {
		return nil, err
	}
	return &BrevisDisputeResponseTimeoutUpdatedIterator{contract: _BrevisDispute.contract, event: "ResponseTimeoutUpdated", logs: logs, sub: sub}, nil
}

// WatchResponseTimeoutUpdated is a free log subscription operation binding the contract event 0x86fe7fc31f35681a1ed77325f0cf24935a5d25b1861e7ce9ceed9cb67f222270.
//
// Solidity: event ResponseTimeoutUpdated(uint256 from, uint256 to)
func (_BrevisDispute *BrevisDisputeFilterer) WatchResponseTimeoutUpdated(opts *bind.WatchOpts, sink chan<- *BrevisDisputeResponseTimeoutUpdated) (event.Subscription, error) {

	logs, sub, err := _BrevisDispute.contract.WatchLogs(opts, "ResponseTimeoutUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisDisputeResponseTimeoutUpdated)
				if err := _BrevisDispute.contract.UnpackLog(event, "ResponseTimeoutUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseResponseTimeoutUpdated is a log parse operation binding the contract event 0x86fe7fc31f35681a1ed77325f0cf24935a5d25b1861e7ce9ceed9cb67f222270.
//
// Solidity: event ResponseTimeoutUpdated(uint256 from, uint256 to)
func (_BrevisDispute *BrevisDisputeFilterer) ParseResponseTimeoutUpdated(log types.Log) (*BrevisDisputeResponseTimeoutUpdated, error) {
	event := new(BrevisDisputeResponseTimeoutUpdated)
	if err := _BrevisDispute.contract.UnpackLog(event, "ResponseTimeoutUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisProofMetaData contains all meta data concerning the BrevisProof contract.
var BrevisProofMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"contractISMT\",\"name\":\"_smtContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64[]\",\"name\":\"chainIds\",\"type\":\"uint64[]\"},{\"indexed\":false,\"internalType\":\"contractIZkpVerifier[]\",\"name\":\"newAddresses\",\"type\":\"address[]\"}],\"name\":\"AggProofVerifierAddressesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"smtContract\",\"type\":\"address\"}],\"name\":\"SmtContractUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64[]\",\"name\":\"chainIds\",\"type\":\"uint64[]\"},{\"indexed\":false,\"internalType\":\"contractIZkpVerifier[]\",\"name\":\"newAddresses\",\"type\":\"address[]\"}],\"name\":\"VerifierAddressesUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addPausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"addProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"aggProofVerifierAddress\",\"outputs\":[{\"internalType\":\"contractIZkpVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isActiveProver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"merkleRoots\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numPausers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numProvers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pauserList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"proofs\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proverStates\",\"outputs\":[{\"internalType\":\"enumBrevisAccess.ProverState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"provers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removePausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"removeProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"smtContract\",\"outputs\":[{\"internalType\":\"contractISMT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proofIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"_proofWithPubInputs\",\"type\":\"bytes\"}],\"name\":\"submitAggProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_proofWithPubInputs\",\"type\":\"bytes\"}],\"name\":\"submitProof\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"proofId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appVkHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64[]\",\"name\":\"_chainIds\",\"type\":\"uint64[]\"},{\"internalType\":\"contractIZkpVerifier[]\",\"name\":\"_verifierAddresses\",\"type\":\"address[]\"}],\"name\":\"updateAggProofVerifierAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractISMT\",\"name\":\"_smtContract\",\"type\":\"address\"}],\"name\":\"updateSmtContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64[]\",\"name\":\"_chainIds\",\"type\":\"uint64[]\"},{\"internalType\":\"contractIZkpVerifier[]\",\"name\":\"_verifierAddresses\",\"type\":\"address[]\"}],\"name\":\"updateVerifierAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"commitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"vkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"smtRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBrevis.ProofData[]\",\"name\":\"_proofDataArray\",\"type\":\"tuple[]\"}],\"name\":\"validateAggProofData\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"commitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"vkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"smtRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBrevis.ProofData\",\"name\":\"_proofData\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint8\",\"name\":\"_nodeIndex\",\"type\":\"uint8\"}],\"name\":\"validateAggProofData\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_appVkHash\",\"type\":\"bytes32\"}],\"name\":\"validateProofAppData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"verifierAddresses\",\"outputs\":[{\"internalType\":\"contractIZkpVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x608034620001b357601f6200256d38819003918201601f1916830192916001600160401b03841183851017620001b75780839260409586528339602092839181010312620001b357516001600160a01b03808216929091839003620001b3575f918254855191339082167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08680a36001600160a81b0319163360ff60a01b1981169190911784558352600182528483205460ff16620001735750600254680100000000000000008110156200015f5760018101806002558110156200014b5790847f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f89260028552828520019360018060a01b03199433868254161790553381526001835220600160ff198254161790558451338152a16005541617600555516123a19081620001cc8239f35b634e487b7160e01b83526032600452602483fd5b634e487b7160e01b83526041600452602483fd5b60649162461bcd60e51b82526004820152601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152fd5b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe60406080815260049081361015610014575f80fd5b5f91823560e01c80631396511e14611811578063158535ff146117df5780633221aec6146117b75780633bda38a3146114435780633f4ba83a14611342578063444d95b01461131b57806346fbf68e14610c925780634f4fef18146112fe57806350d410631461123e57806358a16b441461121f5780635c975abb146111fa578063677625f214610fda5780636b2c0f5514610fa35780636ef8d66d14610f895780637b1cc45014610d9e5780637dbafb1114610cce57806380f51c1214610c9257806382dc1ec414610c585780638456cb5914610b3f5780638da5cb5b14610b195780639017837014610ac8578063a036e79914610a78578063b4f7a72714610797578063ceae339014610756578063e04409531461047d578063e6c6fcec1461042d578063e79b7a51146103d4578063ec64842e14610378578063f2fde38b1461029b578063f5cec6af1461025a578063fabc74f5146101fc578063fd1190ea146101b85763fe5a537714610189575f80fd5b346101b45760203660031901126101b4578160209360ff923581526006855220541690519015158152f35b8280fd5b5091346101f95760203660031901126101f957823592548310156101f957506001600160a01b036101ea6020936118cc565b92905490519260031b1c168152f35b80fd5b50919034610256576020366003190112610256576001600160a01b0361022061191c565b168252600360205260ff8183205416905191600382101561024357602083838152f35b634e487b7160e01b815260218452602490fd5b5080fd5b505034610256576020366003190112610256576001600160a01b038160209367ffffffffffffffff61028a611901565b168152600885522054169051908152f35b50346101b45760203660031901126101b4576102b561191c565b908354906001600160a01b03808316936102d0338614611cf7565b1693841561030f5750506001600160a01b031916821783557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b906020608492519162461bcd60e51b8352820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152fd5b5082346101f95760203660031901126101f9576001600160a01b0361039b61191c565b168152600360205260ff83822054169160038310156103c1576020836001865191148152f35b634e487b7160e01b825260219052602490fd5b83346101f9576103e336611a14565b906001600160a01b03916103fb838354163314611cf7565b815b8151811015610429578061041f856104186104249486611e94565b51166120ca565b611ba2565b6103fd565b8280f35b83346101f95761043c36611a14565b906001600160a01b0391610454838354163314611cf7565b815b8151811015610429578061041f856104716104789486611e94565b5116611ef4565b610456565b5090346101b457806003193601126101b457610497611901565b906024359267ffffffffffffffff93848111610752576104ba9036908301611a9d565b90913387526020916003835260ff8589205416600381101561073f5760016104e29114611acb565b8686168852600883526001600160a01b039384868a20541680156106fc5784875180926322bb937360e11b8252818061051e88888b8401611b2f565b03915afa9081156106f2579061053b918b916106d5575b50611b56565b85519760a08901908111898210176106c257865288885288848901528588019489865260608901978a895260808a01918b835261058161057b8686611e52565b90611e78565b809b5261059161057b8686611e65565b809352610200948086116106be576101e0850135809952610220116106ba576105f19487940135809a526005541690885180958194829363080cdb0b60e11b84528984016020909392919367ffffffffffffffff60408201951681520152565b03915afa9081156106b0578891610683575b50156106425750606095838051838101908582528783820152828152610628816119c2565b519020918781526009845220558251948552840152820152f35b60649184519162461bcd60e51b8352820152601260248201527f736d7420726f6f74206e6f742076616c696400000000000000000000000000006044820152fd5b6106a39150833d85116106a9575b61069b81836119f2565b810190611b17565b5f610603565b503d610691565b85513d8a823e3d90fd5b8b80fd5b8c80fd5b634e487b7160e01b8a526041845260248afd5b6106ec9150863d88116106a95761069b81836119f2565b5f610535565b87513d8c823e3d90fd5b865162461bcd60e51b8152808501869052601660248201527f636861696e207665726966696572206e6f7420736574000000000000000000006044820152606490fd5b634e487b7160e01b895260218352602489fd5b8580fd5b505034610256576020366003190112610256576001600160a01b038160209367ffffffffffffffff610786611901565b168152600785522054169051908152f35b5090346101b45760603660031901126101b4576107b2611901565b91602467ffffffffffffffff8135818111610a74576107d49036908501611946565b9093604435838111610a70576107ed9036908301611a9d565b959094338a526020966003885260ff898c2054169960038b1015610a5e57869061081a6001809d14611acb565b168b52600788526001600160a01b03898c2054168015610a1e5789516322bb937360e11b815290899082908180610854878e8c8401611b2f565b03915afa908c8215610a135761057b9261088b949261087892916109fc5750611b56565b61088561057b828b611e52565b98611e65565b9288519261020090818501858110898211176109ea578b52813686378c5b8781106109cb57505060109586811061097b575b50895195898701948d908d8c885b8585106109665750505050505085526102208501958587109087111761095557505083875282519020036109115750508452600690528220805460ff1916909117905580f35b907f70726f6f66496473206e6f7420726967687400000000000000000000000000006102646064938662461bcd60e51b855261022482015260126102448201520152fd5b634e487b7160e01b8b526041905289fd5b819084518152019201920191908c8f916108cb565b805b87811061098a57506108bd565b5f1982018281116109b957906109a36109b49288611bd4565b516109ae8289611bd4565b52611ba2565b61097d565b634e487b7160e01b8f5260118552858ffd5b806109da6109e5928a85611bc4565b356109ae8289611bd4565b6108a9565b634e487b7160e01b8e5260418452848efd5b6106ec91508c8d3d106106a95761069b81836119f2565b8b51903d90823e3d90fd5b6064858a85818e519362461bcd60e51b85528401528201527f636861696e206167672070726f6f66207665726966696572206e6f74207365746044820152fd5b634e487b7160e01b8c5260218552828cfd5b8880fd5b8680fd5b83346101f957610a8736611a14565b906001600160a01b0391610a9f838354163314611cf7565b815b8151811015610429578061041f85610abc610ac39486611e94565b51166121af565b610aa1565b50346101b45760603660031901126101b45781602093610b1292358152600985522054825184810190602435825260443585820152848152610b09816119c2565b51902014611cab565b5160018152f35b5050346102565781600319360112610256576001600160a01b0360209254169051908152f35b5090346101b457826003193601126101b457338352600191602090838252610b6c60ff8487205416611ea8565b845460ff8160a01c16610c165760ff60a01b197401000000000000000000000000000000000000000091161785557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258828451338152a184845b610bcd578580f35b8154811015610c1257806001600160a01b03610beb610c0c936118cc565b919054600392831b1c1688528452848720600260ff19825416179055611ba2565b84610bc5565b8580f35b50915162461bcd60e51b815291820152601060248201527f5061757361626c653a20706175736564000000000000000000000000000000006044820152606490fd5b83346101f95760203660031901126101f957610c8f610c7561191c565b610c8a6001600160a01b038454163314611cf7565b6120ca565b80f35b5050346102565760203660031901126102565760ff816020936001600160a01b03610cbb61191c565b1681526001855220541690519015158152f35b50503461025657610cde36611977565b91936001600160a01b03610cf6818854163314611cf7565b610d01848714611d42565b865b868110610d4457877f4a5f8b4623084de3ef4b23e6c713416b50a966a1914aaf21175d206015e59d4e8888610d3e8989895194859485611db7565b0390a180f35b80610d5b610d56610d99938888611bc4565b611d8e565b67ffffffffffffffff610d77610d72848c8c611bc4565b611da2565b168a52600760205283858b2091166001600160a01b0319825416179055611ba2565b610d03565b509190346102565761012036600319011261025657610dbb611901565b9160a03660231901126101f95760c4359360e43567ffffffffffffffff81116101b457610deb9036908301611946565b9095610104359660ff958689168099036107525782865260209160068352610e17888389205416611c5f565b600554825163080cdb0b60e11b815267ffffffffffffffff909a168a880190815260a435602082018190529a91859183916001600160a01b0316908290819060400103915afa908115610f7f5790610e76918991610f62575b50611bf5565b815160248035858301908152602081019b909b5260443560408c015260643560608c015260843560808c01529990610ebb8160a084015b03601f1981018352826119f2565b5190209387945b89861688811015610f56578a91908d811c600116610f2757610ee5908986611bc4565b3585519087820192835286820152858152610eff816119c2565b519020955b16898114610f155760010194610ec2565b634e487b7160e01b8952601188528a89fd5b610f32908986611bc4565b359085519087820192835286820152858152610f4d816119c2565b51902095610f04565b89610c8f838514611cab565b610f799150853d87116106a95761069b81836119f2565b5f610e70565b83513d8a823e3d90fd5b83346101f957806003193601126101f957610c8f336121af565b83346101f95760203660031901126101f957610c8f610fc061191c565b610fd56001600160a01b038454163314611cf7565b6121af565b5082346101f957602092836003193601126102565767ffffffffffffffff9280358481116111f657366023820112156111f657808201359485116111e3578460051b9083519561102c888401886119f2565b86528686016024809383010191368311610a74579083899201905b8382106111cc575050505083546001600160a01b039161106a3384841614611cf7565b60ff9160a01c8216156111c4576002925b865b88518110156111c05781611091828b611e94565b51168089526003808c5285898b205416818110156111ae5761116c5787546801000000000000000081101561115a57826110d38260016110f394018c556118cc565b90919082549060031b916001600160a01b03809116831b921b1916179055565b818a52808c52888a2090871015611148578b61114393927fef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd0396849260ff19815416898b161790558a51908152a1611ba2565b61107d565b634e487b7160e01b8a5260218852848afd5b634e487b7160e01b8b5260418952858bfd5b885162461bcd60e51b81528089018d90526011818701527f6163636f756e742069732070726f7665720000000000000000000000000000006044820152606490fd5b634e487b7160e01b8b5260218952858bfd5b8780f35b60019261107b565b8280916111d884611932565b815201910190611047565b634e487b7160e01b845260418252602484fd5b8380fd5b50503461025657816003193601126102565760ff6020925460a01c1690519015158152f35b5050346102565781600319360112610256576020906002549051908152f35b5050346102565761124e36611977565b91936001600160a01b03611266818854163314611cf7565b611271848714611d42565b865b8681106112ae57877f10ec8ad6a03997446c98d9aabf3ad339cc9621ec7cd4b47b04fe1ba8f75b42238888610d3e8989895194859485611db7565b806112c0610d566112f9938888611bc4565b67ffffffffffffffff6112d7610d72848c8c611bc4565b168a52600860205283858b2091166001600160a01b0319825416179055611ba2565b611273565b50346101b457826003193601126101b45760209250549051908152f35b50346101b45760203660031901126101b45760209282913581526009845220549051908152f35b50919034610256578160031936011261025657338252600190602082815261136f60ff8386205416611ea8565b83549460ff8660a01c16156114025760ff60a01b198495961686557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa828451338152a185935b6113bd578580f35b8054841015610c12576113fc846001600160a01b036113dc88976118cc565b919054600392831b1c16895284528488208660ff19825416179055611ba2565b936113b5565b915162461bcd60e51b815291820152601460248201527f5061757361626c653a206e6f74207061757365640000000000000000000000006044820152606490fd5b50346101b457816003193601126101b45761145c611901565b90602480359167ffffffffffffffff93848411610a745736602385011215610a745783820135908582116117b3578385019484369160a085020101116117b357601094858311611771578751966103e0908189019081118982101761175f5789939293523688376005546001600160a01b03169089805b8581106116485750505050508381106115fb575b5085835b61150c5786610c8f60ff886103c08901518452600660205283205416611c5f565b919486949193965b5f1988018881116115e9578110156115cc576115396115338286611c52565b84611c41565b516115448286611c52565b906001918281018091116115ba5761159b916115636115959288611c41565b51865190602082019283528782015286815261157e816119c2565b519020928461158d8d8a611c52565b911c90611c52565b85611c41565b52600281018091111561151457634e487b7160e01b8652601185528686fd5b634e487b7160e01b8952601188528989fd5b509491866115de919794929597611c52565b9260011c92836114eb565b634e487b7160e01b8752601186528787fd5b5f19810190808211905b8581106116135750506114e7565b8161163657611631906116268489611c41565b516109ae828a611c41565b611605565b634e487b7160e01b8952601184528489fd5b60808b611691858a8461165c878d8d611be5565b013584518094819263080cdb0b60e11b8352602095869584016020909392919367ffffffffffffffff60408201951681520152565b03818b5afa9586156117545761173696611729936116b4929161173d5750611bf5565b610ead6116c2868c8c611be5565b35946116cf878d8d611be5565b0135938a8c60606116fd8a876116e6828688611be5565b013593866116f5838389611be5565b013595611be5565b0135925196879586019889939160a0959391855260208501526040840152606083015260808201520190565b5190206109ae828c611c41565b8a906114d3565b610f799150833d85116106a95761069b81836119f2565b8351903d90823e3d90fd5b634e487b7160e01b8b5260418652868bfd5b875162461bcd60e51b8152602081860152600c818701527f73697a65206578636565647300000000000000000000000000000000000000006044820152606490fd5b8780fd5b5050346102565781600319360112610256576020906001600160a01b03600554169051908152f35b50346101b45760203660031901126101b45735916002548310156101f957506001600160a01b036101ea602093611883565b50346101b45760203660031901126101b457356001600160a01b03908181168091036111f6577f674c535cde998bcb47d0688f644df545597c7d6edb95643cb21c82c2d490ff7f926118696020938654163314611cf7565b816001600160a01b0319600554161760055551908152a180f35b6002548110156118b85760025f527f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace01905f90565b634e487b7160e01b5f52603260045260245ffd5b6004548110156118b85760045f527f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b01905f90565b6004359067ffffffffffffffff8216820361191857565b5f80fd5b600435906001600160a01b038216820361191857565b35906001600160a01b038216820361191857565b9181601f840112156119185782359167ffffffffffffffff8311611918576020808501948460051b01011161191857565b60406003198201126119185767ffffffffffffffff9160043583811161191857826119a491600401611946565b93909392602435918211611918576119be91600401611946565b9091565b6060810190811067ffffffffffffffff8211176119de57604052565b634e487b7160e01b5f52604160045260245ffd5b90601f8019910116810190811067ffffffffffffffff8211176119de57604052565b6020806003198301126119185767ffffffffffffffff9160043583811161191857816023820112156119185780600401359384116119de578360051b9060405194611a61858401876119f2565b855260248486019282010192831161191857602401905b828210611a86575050505090565b838091611a9284611932565b815201910190611a78565b9181601f840112156119185782359167ffffffffffffffff8311611918576020838186019501011161191857565b15611ad257565b60405162461bcd60e51b815260206004820152601260248201527f6e6f7420696e76616c69642070726f76657200000000000000000000000000006044820152606490fd5b90816020910312611918575180151581036119185790565b90918060409360208452816020850152848401375f828201840152601f01601f1916010190565b15611b5d57565b60405162461bcd60e51b815260206004820152600f60248201527f70726f6f66206e6f742076616c696400000000000000000000000000000000006044820152606490fd5b5f198114611bb05760010190565b634e487b7160e01b5f52601160045260245ffd5b91908110156118b85760051b0190565b9060108110156118b85760051b0190565b91908110156118b85760a0020190565b15611bfc57565b60405162461bcd60e51b815260206004820152601060248201527f696e76616c696420736d7420726f6f74000000000000000000000000000000006044820152606490fd5b90601f8110156118b85760051b0190565b91908201809211611bb057565b15611c6657565b60405162461bcd60e51b815260206004820152601660248201527f6d65726b6c6520726f6f74206e6f7420657869737473000000000000000000006044820152606490fd5b15611cb257565b60405162461bcd60e51b815260206004820152600c60248201527f696e76616c6964206461746100000000000000000000000000000000000000006044820152606490fd5b15611cfe57565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b15611d4957565b60405162461bcd60e51b815260206004820152601060248201527f6c656e677468206e6f74206d61746368000000000000000000000000000000006044820152606490fd5b356001600160a01b03811681036119185790565b3567ffffffffffffffff811681036119185790565b90929391806040830160408452526060820193905f905b808210611e245750505080830360209182015281835291820192915f5b828110611df9575050505090565b909192938435906001600160a01b038216809203611918579081528201938201929190600101611deb565b9091939484359067ffffffffffffffff82168092036119185790815260209081019594019160010190611dce565b906101a011611918576101800190602090565b906101c011611918576101a00190602090565b359060208110611e86575090565b5f199060200360031b1b1690565b80518210156118b85760209160051b010190565b15611eaf57565b60405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f74207061757365720000000000000000000000006044820152606490fd5b6001600160a01b03809116915f83815260039360209185835260409060ff8282205416878110156120b65715612072576004968754965f199081890198891161205f57835b8a5481101561201c578682611f4d836118cc565b905490871b1c1614611f6757611f6290611ba2565b611f39565b909192939495969798808210611ff7575b50505087548015611fe45797849392917fd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d98598990190611fce611fb9836118cc565b6001600160a01b0382549160031b1b19169055565b55848252855220805460ff1916905551908152a1565b634e487b7160e01b845260318952602484fd5b612014926120076110d3926118cc565b905490871b1c16916118cc565b5f8080611f78565b855162461bcd60e51b8152808c01899052601060248201527f70726f766572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b634e487b7160e01b845260118a52602484fd5b815162461bcd60e51b815260048101859052601560248201527f6163636f756e74206973206e6f742070726f76657200000000000000000000006044820152606490fd5b634e487b7160e01b82526021600452602482fd5b6001600160a01b038116905f90828252600160205260ff60408320541661216a57600254680100000000000000008110156121565760209261213a7f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f895936110d384600160409601600255611883565b8281526001845220600160ff19825416179055604051908152a1565b634e487b7160e01b83526041600452602483fd5b60405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152606490fd5b6001600160a01b03809116905f9282845260019060209382855260409360ff858820541615612327576002805490915f199182810190811161231357908695949392918a975b61223e575b885162461bcd60e51b8152600481018b9052601060248201527f706175736572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b8399989799548a101561230a5781856122568c611883565b929054600393841b1c161461227f57506122768798999a97959697611ba2565b979695946121f5565b92939497969599918183106122e5575b50505050815480156122d157918493917fcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e9899930190611fce611fb983611883565b634e487b7160e01b89526031600452602489fd5b612301936122f56110d393611883565b9054911b1c1691611883565b5f80808061228f565b879899506121fa565b634e487b7160e01b8a52601160045260248afd5b845162461bcd60e51b815260048101879052601560248201527f4163636f756e74206973206e6f742070617573657200000000000000000000006044820152606490fdfea2646970667358221220321cf657bd594f7d235f0103f13073543f68a06d98b1ecf6f7a1540727dcad7564736f6c63430008140033",
}

// BrevisProofABI is the input ABI used to generate the binding from.
// Deprecated: Use BrevisProofMetaData.ABI instead.
var BrevisProofABI = BrevisProofMetaData.ABI

// BrevisProofBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use BrevisProofMetaData.Bin instead.
var BrevisProofBin = BrevisProofMetaData.Bin

// DeployBrevisProof deploys a new Ethereum contract, binding an instance of BrevisProof to it.
func DeployBrevisProof(auth *bind.TransactOpts, backend bind.ContractBackend, _smtContract common.Address) (common.Address, *types.Transaction, *BrevisProof, error) {
	parsed, err := BrevisProofMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(BrevisProofBin), backend, _smtContract)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &BrevisProof{BrevisProofCaller: BrevisProofCaller{contract: contract}, BrevisProofTransactor: BrevisProofTransactor{contract: contract}, BrevisProofFilterer: BrevisProofFilterer{contract: contract}}, nil
}

// BrevisProof is an auto generated Go binding around an Ethereum contract.
type BrevisProof struct {
	BrevisProofCaller     // Read-only binding to the contract
	BrevisProofTransactor // Write-only binding to the contract
	BrevisProofFilterer   // Log filterer for contract events
}

// BrevisProofCaller is an auto generated read-only Go binding around an Ethereum contract.
type BrevisProofCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisProofTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BrevisProofTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisProofFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BrevisProofFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisProofSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BrevisProofSession struct {
	Contract     *BrevisProof      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BrevisProofCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BrevisProofCallerSession struct {
	Contract *BrevisProofCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// BrevisProofTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BrevisProofTransactorSession struct {
	Contract     *BrevisProofTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// BrevisProofRaw is an auto generated low-level Go binding around an Ethereum contract.
type BrevisProofRaw struct {
	Contract *BrevisProof // Generic contract binding to access the raw methods on
}

// BrevisProofCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BrevisProofCallerRaw struct {
	Contract *BrevisProofCaller // Generic read-only contract binding to access the raw methods on
}

// BrevisProofTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BrevisProofTransactorRaw struct {
	Contract *BrevisProofTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBrevisProof creates a new instance of BrevisProof, bound to a specific deployed contract.
func NewBrevisProof(address common.Address, backend bind.ContractBackend) (*BrevisProof, error) {
	contract, err := bindBrevisProof(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BrevisProof{BrevisProofCaller: BrevisProofCaller{contract: contract}, BrevisProofTransactor: BrevisProofTransactor{contract: contract}, BrevisProofFilterer: BrevisProofFilterer{contract: contract}}, nil
}

// NewBrevisProofCaller creates a new read-only instance of BrevisProof, bound to a specific deployed contract.
func NewBrevisProofCaller(address common.Address, caller bind.ContractCaller) (*BrevisProofCaller, error) {
	contract, err := bindBrevisProof(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BrevisProofCaller{contract: contract}, nil
}

// NewBrevisProofTransactor creates a new write-only instance of BrevisProof, bound to a specific deployed contract.
func NewBrevisProofTransactor(address common.Address, transactor bind.ContractTransactor) (*BrevisProofTransactor, error) {
	contract, err := bindBrevisProof(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BrevisProofTransactor{contract: contract}, nil
}

// NewBrevisProofFilterer creates a new log filterer instance of BrevisProof, bound to a specific deployed contract.
func NewBrevisProofFilterer(address common.Address, filterer bind.ContractFilterer) (*BrevisProofFilterer, error) {
	contract, err := bindBrevisProof(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BrevisProofFilterer{contract: contract}, nil
}

// bindBrevisProof binds a generic wrapper to an already deployed contract.
func bindBrevisProof(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BrevisProofMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BrevisProof *BrevisProofRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BrevisProof.Contract.BrevisProofCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BrevisProof *BrevisProofRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisProof.Contract.BrevisProofTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BrevisProof *BrevisProofRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BrevisProof.Contract.BrevisProofTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BrevisProof *BrevisProofCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BrevisProof.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BrevisProof *BrevisProofTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisProof.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BrevisProof *BrevisProofTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BrevisProof.Contract.contract.Transact(opts, method, params...)
}

// AggProofVerifierAddress is a free data retrieval call binding the contract method 0xceae3390.
//
// Solidity: function aggProofVerifierAddress(uint64 ) view returns(address)
func (_BrevisProof *BrevisProofCaller) AggProofVerifierAddress(opts *bind.CallOpts, arg0 uint64) (common.Address, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "aggProofVerifierAddress", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// AggProofVerifierAddress is a free data retrieval call binding the contract method 0xceae3390.
//
// Solidity: function aggProofVerifierAddress(uint64 ) view returns(address)
func (_BrevisProof *BrevisProofSession) AggProofVerifierAddress(arg0 uint64) (common.Address, error) {
	return _BrevisProof.Contract.AggProofVerifierAddress(&_BrevisProof.CallOpts, arg0)
}

// AggProofVerifierAddress is a free data retrieval call binding the contract method 0xceae3390.
//
// Solidity: function aggProofVerifierAddress(uint64 ) view returns(address)
func (_BrevisProof *BrevisProofCallerSession) AggProofVerifierAddress(arg0 uint64) (common.Address, error) {
	return _BrevisProof.Contract.AggProofVerifierAddress(&_BrevisProof.CallOpts, arg0)
}

// IsActiveProver is a free data retrieval call binding the contract method 0xec64842e.
//
// Solidity: function isActiveProver(address _account) view returns(bool)
func (_BrevisProof *BrevisProofCaller) IsActiveProver(opts *bind.CallOpts, _account common.Address) (bool, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "isActiveProver", _account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsActiveProver is a free data retrieval call binding the contract method 0xec64842e.
//
// Solidity: function isActiveProver(address _account) view returns(bool)
func (_BrevisProof *BrevisProofSession) IsActiveProver(_account common.Address) (bool, error) {
	return _BrevisProof.Contract.IsActiveProver(&_BrevisProof.CallOpts, _account)
}

// IsActiveProver is a free data retrieval call binding the contract method 0xec64842e.
//
// Solidity: function isActiveProver(address _account) view returns(bool)
func (_BrevisProof *BrevisProofCallerSession) IsActiveProver(_account common.Address) (bool, error) {
	return _BrevisProof.Contract.IsActiveProver(&_BrevisProof.CallOpts, _account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BrevisProof *BrevisProofCaller) IsPauser(opts *bind.CallOpts, account common.Address) (bool, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "isPauser", account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BrevisProof *BrevisProofSession) IsPauser(account common.Address) (bool, error) {
	return _BrevisProof.Contract.IsPauser(&_BrevisProof.CallOpts, account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BrevisProof *BrevisProofCallerSession) IsPauser(account common.Address) (bool, error) {
	return _BrevisProof.Contract.IsPauser(&_BrevisProof.CallOpts, account)
}

// MerkleRoots is a free data retrieval call binding the contract method 0xfe5a5377.
//
// Solidity: function merkleRoots(bytes32 ) view returns(bool)
func (_BrevisProof *BrevisProofCaller) MerkleRoots(opts *bind.CallOpts, arg0 [32]byte) (bool, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "merkleRoots", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// MerkleRoots is a free data retrieval call binding the contract method 0xfe5a5377.
//
// Solidity: function merkleRoots(bytes32 ) view returns(bool)
func (_BrevisProof *BrevisProofSession) MerkleRoots(arg0 [32]byte) (bool, error) {
	return _BrevisProof.Contract.MerkleRoots(&_BrevisProof.CallOpts, arg0)
}

// MerkleRoots is a free data retrieval call binding the contract method 0xfe5a5377.
//
// Solidity: function merkleRoots(bytes32 ) view returns(bool)
func (_BrevisProof *BrevisProofCallerSession) MerkleRoots(arg0 [32]byte) (bool, error) {
	return _BrevisProof.Contract.MerkleRoots(&_BrevisProof.CallOpts, arg0)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BrevisProof *BrevisProofCaller) NumPausers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "numPausers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BrevisProof *BrevisProofSession) NumPausers() (*big.Int, error) {
	return _BrevisProof.Contract.NumPausers(&_BrevisProof.CallOpts)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BrevisProof *BrevisProofCallerSession) NumPausers() (*big.Int, error) {
	return _BrevisProof.Contract.NumPausers(&_BrevisProof.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BrevisProof *BrevisProofCaller) NumProvers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "numProvers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BrevisProof *BrevisProofSession) NumProvers() (*big.Int, error) {
	return _BrevisProof.Contract.NumProvers(&_BrevisProof.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BrevisProof *BrevisProofCallerSession) NumProvers() (*big.Int, error) {
	return _BrevisProof.Contract.NumProvers(&_BrevisProof.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BrevisProof *BrevisProofCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BrevisProof *BrevisProofSession) Owner() (common.Address, error) {
	return _BrevisProof.Contract.Owner(&_BrevisProof.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BrevisProof *BrevisProofCallerSession) Owner() (common.Address, error) {
	return _BrevisProof.Contract.Owner(&_BrevisProof.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BrevisProof *BrevisProofCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BrevisProof *BrevisProofSession) Paused() (bool, error) {
	return _BrevisProof.Contract.Paused(&_BrevisProof.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BrevisProof *BrevisProofCallerSession) Paused() (bool, error) {
	return _BrevisProof.Contract.Paused(&_BrevisProof.CallOpts)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BrevisProof *BrevisProofCaller) PauserList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "pauserList", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BrevisProof *BrevisProofSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _BrevisProof.Contract.PauserList(&_BrevisProof.CallOpts, arg0)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BrevisProof *BrevisProofCallerSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _BrevisProof.Contract.PauserList(&_BrevisProof.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BrevisProof *BrevisProofCaller) Pausers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "pausers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BrevisProof *BrevisProofSession) Pausers(arg0 common.Address) (bool, error) {
	return _BrevisProof.Contract.Pausers(&_BrevisProof.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BrevisProof *BrevisProofCallerSession) Pausers(arg0 common.Address) (bool, error) {
	return _BrevisProof.Contract.Pausers(&_BrevisProof.CallOpts, arg0)
}

// Proofs is a free data retrieval call binding the contract method 0x444d95b0.
//
// Solidity: function proofs(bytes32 ) view returns(bytes32)
func (_BrevisProof *BrevisProofCaller) Proofs(opts *bind.CallOpts, arg0 [32]byte) ([32]byte, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "proofs", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// Proofs is a free data retrieval call binding the contract method 0x444d95b0.
//
// Solidity: function proofs(bytes32 ) view returns(bytes32)
func (_BrevisProof *BrevisProofSession) Proofs(arg0 [32]byte) ([32]byte, error) {
	return _BrevisProof.Contract.Proofs(&_BrevisProof.CallOpts, arg0)
}

// Proofs is a free data retrieval call binding the contract method 0x444d95b0.
//
// Solidity: function proofs(bytes32 ) view returns(bytes32)
func (_BrevisProof *BrevisProofCallerSession) Proofs(arg0 [32]byte) ([32]byte, error) {
	return _BrevisProof.Contract.Proofs(&_BrevisProof.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BrevisProof *BrevisProofCaller) ProverStates(opts *bind.CallOpts, arg0 common.Address) (uint8, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "proverStates", arg0)

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BrevisProof *BrevisProofSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _BrevisProof.Contract.ProverStates(&_BrevisProof.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BrevisProof *BrevisProofCallerSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _BrevisProof.Contract.ProverStates(&_BrevisProof.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BrevisProof *BrevisProofCaller) Provers(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "provers", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BrevisProof *BrevisProofSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _BrevisProof.Contract.Provers(&_BrevisProof.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BrevisProof *BrevisProofCallerSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _BrevisProof.Contract.Provers(&_BrevisProof.CallOpts, arg0)
}

// SmtContract is a free data retrieval call binding the contract method 0x3221aec6.
//
// Solidity: function smtContract() view returns(address)
func (_BrevisProof *BrevisProofCaller) SmtContract(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "smtContract")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SmtContract is a free data retrieval call binding the contract method 0x3221aec6.
//
// Solidity: function smtContract() view returns(address)
func (_BrevisProof *BrevisProofSession) SmtContract() (common.Address, error) {
	return _BrevisProof.Contract.SmtContract(&_BrevisProof.CallOpts)
}

// SmtContract is a free data retrieval call binding the contract method 0x3221aec6.
//
// Solidity: function smtContract() view returns(address)
func (_BrevisProof *BrevisProofCallerSession) SmtContract() (common.Address, error) {
	return _BrevisProof.Contract.SmtContract(&_BrevisProof.CallOpts)
}

// ValidateAggProofData is a free data retrieval call binding the contract method 0x3bda38a3.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray) view returns()
func (_BrevisProof *BrevisProofCaller) ValidateAggProofData(opts *bind.CallOpts, _chainId uint64, _proofDataArray []BrevisProofData) error {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "validateAggProofData", _chainId, _proofDataArray)

	if err != nil {
		return err
	}

	return err

}

// ValidateAggProofData is a free data retrieval call binding the contract method 0x3bda38a3.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray) view returns()
func (_BrevisProof *BrevisProofSession) ValidateAggProofData(_chainId uint64, _proofDataArray []BrevisProofData) error {
	return _BrevisProof.Contract.ValidateAggProofData(&_BrevisProof.CallOpts, _chainId, _proofDataArray)
}

// ValidateAggProofData is a free data retrieval call binding the contract method 0x3bda38a3.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray) view returns()
func (_BrevisProof *BrevisProofCallerSession) ValidateAggProofData(_chainId uint64, _proofDataArray []BrevisProofData) error {
	return _BrevisProof.Contract.ValidateAggProofData(&_BrevisProof.CallOpts, _chainId, _proofDataArray)
}

// ValidateAggProofData0 is a free data retrieval call binding the contract method 0x7b1cc450.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32) _proofData, bytes32 _merkleRoot, bytes32[] _merkleProof, uint8 _nodeIndex) view returns()
func (_BrevisProof *BrevisProofCaller) ValidateAggProofData0(opts *bind.CallOpts, _chainId uint64, _proofData BrevisProofData, _merkleRoot [32]byte, _merkleProof [][32]byte, _nodeIndex uint8) error {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "validateAggProofData0", _chainId, _proofData, _merkleRoot, _merkleProof, _nodeIndex)

	if err != nil {
		return err
	}

	return err

}

// ValidateAggProofData0 is a free data retrieval call binding the contract method 0x7b1cc450.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32) _proofData, bytes32 _merkleRoot, bytes32[] _merkleProof, uint8 _nodeIndex) view returns()
func (_BrevisProof *BrevisProofSession) ValidateAggProofData0(_chainId uint64, _proofData BrevisProofData, _merkleRoot [32]byte, _merkleProof [][32]byte, _nodeIndex uint8) error {
	return _BrevisProof.Contract.ValidateAggProofData0(&_BrevisProof.CallOpts, _chainId, _proofData, _merkleRoot, _merkleProof, _nodeIndex)
}

// ValidateAggProofData0 is a free data retrieval call binding the contract method 0x7b1cc450.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32) _proofData, bytes32 _merkleRoot, bytes32[] _merkleProof, uint8 _nodeIndex) view returns()
func (_BrevisProof *BrevisProofCallerSession) ValidateAggProofData0(_chainId uint64, _proofData BrevisProofData, _merkleRoot [32]byte, _merkleProof [][32]byte, _nodeIndex uint8) error {
	return _BrevisProof.Contract.ValidateAggProofData0(&_BrevisProof.CallOpts, _chainId, _proofData, _merkleRoot, _merkleProof, _nodeIndex)
}

// ValidateProofAppData is a free data retrieval call binding the contract method 0x90178370.
//
// Solidity: function validateProofAppData(bytes32 _proofId, bytes32 _appCommitHash, bytes32 _appVkHash) view returns(bool)
func (_BrevisProof *BrevisProofCaller) ValidateProofAppData(opts *bind.CallOpts, _proofId [32]byte, _appCommitHash [32]byte, _appVkHash [32]byte) (bool, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "validateProofAppData", _proofId, _appCommitHash, _appVkHash)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// ValidateProofAppData is a free data retrieval call binding the contract method 0x90178370.
//
// Solidity: function validateProofAppData(bytes32 _proofId, bytes32 _appCommitHash, bytes32 _appVkHash) view returns(bool)
func (_BrevisProof *BrevisProofSession) ValidateProofAppData(_proofId [32]byte, _appCommitHash [32]byte, _appVkHash [32]byte) (bool, error) {
	return _BrevisProof.Contract.ValidateProofAppData(&_BrevisProof.CallOpts, _proofId, _appCommitHash, _appVkHash)
}

// ValidateProofAppData is a free data retrieval call binding the contract method 0x90178370.
//
// Solidity: function validateProofAppData(bytes32 _proofId, bytes32 _appCommitHash, bytes32 _appVkHash) view returns(bool)
func (_BrevisProof *BrevisProofCallerSession) ValidateProofAppData(_proofId [32]byte, _appCommitHash [32]byte, _appVkHash [32]byte) (bool, error) {
	return _BrevisProof.Contract.ValidateProofAppData(&_BrevisProof.CallOpts, _proofId, _appCommitHash, _appVkHash)
}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_BrevisProof *BrevisProofCaller) VerifierAddresses(opts *bind.CallOpts, arg0 uint64) (common.Address, error) {
	var out []interface{}
	err := _BrevisProof.contract.Call(opts, &out, "verifierAddresses", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_BrevisProof *BrevisProofSession) VerifierAddresses(arg0 uint64) (common.Address, error) {
	return _BrevisProof.Contract.VerifierAddresses(&_BrevisProof.CallOpts, arg0)
}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_BrevisProof *BrevisProofCallerSession) VerifierAddresses(arg0 uint64) (common.Address, error) {
	return _BrevisProof.Contract.VerifierAddresses(&_BrevisProof.CallOpts, arg0)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BrevisProof *BrevisProofTransactor) AddPauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "addPauser", account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BrevisProof *BrevisProofSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.AddPauser(&_BrevisProof.TransactOpts, account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BrevisProof *BrevisProofTransactorSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.AddPauser(&_BrevisProof.TransactOpts, account)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BrevisProof *BrevisProofTransactor) AddPausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "addPausers", accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BrevisProof *BrevisProofSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.AddPausers(&_BrevisProof.TransactOpts, accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BrevisProof *BrevisProofTransactorSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.AddPausers(&_BrevisProof.TransactOpts, accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BrevisProof *BrevisProofTransactor) AddProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "addProvers", _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BrevisProof *BrevisProofSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.AddProvers(&_BrevisProof.TransactOpts, _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BrevisProof *BrevisProofTransactorSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.AddProvers(&_BrevisProof.TransactOpts, _accounts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BrevisProof *BrevisProofTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BrevisProof *BrevisProofSession) Pause() (*types.Transaction, error) {
	return _BrevisProof.Contract.Pause(&_BrevisProof.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BrevisProof *BrevisProofTransactorSession) Pause() (*types.Transaction, error) {
	return _BrevisProof.Contract.Pause(&_BrevisProof.TransactOpts)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BrevisProof *BrevisProofTransactor) RemovePauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "removePauser", account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BrevisProof *BrevisProofSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.RemovePauser(&_BrevisProof.TransactOpts, account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BrevisProof *BrevisProofTransactorSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.RemovePauser(&_BrevisProof.TransactOpts, account)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BrevisProof *BrevisProofTransactor) RemovePausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "removePausers", accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BrevisProof *BrevisProofSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.RemovePausers(&_BrevisProof.TransactOpts, accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BrevisProof *BrevisProofTransactorSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.RemovePausers(&_BrevisProof.TransactOpts, accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BrevisProof *BrevisProofTransactor) RemoveProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "removeProvers", _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BrevisProof *BrevisProofSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.RemoveProvers(&_BrevisProof.TransactOpts, _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BrevisProof *BrevisProofTransactorSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.RemoveProvers(&_BrevisProof.TransactOpts, _accounts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BrevisProof *BrevisProofTransactor) RenouncePauser(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "renouncePauser")
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BrevisProof *BrevisProofSession) RenouncePauser() (*types.Transaction, error) {
	return _BrevisProof.Contract.RenouncePauser(&_BrevisProof.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BrevisProof *BrevisProofTransactorSession) RenouncePauser() (*types.Transaction, error) {
	return _BrevisProof.Contract.RenouncePauser(&_BrevisProof.TransactOpts)
}

// SubmitAggProof is a paid mutator transaction binding the contract method 0xb4f7a727.
//
// Solidity: function submitAggProof(uint64 _chainId, bytes32[] _proofIds, bytes _proofWithPubInputs) returns()
func (_BrevisProof *BrevisProofTransactor) SubmitAggProof(opts *bind.TransactOpts, _chainId uint64, _proofIds [][32]byte, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "submitAggProof", _chainId, _proofIds, _proofWithPubInputs)
}

// SubmitAggProof is a paid mutator transaction binding the contract method 0xb4f7a727.
//
// Solidity: function submitAggProof(uint64 _chainId, bytes32[] _proofIds, bytes _proofWithPubInputs) returns()
func (_BrevisProof *BrevisProofSession) SubmitAggProof(_chainId uint64, _proofIds [][32]byte, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _BrevisProof.Contract.SubmitAggProof(&_BrevisProof.TransactOpts, _chainId, _proofIds, _proofWithPubInputs)
}

// SubmitAggProof is a paid mutator transaction binding the contract method 0xb4f7a727.
//
// Solidity: function submitAggProof(uint64 _chainId, bytes32[] _proofIds, bytes _proofWithPubInputs) returns()
func (_BrevisProof *BrevisProofTransactorSession) SubmitAggProof(_chainId uint64, _proofIds [][32]byte, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _BrevisProof.Contract.SubmitAggProof(&_BrevisProof.TransactOpts, _chainId, _proofIds, _proofWithPubInputs)
}

// SubmitProof is a paid mutator transaction binding the contract method 0xe0440953.
//
// Solidity: function submitProof(uint64 _chainId, bytes _proofWithPubInputs) returns(bytes32 proofId, bytes32 appCommitHash, bytes32 appVkHash)
func (_BrevisProof *BrevisProofTransactor) SubmitProof(opts *bind.TransactOpts, _chainId uint64, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "submitProof", _chainId, _proofWithPubInputs)
}

// SubmitProof is a paid mutator transaction binding the contract method 0xe0440953.
//
// Solidity: function submitProof(uint64 _chainId, bytes _proofWithPubInputs) returns(bytes32 proofId, bytes32 appCommitHash, bytes32 appVkHash)
func (_BrevisProof *BrevisProofSession) SubmitProof(_chainId uint64, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _BrevisProof.Contract.SubmitProof(&_BrevisProof.TransactOpts, _chainId, _proofWithPubInputs)
}

// SubmitProof is a paid mutator transaction binding the contract method 0xe0440953.
//
// Solidity: function submitProof(uint64 _chainId, bytes _proofWithPubInputs) returns(bytes32 proofId, bytes32 appCommitHash, bytes32 appVkHash)
func (_BrevisProof *BrevisProofTransactorSession) SubmitProof(_chainId uint64, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _BrevisProof.Contract.SubmitProof(&_BrevisProof.TransactOpts, _chainId, _proofWithPubInputs)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BrevisProof *BrevisProofTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BrevisProof *BrevisProofSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.TransferOwnership(&_BrevisProof.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BrevisProof *BrevisProofTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.TransferOwnership(&_BrevisProof.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BrevisProof *BrevisProofTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BrevisProof *BrevisProofSession) Unpause() (*types.Transaction, error) {
	return _BrevisProof.Contract.Unpause(&_BrevisProof.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BrevisProof *BrevisProofTransactorSession) Unpause() (*types.Transaction, error) {
	return _BrevisProof.Contract.Unpause(&_BrevisProof.TransactOpts)
}

// UpdateAggProofVerifierAddresses is a paid mutator transaction binding the contract method 0x7dbafb11.
//
// Solidity: function updateAggProofVerifierAddresses(uint64[] _chainIds, address[] _verifierAddresses) returns()
func (_BrevisProof *BrevisProofTransactor) UpdateAggProofVerifierAddresses(opts *bind.TransactOpts, _chainIds []uint64, _verifierAddresses []common.Address) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "updateAggProofVerifierAddresses", _chainIds, _verifierAddresses)
}

// UpdateAggProofVerifierAddresses is a paid mutator transaction binding the contract method 0x7dbafb11.
//
// Solidity: function updateAggProofVerifierAddresses(uint64[] _chainIds, address[] _verifierAddresses) returns()
func (_BrevisProof *BrevisProofSession) UpdateAggProofVerifierAddresses(_chainIds []uint64, _verifierAddresses []common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.UpdateAggProofVerifierAddresses(&_BrevisProof.TransactOpts, _chainIds, _verifierAddresses)
}

// UpdateAggProofVerifierAddresses is a paid mutator transaction binding the contract method 0x7dbafb11.
//
// Solidity: function updateAggProofVerifierAddresses(uint64[] _chainIds, address[] _verifierAddresses) returns()
func (_BrevisProof *BrevisProofTransactorSession) UpdateAggProofVerifierAddresses(_chainIds []uint64, _verifierAddresses []common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.UpdateAggProofVerifierAddresses(&_BrevisProof.TransactOpts, _chainIds, _verifierAddresses)
}

// UpdateSmtContract is a paid mutator transaction binding the contract method 0x1396511e.
//
// Solidity: function updateSmtContract(address _smtContract) returns()
func (_BrevisProof *BrevisProofTransactor) UpdateSmtContract(opts *bind.TransactOpts, _smtContract common.Address) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "updateSmtContract", _smtContract)
}

// UpdateSmtContract is a paid mutator transaction binding the contract method 0x1396511e.
//
// Solidity: function updateSmtContract(address _smtContract) returns()
func (_BrevisProof *BrevisProofSession) UpdateSmtContract(_smtContract common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.UpdateSmtContract(&_BrevisProof.TransactOpts, _smtContract)
}

// UpdateSmtContract is a paid mutator transaction binding the contract method 0x1396511e.
//
// Solidity: function updateSmtContract(address _smtContract) returns()
func (_BrevisProof *BrevisProofTransactorSession) UpdateSmtContract(_smtContract common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.UpdateSmtContract(&_BrevisProof.TransactOpts, _smtContract)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0x50d41063.
//
// Solidity: function updateVerifierAddress(uint64[] _chainIds, address[] _verifierAddresses) returns()
func (_BrevisProof *BrevisProofTransactor) UpdateVerifierAddress(opts *bind.TransactOpts, _chainIds []uint64, _verifierAddresses []common.Address) (*types.Transaction, error) {
	return _BrevisProof.contract.Transact(opts, "updateVerifierAddress", _chainIds, _verifierAddresses)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0x50d41063.
//
// Solidity: function updateVerifierAddress(uint64[] _chainIds, address[] _verifierAddresses) returns()
func (_BrevisProof *BrevisProofSession) UpdateVerifierAddress(_chainIds []uint64, _verifierAddresses []common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.UpdateVerifierAddress(&_BrevisProof.TransactOpts, _chainIds, _verifierAddresses)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0x50d41063.
//
// Solidity: function updateVerifierAddress(uint64[] _chainIds, address[] _verifierAddresses) returns()
func (_BrevisProof *BrevisProofTransactorSession) UpdateVerifierAddress(_chainIds []uint64, _verifierAddresses []common.Address) (*types.Transaction, error) {
	return _BrevisProof.Contract.UpdateVerifierAddress(&_BrevisProof.TransactOpts, _chainIds, _verifierAddresses)
}

// BrevisProofAggProofVerifierAddressesUpdatedIterator is returned from FilterAggProofVerifierAddressesUpdated and is used to iterate over the raw logs and unpacked data for AggProofVerifierAddressesUpdated events raised by the BrevisProof contract.
type BrevisProofAggProofVerifierAddressesUpdatedIterator struct {
	Event *BrevisProofAggProofVerifierAddressesUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisProofAggProofVerifierAddressesUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisProofAggProofVerifierAddressesUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisProofAggProofVerifierAddressesUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisProofAggProofVerifierAddressesUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisProofAggProofVerifierAddressesUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisProofAggProofVerifierAddressesUpdated represents a AggProofVerifierAddressesUpdated event raised by the BrevisProof contract.
type BrevisProofAggProofVerifierAddressesUpdated struct {
	ChainIds     []uint64
	NewAddresses []common.Address
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterAggProofVerifierAddressesUpdated is a free log retrieval operation binding the contract event 0x4a5f8b4623084de3ef4b23e6c713416b50a966a1914aaf21175d206015e59d4e.
//
// Solidity: event AggProofVerifierAddressesUpdated(uint64[] chainIds, address[] newAddresses)
func (_BrevisProof *BrevisProofFilterer) FilterAggProofVerifierAddressesUpdated(opts *bind.FilterOpts) (*BrevisProofAggProofVerifierAddressesUpdatedIterator, error) {

	logs, sub, err := _BrevisProof.contract.FilterLogs(opts, "AggProofVerifierAddressesUpdated")
	if err != nil {
		return nil, err
	}
	return &BrevisProofAggProofVerifierAddressesUpdatedIterator{contract: _BrevisProof.contract, event: "AggProofVerifierAddressesUpdated", logs: logs, sub: sub}, nil
}

// WatchAggProofVerifierAddressesUpdated is a free log subscription operation binding the contract event 0x4a5f8b4623084de3ef4b23e6c713416b50a966a1914aaf21175d206015e59d4e.
//
// Solidity: event AggProofVerifierAddressesUpdated(uint64[] chainIds, address[] newAddresses)
func (_BrevisProof *BrevisProofFilterer) WatchAggProofVerifierAddressesUpdated(opts *bind.WatchOpts, sink chan<- *BrevisProofAggProofVerifierAddressesUpdated) (event.Subscription, error) {

	logs, sub, err := _BrevisProof.contract.WatchLogs(opts, "AggProofVerifierAddressesUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisProofAggProofVerifierAddressesUpdated)
				if err := _BrevisProof.contract.UnpackLog(event, "AggProofVerifierAddressesUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAggProofVerifierAddressesUpdated is a log parse operation binding the contract event 0x4a5f8b4623084de3ef4b23e6c713416b50a966a1914aaf21175d206015e59d4e.
//
// Solidity: event AggProofVerifierAddressesUpdated(uint64[] chainIds, address[] newAddresses)
func (_BrevisProof *BrevisProofFilterer) ParseAggProofVerifierAddressesUpdated(log types.Log) (*BrevisProofAggProofVerifierAddressesUpdated, error) {
	event := new(BrevisProofAggProofVerifierAddressesUpdated)
	if err := _BrevisProof.contract.UnpackLog(event, "AggProofVerifierAddressesUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisProofOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the BrevisProof contract.
type BrevisProofOwnershipTransferredIterator struct {
	Event *BrevisProofOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisProofOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisProofOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisProofOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisProofOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisProofOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisProofOwnershipTransferred represents a OwnershipTransferred event raised by the BrevisProof contract.
type BrevisProofOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BrevisProof *BrevisProofFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*BrevisProofOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BrevisProof.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &BrevisProofOwnershipTransferredIterator{contract: _BrevisProof.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BrevisProof *BrevisProofFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *BrevisProofOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BrevisProof.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisProofOwnershipTransferred)
				if err := _BrevisProof.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BrevisProof *BrevisProofFilterer) ParseOwnershipTransferred(log types.Log) (*BrevisProofOwnershipTransferred, error) {
	event := new(BrevisProofOwnershipTransferred)
	if err := _BrevisProof.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisProofPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the BrevisProof contract.
type BrevisProofPausedIterator struct {
	Event *BrevisProofPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisProofPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisProofPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisProofPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisProofPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisProofPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisProofPaused represents a Paused event raised by the BrevisProof contract.
type BrevisProofPaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BrevisProof *BrevisProofFilterer) FilterPaused(opts *bind.FilterOpts) (*BrevisProofPausedIterator, error) {

	logs, sub, err := _BrevisProof.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &BrevisProofPausedIterator{contract: _BrevisProof.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BrevisProof *BrevisProofFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *BrevisProofPaused) (event.Subscription, error) {

	logs, sub, err := _BrevisProof.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisProofPaused)
				if err := _BrevisProof.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BrevisProof *BrevisProofFilterer) ParsePaused(log types.Log) (*BrevisProofPaused, error) {
	event := new(BrevisProofPaused)
	if err := _BrevisProof.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisProofPauserAddedIterator is returned from FilterPauserAdded and is used to iterate over the raw logs and unpacked data for PauserAdded events raised by the BrevisProof contract.
type BrevisProofPauserAddedIterator struct {
	Event *BrevisProofPauserAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisProofPauserAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisProofPauserAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisProofPauserAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisProofPauserAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisProofPauserAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisProofPauserAdded represents a PauserAdded event raised by the BrevisProof contract.
type BrevisProofPauserAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserAdded is a free log retrieval operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BrevisProof *BrevisProofFilterer) FilterPauserAdded(opts *bind.FilterOpts) (*BrevisProofPauserAddedIterator, error) {

	logs, sub, err := _BrevisProof.contract.FilterLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return &BrevisProofPauserAddedIterator{contract: _BrevisProof.contract, event: "PauserAdded", logs: logs, sub: sub}, nil
}

// WatchPauserAdded is a free log subscription operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BrevisProof *BrevisProofFilterer) WatchPauserAdded(opts *bind.WatchOpts, sink chan<- *BrevisProofPauserAdded) (event.Subscription, error) {

	logs, sub, err := _BrevisProof.contract.WatchLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisProofPauserAdded)
				if err := _BrevisProof.contract.UnpackLog(event, "PauserAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserAdded is a log parse operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BrevisProof *BrevisProofFilterer) ParsePauserAdded(log types.Log) (*BrevisProofPauserAdded, error) {
	event := new(BrevisProofPauserAdded)
	if err := _BrevisProof.contract.UnpackLog(event, "PauserAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisProofPauserRemovedIterator is returned from FilterPauserRemoved and is used to iterate over the raw logs and unpacked data for PauserRemoved events raised by the BrevisProof contract.
type BrevisProofPauserRemovedIterator struct {
	Event *BrevisProofPauserRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisProofPauserRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisProofPauserRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisProofPauserRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisProofPauserRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisProofPauserRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisProofPauserRemoved represents a PauserRemoved event raised by the BrevisProof contract.
type BrevisProofPauserRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserRemoved is a free log retrieval operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BrevisProof *BrevisProofFilterer) FilterPauserRemoved(opts *bind.FilterOpts) (*BrevisProofPauserRemovedIterator, error) {

	logs, sub, err := _BrevisProof.contract.FilterLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return &BrevisProofPauserRemovedIterator{contract: _BrevisProof.contract, event: "PauserRemoved", logs: logs, sub: sub}, nil
}

// WatchPauserRemoved is a free log subscription operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BrevisProof *BrevisProofFilterer) WatchPauserRemoved(opts *bind.WatchOpts, sink chan<- *BrevisProofPauserRemoved) (event.Subscription, error) {

	logs, sub, err := _BrevisProof.contract.WatchLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisProofPauserRemoved)
				if err := _BrevisProof.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserRemoved is a log parse operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BrevisProof *BrevisProofFilterer) ParsePauserRemoved(log types.Log) (*BrevisProofPauserRemoved, error) {
	event := new(BrevisProofPauserRemoved)
	if err := _BrevisProof.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisProofProverAddedIterator is returned from FilterProverAdded and is used to iterate over the raw logs and unpacked data for ProverAdded events raised by the BrevisProof contract.
type BrevisProofProverAddedIterator struct {
	Event *BrevisProofProverAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisProofProverAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisProofProverAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisProofProverAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisProofProverAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisProofProverAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisProofProverAdded represents a ProverAdded event raised by the BrevisProof contract.
type BrevisProofProverAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverAdded is a free log retrieval operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BrevisProof *BrevisProofFilterer) FilterProverAdded(opts *bind.FilterOpts) (*BrevisProofProverAddedIterator, error) {

	logs, sub, err := _BrevisProof.contract.FilterLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return &BrevisProofProverAddedIterator{contract: _BrevisProof.contract, event: "ProverAdded", logs: logs, sub: sub}, nil
}

// WatchProverAdded is a free log subscription operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BrevisProof *BrevisProofFilterer) WatchProverAdded(opts *bind.WatchOpts, sink chan<- *BrevisProofProverAdded) (event.Subscription, error) {

	logs, sub, err := _BrevisProof.contract.WatchLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisProofProverAdded)
				if err := _BrevisProof.contract.UnpackLog(event, "ProverAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverAdded is a log parse operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BrevisProof *BrevisProofFilterer) ParseProverAdded(log types.Log) (*BrevisProofProverAdded, error) {
	event := new(BrevisProofProverAdded)
	if err := _BrevisProof.contract.UnpackLog(event, "ProverAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisProofProverRemovedIterator is returned from FilterProverRemoved and is used to iterate over the raw logs and unpacked data for ProverRemoved events raised by the BrevisProof contract.
type BrevisProofProverRemovedIterator struct {
	Event *BrevisProofProverRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisProofProverRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisProofProverRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisProofProverRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisProofProverRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisProofProverRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisProofProverRemoved represents a ProverRemoved event raised by the BrevisProof contract.
type BrevisProofProverRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverRemoved is a free log retrieval operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BrevisProof *BrevisProofFilterer) FilterProverRemoved(opts *bind.FilterOpts) (*BrevisProofProverRemovedIterator, error) {

	logs, sub, err := _BrevisProof.contract.FilterLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return &BrevisProofProverRemovedIterator{contract: _BrevisProof.contract, event: "ProverRemoved", logs: logs, sub: sub}, nil
}

// WatchProverRemoved is a free log subscription operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BrevisProof *BrevisProofFilterer) WatchProverRemoved(opts *bind.WatchOpts, sink chan<- *BrevisProofProverRemoved) (event.Subscription, error) {

	logs, sub, err := _BrevisProof.contract.WatchLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisProofProverRemoved)
				if err := _BrevisProof.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverRemoved is a log parse operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BrevisProof *BrevisProofFilterer) ParseProverRemoved(log types.Log) (*BrevisProofProverRemoved, error) {
	event := new(BrevisProofProverRemoved)
	if err := _BrevisProof.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisProofSmtContractUpdatedIterator is returned from FilterSmtContractUpdated and is used to iterate over the raw logs and unpacked data for SmtContractUpdated events raised by the BrevisProof contract.
type BrevisProofSmtContractUpdatedIterator struct {
	Event *BrevisProofSmtContractUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisProofSmtContractUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisProofSmtContractUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisProofSmtContractUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisProofSmtContractUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisProofSmtContractUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisProofSmtContractUpdated represents a SmtContractUpdated event raised by the BrevisProof contract.
type BrevisProofSmtContractUpdated struct {
	SmtContract common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterSmtContractUpdated is a free log retrieval operation binding the contract event 0x674c535cde998bcb47d0688f644df545597c7d6edb95643cb21c82c2d490ff7f.
//
// Solidity: event SmtContractUpdated(address smtContract)
func (_BrevisProof *BrevisProofFilterer) FilterSmtContractUpdated(opts *bind.FilterOpts) (*BrevisProofSmtContractUpdatedIterator, error) {

	logs, sub, err := _BrevisProof.contract.FilterLogs(opts, "SmtContractUpdated")
	if err != nil {
		return nil, err
	}
	return &BrevisProofSmtContractUpdatedIterator{contract: _BrevisProof.contract, event: "SmtContractUpdated", logs: logs, sub: sub}, nil
}

// WatchSmtContractUpdated is a free log subscription operation binding the contract event 0x674c535cde998bcb47d0688f644df545597c7d6edb95643cb21c82c2d490ff7f.
//
// Solidity: event SmtContractUpdated(address smtContract)
func (_BrevisProof *BrevisProofFilterer) WatchSmtContractUpdated(opts *bind.WatchOpts, sink chan<- *BrevisProofSmtContractUpdated) (event.Subscription, error) {

	logs, sub, err := _BrevisProof.contract.WatchLogs(opts, "SmtContractUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisProofSmtContractUpdated)
				if err := _BrevisProof.contract.UnpackLog(event, "SmtContractUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSmtContractUpdated is a log parse operation binding the contract event 0x674c535cde998bcb47d0688f644df545597c7d6edb95643cb21c82c2d490ff7f.
//
// Solidity: event SmtContractUpdated(address smtContract)
func (_BrevisProof *BrevisProofFilterer) ParseSmtContractUpdated(log types.Log) (*BrevisProofSmtContractUpdated, error) {
	event := new(BrevisProofSmtContractUpdated)
	if err := _BrevisProof.contract.UnpackLog(event, "SmtContractUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisProofUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the BrevisProof contract.
type BrevisProofUnpausedIterator struct {
	Event *BrevisProofUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisProofUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisProofUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisProofUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisProofUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisProofUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisProofUnpaused represents a Unpaused event raised by the BrevisProof contract.
type BrevisProofUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BrevisProof *BrevisProofFilterer) FilterUnpaused(opts *bind.FilterOpts) (*BrevisProofUnpausedIterator, error) {

	logs, sub, err := _BrevisProof.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &BrevisProofUnpausedIterator{contract: _BrevisProof.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BrevisProof *BrevisProofFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *BrevisProofUnpaused) (event.Subscription, error) {

	logs, sub, err := _BrevisProof.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisProofUnpaused)
				if err := _BrevisProof.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BrevisProof *BrevisProofFilterer) ParseUnpaused(log types.Log) (*BrevisProofUnpaused, error) {
	event := new(BrevisProofUnpaused)
	if err := _BrevisProof.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisProofVerifierAddressesUpdatedIterator is returned from FilterVerifierAddressesUpdated and is used to iterate over the raw logs and unpacked data for VerifierAddressesUpdated events raised by the BrevisProof contract.
type BrevisProofVerifierAddressesUpdatedIterator struct {
	Event *BrevisProofVerifierAddressesUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisProofVerifierAddressesUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisProofVerifierAddressesUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisProofVerifierAddressesUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisProofVerifierAddressesUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisProofVerifierAddressesUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisProofVerifierAddressesUpdated represents a VerifierAddressesUpdated event raised by the BrevisProof contract.
type BrevisProofVerifierAddressesUpdated struct {
	ChainIds     []uint64
	NewAddresses []common.Address
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterVerifierAddressesUpdated is a free log retrieval operation binding the contract event 0x10ec8ad6a03997446c98d9aabf3ad339cc9621ec7cd4b47b04fe1ba8f75b4223.
//
// Solidity: event VerifierAddressesUpdated(uint64[] chainIds, address[] newAddresses)
func (_BrevisProof *BrevisProofFilterer) FilterVerifierAddressesUpdated(opts *bind.FilterOpts) (*BrevisProofVerifierAddressesUpdatedIterator, error) {

	logs, sub, err := _BrevisProof.contract.FilterLogs(opts, "VerifierAddressesUpdated")
	if err != nil {
		return nil, err
	}
	return &BrevisProofVerifierAddressesUpdatedIterator{contract: _BrevisProof.contract, event: "VerifierAddressesUpdated", logs: logs, sub: sub}, nil
}

// WatchVerifierAddressesUpdated is a free log subscription operation binding the contract event 0x10ec8ad6a03997446c98d9aabf3ad339cc9621ec7cd4b47b04fe1ba8f75b4223.
//
// Solidity: event VerifierAddressesUpdated(uint64[] chainIds, address[] newAddresses)
func (_BrevisProof *BrevisProofFilterer) WatchVerifierAddressesUpdated(opts *bind.WatchOpts, sink chan<- *BrevisProofVerifierAddressesUpdated) (event.Subscription, error) {

	logs, sub, err := _BrevisProof.contract.WatchLogs(opts, "VerifierAddressesUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisProofVerifierAddressesUpdated)
				if err := _BrevisProof.contract.UnpackLog(event, "VerifierAddressesUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseVerifierAddressesUpdated is a log parse operation binding the contract event 0x10ec8ad6a03997446c98d9aabf3ad339cc9621ec7cd4b47b04fe1ba8f75b4223.
//
// Solidity: event VerifierAddressesUpdated(uint64[] chainIds, address[] newAddresses)
func (_BrevisProof *BrevisProofFilterer) ParseVerifierAddressesUpdated(log types.Log) (*BrevisProofVerifierAddressesUpdated, error) {
	event := new(BrevisProofVerifierAddressesUpdated)
	if err := _BrevisProof.contract.UnpackLog(event, "VerifierAddressesUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestMetaData contains all meta data concerning the BrevisRequest contract.
var BrevisRequestMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeCollector\",\"type\":\"address\"},{\"internalType\":\"contractIBrevisProof\",\"name\":\"_brevisProof\",\"type\":\"address\"},{\"internalType\":\"contractIBvnSigsVerifier\",\"name\":\"_bvnSigsVerifier\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"AvsSigsVerifierUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"from\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"to\",\"type\":\"string\"}],\"name\":\"BaseDataUrlUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"BrevisDisputeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"BrevisProofUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"BvnSigsVerifierUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"FeeCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"FeeCollectorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"proofIds\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"internalType\":\"uint64[]\",\"name\":\"nonces\",\"type\":\"uint64[]\"},{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"appCommitHashes\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"appVkHashes\",\"type\":\"bytes32[]\"}],\"name\":\"OpRequestsFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"proofId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"name\":\"RequestCallbackFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"proofId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"RequestFeeIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"proofId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"name\":\"RequestFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"proofId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"name\":\"RequestRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"proofId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"refundee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"gas\",\"type\":\"uint64\"}],\"indexed\":false,\"internalType\":\"structIBrevisTypes.Callback\",\"name\":\"callback\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"option\",\"type\":\"uint8\"}],\"name\":\"RequestSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"RequestTimeoutUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"proofIds\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"internalType\":\"uint64[]\",\"name\":\"nonces\",\"type\":\"uint64[]\"}],\"name\":\"RequestsCallbackFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"proofIds\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"internalType\":\"uint64[]\",\"name\":\"nonces\",\"type\":\"uint64[]\"}],\"name\":\"RequestsFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addPausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"addProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"commitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"vkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"smtRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBrevis.ProofData\",\"name\":\"_proofData\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint8\",\"name\":\"_nodeIndex\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"_appCircuitOutput\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_callbackTarget\",\"type\":\"address\"}],\"name\":\"applyBrevisAggProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"commitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"vkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"smtRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBrevis.ProofData[]\",\"name\":\"_proofDataArray\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_appCircuitOutputs\",\"type\":\"bytes[]\"},{\"internalType\":\"address[]\",\"name\":\"_callbackTargets\",\"type\":\"address[]\"}],\"name\":\"applyBrevisAggProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_appCircuitOutput\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_callbackTarget\",\"type\":\"address\"}],\"name\":\"applyBrevisProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avsSigsVerifier\",\"outputs\":[{\"internalType\":\"contractIAvsSigsVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseDataURL\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"brevisDispute\",\"outputs\":[{\"internalType\":\"contractIBrevisDispute\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"brevisProof\",\"outputs\":[{\"internalType\":\"contractIBrevisProof\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bvnSigsVerifier\",\"outputs\":[{\"internalType\":\"contractIBvnSigsVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"collectFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"}],\"name\":\"dataURL\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeCollector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_proofIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint64[]\",\"name\":\"_nonces\",\"type\":\"uint64[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_appCommitHashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_appVkHashes\",\"type\":\"bytes32[]\"},{\"components\":[{\"internalType\":\"bytes[]\",\"name\":\"sigs\",\"type\":\"bytes[]\"},{\"internalType\":\"address[]\",\"name\":\"signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"powers\",\"type\":\"uint256[]\"}],\"internalType\":\"structIBvnSigsVerifier.SigInfo\",\"name\":\"_bvnSigInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"blockNum\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"uint32[]\",\"name\":\"nonSignerQuorumBitmapIndices\",\"type\":\"uint32[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"X\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Y\",\"type\":\"uint256\"}],\"internalType\":\"structIAvsSigsVerifier.BN254_G1Point[]\",\"name\":\"nonSignerPubkeys\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"X\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Y\",\"type\":\"uint256\"}],\"internalType\":\"structIAvsSigsVerifier.BN254_G1Point[]\",\"name\":\"quorumApks\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"X\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"Y\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIAvsSigsVerifier.BN254_G2Point\",\"name\":\"apkG2\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"X\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Y\",\"type\":\"uint256\"}],\"internalType\":\"structIAvsSigsVerifier.BN254_G1Point\",\"name\":\"sigma\",\"type\":\"tuple\"},{\"internalType\":\"uint32[]\",\"name\":\"quorumApkIndices\",\"type\":\"uint32[]\"},{\"internalType\":\"uint32[]\",\"name\":\"totalStakeIndices\",\"type\":\"uint32[]\"},{\"internalType\":\"uint32[][]\",\"name\":\"nonSignerStakeIndices\",\"type\":\"uint32[][]\"}],\"internalType\":\"structIAvsSigsVerifier.NonSignerStakesAndSignature\",\"name\":\"params\",\"type\":\"tuple\"}],\"internalType\":\"structIAvsSigsVerifier.SigInfo\",\"name\":\"_avsSigInfo\",\"type\":\"tuple\"}],\"name\":\"fulfillOpRequests\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_appCircuitOutput\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_callbackTarget\",\"type\":\"address\"}],\"name\":\"fulfillRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_proofIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint64[]\",\"name\":\"_nonces\",\"type\":\"uint64[]\"},{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"commitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"vkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"smtRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBrevis.ProofData[]\",\"name\":\"_proofDataArray\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_appCircuitOutputs\",\"type\":\"bytes[]\"},{\"internalType\":\"address[]\",\"name\":\"_callbackTargets\",\"type\":\"address[]\"}],\"name\":\"fulfillRequests\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_addGas\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"_currentFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_refundee\",\"type\":\"address\"}],\"name\":\"increaseGasFee\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isActiveProver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numPausers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numProvers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"onchainRequests\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"feeHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"gas\",\"type\":\"uint64\"}],\"internalType\":\"structIBrevisTypes.Callback\",\"name\":\"callback\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"opdata\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pauserList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proverStates\",\"outputs\":[{\"internalType\":\"enumBrevisAccess.ProverState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"provers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"queryRequestStatus\",\"outputs\":[{\"internalType\":\"enumIBrevisTypes.RequestStatus\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"_challengeWindow\",\"type\":\"uint256\"}],\"name\":\"queryRequestStatus\",\"outputs\":[{\"internalType\":\"enumIBrevisTypes.RequestStatus\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_refundee\",\"type\":\"address\"}],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removePausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"removeProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestTimeout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"requests\",\"outputs\":[{\"internalType\":\"enumIBrevisTypes.RequestStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"option\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_refundee\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"gas\",\"type\":\"uint64\"}],\"internalType\":\"structIBrevisTypes.Callback\",\"name\":\"_callback\",\"type\":\"tuple\"},{\"internalType\":\"uint8\",\"name\":\"_option\",\"type\":\"uint8\"}],\"name\":\"sendRequest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_avsSigsVerifier\",\"type\":\"address\"}],\"name\":\"setAvsSigsVerifier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_url\",\"type\":\"string\"}],\"name\":\"setBaseDataURL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_brevisDispute\",\"type\":\"address\"}],\"name\":\"setBrevisDispute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_brevisProof\",\"type\":\"address\"}],\"name\":\"setBrevisProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bvnSigsVerifier\",\"type\":\"address\"}],\"name\":\"setBvnSigsVerifier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeCollector\",\"type\":\"address\"}],\"name\":\"setFeeCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestKey\",\"type\":\"bytes32\"},{\"internalType\":\"enumIBrevisTypes.RequestStatus\",\"name\":\"_status\",\"type\":\"uint8\"}],\"name\":\"setRequestStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timeout\",\"type\":\"uint256\"}],\"name\":\"setRequestTimeout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"_appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_challengeWindow\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_option\",\"type\":\"uint8\"}],\"name\":\"validateOpAppData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"_appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"_option\",\"type\":\"uint8\"}],\"name\":\"validateOpAppData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_proofIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint64[]\",\"name\":\"_nonces\",\"type\":\"uint64[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_appCommitHashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_appVkHashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"_challengeWindow\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_option\",\"type\":\"uint8\"}],\"name\":\"validateOpAppData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
	Bin: "0x608034620001e157601f6200522738819003918201601f191683019291906001600160401b03841183851017620001e5578160609284926040968752833981010312620001e15780516001600160a01b039182821691829003620001e15760208082015191848316809303620001e15785015193808516809503620001e1575f9081549460018060a01b031995338782161784558851923391167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08580a3600180546001600160a81b031916919091179055338252600283528682205460ff166200019f5750600354680100000000000000008110156200018b576001810180600355811015620001775781879160037f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f89594528382200133878254161790553381526002835220600160ff198254161790558551338152a1816006541617600655600a541617600a555161502d9081620001fa8239f35b634e487b7160e01b82526032600452602482fd5b634e487b7160e01b82526041600452602482fd5b62461bcd60e51b815260048101839052601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152606490fd5b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe6080604052600436101561001a575b3615610018575f80fd5b005b5f3560e01c80630b9c8c41146103745780630dbeefaf1461036f578063158535ff1461036a578063191fa9b61461036557806319d43eb51461036057806325cda16d1461035b57806335d43733146103565780633f20b4c9146103515780633f2b17b11461034c5780633f4ba83a1461034757806346fbf68e146103065780634f4fef181461034257806354eee2f01461033d57806358a16b44146103385780635c975abb14610333578063622b6af41461032e578063666d165114610329578063677625f2146103245780636b2c0f551461031f5780636ef8d66d1461031a5780637a784a1c146103155780637d91f017146103105780637ff7b0d21461030b57806380f51c121461030657806382dc1ec4146103015780638456cb59146102fc57806384c2d279146102f75780638cd2ed66146102f25780638da5cb5b146102ed578063967a6581146102e85780639d866985146102e3578063a036e799146102de578063a42dce80146102d9578063a65b3c06146102d4578063a8135374146102cf578063a90f4bd7146102ca578063b33e1a39146102c5578063b5c06c33146102c0578063bc7c2050146102bb578063c2eaa931146102b6578063c33529ae146102b1578063c415b95c146102ac578063c49af0fa146102a7578063c772c87f146102a2578063c7f5aaa01461029d578063cd97824914610298578063e6c6fcec14610293578063e79b7a511461028e578063ec64842e14610289578063f2fde38b14610284578063fabc74f51461027f578063fb22b7a81461027a578063fc0cfccc146102755763fd1190ea0361000e5761283b565b6126ae565b6125eb565b6125a3565b6124b8565b61246c565b61241e565b6123d0565b612166565b612140565b6120af565b612057565b612003565b611dd1565b611da7565b611ba4565b611ae3565b611a78565b6119da565b611949565b611881565b6117d4565b611786565b611735565b611679565b611654565b6115c9565b611519565b611413565b6113d9565b610d32565b611310565b6112ea565b611158565b6110ee565b6110b4565b610f66565b610e7c565b610e1b565b610df6565b610dd9565b610d90565b610d73565b610c0d565b610be7565b610bca565b610b12565b610aa1565b61085b565b61067e565b6105c8565b6103fb565b610387565b5f91031261038357565b5f80fd5b34610383575f3660031901126103835760206001600160a01b03600b5416604051908152f35b9181601f84011215610383578235916001600160401b038311610383576020838186019501011161038357565b6001600160a01b0381160361038357565b61014435906103f9826103da565b565b346103835760a0366003190112610383576044356024356064356001600160401b038111610383576104319036906004016103ad565b909260843561043f816103da565b6104606104546006546001600160a01b031690565b6001600160a01b031690565b604051630901783760e41b8152600480359082015260248101849052604481018690529290602090849060649082905afa908115610512576001600160a01b03936104c392610517575b506104b6368689611122565b6020815191012014612b5a565b16803b15610383576104ef935f809460405196879586948593633ceb5b5160e11b855260048501613d6d565b03925af18015610512576104ff57005b8061050c61001892610932565b80610379565b612b03565b6105379060203d811161053e575b61052f8183610980565b810190613d55565b505f6104aa565b503d610525565b634e487b7160e01b5f52603260045260245ffd5b60055481101561058e5760055f527f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db001905f90565b610545565b60035481101561058e5760035f527fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b01905f90565b3461038357602036600319011261038357600435600354811015610383576001600160a01b0360209160035f527fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b015416604051908152f35b6001600160401b0381160361038357565b604435906103f982610621565b604090606319011261038357606490565b908160409103126103835790565b60a4359060ff8216820361038357565b6084359060ff8216820361038357565b60c0366003190112610383577fa067fba43ae94917e16e55db2317937adb10c6b47b9c9e3bb33843fef25874ad6024356004356106ba82610621565b604435916106c7836103da565b6106d03661063f565b6106d861065e565b908493604051956001600160a01b03602088018861070f888684906028926001600160c01b031991835260c01b1660208201520190565b0398610723601f199a8b8101835282610980565b51902091600361074561073e855f52600860205260405f2090565b5460ff1690565b9661074f8861171e565b6107598815612894565b169586610850578061076d6107ae9261171e565b61077f610778610e9b565b91826128e0565b426001600160401b0316602082015260ff881660408201526107a9855f52600860205260405f2090565b612904565b1615610848575b610835906108308761084397989961080460405191826107f860208201953487909160349282526bffffffffffffffffffffffff199060601b1660208201520190565b03908101835282610980565b51902091610810610eba565b92835261081d368761295f565b60208401525f52600960205260405f2090565b612999565b6040519586953492876129f7565b0390a1005b3395506107b5565b506107ae600361076d565b34610383576040366003190112610383576024356009811015610383576001600160a01b03600c541633036108a157610018906004355f52600860205260405f206128ec565b60405162461bcd60e51b815260206004820152600e60248201527f696e76616c6964207365747465720000000000000000000000000000000000006044820152606490fd5b90600182811c92168015610914575b602083101461090057565b634e487b7160e01b5f52602260045260245ffd5b91607f16916108f5565b634e487b7160e01b5f52604160045260245ffd5b6001600160401b03811161094557604052565b61091e565b604081019081106001600160401b0382111761094557604052565b602081019081106001600160401b0382111761094557604052565b90601f801991011681019081106001600160401b0382111761094557604052565b604051905f82600d54916109b4836108e6565b80835292600190818116908115610a3957506001146109db575b506103f992500383610980565b600d5f90815291507fd7b6990105719101dabeb77144f2a3385c8033acd3af97e9423a695e81ad1eb55b848310610a1e57506103f993505081016020015f6109ce565b81935090816020925483858a01015201910190918592610a05565b9050602092506103f994915060ff191682840152151560051b8201015f6109ce565b5f5b838110610a6c5750505f910152565b8181015183820152602001610a5d565b90602091610a9581518092818552858086019101610a5b565b601f01601f1916010190565b34610383575f36600319011261038357610ad0610abc6109a1565b604051918291602083526020830190610a7c565b0390f35b9181601f84011215610383578235916001600160401b038311610383576020808501948460051b01011161038357565b908160609103126103835790565b346103835760c03660031901126103835760046001600160401b03813581811161038357610b439036908401610ad4565b60249291923582811161038357610b5d9036908601610ad4565b60449291923584811161038357610b779036908801610ad4565b9160643586811161038357610b8f9036908a01610ad4565b95909460843588811161038357610ba99036908c01610b04565b9760a435908111610383576100189a610bc491369101610650565b98613623565b34610383575f366003190112610383576020600754604051908152f35b34610383575f3660031901126103835760206001600160a01b03600a5416604051908152f35b34610383575f80600319360112610d2f573381526002602052610c3660ff6040832054166147f5565b6001805460ff8160a01c1615610cea5760ff60a01b191681557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa6020604051338152a181815b610c84578280f35b600554811015610ce65780610cdb610cce610cb7610ca4610ce095610559565b90546001600160a01b039160031b1c1690565b6001600160a01b03165f52600460205260405f2090565b805460ff19166001179055565b6131ed565b81610c7c565b8280f35b60405162461bcd60e51b815260206004820152601460248201527f5061757361626c653a206e6f74207061757365640000000000000000000000006044820152606490fd5b80fd5b34610383576020366003190112610383576001600160a01b03600435610d57816103da565b165f526002602052602060ff60405f2054166040519015158152f35b34610383575f366003190112610383576020600554604051908152f35b346103835760c0366003190112610383576020610dcf602435610db281610621565b610dba61065e565b90608435906064359060443590600435614725565b6040519015158152f35b34610383575f366003190112610383576020600354604051908152f35b34610383575f36600319011261038357602060ff60015460a01c166040519015158152f35b34610383576020366003190112610383577f87a73c061f18ffd513249d1d727921e40e348948b01e2979efb36ef4f5204a636040600435610e676001600160a01b035f54163314613f59565b600754908060075582519182526020820152a1005b3461038357602036600319011261038357610ad0610abc60043561418f565b60405190606082018281106001600160401b0382111761094557604052565b604051906103f98261094a565b6001600160401b0381116109455760051b60200190565b60208060031983011261038357600435916001600160401b0383116103835780602384011215610383578260040135610f1681610ec7565b93610f246040519586610980565b81855260248486019260051b82010192831161038357602401905b828210610f4d575050505090565b8380918335610f5b816103da565b815201910190610f3f565b3461038357610f7436610ede565b6001600160a01b035f91610f8c828454163314613f59565b60ff9060019282845460a01c165f146110ad576002915b85855b610fae578680f35b81518110156110a95782610fc28284613394565b5116808852600460209080825260409188838c20541660038110156110a457611064575050611056827fef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd0396849261101a61105e9695614859565b61103e89611039846001600160a01b03165f52600460205260405f2090565b614841565b516001600160a01b0390911681529081906020820190565b0390a16131ed565b85610fa6565b606492519162461bcd60e51b8352820152601160248201527f6163636f756e742069732070726f7665720000000000000000000000000000006044820152fd5b61170a565b8680f35b8391610fa3565b34610383576020366003190112610383576100186004356110d4816103da565b6110e96001600160a01b035f54163314613f59565b614ed0565b34610383575f3660031901126103835761001833614ed0565b6001600160401b03811161094557601f01601f191660200190565b92919261112e82611107565b9161113c6040519384610980565b829481845281830111610383578281602093845f960137010152565b3461038357602080600319360112610383576001600160401b039060043582811161038357366023820112156103835761119c903690602481600401359101611122565b5f916111b36001600160a01b038454163314613f59565b6111bb6109a1565b908251948511610945576111d9856111d4600d546108e6565b613fa4565b80601f86116001146112465750938084957fe7fa7d4cb7253455bd011caadc607a0db44090fd2ea468dd50c5613ac9e9820f959161123b575b508160011b915f199060031b1c191617600d555b61123560405192839283614014565b0390a180f35b90508301515f611212565b600d5f5290601f1986167fd7b6990105719101dabeb77144f2a3385c8033acd3af97e9423a695e81ad1eb59286905b8282106112d25750509186917fe7fa7d4cb7253455bd011caadc607a0db44090fd2ea468dd50c5613ac9e9820f9697600194106112ba575b5050811b01600d55611226565b8501515f1960f88460031b161c191690555f806112ad565b80600185968294968a01518155019501930190611275565b34610383575f3660031901126103835760206001600160a01b03600c5416604051908152f35b3461038357604036600319011261038357602435600435611330826103da565b6001600160a01b0380600154163303611394577ff10cda68996dfb656d49ab0db3c62cc5f0849710633671a337171c3ad9255186916040915f9461138586808080878661c350f161137f613478565b506135d7565b8351928352166020820152a180f35b60405162461bcd60e51b815260206004820152601160248201527f6e6f742066656520636f6c6c6563746f720000000000000000000000000000006044820152606490fd5b34610383576020366003190112610383576100186004356113f9816103da565b61140e6001600160a01b035f54163314613f59565b614d7c565b34610383575f80600319360112610d2f57338152600260205261143c60ff6040832054166147f5565b6001805460ff8160a01c166114d45760ff60a01b197401000000000000000000000000000000000000000091161781557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586020604051338152a181815b6114a1578280f35b600554811015610ce65780610cdb6114c1610cb7610ca46114ce95610559565b805460ff19166002179055565b81611499565b60405162461bcd60e51b815260206004820152601060248201527f5061757361626c653a20706175736564000000000000000000000000000000006044820152606490fd5b346103835760a03660031901126103835760243561153681610621565b600461154061066e565b60206001600160a01b03600c541660405193848092633528638f60e11b82525afa801561051257610ad093611587935f92611599575b506064359060443590600435614725565b60405190151581529081906020820190565b6115bb91925060203d81116115c2575b6115b38183610980565b810190614039565b905f611576565b503d6115a9565b3461038357610160366003190112610383576004356115e781610621565b60a0366023190112610383576001600160401b039060e43582811161038357611614903690600401610ad4565b906101043560ff8116810361038357610124359485116103835761163f6100189536906004016103ad565b93909261164a6103eb565b9560c43590613e7b565b34610383575f3660031901126103835760206001600160a01b035f5416604051908152f35b34610383576020366003190112610383577f032d76868790fdb5fb04c6f54308ddd47ecf8a80e5995610816aa0b29773b5206004356116b7816103da565b6001600160a01b03906116ce825f54163314613f59565b600a80548284166001600160a01b031982161790915560408051939091166001600160a01b039081168452909116602083015281908101610843565b634e487b7160e01b5f52602160045260245ffd5b600911156110a457565b9060098210156110a45752565b34610383576020366003190112610383576004355f526008602052606060405f205460ff6040519161176983838316611728565b6001600160401b038160081c16602084015260481c166040820152f35b346103835761179436610ede565b6001600160a01b03906117ab825f54163314613f59565b5f5b81518110156100185780610cdb846117c86117cf9486613394565b5116614ed0565b6117ad565b34610383576020366003190112610383577f5d16ad41baeb009cd23eb8f6c7cde5c2e0cd5acf4a33926ab488875c37c37f38600435611812816103da565b6001600160a01b0390611829825f54163314613f59565b600180548284166001600160a01b031982161790915560408051939091166001600160a01b039081168452909116602083015281908101610843565b90929160ff60209161187b846040810197611728565b16910152565b346103835760403660031901126103835760046024356118a081610621565b6040516118dd816118cf6020820194863586906028926001600160c01b031991835260c01b1660208201520190565b03601f198101835282610980565b51902060206001600160a01b03600c541660405193848092633528638f60e11b82525afa90811561051257611919925f92611929575b50614504565b90610ad060405192839283611865565b61194291925060203d81116115c2576115b38183610980565b905f611913565b34610383576020366003190112610383577f032d76868790fdb5fb04c6f54308ddd47ecf8a80e5995610816aa0b29773b520600435611987816103da565b6001600160a01b039061199e825f54163314613f59565b600b80548284166001600160a01b031982161790915560408051939091166001600160a01b039081168452909116602083015281908101610843565b346103835760c0366003190112610383576001600160401b0360043581811161038357611a0b903690600401610ad4565b60249291923582811161038357611a26903690600401610ad4565b60449491943584811161038357611a41903690600401610ad4565b60649691963595861161038357610ad096611a63611587973690600401610ad4565b949093611a6e61065e565b9760843597614048565b3461038357606036600319011261038357611919602435611a9881610621565b60405190611ad782611ac9602082019360043585906028926001600160c01b031991835260c01b1660208201520190565b03601f198101845283610980565b60443591519020614504565b34610383576020366003190112610383577fe04e2434309a3c5548fe58cd48e2054b9f2c3a0581f0df4277aa52d191a8b794600435611b21816103da565b6001600160a01b0390611b38825f54163314613f59565b600c80548284166001600160a01b031982161790915560408051939091166001600160a01b039081168452909116602083015281908101610843565b9181601f84011215610383578235916001600160401b0383116103835760208085019460a0850201011161038357565b3461038357608036600319011261038357600435611bc181610621565b60246001600160401b03813581811161038357611be2903690600401611b74565b909260443583811161038357611bfc903690600401610ad4565b909360643590811161038357611c16903690600401610ad4565b919094611c2e6104546006546001600160a01b031690565b96873b15610383576040978851998a8092633bda38a360e01b8252815f9d8e948c886004840192611c5e93613119565b03915afa801561051257611d94575b50885b868110611c7b578980f35b89868a868a8c8a8989611c9a610454611c958c8688613219565b613274565b611cb6575b505050505050505050611cb1906131ed565b611c70565b9289899896938693828a611cce828e9b819e9b613200565b013596611cda92613229565b3690611ce592611122565b94855160208097012014611cf890612b5a565b611d0192613219565b611d0a90613274565b95611d15918b613200565b60600135611d24898d8d613229565b909351938493840196633ceb5b5160e11b8852840192611d4393613d6d565b03601f1981018252611d559082610980565b51925af1611d61613478565b611d6a83614c53565b90611d7490614b46565b611d7d91613d9b565b611d8691613deb565b89868a868a8c8a8989611c9f565b8061050c611da192610932565b5f611c6d565b34610383576020366003190112610383576004355f52600e602052602060405f2054604051908152f35b60a0366003190112610383577f26313df9aa6577df866c6588c888b4c89d59707d6df9fd0befdb29cb976945b6602435600435611e0d82610621565b610843604435611e1c81610621565b611f74600160643560843593611e31856103da565b611f53611e6b611f48611f19611ec28b8d604051958691602083019384906028926001600160c01b031991835260c01b1660208201520190565b0394611e7f601f1996878101835282610980565b519020611eb4611e9a61073e835f52600860205260405f2090565b611ea38161171e565b8a8114908115611fef575b50612894565b5f52600960205260405f2090565b95611f1287548b604051611f0981611efd60208201948886909160349282526bffffffffffffffffffffffff199060601b1660208201520190565b03898101835282610980565b51902014613515565b3490613561565b976040519182918a60208401909160349282526bffffffffffffffffffffffff199060601b1660208201520190565b039182018152610980565b6001600160401b038116611fa4575b50015460a01c6001600160401b031690565b604051948594859094939291606092608083019683526001600160401b0380921660208401521660408201520152565b8183018054611fe992611fc29160a01c6001600160401b031661356e565b67ffffffffffffffff60a01b1967ffffffffffffffff60a01b83549260a01b169116179055565b5f611f62565b60039150611ffc8161171e565b145f611eae565b34610383575f3660031901126103835760206001600160a01b0360015416604051908152f35b906040516120368161094a565b91546001600160a01b038116835260a01c6001600160401b03166020830152565b34610383576020366003190112610383576004355f526009602052606060405f206001600160401b036020612090600184549401612029565b6040519384526001600160a01b03815116828501520151166040820152f35b34610383576020366003190112610383577fddb7d4b45d521a6718ed9ccac62f1faa18b869772bca7e77ab6f392912a4ec186004356120ed816103da565b6001600160a01b0390612104825f54163314613f59565b600680548284166001600160a01b031982161790915560408051939091166001600160a01b039081168452909116602083015281908101610843565b34610383575f3660031901126103835760206001600160a01b0360065416604051908152f35b346103835760c03660031901126103835760043560243561218681610621565b6044359061219382610621565b6001600160401b0392606435848111610383576121b49036906004016103ad565b94608435908111610383576121cd9036906004016103ad565b94909160a435916121dd836103da565b5f97338952600460205260ff60408a2054169160038310156110a45761223f9361220b600160609514612a59565b8a6122216104546006546001600160a01b031690565b926040519687958694859363e044095360e01b855260048501612ae0565b03925af1918215610512577fc2b28def014c5f6ccb93ba212bc842430ed5b3d5a6e1a28d27e98a568e5fc02f9661230c94612308948a8b958c92612397575b5061228a908914612b0e565b60405160208101906122b9816118cf8d8d86906028926001600160c01b031991835260c01b1660208201520190565b519020936122cf855f52600860205260405f2090565b956122fc6122de885460ff1690565b976122e88961171e565b600189148015612386575b6114c190612894565b84612371575b50614240565b1590565b612332575b604080519182526001600160401b0390921660208201529081908101611235565b604080518281526001600160401b03841660208201527f65ec418e0b7b50180dd133ac2495d373d2df1b616648284452f7b57ac532ce4a9190a1612311565b612380906104b6368787611122565b5f612302565b506123908961171e565b88156122f3565b905061228a95506123bf915060603d81116123c9575b6123b78183610980565b810190612aa5565b959095919061227e565b503d6123ad565b34610383576123de36610ede565b6001600160a01b03906123f5825f54163314613f59565b5f5b81518110156100185780610cdb846124126124199486613394565b51166149d0565b6123f7565b346103835761242c36610ede565b6001600160a01b0390612443825f54163314613f59565b5f5b81518110156100185780610cdb846124606124679486613394565b5116614d7c565b612445565b34610383576020366003190112610383576001600160a01b03600435612491816103da565b165f52600460205260ff60405f20541660038110156110a457602090600160405191148152f35b34610383576020366003190112610383576004356124d5816103da565b5f908154906001600160a01b03808316916124f1338414613f59565b1691821561252e576001600160a01b031916821783557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608490fd5b600311156110a457565b34610383576020366003190112610383576001600160a01b036004356125c8816103da565b165f52600460205260ff60405f20541660405160038210156110a4576020918152f35b346103835760e03660031901126103835760046001600160401b0381358181116103835761261c9036908401610ad4565b91602435818111610383576126349036908601610ad4565b61263f929192610632565b906064358381116103835761265790369089016103ad565b906084358581116103835761266f9036908b01611b74565b94909360a435878111610383576126899036908d01610ad4565b98909760c435908111610383576100189c6126a691369101610ad4565b9b909a612ba6565b34610383576080366003190112610383576004357f6c005c1eef4990013ad08bd5c941274dcd8d109eb0ca4ac049587173d21be21f6024356126ef81610621565b6044359261231161282e606435612705816103da565b6128206040519161280d60208401846127378a8a84906028926001600160c01b031991835260c01b1660208201520190565b039461274b601f1996878101835282610980565b519020936127c36127bc6127aa602061277461276f8a5f52600860205260405f2090565b613589565b61279c81516127828161171e565b61278b8161171e565b60018114908115611fef5750612894565b01516001600160401b031690565b6001600160401b036007549116613561565b42116135d0565b8a6127d6865f52600960205260405f2090565b5491611f0960405191826107f888602083019687909160349282526bffffffffffffffffffffffff199060601b1660208201520190565b5f8080809b819461c350f161137f613478565b5f52600860205260405f2090565b805460ff19166008179055565b3461038357602036600319011261038357600435600554811015610383576001600160a01b0360209160055f527f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db0015416604051908152f35b1561289b57565b60405162461bcd60e51b815260206004820152600e60248201527f696e76616c6964207374617475730000000000000000000000000000000000006044820152606490fd5b60098210156110a45752565b9060098110156110a45760ff80198354169116179055565b90805160098110156110a45761291a90836128ec565b6020810151825460409092015169ffffffffffffffffff001990921660089190911b68ffffffffffffffff00161760489190911b69ff00000000000000000016179055565b9190826040910312610383576040516129778161094a565b60208082948035612987816103da565b845201359161299583610621565b0152565b906001600160401b0360208060016103f99585518155019301516001600160a01b038151166001600160a01b031985541617845501511667ffffffffffffffff60a01b1967ffffffffffffffff60a01b83549260a01b169116179055565b9460209060ff9460c096999894939960e089019a89526001600160401b03809516848a01526001600160a01b0380921660408a015260608901528135612a3c816103da565b1660808801520135612a4d81610621565b1660a085015216910152565b15612a6057565b60405162461bcd60e51b815260206004820152601260248201527f6e6f7420696e76616c69642070726f76657200000000000000000000000000006044820152606490fd5b90816060910312610383578051916040602083015192015190565b908060209392818452848401375f828201840152601f01601f1916010190565b6040906001600160401b03612b0095931681528160208201520191612ac0565b90565b6040513d5f823e3d90fd5b15612b1557565b60405162461bcd60e51b815260206004820152600f60248201527f696e76616c69642070726f6f66496400000000000000000000000000000000006044820152606490fd5b15612b6157565b60405162461bcd60e51b815260206004820152601660248201527f696e76616c69642063697263756974206f7574707574000000000000000000006044820152606490fd5b99929893919c9b95909a9694335f52600460205260ff60405f20541660038110156110a4576001612bd79114612a59565b612bec6104546006546001600160a01b031690565b90813b15610383575f918d838e612c1a6040519788968795869463b4f7a72760e01b86528c600487016130e4565b03925af18015610512576130ad575b50612c3f6104546006546001600160a01b031690565b803b1561038357875f9186612c6b9460405195869485938493633bda38a360e01b855260048501613119565b03915afa80156105125761309a575b5060018414808015613091575b8785888f8c908f8f612c998a9861318d565b8c5f978c5f985b858a10612e075750505050505050505050612cbd91501515613316565b612d00575b505050505050612cfb907f5222b9309369092c135ac01f588e14730b87b05890b5c016dcb1f9b9a55d14f09495604051948594856134ee565b0390a1565b612d12869b9398959a97949996613362565b985f5b8a51811015612d4957808b612d3e8f936060612d368f612d44978491613200565b013592613394565b526131ed565b612d15565b50612cfb979b505f949699918594969950612dae612d8c611c9587947f5222b9309369092c135ac01f588e14730b87b05890b5c016dcb1f9b9a55d14f09f613210565b946118cf6040519384926020840197630ef280bf60e21b89526024850161342a565b51925af1612dba613478565b5015612dcd575b959481925f8080612cc2565b7ff97038d0ee914b31475cdb033a5264b8f2c4d5a89fc292214bea2ac641b49e7660405180612dff85858a8a856134ee565b0390a1612dc1565b8b876118cf612ea9612ec89f612e7b8f8e612e74828f8f612e6f8f8f908f86612e809c6040612e60838686612e5b8c612e548f8690612e4d826104b69f612e689f613200565b3593613219565b3514612b0e565b613200565b013594613229565b3691611122565b613219565b3596613219565b61326a565b604051928391602083019586906028926001600160c01b031991835260c01b1660208201520190565b51902093612ebf855f52600860205260405f2090565b9d8e5460ff1690565b95612ed28761171e565b600187149b8c8015613080575b612f0e575b50505050505050505050505050612efc9192506131ed565b908391888f8c908f8f8c8f8c8e612ca0565b8d98999a9b9c9f612efc9f610cdb612f2d92600260ff19825416179055565b9f6001831115612feb5750612f6a9795936060612e608b6123089a9896612f5c611c9583612f62998199613219565b97613200565b929091614240565b612f8d575b50505050505b82918f8c908f8f5f8f8f8f8f908f928f918591612ee4565b7f65ec418e0b7b50180dd133ac2495d373d2df1b616648284452f7b57ac532ce4a94612fc082612fc795612e7b95613219565b3594613219565b604080519283526001600160401b0391909116602083015290a18a8f8e8e84612f6f565b99509b509950505050509350613001915061171e565b61300e575b505050612f75565b60206001600160401b039261279c613078956001600160a01b03613069610454611c95613051600161304b6130719b5f52600960205260405f2090565b01612029565b9661306388516001600160a01b031690565b95613210565b91161461327e565b16156132ca565b88885f613006565b5061308a8861171e565b8715612edf565b50848a14612c87565b8061050c6130a792610932565b5f612c7a565b8061050c6130ba92610932565b5f612c29565b90918281526001600160fb1b0383116103835760209260051b809284830137010190565b9391612b0095936001600160401b0361310b931686526060602087015260608601916130c0565b926040818503910152612ac0565b9192906040926001600160401b038482019216815282602092858484015252606080910194935f925b8484106131525750505050505090565b853587528581013587820152858201358783015285830135878401526080808701359088015260a09687019690950194600190930192613142565b1561319457565b60405162461bcd60e51b815260206004820152601760248201527f696e76616c69642063616c6c6261636b206c656e6774680000000000000000006044820152606490fd5b634e487b7160e01b5f52601160045260245ffd5b5f1981146131fb5760010190565b6131d9565b919081101561058e5760a0020190565b901561058e5790565b919081101561058e5760051b0190565b919081101561058e5760051b81013590601e19813603018212156103835701908135916001600160401b038311610383576020018236038113610383579190565b35612b0081610621565b35612b00816103da565b1561328557565b60405162461bcd60e51b815260206004820152601160248201527f63616c6c6261636b206d69736d617463680000000000000000000000000000006044820152606490fd5b156132d157565b60405162461bcd60e51b815260206004820152601e60248201527f696e76616c69642067617320666f722062617463682063616c6c6261636b00006044820152606490fd5b1561331d57565b60405162461bcd60e51b815260206004820152601560248201527f6e6f2066756c66696c6c656420726571756573747300000000000000000000006044820152606490fd5b9061336c82610ec7565b6133796040519182610980565b828152809261338a601f1991610ec7565b0190602036910137565b805182101561058e5760209160051b010190565b90808352602080930192838260051b850194845f925b8584106133cf575050505050505090565b9091929394959681810384528735601e19843603018112156103835783018681019190356001600160401b0381116103835780360383136103835761341988928392600195612ac0565b9901940194019295949391906133be565b9193929093604083019260408152855180945260608101936020809701905f5b81811061346457505050612b0094958185039101526133a8565b82518752958801959188019160010161344a565b3d156134a2573d9061348982611107565b916134976040519384610980565b82523d5f602084013e565b606090565b9190808252602080920192915f5b8281106134c3575050505090565b9091929382806001926001600160401b0388356134df81610621565b168152019501939291016134b5565b929061350790612b0095936040865260408601916130c0565b9260208185039101526134a7565b1561351c57565b60405162461bcd60e51b815260206004820152600d60248201527f696e76616c696420696e707574000000000000000000000000000000000000006044820152606490fd5b919082018092116131fb57565b9190916001600160401b03808094169116019182116131fb57565b90604051606081016001600160401b0390828110828211176109455760409160ff918352839554906135bd838316866128e0565b8160081c16602085015260481c16910152565b1561038357565b156135de57565b60405162461bcd60e51b815260206004820152601260248201527f73656e64206e6174697665206661696c656400000000000000000000000000006044820152606490fd5b96959890975f91338352600460205260409260ff84822054169260038410156110a457848c848f8e8b8f8f938f9b9460018f961461366090612a59565b8a9c61366c8b80613900565b905015948515613689906136f89a6107f8986138e4575b50613935565b8a5146602082019081526bffffffffffffffffffffffff193060601b1660408301527f46756c66696c6c52657175657374730000000000000000000000000000000000605483015260438252601f1999916136e5606382610980565b5190209b519a8b9860208a019d8e61399c565b519020906137068180613900565b9050613845575b506001600160401b0361371f8461326a565b16613770575b5050509183916137668694898d8a7f599dc3a262ef12090a85966f98eb3576ad3412b27513e677d6eaaee82a82bea69f9a8f9a8f612cfb9f9e9c8a9161437c565b5198899889613d09565b826137a761379c949e9997959b9a989694613796610454600b546001600160a01b031690565b9261326a565b9e6020810190613a7e565b813b1561384157845163429cf09960e11b81529e8f93849283926137ce9260048501613bf4565b03915afa97881561051257898888887f599dc3a262ef12090a85966f98eb3576ad3412b27513e677d6eaaee82a82bea69f8f88612cfb9f916002613766998e958e9561382e575b50179a50509a50509a50509d5050829496989950613725565b8061050c61383b92610932565b5f613815565b8380fd5b90935061385d610454600a546001600160a01b031690565b6138678280613900565b91906138856138796020860186613900565b9190958a810190613900565b91843b156138e05787959493928a926138b4928d51998a98899788976303d42a8960e41b895260048901613a04565b03915afa8015610512576138cd575b506001925f61370d565b8061050c6138da92610932565b5f6138c3565b8780fd5b6001600160401b0391506138f79061326a565b1615158f613683565b903590601e198136030182121561038357018035906001600160401b03821161038357602001918160051b3603831361038357565b1561393c57565b60405162461bcd60e51b815260206004820152600a60248201527f656d7074792073696773000000000000000000000000000000000000000000006044820152606490fd5b91906001600160fb1b0381116103835760051b809282370190565b939998969594926139b592918552602080950191613981565b97915f5b8281106139d95750505050946139d391612b009596613981565b91613981565b9091929882806001926001600160401b038d356139f581610621565b168152019a01939291016139b9565b929097969491979593958352613a28602098899260808487015260808601916133a8565b83810360408501528281520194905f5b818110613a5557505050612b0094955060608185039101526130c0565b90919588806001926001600160a01b038a35613a70816103da565b168152019701929101613a38565b90359061017e1981360301821215610383570190565b9035601e19823603018112156103835701602081359101916001600160401b038211610383578160051b3603831361038357565b9190808252602080920192915f805b838210613ae657505050505090565b9091929394853563ffffffff8116809103613b0e578152830194830193929160010190613ad7565b8280fd5b9035601e19823603018112156103835701602081359101916001600160401b038211610383578160061b3603831361038357565b916020908281520191905f5b818110613b5f5750505090565b90919280613b796001928660208091803584520135910152565b60409081019401929101613b52565b9060408080938181853701910137565b90808352602080930192838260051b810194845f925b858410613bbf575050505050505090565b909192939495968580613be38385600195038852613bdd8c88613a94565b90613ac8565b990194019401929594939190613bae565b613c3f906001600160401b03612b0095946101c094835216602082015260606040820152613cfa613cee613c288680613a94565b9490610180958660608701526101e0860191613ac8565b93613cdd613cd4613c8a613c6d613c5960208c018c613b12565b605f198a8c03810160808c01529a91613b46565b613c7a60408c018c613b12565b908a8a84030160a08b0152613b46565b613c9a60c0880160608c01613b88565b61014093613cb785890160e08d0160208091803584520135910152565b613cc56101208c018c613a94565b918a8a850301908a0152613ac8565b91880188613a94565b9086868403016101a0870152613ac8565b94610160810190613a94565b93909282860301910152613b98565b969492613d4794613d2b613d3993612b009b999560808c5260808c01916130c0565b9189830360208b01526134a7565b9186830360408801526130c0565b9260608185039101526130c0565b90816020910312610383575180151581036103835790565b604090612b00949281528160208201520191612ac0565b90613d9760209282815194859201610a5b565b0190565b60216103f9919392936040519481613dbd879351809260208087019101610a5b565b8201601d60f91b6020820152613ddc8251809360208785019101610a5b565b01036001810185520183610980565b15613df35750565b60405162461bcd60e51b815260206004820152908190613e17906024830190610a7c565b0390fd5b93926101009360ff936001600160401b03613e7494999899168752602435602088015260443560408801526064356060880152608435608088015260a43560a088015260c08701526101208060e08801528601916130c0565b9416910152565b90969392949596613e976104546006546001600160a01b031690565b91823b1561038357613ec15f95604051988996879586956307b1cc4560e41b875260048701613e1b565b03915afa918215610512576001600160a01b0392613f46575b50613ef9613ee9368686611122565b6020815191012060643514612b5a565b1691823b1561038357613f28925f9283604051809681958294633ceb5b5160e11b845260843560048501613d6d565b03925af1801561051257613f395750565b8061050c6103f992610932565b8061050c613f5392610932565b5f613eda565b15613f6057565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b601f8111613fb0575050565b5f90600d82527fd7b6990105719101dabeb77144f2a3385c8033acd3af97e9423a695e81ad1eb5906020601f850160051c8301941061400a575b601f0160051c01915b828110613fff57505050565b818155600101613ff3565b9092508290613fea565b909161402b612b0093604084526040840190610a7c565b916020818403910152610a7c565b90816020910312610383575190565b989592969794909391935f98895b82811061406e57505050505050505050505050600190565b6140ae8989898f898f8789612fc08f958e61409c8f6140a797614095888096938194613219565b359b613219565b3596612e6f88610621565b3592614725565b156140c1576140bc906131ed565b614056565b50505050505050505050905090565b9060405191825f600d546140e3816108e6565b906001908181169081156141675750600114614109575b5050611ac9906103f993613d84565b600d5f9081529192507fd7b6990105719101dabeb77144f2a3385c8033acd3af97e9423a695e81ad1eb55b83831061414c57505050810160200182611ac96140fa565b80546020848a01810191909152889550909201918101614134565b611ac99450602092506103f99693915060ff19168286015280151502840101918194506140fa565b61419a600d546108e6565b1561422d576141a7614bfa565b9060306141b383614c25565b5360786141bf83614c32565b5360415b600181116141df5750906141da612b009215614d31565b6140d0565b90600f811690601082101561058e577f3031323334353637383961626364656600000000000000000000000000000000614228921a61421e8486614c42565b5360041c91614d25565b6141c3565b5060405161423a81610965565b5f815290565b9491929360015f936142518161171e565b146142d4575b506001600160a01b038516614271575b5050505050600190565b5f94859483156142c3575b6142a4869394956118cf6040519384926020840198633ceb5b5160e11b8a5260248501613d6d565b5193f16142af613478565b50156142bf575f80808080614267565b5f90565b859293506142a45a9493505061427c565b61432991925060206142f6600161304b61431d945f52600960205260405f2090565b61279c61430a82516001600160a01b031690565b6001600160a01b03808b1691161461327e565b6001600160401b031690565b905f614257565b1561433757565b60405162461bcd60e51b815260206004820152601a60248201527f696e73756666696369656e74207479706573206f6620736967730000000000006044820152606490fd5b9792909695965f5b8181106143975750505050505050505050565b806107a96144b58b6107f86144a38f6144888f988f998f8f8f9c8f928f6144bb9f9387946143d8612e7b87612e7499612fc06144019f612e6f988491613219565b6040519b8c91602083019384906028926001600160c01b031991835260c01b1660208201520190565b039a614415601f199c8d8101835282610980565b5190209e8f61442f61276f825f52600860205260405f2090565b6003815161443c8161171e565b6144458161171e565b036144c0576040015161445f9060ff858116911614614330565b61282061446a610e9b565b6004815293426001600160401b0316602086015260ff166040850152565b60408051602081019687529135908201529283906060820190565b519020915f52600e60205260405f2090565b556131ed565b614384565b6144dd90516144ce8161171e565b6144d78161171e565b15612894565b61445f565b90816020910312610383575160078110156103835790565b600711156110a457565b91909161451c61276f825f52600860205260405f2090565b926004845161452a8161171e565b6145338161171e565b0361458757614559915061455461431d60208601516001600160401b031690565b613561565b4211614579575b612b0060408351936145718561171e565b015160ff1690565b60409091015160ff16600791565b600584516145948161171e565b61459d8161171e565b146145aa575b5050614560565b6145bf610454600c546001600160a01b031690565b604051635976123b60e11b81526004810184905260209391908481602481855afa908115610512575f916146ac575b506145f8816144fa565b60028114908115614698575b501561463357505061455461431d614625938601516001600160401b031690565b4211614579575b5f806145a3565b60405163011cfebb60e51b815260048101929092529091508290829060249082905afa918215610512575f9261467b575b505042111561462c5760409091015160ff16600691565b6146919250803d106115c2576115b38183610980565b5f80614664565b600491506146a5816144fa565b145f614604565b6146cc9150853d87116146d2575b6146c48183610980565b8101906144e2565b5f6145ee565b503d6146ba565b156146e057565b60405162461bcd60e51b815260206004820152600c60248201527f696e76616c6964206461746100000000000000000000000000000000000000006044820152606490fd5b92614762926107f86147aa6147b897966147b395604051978891602083019384906028926001600160c01b031991835260c01b1660208201520190565b0396614776601f1998898101835282610980565b5190209561478c875f52600e60205260405f2090565b54946040519384916020830196879091604092825260208201520190565b519020146146d9565b614504565b906147c28161171e565b600781036147d8575060ff908183169216161490565b9050600291506147e78161171e565b146147f0575f90565b600190565b156147fc57565b60405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f74207061757365720000000000000000000000006044820152606490fd5b9060038110156110a45760ff80198354169116179055565b600554906801000000000000000082101561094557600182018060055582101561058e576103f99160055f527f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db001906001600160a01b03166001600160a01b0319825416179055565b156148c957565b60405162461bcd60e51b815260206004820152601560248201527f6163636f756e74206973206e6f742070726f76657200000000000000000000006044820152606490fd5b5f198101919082116131fb57565b600554801561496c575f198101908082101561058e577f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3daf9060055f52016001600160a01b03198154169055600555565b634e487b7160e01b5f52603160045260245ffd5b600354801561496c575f198101908082101561058e577fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85a9060035f52016001600160a01b03198154169055600355565b614a016149f161073e836001600160a01b03165f52600460205260405f2090565b6149fa81612599565b15156148c2565b600590614a0e825461490e565b5f5b8354811015614b0157614a25610ca482610559565b6001600160a01b03808516911614614a4557614a40906131ed565b614a10565b7fd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d9859350908181612cfb949310614ac2575b5050614a8061491c565b614aa8614a9e826001600160a01b03165f52600460205260405f2090565b805460ff19169055565b6040516001600160a01b0390911681529081906020820190565b614ada614ad4610ca4614afa94610559565b91610559565b90919082549060031b916001600160a01b03809116831b921b1916179055565b5f80614a76565b60405162461bcd60e51b815260206004820152601060248201527f70726f766572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b6044815110614bc057600481015181019060208160248401930312610383576024810151906001600160401b038211610383570181604382011215610383576024810151614b9381611107565b92614ba16040519485610980565b8184526044828401011161038357612b00916044602085019101610a5b565b50604051614bcd8161094a565b601d81527f5472616e73616374696f6e2072657665727465642073696c656e746c79000000602082015290565b60405190608082018281106001600160401b0382111761094557604052604282526060366020840137565b80511561058e5760200190565b80516001101561058e5760210190565b90815181101561058e570160200190565b8015614d0757805f908282935b614cf35750614c6e83611107565b92614c7c6040519485610980565b80845281601f19614c8c83611107565b013660208701375b614c9e5750505090565b614ca79061490e565b90600a90603082820681018091116131fb5760f81b7fff0000000000000000000000000000000000000000000000000000000000000016841a614cea8487614c42565b53049081614c94565b92614cff600a916131ed565b930480614c60565b50604051614d148161094a565b60018152600360fc1b602082015290565b80156131fb575f190190565b15614d3857565b606460405162461bcd60e51b815260206004820152602060248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e746044820152fd5b6001600160a01b0381165f52600260205260ff60405f205416614e3f576003546801000000000000000081101561094557600181018060035581101561058e5760035f527fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b0180546001600160a01b0319166001600160a01b0383161790557f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f890612cfb90614aa8610cce826001600160a01b03165f52600260205260405f2090565b60405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152606490fd5b15614e8b57565b60405162461bcd60e51b815260206004820152601560248201527f4163636f756e74206973206e6f742070617573657200000000000000000000006044820152606490fd5b614ef6614ef161073e836001600160a01b03165f52600260205260405f2090565b614e84565b600390614f03825461490e565b5f5b8354811015614fb257614f1a610ca482610593565b6001600160a01b03808516911614614f3a57614f35906131ed565b614f05565b7fcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e9350908181612cfb949310614f93575b5050614f75614980565b614aa8614a9e826001600160a01b03165f52600260205260405f2090565b614ada614fa5610ca4614fab94610593565b91610593565b5f80614f6b565b60405162461bcd60e51b815260206004820152601060248201527f706175736572206e6f7420666f756e64000000000000000000000000000000006044820152606490fdfea264697066735822122033011ce003a96a9cb5531a57043257d82bb936d23937d559bf7d118ac1e3d31e64736f6c63430008140033",
}

// BrevisRequestABI is the input ABI used to generate the binding from.
// Deprecated: Use BrevisRequestMetaData.ABI instead.
var BrevisRequestABI = BrevisRequestMetaData.ABI

// BrevisRequestBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use BrevisRequestMetaData.Bin instead.
var BrevisRequestBin = BrevisRequestMetaData.Bin

// DeployBrevisRequest deploys a new Ethereum contract, binding an instance of BrevisRequest to it.
func DeployBrevisRequest(auth *bind.TransactOpts, backend bind.ContractBackend, _feeCollector common.Address, _brevisProof common.Address, _bvnSigsVerifier common.Address) (common.Address, *types.Transaction, *BrevisRequest, error) {
	parsed, err := BrevisRequestMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(BrevisRequestBin), backend, _feeCollector, _brevisProof, _bvnSigsVerifier)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &BrevisRequest{BrevisRequestCaller: BrevisRequestCaller{contract: contract}, BrevisRequestTransactor: BrevisRequestTransactor{contract: contract}, BrevisRequestFilterer: BrevisRequestFilterer{contract: contract}}, nil
}

// BrevisRequest is an auto generated Go binding around an Ethereum contract.
type BrevisRequest struct {
	BrevisRequestCaller     // Read-only binding to the contract
	BrevisRequestTransactor // Write-only binding to the contract
	BrevisRequestFilterer   // Log filterer for contract events
}

// BrevisRequestCaller is an auto generated read-only Go binding around an Ethereum contract.
type BrevisRequestCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisRequestTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BrevisRequestTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisRequestFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BrevisRequestFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisRequestSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BrevisRequestSession struct {
	Contract     *BrevisRequest    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BrevisRequestCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BrevisRequestCallerSession struct {
	Contract *BrevisRequestCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// BrevisRequestTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BrevisRequestTransactorSession struct {
	Contract     *BrevisRequestTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// BrevisRequestRaw is an auto generated low-level Go binding around an Ethereum contract.
type BrevisRequestRaw struct {
	Contract *BrevisRequest // Generic contract binding to access the raw methods on
}

// BrevisRequestCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BrevisRequestCallerRaw struct {
	Contract *BrevisRequestCaller // Generic read-only contract binding to access the raw methods on
}

// BrevisRequestTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BrevisRequestTransactorRaw struct {
	Contract *BrevisRequestTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBrevisRequest creates a new instance of BrevisRequest, bound to a specific deployed contract.
func NewBrevisRequest(address common.Address, backend bind.ContractBackend) (*BrevisRequest, error) {
	contract, err := bindBrevisRequest(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BrevisRequest{BrevisRequestCaller: BrevisRequestCaller{contract: contract}, BrevisRequestTransactor: BrevisRequestTransactor{contract: contract}, BrevisRequestFilterer: BrevisRequestFilterer{contract: contract}}, nil
}

// NewBrevisRequestCaller creates a new read-only instance of BrevisRequest, bound to a specific deployed contract.
func NewBrevisRequestCaller(address common.Address, caller bind.ContractCaller) (*BrevisRequestCaller, error) {
	contract, err := bindBrevisRequest(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BrevisRequestCaller{contract: contract}, nil
}

// NewBrevisRequestTransactor creates a new write-only instance of BrevisRequest, bound to a specific deployed contract.
func NewBrevisRequestTransactor(address common.Address, transactor bind.ContractTransactor) (*BrevisRequestTransactor, error) {
	contract, err := bindBrevisRequest(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BrevisRequestTransactor{contract: contract}, nil
}

// NewBrevisRequestFilterer creates a new log filterer instance of BrevisRequest, bound to a specific deployed contract.
func NewBrevisRequestFilterer(address common.Address, filterer bind.ContractFilterer) (*BrevisRequestFilterer, error) {
	contract, err := bindBrevisRequest(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BrevisRequestFilterer{contract: contract}, nil
}

// bindBrevisRequest binds a generic wrapper to an already deployed contract.
func bindBrevisRequest(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BrevisRequestMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BrevisRequest *BrevisRequestRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BrevisRequest.Contract.BrevisRequestCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BrevisRequest *BrevisRequestRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisRequest.Contract.BrevisRequestTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BrevisRequest *BrevisRequestRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BrevisRequest.Contract.BrevisRequestTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BrevisRequest *BrevisRequestCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BrevisRequest.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BrevisRequest *BrevisRequestTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisRequest.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BrevisRequest *BrevisRequestTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BrevisRequest.Contract.contract.Transact(opts, method, params...)
}

// AvsSigsVerifier is a free data retrieval call binding the contract method 0x0b9c8c41.
//
// Solidity: function avsSigsVerifier() view returns(address)
func (_BrevisRequest *BrevisRequestCaller) AvsSigsVerifier(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "avsSigsVerifier")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// AvsSigsVerifier is a free data retrieval call binding the contract method 0x0b9c8c41.
//
// Solidity: function avsSigsVerifier() view returns(address)
func (_BrevisRequest *BrevisRequestSession) AvsSigsVerifier() (common.Address, error) {
	return _BrevisRequest.Contract.AvsSigsVerifier(&_BrevisRequest.CallOpts)
}

// AvsSigsVerifier is a free data retrieval call binding the contract method 0x0b9c8c41.
//
// Solidity: function avsSigsVerifier() view returns(address)
func (_BrevisRequest *BrevisRequestCallerSession) AvsSigsVerifier() (common.Address, error) {
	return _BrevisRequest.Contract.AvsSigsVerifier(&_BrevisRequest.CallOpts)
}

// BaseDataURL is a free data retrieval call binding the contract method 0x25cda16d.
//
// Solidity: function baseDataURL() view returns(string)
func (_BrevisRequest *BrevisRequestCaller) BaseDataURL(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "baseDataURL")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// BaseDataURL is a free data retrieval call binding the contract method 0x25cda16d.
//
// Solidity: function baseDataURL() view returns(string)
func (_BrevisRequest *BrevisRequestSession) BaseDataURL() (string, error) {
	return _BrevisRequest.Contract.BaseDataURL(&_BrevisRequest.CallOpts)
}

// BaseDataURL is a free data retrieval call binding the contract method 0x25cda16d.
//
// Solidity: function baseDataURL() view returns(string)
func (_BrevisRequest *BrevisRequestCallerSession) BaseDataURL() (string, error) {
	return _BrevisRequest.Contract.BaseDataURL(&_BrevisRequest.CallOpts)
}

// BrevisDispute is a free data retrieval call binding the contract method 0x7d91f017.
//
// Solidity: function brevisDispute() view returns(address)
func (_BrevisRequest *BrevisRequestCaller) BrevisDispute(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "brevisDispute")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// BrevisDispute is a free data retrieval call binding the contract method 0x7d91f017.
//
// Solidity: function brevisDispute() view returns(address)
func (_BrevisRequest *BrevisRequestSession) BrevisDispute() (common.Address, error) {
	return _BrevisRequest.Contract.BrevisDispute(&_BrevisRequest.CallOpts)
}

// BrevisDispute is a free data retrieval call binding the contract method 0x7d91f017.
//
// Solidity: function brevisDispute() view returns(address)
func (_BrevisRequest *BrevisRequestCallerSession) BrevisDispute() (common.Address, error) {
	return _BrevisRequest.Contract.BrevisDispute(&_BrevisRequest.CallOpts)
}

// BrevisProof is a free data retrieval call binding the contract method 0xc7f5aaa0.
//
// Solidity: function brevisProof() view returns(address)
func (_BrevisRequest *BrevisRequestCaller) BrevisProof(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "brevisProof")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// BrevisProof is a free data retrieval call binding the contract method 0xc7f5aaa0.
//
// Solidity: function brevisProof() view returns(address)
func (_BrevisRequest *BrevisRequestSession) BrevisProof() (common.Address, error) {
	return _BrevisRequest.Contract.BrevisProof(&_BrevisRequest.CallOpts)
}

// BrevisProof is a free data retrieval call binding the contract method 0xc7f5aaa0.
//
// Solidity: function brevisProof() view returns(address)
func (_BrevisRequest *BrevisRequestCallerSession) BrevisProof() (common.Address, error) {
	return _BrevisRequest.Contract.BrevisProof(&_BrevisRequest.CallOpts)
}

// BvnSigsVerifier is a free data retrieval call binding the contract method 0x3f2b17b1.
//
// Solidity: function bvnSigsVerifier() view returns(address)
func (_BrevisRequest *BrevisRequestCaller) BvnSigsVerifier(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "bvnSigsVerifier")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// BvnSigsVerifier is a free data retrieval call binding the contract method 0x3f2b17b1.
//
// Solidity: function bvnSigsVerifier() view returns(address)
func (_BrevisRequest *BrevisRequestSession) BvnSigsVerifier() (common.Address, error) {
	return _BrevisRequest.Contract.BvnSigsVerifier(&_BrevisRequest.CallOpts)
}

// BvnSigsVerifier is a free data retrieval call binding the contract method 0x3f2b17b1.
//
// Solidity: function bvnSigsVerifier() view returns(address)
func (_BrevisRequest *BrevisRequestCallerSession) BvnSigsVerifier() (common.Address, error) {
	return _BrevisRequest.Contract.BvnSigsVerifier(&_BrevisRequest.CallOpts)
}

// DataURL is a free data retrieval call binding the contract method 0x666d1651.
//
// Solidity: function dataURL(bytes32 _proofId) view returns(string)
func (_BrevisRequest *BrevisRequestCaller) DataURL(opts *bind.CallOpts, _proofId [32]byte) (string, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "dataURL", _proofId)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// DataURL is a free data retrieval call binding the contract method 0x666d1651.
//
// Solidity: function dataURL(bytes32 _proofId) view returns(string)
func (_BrevisRequest *BrevisRequestSession) DataURL(_proofId [32]byte) (string, error) {
	return _BrevisRequest.Contract.DataURL(&_BrevisRequest.CallOpts, _proofId)
}

// DataURL is a free data retrieval call binding the contract method 0x666d1651.
//
// Solidity: function dataURL(bytes32 _proofId) view returns(string)
func (_BrevisRequest *BrevisRequestCallerSession) DataURL(_proofId [32]byte) (string, error) {
	return _BrevisRequest.Contract.DataURL(&_BrevisRequest.CallOpts, _proofId)
}

// FeeCollector is a free data retrieval call binding the contract method 0xc415b95c.
//
// Solidity: function feeCollector() view returns(address)
func (_BrevisRequest *BrevisRequestCaller) FeeCollector(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "feeCollector")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// FeeCollector is a free data retrieval call binding the contract method 0xc415b95c.
//
// Solidity: function feeCollector() view returns(address)
func (_BrevisRequest *BrevisRequestSession) FeeCollector() (common.Address, error) {
	return _BrevisRequest.Contract.FeeCollector(&_BrevisRequest.CallOpts)
}

// FeeCollector is a free data retrieval call binding the contract method 0xc415b95c.
//
// Solidity: function feeCollector() view returns(address)
func (_BrevisRequest *BrevisRequestCallerSession) FeeCollector() (common.Address, error) {
	return _BrevisRequest.Contract.FeeCollector(&_BrevisRequest.CallOpts)
}

// IsActiveProver is a free data retrieval call binding the contract method 0xec64842e.
//
// Solidity: function isActiveProver(address _account) view returns(bool)
func (_BrevisRequest *BrevisRequestCaller) IsActiveProver(opts *bind.CallOpts, _account common.Address) (bool, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "isActiveProver", _account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsActiveProver is a free data retrieval call binding the contract method 0xec64842e.
//
// Solidity: function isActiveProver(address _account) view returns(bool)
func (_BrevisRequest *BrevisRequestSession) IsActiveProver(_account common.Address) (bool, error) {
	return _BrevisRequest.Contract.IsActiveProver(&_BrevisRequest.CallOpts, _account)
}

// IsActiveProver is a free data retrieval call binding the contract method 0xec64842e.
//
// Solidity: function isActiveProver(address _account) view returns(bool)
func (_BrevisRequest *BrevisRequestCallerSession) IsActiveProver(_account common.Address) (bool, error) {
	return _BrevisRequest.Contract.IsActiveProver(&_BrevisRequest.CallOpts, _account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BrevisRequest *BrevisRequestCaller) IsPauser(opts *bind.CallOpts, account common.Address) (bool, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "isPauser", account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BrevisRequest *BrevisRequestSession) IsPauser(account common.Address) (bool, error) {
	return _BrevisRequest.Contract.IsPauser(&_BrevisRequest.CallOpts, account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_BrevisRequest *BrevisRequestCallerSession) IsPauser(account common.Address) (bool, error) {
	return _BrevisRequest.Contract.IsPauser(&_BrevisRequest.CallOpts, account)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BrevisRequest *BrevisRequestCaller) NumPausers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "numPausers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BrevisRequest *BrevisRequestSession) NumPausers() (*big.Int, error) {
	return _BrevisRequest.Contract.NumPausers(&_BrevisRequest.CallOpts)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_BrevisRequest *BrevisRequestCallerSession) NumPausers() (*big.Int, error) {
	return _BrevisRequest.Contract.NumPausers(&_BrevisRequest.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BrevisRequest *BrevisRequestCaller) NumProvers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "numProvers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BrevisRequest *BrevisRequestSession) NumProvers() (*big.Int, error) {
	return _BrevisRequest.Contract.NumProvers(&_BrevisRequest.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_BrevisRequest *BrevisRequestCallerSession) NumProvers() (*big.Int, error) {
	return _BrevisRequest.Contract.NumProvers(&_BrevisRequest.CallOpts)
}

// OnchainRequests is a free data retrieval call binding the contract method 0xc49af0fa.
//
// Solidity: function onchainRequests(bytes32 ) view returns(bytes32 feeHash, (address,uint64) callback)
func (_BrevisRequest *BrevisRequestCaller) OnchainRequests(opts *bind.CallOpts, arg0 [32]byte) (struct {
	FeeHash  [32]byte
	Callback IBrevisTypesCallback
}, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "onchainRequests", arg0)

	outstruct := new(struct {
		FeeHash  [32]byte
		Callback IBrevisTypesCallback
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.FeeHash = *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)
	outstruct.Callback = *abi.ConvertType(out[1], new(IBrevisTypesCallback)).(*IBrevisTypesCallback)

	return *outstruct, err

}

// OnchainRequests is a free data retrieval call binding the contract method 0xc49af0fa.
//
// Solidity: function onchainRequests(bytes32 ) view returns(bytes32 feeHash, (address,uint64) callback)
func (_BrevisRequest *BrevisRequestSession) OnchainRequests(arg0 [32]byte) (struct {
	FeeHash  [32]byte
	Callback IBrevisTypesCallback
}, error) {
	return _BrevisRequest.Contract.OnchainRequests(&_BrevisRequest.CallOpts, arg0)
}

// OnchainRequests is a free data retrieval call binding the contract method 0xc49af0fa.
//
// Solidity: function onchainRequests(bytes32 ) view returns(bytes32 feeHash, (address,uint64) callback)
func (_BrevisRequest *BrevisRequestCallerSession) OnchainRequests(arg0 [32]byte) (struct {
	FeeHash  [32]byte
	Callback IBrevisTypesCallback
}, error) {
	return _BrevisRequest.Contract.OnchainRequests(&_BrevisRequest.CallOpts, arg0)
}

// Opdata is a free data retrieval call binding the contract method 0xc2eaa931.
//
// Solidity: function opdata(bytes32 ) view returns(bytes32)
func (_BrevisRequest *BrevisRequestCaller) Opdata(opts *bind.CallOpts, arg0 [32]byte) ([32]byte, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "opdata", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// Opdata is a free data retrieval call binding the contract method 0xc2eaa931.
//
// Solidity: function opdata(bytes32 ) view returns(bytes32)
func (_BrevisRequest *BrevisRequestSession) Opdata(arg0 [32]byte) ([32]byte, error) {
	return _BrevisRequest.Contract.Opdata(&_BrevisRequest.CallOpts, arg0)
}

// Opdata is a free data retrieval call binding the contract method 0xc2eaa931.
//
// Solidity: function opdata(bytes32 ) view returns(bytes32)
func (_BrevisRequest *BrevisRequestCallerSession) Opdata(arg0 [32]byte) ([32]byte, error) {
	return _BrevisRequest.Contract.Opdata(&_BrevisRequest.CallOpts, arg0)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BrevisRequest *BrevisRequestCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BrevisRequest *BrevisRequestSession) Owner() (common.Address, error) {
	return _BrevisRequest.Contract.Owner(&_BrevisRequest.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_BrevisRequest *BrevisRequestCallerSession) Owner() (common.Address, error) {
	return _BrevisRequest.Contract.Owner(&_BrevisRequest.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BrevisRequest *BrevisRequestCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BrevisRequest *BrevisRequestSession) Paused() (bool, error) {
	return _BrevisRequest.Contract.Paused(&_BrevisRequest.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_BrevisRequest *BrevisRequestCallerSession) Paused() (bool, error) {
	return _BrevisRequest.Contract.Paused(&_BrevisRequest.CallOpts)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BrevisRequest *BrevisRequestCaller) PauserList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "pauserList", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BrevisRequest *BrevisRequestSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _BrevisRequest.Contract.PauserList(&_BrevisRequest.CallOpts, arg0)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_BrevisRequest *BrevisRequestCallerSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _BrevisRequest.Contract.PauserList(&_BrevisRequest.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BrevisRequest *BrevisRequestCaller) Pausers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "pausers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BrevisRequest *BrevisRequestSession) Pausers(arg0 common.Address) (bool, error) {
	return _BrevisRequest.Contract.Pausers(&_BrevisRequest.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_BrevisRequest *BrevisRequestCallerSession) Pausers(arg0 common.Address) (bool, error) {
	return _BrevisRequest.Contract.Pausers(&_BrevisRequest.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BrevisRequest *BrevisRequestCaller) ProverStates(opts *bind.CallOpts, arg0 common.Address) (uint8, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "proverStates", arg0)

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BrevisRequest *BrevisRequestSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _BrevisRequest.Contract.ProverStates(&_BrevisRequest.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_BrevisRequest *BrevisRequestCallerSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _BrevisRequest.Contract.ProverStates(&_BrevisRequest.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BrevisRequest *BrevisRequestCaller) Provers(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "provers", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BrevisRequest *BrevisRequestSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _BrevisRequest.Contract.Provers(&_BrevisRequest.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_BrevisRequest *BrevisRequestCallerSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _BrevisRequest.Contract.Provers(&_BrevisRequest.CallOpts, arg0)
}

// QueryRequestStatus is a free data retrieval call binding the contract method 0xa65b3c06.
//
// Solidity: function queryRequestStatus(bytes32 _proofId, uint64 _nonce) view returns(uint8, uint8)
func (_BrevisRequest *BrevisRequestCaller) QueryRequestStatus(opts *bind.CallOpts, _proofId [32]byte, _nonce uint64) (uint8, uint8, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "queryRequestStatus", _proofId, _nonce)

	if err != nil {
		return *new(uint8), *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)
	out1 := *abi.ConvertType(out[1], new(uint8)).(*uint8)

	return out0, out1, err

}

// QueryRequestStatus is a free data retrieval call binding the contract method 0xa65b3c06.
//
// Solidity: function queryRequestStatus(bytes32 _proofId, uint64 _nonce) view returns(uint8, uint8)
func (_BrevisRequest *BrevisRequestSession) QueryRequestStatus(_proofId [32]byte, _nonce uint64) (uint8, uint8, error) {
	return _BrevisRequest.Contract.QueryRequestStatus(&_BrevisRequest.CallOpts, _proofId, _nonce)
}

// QueryRequestStatus is a free data retrieval call binding the contract method 0xa65b3c06.
//
// Solidity: function queryRequestStatus(bytes32 _proofId, uint64 _nonce) view returns(uint8, uint8)
func (_BrevisRequest *BrevisRequestCallerSession) QueryRequestStatus(_proofId [32]byte, _nonce uint64) (uint8, uint8, error) {
	return _BrevisRequest.Contract.QueryRequestStatus(&_BrevisRequest.CallOpts, _proofId, _nonce)
}

// QueryRequestStatus0 is a free data retrieval call binding the contract method 0xb33e1a39.
//
// Solidity: function queryRequestStatus(bytes32 _proofId, uint64 _nonce, uint256 _challengeWindow) view returns(uint8, uint8)
func (_BrevisRequest *BrevisRequestCaller) QueryRequestStatus0(opts *bind.CallOpts, _proofId [32]byte, _nonce uint64, _challengeWindow *big.Int) (uint8, uint8, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "queryRequestStatus0", _proofId, _nonce, _challengeWindow)

	if err != nil {
		return *new(uint8), *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)
	out1 := *abi.ConvertType(out[1], new(uint8)).(*uint8)

	return out0, out1, err

}

// QueryRequestStatus0 is a free data retrieval call binding the contract method 0xb33e1a39.
//
// Solidity: function queryRequestStatus(bytes32 _proofId, uint64 _nonce, uint256 _challengeWindow) view returns(uint8, uint8)
func (_BrevisRequest *BrevisRequestSession) QueryRequestStatus0(_proofId [32]byte, _nonce uint64, _challengeWindow *big.Int) (uint8, uint8, error) {
	return _BrevisRequest.Contract.QueryRequestStatus0(&_BrevisRequest.CallOpts, _proofId, _nonce, _challengeWindow)
}

// QueryRequestStatus0 is a free data retrieval call binding the contract method 0xb33e1a39.
//
// Solidity: function queryRequestStatus(bytes32 _proofId, uint64 _nonce, uint256 _challengeWindow) view returns(uint8, uint8)
func (_BrevisRequest *BrevisRequestCallerSession) QueryRequestStatus0(_proofId [32]byte, _nonce uint64, _challengeWindow *big.Int) (uint8, uint8, error) {
	return _BrevisRequest.Contract.QueryRequestStatus0(&_BrevisRequest.CallOpts, _proofId, _nonce, _challengeWindow)
}

// RequestTimeout is a free data retrieval call binding the contract method 0x3f20b4c9.
//
// Solidity: function requestTimeout() view returns(uint256)
func (_BrevisRequest *BrevisRequestCaller) RequestTimeout(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "requestTimeout")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// RequestTimeout is a free data retrieval call binding the contract method 0x3f20b4c9.
//
// Solidity: function requestTimeout() view returns(uint256)
func (_BrevisRequest *BrevisRequestSession) RequestTimeout() (*big.Int, error) {
	return _BrevisRequest.Contract.RequestTimeout(&_BrevisRequest.CallOpts)
}

// RequestTimeout is a free data retrieval call binding the contract method 0x3f20b4c9.
//
// Solidity: function requestTimeout() view returns(uint256)
func (_BrevisRequest *BrevisRequestCallerSession) RequestTimeout() (*big.Int, error) {
	return _BrevisRequest.Contract.RequestTimeout(&_BrevisRequest.CallOpts)
}

// Requests is a free data retrieval call binding the contract method 0x9d866985.
//
// Solidity: function requests(bytes32 ) view returns(uint8 status, uint64 timestamp, uint8 option)
func (_BrevisRequest *BrevisRequestCaller) Requests(opts *bind.CallOpts, arg0 [32]byte) (struct {
	Status    uint8
	Timestamp uint64
	Option    uint8
}, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "requests", arg0)

	outstruct := new(struct {
		Status    uint8
		Timestamp uint64
		Option    uint8
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Status = *abi.ConvertType(out[0], new(uint8)).(*uint8)
	outstruct.Timestamp = *abi.ConvertType(out[1], new(uint64)).(*uint64)
	outstruct.Option = *abi.ConvertType(out[2], new(uint8)).(*uint8)

	return *outstruct, err

}

// Requests is a free data retrieval call binding the contract method 0x9d866985.
//
// Solidity: function requests(bytes32 ) view returns(uint8 status, uint64 timestamp, uint8 option)
func (_BrevisRequest *BrevisRequestSession) Requests(arg0 [32]byte) (struct {
	Status    uint8
	Timestamp uint64
	Option    uint8
}, error) {
	return _BrevisRequest.Contract.Requests(&_BrevisRequest.CallOpts, arg0)
}

// Requests is a free data retrieval call binding the contract method 0x9d866985.
//
// Solidity: function requests(bytes32 ) view returns(uint8 status, uint64 timestamp, uint8 option)
func (_BrevisRequest *BrevisRequestCallerSession) Requests(arg0 [32]byte) (struct {
	Status    uint8
	Timestamp uint64
	Option    uint8
}, error) {
	return _BrevisRequest.Contract.Requests(&_BrevisRequest.CallOpts, arg0)
}

// ValidateOpAppData is a free data retrieval call binding the contract method 0x54eee2f0.
//
// Solidity: function validateOpAppData(bytes32 _proofId, uint64 _nonce, bytes32 _appCommitHash, bytes32 _appVkHash, uint256 _challengeWindow, uint8 _option) view returns(bool)
func (_BrevisRequest *BrevisRequestCaller) ValidateOpAppData(opts *bind.CallOpts, _proofId [32]byte, _nonce uint64, _appCommitHash [32]byte, _appVkHash [32]byte, _challengeWindow *big.Int, _option uint8) (bool, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "validateOpAppData", _proofId, _nonce, _appCommitHash, _appVkHash, _challengeWindow, _option)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// ValidateOpAppData is a free data retrieval call binding the contract method 0x54eee2f0.
//
// Solidity: function validateOpAppData(bytes32 _proofId, uint64 _nonce, bytes32 _appCommitHash, bytes32 _appVkHash, uint256 _challengeWindow, uint8 _option) view returns(bool)
func (_BrevisRequest *BrevisRequestSession) ValidateOpAppData(_proofId [32]byte, _nonce uint64, _appCommitHash [32]byte, _appVkHash [32]byte, _challengeWindow *big.Int, _option uint8) (bool, error) {
	return _BrevisRequest.Contract.ValidateOpAppData(&_BrevisRequest.CallOpts, _proofId, _nonce, _appCommitHash, _appVkHash, _challengeWindow, _option)
}

// ValidateOpAppData is a free data retrieval call binding the contract method 0x54eee2f0.
//
// Solidity: function validateOpAppData(bytes32 _proofId, uint64 _nonce, bytes32 _appCommitHash, bytes32 _appVkHash, uint256 _challengeWindow, uint8 _option) view returns(bool)
func (_BrevisRequest *BrevisRequestCallerSession) ValidateOpAppData(_proofId [32]byte, _nonce uint64, _appCommitHash [32]byte, _appVkHash [32]byte, _challengeWindow *big.Int, _option uint8) (bool, error) {
	return _BrevisRequest.Contract.ValidateOpAppData(&_BrevisRequest.CallOpts, _proofId, _nonce, _appCommitHash, _appVkHash, _challengeWindow, _option)
}

// ValidateOpAppData0 is a free data retrieval call binding the contract method 0x84c2d279.
//
// Solidity: function validateOpAppData(bytes32 _proofId, uint64 _nonce, bytes32 _appCommitHash, bytes32 _appVkHash, uint8 _option) view returns(bool)
func (_BrevisRequest *BrevisRequestCaller) ValidateOpAppData0(opts *bind.CallOpts, _proofId [32]byte, _nonce uint64, _appCommitHash [32]byte, _appVkHash [32]byte, _option uint8) (bool, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "validateOpAppData0", _proofId, _nonce, _appCommitHash, _appVkHash, _option)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// ValidateOpAppData0 is a free data retrieval call binding the contract method 0x84c2d279.
//
// Solidity: function validateOpAppData(bytes32 _proofId, uint64 _nonce, bytes32 _appCommitHash, bytes32 _appVkHash, uint8 _option) view returns(bool)
func (_BrevisRequest *BrevisRequestSession) ValidateOpAppData0(_proofId [32]byte, _nonce uint64, _appCommitHash [32]byte, _appVkHash [32]byte, _option uint8) (bool, error) {
	return _BrevisRequest.Contract.ValidateOpAppData0(&_BrevisRequest.CallOpts, _proofId, _nonce, _appCommitHash, _appVkHash, _option)
}

// ValidateOpAppData0 is a free data retrieval call binding the contract method 0x84c2d279.
//
// Solidity: function validateOpAppData(bytes32 _proofId, uint64 _nonce, bytes32 _appCommitHash, bytes32 _appVkHash, uint8 _option) view returns(bool)
func (_BrevisRequest *BrevisRequestCallerSession) ValidateOpAppData0(_proofId [32]byte, _nonce uint64, _appCommitHash [32]byte, _appVkHash [32]byte, _option uint8) (bool, error) {
	return _BrevisRequest.Contract.ValidateOpAppData0(&_BrevisRequest.CallOpts, _proofId, _nonce, _appCommitHash, _appVkHash, _option)
}

// ValidateOpAppData1 is a free data retrieval call binding the contract method 0xa90f4bd7.
//
// Solidity: function validateOpAppData(bytes32[] _proofIds, uint64[] _nonces, bytes32[] _appCommitHashes, bytes32[] _appVkHashes, uint256 _challengeWindow, uint8 _option) view returns(bool)
func (_BrevisRequest *BrevisRequestCaller) ValidateOpAppData1(opts *bind.CallOpts, _proofIds [][32]byte, _nonces []uint64, _appCommitHashes [][32]byte, _appVkHashes [][32]byte, _challengeWindow *big.Int, _option uint8) (bool, error) {
	var out []interface{}
	err := _BrevisRequest.contract.Call(opts, &out, "validateOpAppData1", _proofIds, _nonces, _appCommitHashes, _appVkHashes, _challengeWindow, _option)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// ValidateOpAppData1 is a free data retrieval call binding the contract method 0xa90f4bd7.
//
// Solidity: function validateOpAppData(bytes32[] _proofIds, uint64[] _nonces, bytes32[] _appCommitHashes, bytes32[] _appVkHashes, uint256 _challengeWindow, uint8 _option) view returns(bool)
func (_BrevisRequest *BrevisRequestSession) ValidateOpAppData1(_proofIds [][32]byte, _nonces []uint64, _appCommitHashes [][32]byte, _appVkHashes [][32]byte, _challengeWindow *big.Int, _option uint8) (bool, error) {
	return _BrevisRequest.Contract.ValidateOpAppData1(&_BrevisRequest.CallOpts, _proofIds, _nonces, _appCommitHashes, _appVkHashes, _challengeWindow, _option)
}

// ValidateOpAppData1 is a free data retrieval call binding the contract method 0xa90f4bd7.
//
// Solidity: function validateOpAppData(bytes32[] _proofIds, uint64[] _nonces, bytes32[] _appCommitHashes, bytes32[] _appVkHashes, uint256 _challengeWindow, uint8 _option) view returns(bool)
func (_BrevisRequest *BrevisRequestCallerSession) ValidateOpAppData1(_proofIds [][32]byte, _nonces []uint64, _appCommitHashes [][32]byte, _appVkHashes [][32]byte, _challengeWindow *big.Int, _option uint8) (bool, error) {
	return _BrevisRequest.Contract.ValidateOpAppData1(&_BrevisRequest.CallOpts, _proofIds, _nonces, _appCommitHashes, _appVkHashes, _challengeWindow, _option)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BrevisRequest *BrevisRequestTransactor) AddPauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "addPauser", account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BrevisRequest *BrevisRequestSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.AddPauser(&_BrevisRequest.TransactOpts, account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.AddPauser(&_BrevisRequest.TransactOpts, account)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BrevisRequest *BrevisRequestTransactor) AddPausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "addPausers", accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BrevisRequest *BrevisRequestSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.AddPausers(&_BrevisRequest.TransactOpts, accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.AddPausers(&_BrevisRequest.TransactOpts, accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BrevisRequest *BrevisRequestTransactor) AddProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "addProvers", _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BrevisRequest *BrevisRequestSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.AddProvers(&_BrevisRequest.TransactOpts, _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.AddProvers(&_BrevisRequest.TransactOpts, _accounts)
}

// ApplyBrevisAggProof is a paid mutator transaction binding the contract method 0x8cd2ed66.
//
// Solidity: function applyBrevisAggProof(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32) _proofData, bytes32 _merkleRoot, bytes32[] _merkleProof, uint8 _nodeIndex, bytes _appCircuitOutput, address _callbackTarget) returns()
func (_BrevisRequest *BrevisRequestTransactor) ApplyBrevisAggProof(opts *bind.TransactOpts, _chainId uint64, _proofData BrevisProofData, _merkleRoot [32]byte, _merkleProof [][32]byte, _nodeIndex uint8, _appCircuitOutput []byte, _callbackTarget common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "applyBrevisAggProof", _chainId, _proofData, _merkleRoot, _merkleProof, _nodeIndex, _appCircuitOutput, _callbackTarget)
}

// ApplyBrevisAggProof is a paid mutator transaction binding the contract method 0x8cd2ed66.
//
// Solidity: function applyBrevisAggProof(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32) _proofData, bytes32 _merkleRoot, bytes32[] _merkleProof, uint8 _nodeIndex, bytes _appCircuitOutput, address _callbackTarget) returns()
func (_BrevisRequest *BrevisRequestSession) ApplyBrevisAggProof(_chainId uint64, _proofData BrevisProofData, _merkleRoot [32]byte, _merkleProof [][32]byte, _nodeIndex uint8, _appCircuitOutput []byte, _callbackTarget common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.ApplyBrevisAggProof(&_BrevisRequest.TransactOpts, _chainId, _proofData, _merkleRoot, _merkleProof, _nodeIndex, _appCircuitOutput, _callbackTarget)
}

// ApplyBrevisAggProof is a paid mutator transaction binding the contract method 0x8cd2ed66.
//
// Solidity: function applyBrevisAggProof(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32) _proofData, bytes32 _merkleRoot, bytes32[] _merkleProof, uint8 _nodeIndex, bytes _appCircuitOutput, address _callbackTarget) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) ApplyBrevisAggProof(_chainId uint64, _proofData BrevisProofData, _merkleRoot [32]byte, _merkleProof [][32]byte, _nodeIndex uint8, _appCircuitOutput []byte, _callbackTarget common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.ApplyBrevisAggProof(&_BrevisRequest.TransactOpts, _chainId, _proofData, _merkleRoot, _merkleProof, _nodeIndex, _appCircuitOutput, _callbackTarget)
}

// ApplyBrevisAggProof0 is a paid mutator transaction binding the contract method 0xbc7c2050.
//
// Solidity: function applyBrevisAggProof(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray, bytes[] _appCircuitOutputs, address[] _callbackTargets) returns()
func (_BrevisRequest *BrevisRequestTransactor) ApplyBrevisAggProof0(opts *bind.TransactOpts, _chainId uint64, _proofDataArray []BrevisProofData, _appCircuitOutputs [][]byte, _callbackTargets []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "applyBrevisAggProof0", _chainId, _proofDataArray, _appCircuitOutputs, _callbackTargets)
}

// ApplyBrevisAggProof0 is a paid mutator transaction binding the contract method 0xbc7c2050.
//
// Solidity: function applyBrevisAggProof(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray, bytes[] _appCircuitOutputs, address[] _callbackTargets) returns()
func (_BrevisRequest *BrevisRequestSession) ApplyBrevisAggProof0(_chainId uint64, _proofDataArray []BrevisProofData, _appCircuitOutputs [][]byte, _callbackTargets []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.ApplyBrevisAggProof0(&_BrevisRequest.TransactOpts, _chainId, _proofDataArray, _appCircuitOutputs, _callbackTargets)
}

// ApplyBrevisAggProof0 is a paid mutator transaction binding the contract method 0xbc7c2050.
//
// Solidity: function applyBrevisAggProof(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray, bytes[] _appCircuitOutputs, address[] _callbackTargets) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) ApplyBrevisAggProof0(_chainId uint64, _proofDataArray []BrevisProofData, _appCircuitOutputs [][]byte, _callbackTargets []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.ApplyBrevisAggProof0(&_BrevisRequest.TransactOpts, _chainId, _proofDataArray, _appCircuitOutputs, _callbackTargets)
}

// ApplyBrevisProof is a paid mutator transaction binding the contract method 0x0dbeefaf.
//
// Solidity: function applyBrevisProof(bytes32 _proofId, bytes32 _appVkHash, bytes32 _appCommitHash, bytes _appCircuitOutput, address _callbackTarget) returns()
func (_BrevisRequest *BrevisRequestTransactor) ApplyBrevisProof(opts *bind.TransactOpts, _proofId [32]byte, _appVkHash [32]byte, _appCommitHash [32]byte, _appCircuitOutput []byte, _callbackTarget common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "applyBrevisProof", _proofId, _appVkHash, _appCommitHash, _appCircuitOutput, _callbackTarget)
}

// ApplyBrevisProof is a paid mutator transaction binding the contract method 0x0dbeefaf.
//
// Solidity: function applyBrevisProof(bytes32 _proofId, bytes32 _appVkHash, bytes32 _appCommitHash, bytes _appCircuitOutput, address _callbackTarget) returns()
func (_BrevisRequest *BrevisRequestSession) ApplyBrevisProof(_proofId [32]byte, _appVkHash [32]byte, _appCommitHash [32]byte, _appCircuitOutput []byte, _callbackTarget common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.ApplyBrevisProof(&_BrevisRequest.TransactOpts, _proofId, _appVkHash, _appCommitHash, _appCircuitOutput, _callbackTarget)
}

// ApplyBrevisProof is a paid mutator transaction binding the contract method 0x0dbeefaf.
//
// Solidity: function applyBrevisProof(bytes32 _proofId, bytes32 _appVkHash, bytes32 _appCommitHash, bytes _appCircuitOutput, address _callbackTarget) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) ApplyBrevisProof(_proofId [32]byte, _appVkHash [32]byte, _appCommitHash [32]byte, _appCircuitOutput []byte, _callbackTarget common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.ApplyBrevisProof(&_BrevisRequest.TransactOpts, _proofId, _appVkHash, _appCommitHash, _appCircuitOutput, _callbackTarget)
}

// CollectFee is a paid mutator transaction binding the contract method 0x7ff7b0d2.
//
// Solidity: function collectFee(uint256 _amount, address _to) returns()
func (_BrevisRequest *BrevisRequestTransactor) CollectFee(opts *bind.TransactOpts, _amount *big.Int, _to common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "collectFee", _amount, _to)
}

// CollectFee is a paid mutator transaction binding the contract method 0x7ff7b0d2.
//
// Solidity: function collectFee(uint256 _amount, address _to) returns()
func (_BrevisRequest *BrevisRequestSession) CollectFee(_amount *big.Int, _to common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.CollectFee(&_BrevisRequest.TransactOpts, _amount, _to)
}

// CollectFee is a paid mutator transaction binding the contract method 0x7ff7b0d2.
//
// Solidity: function collectFee(uint256 _amount, address _to) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) CollectFee(_amount *big.Int, _to common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.CollectFee(&_BrevisRequest.TransactOpts, _amount, _to)
}

// FulfillOpRequests is a paid mutator transaction binding the contract method 0x35d43733.
//
// Solidity: function fulfillOpRequests(bytes32[] _proofIds, uint64[] _nonces, bytes32[] _appCommitHashes, bytes32[] _appVkHashes, (bytes[],address[],uint256[]) _bvnSigInfo, (uint64,(uint32[],(uint256,uint256)[],(uint256,uint256)[],(uint256[2],uint256[2]),(uint256,uint256),uint32[],uint32[],uint32[][])) _avsSigInfo) returns()
func (_BrevisRequest *BrevisRequestTransactor) FulfillOpRequests(opts *bind.TransactOpts, _proofIds [][32]byte, _nonces []uint64, _appCommitHashes [][32]byte, _appVkHashes [][32]byte, _bvnSigInfo IBvnSigsVerifierSigInfo, _avsSigInfo IAvsSigsVerifierSigInfo) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "fulfillOpRequests", _proofIds, _nonces, _appCommitHashes, _appVkHashes, _bvnSigInfo, _avsSigInfo)
}

// FulfillOpRequests is a paid mutator transaction binding the contract method 0x35d43733.
//
// Solidity: function fulfillOpRequests(bytes32[] _proofIds, uint64[] _nonces, bytes32[] _appCommitHashes, bytes32[] _appVkHashes, (bytes[],address[],uint256[]) _bvnSigInfo, (uint64,(uint32[],(uint256,uint256)[],(uint256,uint256)[],(uint256[2],uint256[2]),(uint256,uint256),uint32[],uint32[],uint32[][])) _avsSigInfo) returns()
func (_BrevisRequest *BrevisRequestSession) FulfillOpRequests(_proofIds [][32]byte, _nonces []uint64, _appCommitHashes [][32]byte, _appVkHashes [][32]byte, _bvnSigInfo IBvnSigsVerifierSigInfo, _avsSigInfo IAvsSigsVerifierSigInfo) (*types.Transaction, error) {
	return _BrevisRequest.Contract.FulfillOpRequests(&_BrevisRequest.TransactOpts, _proofIds, _nonces, _appCommitHashes, _appVkHashes, _bvnSigInfo, _avsSigInfo)
}

// FulfillOpRequests is a paid mutator transaction binding the contract method 0x35d43733.
//
// Solidity: function fulfillOpRequests(bytes32[] _proofIds, uint64[] _nonces, bytes32[] _appCommitHashes, bytes32[] _appVkHashes, (bytes[],address[],uint256[]) _bvnSigInfo, (uint64,(uint32[],(uint256,uint256)[],(uint256,uint256)[],(uint256[2],uint256[2]),(uint256,uint256),uint32[],uint32[],uint32[][])) _avsSigInfo) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) FulfillOpRequests(_proofIds [][32]byte, _nonces []uint64, _appCommitHashes [][32]byte, _appVkHashes [][32]byte, _bvnSigInfo IBvnSigsVerifierSigInfo, _avsSigInfo IAvsSigsVerifierSigInfo) (*types.Transaction, error) {
	return _BrevisRequest.Contract.FulfillOpRequests(&_BrevisRequest.TransactOpts, _proofIds, _nonces, _appCommitHashes, _appVkHashes, _bvnSigInfo, _avsSigInfo)
}

// FulfillRequest is a paid mutator transaction binding the contract method 0xcd978249.
//
// Solidity: function fulfillRequest(bytes32 _proofId, uint64 _nonce, uint64 _chainId, bytes _proof, bytes _appCircuitOutput, address _callbackTarget) returns()
func (_BrevisRequest *BrevisRequestTransactor) FulfillRequest(opts *bind.TransactOpts, _proofId [32]byte, _nonce uint64, _chainId uint64, _proof []byte, _appCircuitOutput []byte, _callbackTarget common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "fulfillRequest", _proofId, _nonce, _chainId, _proof, _appCircuitOutput, _callbackTarget)
}

// FulfillRequest is a paid mutator transaction binding the contract method 0xcd978249.
//
// Solidity: function fulfillRequest(bytes32 _proofId, uint64 _nonce, uint64 _chainId, bytes _proof, bytes _appCircuitOutput, address _callbackTarget) returns()
func (_BrevisRequest *BrevisRequestSession) FulfillRequest(_proofId [32]byte, _nonce uint64, _chainId uint64, _proof []byte, _appCircuitOutput []byte, _callbackTarget common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.FulfillRequest(&_BrevisRequest.TransactOpts, _proofId, _nonce, _chainId, _proof, _appCircuitOutput, _callbackTarget)
}

// FulfillRequest is a paid mutator transaction binding the contract method 0xcd978249.
//
// Solidity: function fulfillRequest(bytes32 _proofId, uint64 _nonce, uint64 _chainId, bytes _proof, bytes _appCircuitOutput, address _callbackTarget) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) FulfillRequest(_proofId [32]byte, _nonce uint64, _chainId uint64, _proof []byte, _appCircuitOutput []byte, _callbackTarget common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.FulfillRequest(&_BrevisRequest.TransactOpts, _proofId, _nonce, _chainId, _proof, _appCircuitOutput, _callbackTarget)
}

// FulfillRequests is a paid mutator transaction binding the contract method 0xfb22b7a8.
//
// Solidity: function fulfillRequests(bytes32[] _proofIds, uint64[] _nonces, uint64 _chainId, bytes _proof, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray, bytes[] _appCircuitOutputs, address[] _callbackTargets) returns()
func (_BrevisRequest *BrevisRequestTransactor) FulfillRequests(opts *bind.TransactOpts, _proofIds [][32]byte, _nonces []uint64, _chainId uint64, _proof []byte, _proofDataArray []BrevisProofData, _appCircuitOutputs [][]byte, _callbackTargets []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "fulfillRequests", _proofIds, _nonces, _chainId, _proof, _proofDataArray, _appCircuitOutputs, _callbackTargets)
}

// FulfillRequests is a paid mutator transaction binding the contract method 0xfb22b7a8.
//
// Solidity: function fulfillRequests(bytes32[] _proofIds, uint64[] _nonces, uint64 _chainId, bytes _proof, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray, bytes[] _appCircuitOutputs, address[] _callbackTargets) returns()
func (_BrevisRequest *BrevisRequestSession) FulfillRequests(_proofIds [][32]byte, _nonces []uint64, _chainId uint64, _proof []byte, _proofDataArray []BrevisProofData, _appCircuitOutputs [][]byte, _callbackTargets []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.FulfillRequests(&_BrevisRequest.TransactOpts, _proofIds, _nonces, _chainId, _proof, _proofDataArray, _appCircuitOutputs, _callbackTargets)
}

// FulfillRequests is a paid mutator transaction binding the contract method 0xfb22b7a8.
//
// Solidity: function fulfillRequests(bytes32[] _proofIds, uint64[] _nonces, uint64 _chainId, bytes _proof, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray, bytes[] _appCircuitOutputs, address[] _callbackTargets) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) FulfillRequests(_proofIds [][32]byte, _nonces []uint64, _chainId uint64, _proof []byte, _proofDataArray []BrevisProofData, _appCircuitOutputs [][]byte, _callbackTargets []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.FulfillRequests(&_BrevisRequest.TransactOpts, _proofIds, _nonces, _chainId, _proof, _proofDataArray, _appCircuitOutputs, _callbackTargets)
}

// IncreaseGasFee is a paid mutator transaction binding the contract method 0xc33529ae.
//
// Solidity: function increaseGasFee(bytes32 _proofId, uint64 _nonce, uint64 _addGas, uint256 _currentFee, address _refundee) payable returns()
func (_BrevisRequest *BrevisRequestTransactor) IncreaseGasFee(opts *bind.TransactOpts, _proofId [32]byte, _nonce uint64, _addGas uint64, _currentFee *big.Int, _refundee common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "increaseGasFee", _proofId, _nonce, _addGas, _currentFee, _refundee)
}

// IncreaseGasFee is a paid mutator transaction binding the contract method 0xc33529ae.
//
// Solidity: function increaseGasFee(bytes32 _proofId, uint64 _nonce, uint64 _addGas, uint256 _currentFee, address _refundee) payable returns()
func (_BrevisRequest *BrevisRequestSession) IncreaseGasFee(_proofId [32]byte, _nonce uint64, _addGas uint64, _currentFee *big.Int, _refundee common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.IncreaseGasFee(&_BrevisRequest.TransactOpts, _proofId, _nonce, _addGas, _currentFee, _refundee)
}

// IncreaseGasFee is a paid mutator transaction binding the contract method 0xc33529ae.
//
// Solidity: function increaseGasFee(bytes32 _proofId, uint64 _nonce, uint64 _addGas, uint256 _currentFee, address _refundee) payable returns()
func (_BrevisRequest *BrevisRequestTransactorSession) IncreaseGasFee(_proofId [32]byte, _nonce uint64, _addGas uint64, _currentFee *big.Int, _refundee common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.IncreaseGasFee(&_BrevisRequest.TransactOpts, _proofId, _nonce, _addGas, _currentFee, _refundee)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BrevisRequest *BrevisRequestTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BrevisRequest *BrevisRequestSession) Pause() (*types.Transaction, error) {
	return _BrevisRequest.Contract.Pause(&_BrevisRequest.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_BrevisRequest *BrevisRequestTransactorSession) Pause() (*types.Transaction, error) {
	return _BrevisRequest.Contract.Pause(&_BrevisRequest.TransactOpts)
}

// Refund is a paid mutator transaction binding the contract method 0xfc0cfccc.
//
// Solidity: function refund(bytes32 _proofId, uint64 _nonce, uint256 _amount, address _refundee) returns()
func (_BrevisRequest *BrevisRequestTransactor) Refund(opts *bind.TransactOpts, _proofId [32]byte, _nonce uint64, _amount *big.Int, _refundee common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "refund", _proofId, _nonce, _amount, _refundee)
}

// Refund is a paid mutator transaction binding the contract method 0xfc0cfccc.
//
// Solidity: function refund(bytes32 _proofId, uint64 _nonce, uint256 _amount, address _refundee) returns()
func (_BrevisRequest *BrevisRequestSession) Refund(_proofId [32]byte, _nonce uint64, _amount *big.Int, _refundee common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.Refund(&_BrevisRequest.TransactOpts, _proofId, _nonce, _amount, _refundee)
}

// Refund is a paid mutator transaction binding the contract method 0xfc0cfccc.
//
// Solidity: function refund(bytes32 _proofId, uint64 _nonce, uint256 _amount, address _refundee) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) Refund(_proofId [32]byte, _nonce uint64, _amount *big.Int, _refundee common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.Refund(&_BrevisRequest.TransactOpts, _proofId, _nonce, _amount, _refundee)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BrevisRequest *BrevisRequestTransactor) RemovePauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "removePauser", account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BrevisRequest *BrevisRequestSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.RemovePauser(&_BrevisRequest.TransactOpts, account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.RemovePauser(&_BrevisRequest.TransactOpts, account)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BrevisRequest *BrevisRequestTransactor) RemovePausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "removePausers", accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BrevisRequest *BrevisRequestSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.RemovePausers(&_BrevisRequest.TransactOpts, accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.RemovePausers(&_BrevisRequest.TransactOpts, accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BrevisRequest *BrevisRequestTransactor) RemoveProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "removeProvers", _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BrevisRequest *BrevisRequestSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.RemoveProvers(&_BrevisRequest.TransactOpts, _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.RemoveProvers(&_BrevisRequest.TransactOpts, _accounts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BrevisRequest *BrevisRequestTransactor) RenouncePauser(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "renouncePauser")
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BrevisRequest *BrevisRequestSession) RenouncePauser() (*types.Transaction, error) {
	return _BrevisRequest.Contract.RenouncePauser(&_BrevisRequest.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_BrevisRequest *BrevisRequestTransactorSession) RenouncePauser() (*types.Transaction, error) {
	return _BrevisRequest.Contract.RenouncePauser(&_BrevisRequest.TransactOpts)
}

// SendRequest is a paid mutator transaction binding the contract method 0x191fa9b6.
//
// Solidity: function sendRequest(bytes32 _proofId, uint64 _nonce, address _refundee, (address,uint64) _callback, uint8 _option) payable returns()
func (_BrevisRequest *BrevisRequestTransactor) SendRequest(opts *bind.TransactOpts, _proofId [32]byte, _nonce uint64, _refundee common.Address, _callback IBrevisTypesCallback, _option uint8) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "sendRequest", _proofId, _nonce, _refundee, _callback, _option)
}

// SendRequest is a paid mutator transaction binding the contract method 0x191fa9b6.
//
// Solidity: function sendRequest(bytes32 _proofId, uint64 _nonce, address _refundee, (address,uint64) _callback, uint8 _option) payable returns()
func (_BrevisRequest *BrevisRequestSession) SendRequest(_proofId [32]byte, _nonce uint64, _refundee common.Address, _callback IBrevisTypesCallback, _option uint8) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SendRequest(&_BrevisRequest.TransactOpts, _proofId, _nonce, _refundee, _callback, _option)
}

// SendRequest is a paid mutator transaction binding the contract method 0x191fa9b6.
//
// Solidity: function sendRequest(bytes32 _proofId, uint64 _nonce, address _refundee, (address,uint64) _callback, uint8 _option) payable returns()
func (_BrevisRequest *BrevisRequestTransactorSession) SendRequest(_proofId [32]byte, _nonce uint64, _refundee common.Address, _callback IBrevisTypesCallback, _option uint8) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SendRequest(&_BrevisRequest.TransactOpts, _proofId, _nonce, _refundee, _callback, _option)
}

// SetAvsSigsVerifier is a paid mutator transaction binding the contract method 0xa8135374.
//
// Solidity: function setAvsSigsVerifier(address _avsSigsVerifier) returns()
func (_BrevisRequest *BrevisRequestTransactor) SetAvsSigsVerifier(opts *bind.TransactOpts, _avsSigsVerifier common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "setAvsSigsVerifier", _avsSigsVerifier)
}

// SetAvsSigsVerifier is a paid mutator transaction binding the contract method 0xa8135374.
//
// Solidity: function setAvsSigsVerifier(address _avsSigsVerifier) returns()
func (_BrevisRequest *BrevisRequestSession) SetAvsSigsVerifier(_avsSigsVerifier common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetAvsSigsVerifier(&_BrevisRequest.TransactOpts, _avsSigsVerifier)
}

// SetAvsSigsVerifier is a paid mutator transaction binding the contract method 0xa8135374.
//
// Solidity: function setAvsSigsVerifier(address _avsSigsVerifier) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) SetAvsSigsVerifier(_avsSigsVerifier common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetAvsSigsVerifier(&_BrevisRequest.TransactOpts, _avsSigsVerifier)
}

// SetBaseDataURL is a paid mutator transaction binding the contract method 0x7a784a1c.
//
// Solidity: function setBaseDataURL(string _url) returns()
func (_BrevisRequest *BrevisRequestTransactor) SetBaseDataURL(opts *bind.TransactOpts, _url string) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "setBaseDataURL", _url)
}

// SetBaseDataURL is a paid mutator transaction binding the contract method 0x7a784a1c.
//
// Solidity: function setBaseDataURL(string _url) returns()
func (_BrevisRequest *BrevisRequestSession) SetBaseDataURL(_url string) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetBaseDataURL(&_BrevisRequest.TransactOpts, _url)
}

// SetBaseDataURL is a paid mutator transaction binding the contract method 0x7a784a1c.
//
// Solidity: function setBaseDataURL(string _url) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) SetBaseDataURL(_url string) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetBaseDataURL(&_BrevisRequest.TransactOpts, _url)
}

// SetBrevisDispute is a paid mutator transaction binding the contract method 0xb5c06c33.
//
// Solidity: function setBrevisDispute(address _brevisDispute) returns()
func (_BrevisRequest *BrevisRequestTransactor) SetBrevisDispute(opts *bind.TransactOpts, _brevisDispute common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "setBrevisDispute", _brevisDispute)
}

// SetBrevisDispute is a paid mutator transaction binding the contract method 0xb5c06c33.
//
// Solidity: function setBrevisDispute(address _brevisDispute) returns()
func (_BrevisRequest *BrevisRequestSession) SetBrevisDispute(_brevisDispute common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetBrevisDispute(&_BrevisRequest.TransactOpts, _brevisDispute)
}

// SetBrevisDispute is a paid mutator transaction binding the contract method 0xb5c06c33.
//
// Solidity: function setBrevisDispute(address _brevisDispute) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) SetBrevisDispute(_brevisDispute common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetBrevisDispute(&_BrevisRequest.TransactOpts, _brevisDispute)
}

// SetBrevisProof is a paid mutator transaction binding the contract method 0xc772c87f.
//
// Solidity: function setBrevisProof(address _brevisProof) returns()
func (_BrevisRequest *BrevisRequestTransactor) SetBrevisProof(opts *bind.TransactOpts, _brevisProof common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "setBrevisProof", _brevisProof)
}

// SetBrevisProof is a paid mutator transaction binding the contract method 0xc772c87f.
//
// Solidity: function setBrevisProof(address _brevisProof) returns()
func (_BrevisRequest *BrevisRequestSession) SetBrevisProof(_brevisProof common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetBrevisProof(&_BrevisRequest.TransactOpts, _brevisProof)
}

// SetBrevisProof is a paid mutator transaction binding the contract method 0xc772c87f.
//
// Solidity: function setBrevisProof(address _brevisProof) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) SetBrevisProof(_brevisProof common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetBrevisProof(&_BrevisRequest.TransactOpts, _brevisProof)
}

// SetBvnSigsVerifier is a paid mutator transaction binding the contract method 0x967a6581.
//
// Solidity: function setBvnSigsVerifier(address _bvnSigsVerifier) returns()
func (_BrevisRequest *BrevisRequestTransactor) SetBvnSigsVerifier(opts *bind.TransactOpts, _bvnSigsVerifier common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "setBvnSigsVerifier", _bvnSigsVerifier)
}

// SetBvnSigsVerifier is a paid mutator transaction binding the contract method 0x967a6581.
//
// Solidity: function setBvnSigsVerifier(address _bvnSigsVerifier) returns()
func (_BrevisRequest *BrevisRequestSession) SetBvnSigsVerifier(_bvnSigsVerifier common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetBvnSigsVerifier(&_BrevisRequest.TransactOpts, _bvnSigsVerifier)
}

// SetBvnSigsVerifier is a paid mutator transaction binding the contract method 0x967a6581.
//
// Solidity: function setBvnSigsVerifier(address _bvnSigsVerifier) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) SetBvnSigsVerifier(_bvnSigsVerifier common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetBvnSigsVerifier(&_BrevisRequest.TransactOpts, _bvnSigsVerifier)
}

// SetFeeCollector is a paid mutator transaction binding the contract method 0xa42dce80.
//
// Solidity: function setFeeCollector(address _feeCollector) returns()
func (_BrevisRequest *BrevisRequestTransactor) SetFeeCollector(opts *bind.TransactOpts, _feeCollector common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "setFeeCollector", _feeCollector)
}

// SetFeeCollector is a paid mutator transaction binding the contract method 0xa42dce80.
//
// Solidity: function setFeeCollector(address _feeCollector) returns()
func (_BrevisRequest *BrevisRequestSession) SetFeeCollector(_feeCollector common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetFeeCollector(&_BrevisRequest.TransactOpts, _feeCollector)
}

// SetFeeCollector is a paid mutator transaction binding the contract method 0xa42dce80.
//
// Solidity: function setFeeCollector(address _feeCollector) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) SetFeeCollector(_feeCollector common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetFeeCollector(&_BrevisRequest.TransactOpts, _feeCollector)
}

// SetRequestStatus is a paid mutator transaction binding the contract method 0x19d43eb5.
//
// Solidity: function setRequestStatus(bytes32 requestKey, uint8 _status) returns()
func (_BrevisRequest *BrevisRequestTransactor) SetRequestStatus(opts *bind.TransactOpts, requestKey [32]byte, _status uint8) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "setRequestStatus", requestKey, _status)
}

// SetRequestStatus is a paid mutator transaction binding the contract method 0x19d43eb5.
//
// Solidity: function setRequestStatus(bytes32 requestKey, uint8 _status) returns()
func (_BrevisRequest *BrevisRequestSession) SetRequestStatus(requestKey [32]byte, _status uint8) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetRequestStatus(&_BrevisRequest.TransactOpts, requestKey, _status)
}

// SetRequestStatus is a paid mutator transaction binding the contract method 0x19d43eb5.
//
// Solidity: function setRequestStatus(bytes32 requestKey, uint8 _status) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) SetRequestStatus(requestKey [32]byte, _status uint8) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetRequestStatus(&_BrevisRequest.TransactOpts, requestKey, _status)
}

// SetRequestTimeout is a paid mutator transaction binding the contract method 0x622b6af4.
//
// Solidity: function setRequestTimeout(uint256 _timeout) returns()
func (_BrevisRequest *BrevisRequestTransactor) SetRequestTimeout(opts *bind.TransactOpts, _timeout *big.Int) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "setRequestTimeout", _timeout)
}

// SetRequestTimeout is a paid mutator transaction binding the contract method 0x622b6af4.
//
// Solidity: function setRequestTimeout(uint256 _timeout) returns()
func (_BrevisRequest *BrevisRequestSession) SetRequestTimeout(_timeout *big.Int) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetRequestTimeout(&_BrevisRequest.TransactOpts, _timeout)
}

// SetRequestTimeout is a paid mutator transaction binding the contract method 0x622b6af4.
//
// Solidity: function setRequestTimeout(uint256 _timeout) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) SetRequestTimeout(_timeout *big.Int) (*types.Transaction, error) {
	return _BrevisRequest.Contract.SetRequestTimeout(&_BrevisRequest.TransactOpts, _timeout)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BrevisRequest *BrevisRequestTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BrevisRequest *BrevisRequestSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.TransferOwnership(&_BrevisRequest.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_BrevisRequest *BrevisRequestTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _BrevisRequest.Contract.TransferOwnership(&_BrevisRequest.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BrevisRequest *BrevisRequestTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisRequest.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BrevisRequest *BrevisRequestSession) Unpause() (*types.Transaction, error) {
	return _BrevisRequest.Contract.Unpause(&_BrevisRequest.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_BrevisRequest *BrevisRequestTransactorSession) Unpause() (*types.Transaction, error) {
	return _BrevisRequest.Contract.Unpause(&_BrevisRequest.TransactOpts)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_BrevisRequest *BrevisRequestTransactor) Receive(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisRequest.contract.RawTransact(opts, nil) // calldata is disallowed for receive function
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_BrevisRequest *BrevisRequestSession) Receive() (*types.Transaction, error) {
	return _BrevisRequest.Contract.Receive(&_BrevisRequest.TransactOpts)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_BrevisRequest *BrevisRequestTransactorSession) Receive() (*types.Transaction, error) {
	return _BrevisRequest.Contract.Receive(&_BrevisRequest.TransactOpts)
}

// BrevisRequestAvsSigsVerifierUpdatedIterator is returned from FilterAvsSigsVerifierUpdated and is used to iterate over the raw logs and unpacked data for AvsSigsVerifierUpdated events raised by the BrevisRequest contract.
type BrevisRequestAvsSigsVerifierUpdatedIterator struct {
	Event *BrevisRequestAvsSigsVerifierUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestAvsSigsVerifierUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestAvsSigsVerifierUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestAvsSigsVerifierUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestAvsSigsVerifierUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestAvsSigsVerifierUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestAvsSigsVerifierUpdated represents a AvsSigsVerifierUpdated event raised by the BrevisRequest contract.
type BrevisRequestAvsSigsVerifierUpdated struct {
	From common.Address
	To   common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterAvsSigsVerifierUpdated is a free log retrieval operation binding the contract event 0x06297769d0d4011879e4b190001e695e641c69d3dbcaf41b33a926214ad82d8c.
//
// Solidity: event AvsSigsVerifierUpdated(address from, address to)
func (_BrevisRequest *BrevisRequestFilterer) FilterAvsSigsVerifierUpdated(opts *bind.FilterOpts) (*BrevisRequestAvsSigsVerifierUpdatedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "AvsSigsVerifierUpdated")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestAvsSigsVerifierUpdatedIterator{contract: _BrevisRequest.contract, event: "AvsSigsVerifierUpdated", logs: logs, sub: sub}, nil
}

// WatchAvsSigsVerifierUpdated is a free log subscription operation binding the contract event 0x06297769d0d4011879e4b190001e695e641c69d3dbcaf41b33a926214ad82d8c.
//
// Solidity: event AvsSigsVerifierUpdated(address from, address to)
func (_BrevisRequest *BrevisRequestFilterer) WatchAvsSigsVerifierUpdated(opts *bind.WatchOpts, sink chan<- *BrevisRequestAvsSigsVerifierUpdated) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "AvsSigsVerifierUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestAvsSigsVerifierUpdated)
				if err := _BrevisRequest.contract.UnpackLog(event, "AvsSigsVerifierUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAvsSigsVerifierUpdated is a log parse operation binding the contract event 0x06297769d0d4011879e4b190001e695e641c69d3dbcaf41b33a926214ad82d8c.
//
// Solidity: event AvsSigsVerifierUpdated(address from, address to)
func (_BrevisRequest *BrevisRequestFilterer) ParseAvsSigsVerifierUpdated(log types.Log) (*BrevisRequestAvsSigsVerifierUpdated, error) {
	event := new(BrevisRequestAvsSigsVerifierUpdated)
	if err := _BrevisRequest.contract.UnpackLog(event, "AvsSigsVerifierUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestBaseDataUrlUpdatedIterator is returned from FilterBaseDataUrlUpdated and is used to iterate over the raw logs and unpacked data for BaseDataUrlUpdated events raised by the BrevisRequest contract.
type BrevisRequestBaseDataUrlUpdatedIterator struct {
	Event *BrevisRequestBaseDataUrlUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestBaseDataUrlUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestBaseDataUrlUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestBaseDataUrlUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestBaseDataUrlUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestBaseDataUrlUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestBaseDataUrlUpdated represents a BaseDataUrlUpdated event raised by the BrevisRequest contract.
type BrevisRequestBaseDataUrlUpdated struct {
	From string
	To   string
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterBaseDataUrlUpdated is a free log retrieval operation binding the contract event 0xe7fa7d4cb7253455bd011caadc607a0db44090fd2ea468dd50c5613ac9e9820f.
//
// Solidity: event BaseDataUrlUpdated(string from, string to)
func (_BrevisRequest *BrevisRequestFilterer) FilterBaseDataUrlUpdated(opts *bind.FilterOpts) (*BrevisRequestBaseDataUrlUpdatedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "BaseDataUrlUpdated")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestBaseDataUrlUpdatedIterator{contract: _BrevisRequest.contract, event: "BaseDataUrlUpdated", logs: logs, sub: sub}, nil
}

// WatchBaseDataUrlUpdated is a free log subscription operation binding the contract event 0xe7fa7d4cb7253455bd011caadc607a0db44090fd2ea468dd50c5613ac9e9820f.
//
// Solidity: event BaseDataUrlUpdated(string from, string to)
func (_BrevisRequest *BrevisRequestFilterer) WatchBaseDataUrlUpdated(opts *bind.WatchOpts, sink chan<- *BrevisRequestBaseDataUrlUpdated) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "BaseDataUrlUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestBaseDataUrlUpdated)
				if err := _BrevisRequest.contract.UnpackLog(event, "BaseDataUrlUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBaseDataUrlUpdated is a log parse operation binding the contract event 0xe7fa7d4cb7253455bd011caadc607a0db44090fd2ea468dd50c5613ac9e9820f.
//
// Solidity: event BaseDataUrlUpdated(string from, string to)
func (_BrevisRequest *BrevisRequestFilterer) ParseBaseDataUrlUpdated(log types.Log) (*BrevisRequestBaseDataUrlUpdated, error) {
	event := new(BrevisRequestBaseDataUrlUpdated)
	if err := _BrevisRequest.contract.UnpackLog(event, "BaseDataUrlUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestBrevisDisputeUpdatedIterator is returned from FilterBrevisDisputeUpdated and is used to iterate over the raw logs and unpacked data for BrevisDisputeUpdated events raised by the BrevisRequest contract.
type BrevisRequestBrevisDisputeUpdatedIterator struct {
	Event *BrevisRequestBrevisDisputeUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestBrevisDisputeUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestBrevisDisputeUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestBrevisDisputeUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestBrevisDisputeUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestBrevisDisputeUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestBrevisDisputeUpdated represents a BrevisDisputeUpdated event raised by the BrevisRequest contract.
type BrevisRequestBrevisDisputeUpdated struct {
	From common.Address
	To   common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterBrevisDisputeUpdated is a free log retrieval operation binding the contract event 0xe04e2434309a3c5548fe58cd48e2054b9f2c3a0581f0df4277aa52d191a8b794.
//
// Solidity: event BrevisDisputeUpdated(address from, address to)
func (_BrevisRequest *BrevisRequestFilterer) FilterBrevisDisputeUpdated(opts *bind.FilterOpts) (*BrevisRequestBrevisDisputeUpdatedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "BrevisDisputeUpdated")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestBrevisDisputeUpdatedIterator{contract: _BrevisRequest.contract, event: "BrevisDisputeUpdated", logs: logs, sub: sub}, nil
}

// WatchBrevisDisputeUpdated is a free log subscription operation binding the contract event 0xe04e2434309a3c5548fe58cd48e2054b9f2c3a0581f0df4277aa52d191a8b794.
//
// Solidity: event BrevisDisputeUpdated(address from, address to)
func (_BrevisRequest *BrevisRequestFilterer) WatchBrevisDisputeUpdated(opts *bind.WatchOpts, sink chan<- *BrevisRequestBrevisDisputeUpdated) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "BrevisDisputeUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestBrevisDisputeUpdated)
				if err := _BrevisRequest.contract.UnpackLog(event, "BrevisDisputeUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBrevisDisputeUpdated is a log parse operation binding the contract event 0xe04e2434309a3c5548fe58cd48e2054b9f2c3a0581f0df4277aa52d191a8b794.
//
// Solidity: event BrevisDisputeUpdated(address from, address to)
func (_BrevisRequest *BrevisRequestFilterer) ParseBrevisDisputeUpdated(log types.Log) (*BrevisRequestBrevisDisputeUpdated, error) {
	event := new(BrevisRequestBrevisDisputeUpdated)
	if err := _BrevisRequest.contract.UnpackLog(event, "BrevisDisputeUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestBrevisProofUpdatedIterator is returned from FilterBrevisProofUpdated and is used to iterate over the raw logs and unpacked data for BrevisProofUpdated events raised by the BrevisRequest contract.
type BrevisRequestBrevisProofUpdatedIterator struct {
	Event *BrevisRequestBrevisProofUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestBrevisProofUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestBrevisProofUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestBrevisProofUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestBrevisProofUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestBrevisProofUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestBrevisProofUpdated represents a BrevisProofUpdated event raised by the BrevisRequest contract.
type BrevisRequestBrevisProofUpdated struct {
	From common.Address
	To   common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterBrevisProofUpdated is a free log retrieval operation binding the contract event 0xddb7d4b45d521a6718ed9ccac62f1faa18b869772bca7e77ab6f392912a4ec18.
//
// Solidity: event BrevisProofUpdated(address from, address to)
func (_BrevisRequest *BrevisRequestFilterer) FilterBrevisProofUpdated(opts *bind.FilterOpts) (*BrevisRequestBrevisProofUpdatedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "BrevisProofUpdated")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestBrevisProofUpdatedIterator{contract: _BrevisRequest.contract, event: "BrevisProofUpdated", logs: logs, sub: sub}, nil
}

// WatchBrevisProofUpdated is a free log subscription operation binding the contract event 0xddb7d4b45d521a6718ed9ccac62f1faa18b869772bca7e77ab6f392912a4ec18.
//
// Solidity: event BrevisProofUpdated(address from, address to)
func (_BrevisRequest *BrevisRequestFilterer) WatchBrevisProofUpdated(opts *bind.WatchOpts, sink chan<- *BrevisRequestBrevisProofUpdated) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "BrevisProofUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestBrevisProofUpdated)
				if err := _BrevisRequest.contract.UnpackLog(event, "BrevisProofUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBrevisProofUpdated is a log parse operation binding the contract event 0xddb7d4b45d521a6718ed9ccac62f1faa18b869772bca7e77ab6f392912a4ec18.
//
// Solidity: event BrevisProofUpdated(address from, address to)
func (_BrevisRequest *BrevisRequestFilterer) ParseBrevisProofUpdated(log types.Log) (*BrevisRequestBrevisProofUpdated, error) {
	event := new(BrevisRequestBrevisProofUpdated)
	if err := _BrevisRequest.contract.UnpackLog(event, "BrevisProofUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestBvnSigsVerifierUpdatedIterator is returned from FilterBvnSigsVerifierUpdated and is used to iterate over the raw logs and unpacked data for BvnSigsVerifierUpdated events raised by the BrevisRequest contract.
type BrevisRequestBvnSigsVerifierUpdatedIterator struct {
	Event *BrevisRequestBvnSigsVerifierUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestBvnSigsVerifierUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestBvnSigsVerifierUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestBvnSigsVerifierUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestBvnSigsVerifierUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestBvnSigsVerifierUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestBvnSigsVerifierUpdated represents a BvnSigsVerifierUpdated event raised by the BrevisRequest contract.
type BrevisRequestBvnSigsVerifierUpdated struct {
	From common.Address
	To   common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterBvnSigsVerifierUpdated is a free log retrieval operation binding the contract event 0x032d76868790fdb5fb04c6f54308ddd47ecf8a80e5995610816aa0b29773b520.
//
// Solidity: event BvnSigsVerifierUpdated(address from, address to)
func (_BrevisRequest *BrevisRequestFilterer) FilterBvnSigsVerifierUpdated(opts *bind.FilterOpts) (*BrevisRequestBvnSigsVerifierUpdatedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "BvnSigsVerifierUpdated")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestBvnSigsVerifierUpdatedIterator{contract: _BrevisRequest.contract, event: "BvnSigsVerifierUpdated", logs: logs, sub: sub}, nil
}

// WatchBvnSigsVerifierUpdated is a free log subscription operation binding the contract event 0x032d76868790fdb5fb04c6f54308ddd47ecf8a80e5995610816aa0b29773b520.
//
// Solidity: event BvnSigsVerifierUpdated(address from, address to)
func (_BrevisRequest *BrevisRequestFilterer) WatchBvnSigsVerifierUpdated(opts *bind.WatchOpts, sink chan<- *BrevisRequestBvnSigsVerifierUpdated) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "BvnSigsVerifierUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestBvnSigsVerifierUpdated)
				if err := _BrevisRequest.contract.UnpackLog(event, "BvnSigsVerifierUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBvnSigsVerifierUpdated is a log parse operation binding the contract event 0x032d76868790fdb5fb04c6f54308ddd47ecf8a80e5995610816aa0b29773b520.
//
// Solidity: event BvnSigsVerifierUpdated(address from, address to)
func (_BrevisRequest *BrevisRequestFilterer) ParseBvnSigsVerifierUpdated(log types.Log) (*BrevisRequestBvnSigsVerifierUpdated, error) {
	event := new(BrevisRequestBvnSigsVerifierUpdated)
	if err := _BrevisRequest.contract.UnpackLog(event, "BvnSigsVerifierUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestFeeCollectedIterator is returned from FilterFeeCollected and is used to iterate over the raw logs and unpacked data for FeeCollected events raised by the BrevisRequest contract.
type BrevisRequestFeeCollectedIterator struct {
	Event *BrevisRequestFeeCollected // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestFeeCollectedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestFeeCollected)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestFeeCollected)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestFeeCollectedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestFeeCollectedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestFeeCollected represents a FeeCollected event raised by the BrevisRequest contract.
type BrevisRequestFeeCollected struct {
	Amount   *big.Int
	Receiver common.Address
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterFeeCollected is a free log retrieval operation binding the contract event 0xf10cda68996dfb656d49ab0db3c62cc5f0849710633671a337171c3ad9255186.
//
// Solidity: event FeeCollected(uint256 amount, address receiver)
func (_BrevisRequest *BrevisRequestFilterer) FilterFeeCollected(opts *bind.FilterOpts) (*BrevisRequestFeeCollectedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "FeeCollected")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestFeeCollectedIterator{contract: _BrevisRequest.contract, event: "FeeCollected", logs: logs, sub: sub}, nil
}

// WatchFeeCollected is a free log subscription operation binding the contract event 0xf10cda68996dfb656d49ab0db3c62cc5f0849710633671a337171c3ad9255186.
//
// Solidity: event FeeCollected(uint256 amount, address receiver)
func (_BrevisRequest *BrevisRequestFilterer) WatchFeeCollected(opts *bind.WatchOpts, sink chan<- *BrevisRequestFeeCollected) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "FeeCollected")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestFeeCollected)
				if err := _BrevisRequest.contract.UnpackLog(event, "FeeCollected", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFeeCollected is a log parse operation binding the contract event 0xf10cda68996dfb656d49ab0db3c62cc5f0849710633671a337171c3ad9255186.
//
// Solidity: event FeeCollected(uint256 amount, address receiver)
func (_BrevisRequest *BrevisRequestFilterer) ParseFeeCollected(log types.Log) (*BrevisRequestFeeCollected, error) {
	event := new(BrevisRequestFeeCollected)
	if err := _BrevisRequest.contract.UnpackLog(event, "FeeCollected", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestFeeCollectorUpdatedIterator is returned from FilterFeeCollectorUpdated and is used to iterate over the raw logs and unpacked data for FeeCollectorUpdated events raised by the BrevisRequest contract.
type BrevisRequestFeeCollectorUpdatedIterator struct {
	Event *BrevisRequestFeeCollectorUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestFeeCollectorUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestFeeCollectorUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestFeeCollectorUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestFeeCollectorUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestFeeCollectorUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestFeeCollectorUpdated represents a FeeCollectorUpdated event raised by the BrevisRequest contract.
type BrevisRequestFeeCollectorUpdated struct {
	From common.Address
	To   common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterFeeCollectorUpdated is a free log retrieval operation binding the contract event 0x5d16ad41baeb009cd23eb8f6c7cde5c2e0cd5acf4a33926ab488875c37c37f38.
//
// Solidity: event FeeCollectorUpdated(address from, address to)
func (_BrevisRequest *BrevisRequestFilterer) FilterFeeCollectorUpdated(opts *bind.FilterOpts) (*BrevisRequestFeeCollectorUpdatedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "FeeCollectorUpdated")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestFeeCollectorUpdatedIterator{contract: _BrevisRequest.contract, event: "FeeCollectorUpdated", logs: logs, sub: sub}, nil
}

// WatchFeeCollectorUpdated is a free log subscription operation binding the contract event 0x5d16ad41baeb009cd23eb8f6c7cde5c2e0cd5acf4a33926ab488875c37c37f38.
//
// Solidity: event FeeCollectorUpdated(address from, address to)
func (_BrevisRequest *BrevisRequestFilterer) WatchFeeCollectorUpdated(opts *bind.WatchOpts, sink chan<- *BrevisRequestFeeCollectorUpdated) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "FeeCollectorUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestFeeCollectorUpdated)
				if err := _BrevisRequest.contract.UnpackLog(event, "FeeCollectorUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFeeCollectorUpdated is a log parse operation binding the contract event 0x5d16ad41baeb009cd23eb8f6c7cde5c2e0cd5acf4a33926ab488875c37c37f38.
//
// Solidity: event FeeCollectorUpdated(address from, address to)
func (_BrevisRequest *BrevisRequestFilterer) ParseFeeCollectorUpdated(log types.Log) (*BrevisRequestFeeCollectorUpdated, error) {
	event := new(BrevisRequestFeeCollectorUpdated)
	if err := _BrevisRequest.contract.UnpackLog(event, "FeeCollectorUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestOpRequestsFulfilledIterator is returned from FilterOpRequestsFulfilled and is used to iterate over the raw logs and unpacked data for OpRequestsFulfilled events raised by the BrevisRequest contract.
type BrevisRequestOpRequestsFulfilledIterator struct {
	Event *BrevisRequestOpRequestsFulfilled // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestOpRequestsFulfilledIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestOpRequestsFulfilled)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestOpRequestsFulfilled)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestOpRequestsFulfilledIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestOpRequestsFulfilledIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestOpRequestsFulfilled represents a OpRequestsFulfilled event raised by the BrevisRequest contract.
type BrevisRequestOpRequestsFulfilled struct {
	ProofIds        [][32]byte
	Nonces          []uint64
	AppCommitHashes [][32]byte
	AppVkHashes     [][32]byte
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterOpRequestsFulfilled is a free log retrieval operation binding the contract event 0x599dc3a262ef12090a85966f98eb3576ad3412b27513e677d6eaaee82a82bea6.
//
// Solidity: event OpRequestsFulfilled(bytes32[] proofIds, uint64[] nonces, bytes32[] appCommitHashes, bytes32[] appVkHashes)
func (_BrevisRequest *BrevisRequestFilterer) FilterOpRequestsFulfilled(opts *bind.FilterOpts) (*BrevisRequestOpRequestsFulfilledIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "OpRequestsFulfilled")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestOpRequestsFulfilledIterator{contract: _BrevisRequest.contract, event: "OpRequestsFulfilled", logs: logs, sub: sub}, nil
}

// WatchOpRequestsFulfilled is a free log subscription operation binding the contract event 0x599dc3a262ef12090a85966f98eb3576ad3412b27513e677d6eaaee82a82bea6.
//
// Solidity: event OpRequestsFulfilled(bytes32[] proofIds, uint64[] nonces, bytes32[] appCommitHashes, bytes32[] appVkHashes)
func (_BrevisRequest *BrevisRequestFilterer) WatchOpRequestsFulfilled(opts *bind.WatchOpts, sink chan<- *BrevisRequestOpRequestsFulfilled) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "OpRequestsFulfilled")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestOpRequestsFulfilled)
				if err := _BrevisRequest.contract.UnpackLog(event, "OpRequestsFulfilled", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOpRequestsFulfilled is a log parse operation binding the contract event 0x599dc3a262ef12090a85966f98eb3576ad3412b27513e677d6eaaee82a82bea6.
//
// Solidity: event OpRequestsFulfilled(bytes32[] proofIds, uint64[] nonces, bytes32[] appCommitHashes, bytes32[] appVkHashes)
func (_BrevisRequest *BrevisRequestFilterer) ParseOpRequestsFulfilled(log types.Log) (*BrevisRequestOpRequestsFulfilled, error) {
	event := new(BrevisRequestOpRequestsFulfilled)
	if err := _BrevisRequest.contract.UnpackLog(event, "OpRequestsFulfilled", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the BrevisRequest contract.
type BrevisRequestOwnershipTransferredIterator struct {
	Event *BrevisRequestOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestOwnershipTransferred represents a OwnershipTransferred event raised by the BrevisRequest contract.
type BrevisRequestOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BrevisRequest *BrevisRequestFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*BrevisRequestOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &BrevisRequestOwnershipTransferredIterator{contract: _BrevisRequest.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BrevisRequest *BrevisRequestFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *BrevisRequestOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestOwnershipTransferred)
				if err := _BrevisRequest.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_BrevisRequest *BrevisRequestFilterer) ParseOwnershipTransferred(log types.Log) (*BrevisRequestOwnershipTransferred, error) {
	event := new(BrevisRequestOwnershipTransferred)
	if err := _BrevisRequest.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the BrevisRequest contract.
type BrevisRequestPausedIterator struct {
	Event *BrevisRequestPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestPaused represents a Paused event raised by the BrevisRequest contract.
type BrevisRequestPaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BrevisRequest *BrevisRequestFilterer) FilterPaused(opts *bind.FilterOpts) (*BrevisRequestPausedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestPausedIterator{contract: _BrevisRequest.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BrevisRequest *BrevisRequestFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *BrevisRequestPaused) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestPaused)
				if err := _BrevisRequest.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_BrevisRequest *BrevisRequestFilterer) ParsePaused(log types.Log) (*BrevisRequestPaused, error) {
	event := new(BrevisRequestPaused)
	if err := _BrevisRequest.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestPauserAddedIterator is returned from FilterPauserAdded and is used to iterate over the raw logs and unpacked data for PauserAdded events raised by the BrevisRequest contract.
type BrevisRequestPauserAddedIterator struct {
	Event *BrevisRequestPauserAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestPauserAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestPauserAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestPauserAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestPauserAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestPauserAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestPauserAdded represents a PauserAdded event raised by the BrevisRequest contract.
type BrevisRequestPauserAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserAdded is a free log retrieval operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BrevisRequest *BrevisRequestFilterer) FilterPauserAdded(opts *bind.FilterOpts) (*BrevisRequestPauserAddedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestPauserAddedIterator{contract: _BrevisRequest.contract, event: "PauserAdded", logs: logs, sub: sub}, nil
}

// WatchPauserAdded is a free log subscription operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BrevisRequest *BrevisRequestFilterer) WatchPauserAdded(opts *bind.WatchOpts, sink chan<- *BrevisRequestPauserAdded) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestPauserAdded)
				if err := _BrevisRequest.contract.UnpackLog(event, "PauserAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserAdded is a log parse operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_BrevisRequest *BrevisRequestFilterer) ParsePauserAdded(log types.Log) (*BrevisRequestPauserAdded, error) {
	event := new(BrevisRequestPauserAdded)
	if err := _BrevisRequest.contract.UnpackLog(event, "PauserAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestPauserRemovedIterator is returned from FilterPauserRemoved and is used to iterate over the raw logs and unpacked data for PauserRemoved events raised by the BrevisRequest contract.
type BrevisRequestPauserRemovedIterator struct {
	Event *BrevisRequestPauserRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestPauserRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestPauserRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestPauserRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestPauserRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestPauserRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestPauserRemoved represents a PauserRemoved event raised by the BrevisRequest contract.
type BrevisRequestPauserRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserRemoved is a free log retrieval operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BrevisRequest *BrevisRequestFilterer) FilterPauserRemoved(opts *bind.FilterOpts) (*BrevisRequestPauserRemovedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestPauserRemovedIterator{contract: _BrevisRequest.contract, event: "PauserRemoved", logs: logs, sub: sub}, nil
}

// WatchPauserRemoved is a free log subscription operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BrevisRequest *BrevisRequestFilterer) WatchPauserRemoved(opts *bind.WatchOpts, sink chan<- *BrevisRequestPauserRemoved) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestPauserRemoved)
				if err := _BrevisRequest.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserRemoved is a log parse operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_BrevisRequest *BrevisRequestFilterer) ParsePauserRemoved(log types.Log) (*BrevisRequestPauserRemoved, error) {
	event := new(BrevisRequestPauserRemoved)
	if err := _BrevisRequest.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestProverAddedIterator is returned from FilterProverAdded and is used to iterate over the raw logs and unpacked data for ProverAdded events raised by the BrevisRequest contract.
type BrevisRequestProverAddedIterator struct {
	Event *BrevisRequestProverAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestProverAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestProverAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestProverAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestProverAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestProverAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestProverAdded represents a ProverAdded event raised by the BrevisRequest contract.
type BrevisRequestProverAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverAdded is a free log retrieval operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BrevisRequest *BrevisRequestFilterer) FilterProverAdded(opts *bind.FilterOpts) (*BrevisRequestProverAddedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestProverAddedIterator{contract: _BrevisRequest.contract, event: "ProverAdded", logs: logs, sub: sub}, nil
}

// WatchProverAdded is a free log subscription operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BrevisRequest *BrevisRequestFilterer) WatchProverAdded(opts *bind.WatchOpts, sink chan<- *BrevisRequestProverAdded) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestProverAdded)
				if err := _BrevisRequest.contract.UnpackLog(event, "ProverAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverAdded is a log parse operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_BrevisRequest *BrevisRequestFilterer) ParseProverAdded(log types.Log) (*BrevisRequestProverAdded, error) {
	event := new(BrevisRequestProverAdded)
	if err := _BrevisRequest.contract.UnpackLog(event, "ProverAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestProverRemovedIterator is returned from FilterProverRemoved and is used to iterate over the raw logs and unpacked data for ProverRemoved events raised by the BrevisRequest contract.
type BrevisRequestProverRemovedIterator struct {
	Event *BrevisRequestProverRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestProverRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestProverRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestProverRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestProverRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestProverRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestProverRemoved represents a ProverRemoved event raised by the BrevisRequest contract.
type BrevisRequestProverRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverRemoved is a free log retrieval operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BrevisRequest *BrevisRequestFilterer) FilterProverRemoved(opts *bind.FilterOpts) (*BrevisRequestProverRemovedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestProverRemovedIterator{contract: _BrevisRequest.contract, event: "ProverRemoved", logs: logs, sub: sub}, nil
}

// WatchProverRemoved is a free log subscription operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BrevisRequest *BrevisRequestFilterer) WatchProverRemoved(opts *bind.WatchOpts, sink chan<- *BrevisRequestProverRemoved) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestProverRemoved)
				if err := _BrevisRequest.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverRemoved is a log parse operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_BrevisRequest *BrevisRequestFilterer) ParseProverRemoved(log types.Log) (*BrevisRequestProverRemoved, error) {
	event := new(BrevisRequestProverRemoved)
	if err := _BrevisRequest.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestRequestCallbackFailedIterator is returned from FilterRequestCallbackFailed and is used to iterate over the raw logs and unpacked data for RequestCallbackFailed events raised by the BrevisRequest contract.
type BrevisRequestRequestCallbackFailedIterator struct {
	Event *BrevisRequestRequestCallbackFailed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestRequestCallbackFailedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestRequestCallbackFailed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestRequestCallbackFailed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestRequestCallbackFailedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestRequestCallbackFailedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestRequestCallbackFailed represents a RequestCallbackFailed event raised by the BrevisRequest contract.
type BrevisRequestRequestCallbackFailed struct {
	ProofId [32]byte
	Nonce   uint64
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRequestCallbackFailed is a free log retrieval operation binding the contract event 0x65ec418e0b7b50180dd133ac2495d373d2df1b616648284452f7b57ac532ce4a.
//
// Solidity: event RequestCallbackFailed(bytes32 proofId, uint64 nonce)
func (_BrevisRequest *BrevisRequestFilterer) FilterRequestCallbackFailed(opts *bind.FilterOpts) (*BrevisRequestRequestCallbackFailedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "RequestCallbackFailed")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestRequestCallbackFailedIterator{contract: _BrevisRequest.contract, event: "RequestCallbackFailed", logs: logs, sub: sub}, nil
}

// WatchRequestCallbackFailed is a free log subscription operation binding the contract event 0x65ec418e0b7b50180dd133ac2495d373d2df1b616648284452f7b57ac532ce4a.
//
// Solidity: event RequestCallbackFailed(bytes32 proofId, uint64 nonce)
func (_BrevisRequest *BrevisRequestFilterer) WatchRequestCallbackFailed(opts *bind.WatchOpts, sink chan<- *BrevisRequestRequestCallbackFailed) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "RequestCallbackFailed")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestRequestCallbackFailed)
				if err := _BrevisRequest.contract.UnpackLog(event, "RequestCallbackFailed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestCallbackFailed is a log parse operation binding the contract event 0x65ec418e0b7b50180dd133ac2495d373d2df1b616648284452f7b57ac532ce4a.
//
// Solidity: event RequestCallbackFailed(bytes32 proofId, uint64 nonce)
func (_BrevisRequest *BrevisRequestFilterer) ParseRequestCallbackFailed(log types.Log) (*BrevisRequestRequestCallbackFailed, error) {
	event := new(BrevisRequestRequestCallbackFailed)
	if err := _BrevisRequest.contract.UnpackLog(event, "RequestCallbackFailed", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestRequestFeeIncreasedIterator is returned from FilterRequestFeeIncreased and is used to iterate over the raw logs and unpacked data for RequestFeeIncreased events raised by the BrevisRequest contract.
type BrevisRequestRequestFeeIncreasedIterator struct {
	Event *BrevisRequestRequestFeeIncreased // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestRequestFeeIncreasedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestRequestFeeIncreased)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestRequestFeeIncreased)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestRequestFeeIncreasedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestRequestFeeIncreasedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestRequestFeeIncreased represents a RequestFeeIncreased event raised by the BrevisRequest contract.
type BrevisRequestRequestFeeIncreased struct {
	ProofId [32]byte
	Nonce   uint64
	Gas     *big.Int
	Fee     *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRequestFeeIncreased is a free log retrieval operation binding the contract event 0x26313df9aa6577df866c6588c888b4c89d59707d6df9fd0befdb29cb976945b6.
//
// Solidity: event RequestFeeIncreased(bytes32 proofId, uint64 nonce, uint256 gas, uint256 fee)
func (_BrevisRequest *BrevisRequestFilterer) FilterRequestFeeIncreased(opts *bind.FilterOpts) (*BrevisRequestRequestFeeIncreasedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "RequestFeeIncreased")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestRequestFeeIncreasedIterator{contract: _BrevisRequest.contract, event: "RequestFeeIncreased", logs: logs, sub: sub}, nil
}

// WatchRequestFeeIncreased is a free log subscription operation binding the contract event 0x26313df9aa6577df866c6588c888b4c89d59707d6df9fd0befdb29cb976945b6.
//
// Solidity: event RequestFeeIncreased(bytes32 proofId, uint64 nonce, uint256 gas, uint256 fee)
func (_BrevisRequest *BrevisRequestFilterer) WatchRequestFeeIncreased(opts *bind.WatchOpts, sink chan<- *BrevisRequestRequestFeeIncreased) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "RequestFeeIncreased")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestRequestFeeIncreased)
				if err := _BrevisRequest.contract.UnpackLog(event, "RequestFeeIncreased", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestFeeIncreased is a log parse operation binding the contract event 0x26313df9aa6577df866c6588c888b4c89d59707d6df9fd0befdb29cb976945b6.
//
// Solidity: event RequestFeeIncreased(bytes32 proofId, uint64 nonce, uint256 gas, uint256 fee)
func (_BrevisRequest *BrevisRequestFilterer) ParseRequestFeeIncreased(log types.Log) (*BrevisRequestRequestFeeIncreased, error) {
	event := new(BrevisRequestRequestFeeIncreased)
	if err := _BrevisRequest.contract.UnpackLog(event, "RequestFeeIncreased", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestRequestFulfilledIterator is returned from FilterRequestFulfilled and is used to iterate over the raw logs and unpacked data for RequestFulfilled events raised by the BrevisRequest contract.
type BrevisRequestRequestFulfilledIterator struct {
	Event *BrevisRequestRequestFulfilled // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestRequestFulfilledIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestRequestFulfilled)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestRequestFulfilled)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestRequestFulfilledIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestRequestFulfilledIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestRequestFulfilled represents a RequestFulfilled event raised by the BrevisRequest contract.
type BrevisRequestRequestFulfilled struct {
	ProofId [32]byte
	Nonce   uint64
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRequestFulfilled is a free log retrieval operation binding the contract event 0xc2b28def014c5f6ccb93ba212bc842430ed5b3d5a6e1a28d27e98a568e5fc02f.
//
// Solidity: event RequestFulfilled(bytes32 proofId, uint64 nonce)
func (_BrevisRequest *BrevisRequestFilterer) FilterRequestFulfilled(opts *bind.FilterOpts) (*BrevisRequestRequestFulfilledIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "RequestFulfilled")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestRequestFulfilledIterator{contract: _BrevisRequest.contract, event: "RequestFulfilled", logs: logs, sub: sub}, nil
}

// WatchRequestFulfilled is a free log subscription operation binding the contract event 0xc2b28def014c5f6ccb93ba212bc842430ed5b3d5a6e1a28d27e98a568e5fc02f.
//
// Solidity: event RequestFulfilled(bytes32 proofId, uint64 nonce)
func (_BrevisRequest *BrevisRequestFilterer) WatchRequestFulfilled(opts *bind.WatchOpts, sink chan<- *BrevisRequestRequestFulfilled) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "RequestFulfilled")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestRequestFulfilled)
				if err := _BrevisRequest.contract.UnpackLog(event, "RequestFulfilled", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestFulfilled is a log parse operation binding the contract event 0xc2b28def014c5f6ccb93ba212bc842430ed5b3d5a6e1a28d27e98a568e5fc02f.
//
// Solidity: event RequestFulfilled(bytes32 proofId, uint64 nonce)
func (_BrevisRequest *BrevisRequestFilterer) ParseRequestFulfilled(log types.Log) (*BrevisRequestRequestFulfilled, error) {
	event := new(BrevisRequestRequestFulfilled)
	if err := _BrevisRequest.contract.UnpackLog(event, "RequestFulfilled", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestRequestRefundedIterator is returned from FilterRequestRefunded and is used to iterate over the raw logs and unpacked data for RequestRefunded events raised by the BrevisRequest contract.
type BrevisRequestRequestRefundedIterator struct {
	Event *BrevisRequestRequestRefunded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestRequestRefundedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestRequestRefunded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestRequestRefunded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestRequestRefundedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestRequestRefundedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestRequestRefunded represents a RequestRefunded event raised by the BrevisRequest contract.
type BrevisRequestRequestRefunded struct {
	ProofId [32]byte
	Nonce   uint64
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRequestRefunded is a free log retrieval operation binding the contract event 0x6c005c1eef4990013ad08bd5c941274dcd8d109eb0ca4ac049587173d21be21f.
//
// Solidity: event RequestRefunded(bytes32 proofId, uint64 nonce)
func (_BrevisRequest *BrevisRequestFilterer) FilterRequestRefunded(opts *bind.FilterOpts) (*BrevisRequestRequestRefundedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "RequestRefunded")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestRequestRefundedIterator{contract: _BrevisRequest.contract, event: "RequestRefunded", logs: logs, sub: sub}, nil
}

// WatchRequestRefunded is a free log subscription operation binding the contract event 0x6c005c1eef4990013ad08bd5c941274dcd8d109eb0ca4ac049587173d21be21f.
//
// Solidity: event RequestRefunded(bytes32 proofId, uint64 nonce)
func (_BrevisRequest *BrevisRequestFilterer) WatchRequestRefunded(opts *bind.WatchOpts, sink chan<- *BrevisRequestRequestRefunded) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "RequestRefunded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestRequestRefunded)
				if err := _BrevisRequest.contract.UnpackLog(event, "RequestRefunded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestRefunded is a log parse operation binding the contract event 0x6c005c1eef4990013ad08bd5c941274dcd8d109eb0ca4ac049587173d21be21f.
//
// Solidity: event RequestRefunded(bytes32 proofId, uint64 nonce)
func (_BrevisRequest *BrevisRequestFilterer) ParseRequestRefunded(log types.Log) (*BrevisRequestRequestRefunded, error) {
	event := new(BrevisRequestRequestRefunded)
	if err := _BrevisRequest.contract.UnpackLog(event, "RequestRefunded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestRequestSentIterator is returned from FilterRequestSent and is used to iterate over the raw logs and unpacked data for RequestSent events raised by the BrevisRequest contract.
type BrevisRequestRequestSentIterator struct {
	Event *BrevisRequestRequestSent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestRequestSentIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestRequestSent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestRequestSent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestRequestSentIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestRequestSentIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestRequestSent represents a RequestSent event raised by the BrevisRequest contract.
type BrevisRequestRequestSent struct {
	ProofId  [32]byte
	Nonce    uint64
	Refundee common.Address
	Fee      *big.Int
	Callback IBrevisTypesCallback
	Option   uint8
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterRequestSent is a free log retrieval operation binding the contract event 0xa067fba43ae94917e16e55db2317937adb10c6b47b9c9e3bb33843fef25874ad.
//
// Solidity: event RequestSent(bytes32 proofId, uint64 nonce, address refundee, uint256 fee, (address,uint64) callback, uint8 option)
func (_BrevisRequest *BrevisRequestFilterer) FilterRequestSent(opts *bind.FilterOpts) (*BrevisRequestRequestSentIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "RequestSent")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestRequestSentIterator{contract: _BrevisRequest.contract, event: "RequestSent", logs: logs, sub: sub}, nil
}

// WatchRequestSent is a free log subscription operation binding the contract event 0xa067fba43ae94917e16e55db2317937adb10c6b47b9c9e3bb33843fef25874ad.
//
// Solidity: event RequestSent(bytes32 proofId, uint64 nonce, address refundee, uint256 fee, (address,uint64) callback, uint8 option)
func (_BrevisRequest *BrevisRequestFilterer) WatchRequestSent(opts *bind.WatchOpts, sink chan<- *BrevisRequestRequestSent) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "RequestSent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestRequestSent)
				if err := _BrevisRequest.contract.UnpackLog(event, "RequestSent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestSent is a log parse operation binding the contract event 0xa067fba43ae94917e16e55db2317937adb10c6b47b9c9e3bb33843fef25874ad.
//
// Solidity: event RequestSent(bytes32 proofId, uint64 nonce, address refundee, uint256 fee, (address,uint64) callback, uint8 option)
func (_BrevisRequest *BrevisRequestFilterer) ParseRequestSent(log types.Log) (*BrevisRequestRequestSent, error) {
	event := new(BrevisRequestRequestSent)
	if err := _BrevisRequest.contract.UnpackLog(event, "RequestSent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestRequestTimeoutUpdatedIterator is returned from FilterRequestTimeoutUpdated and is used to iterate over the raw logs and unpacked data for RequestTimeoutUpdated events raised by the BrevisRequest contract.
type BrevisRequestRequestTimeoutUpdatedIterator struct {
	Event *BrevisRequestRequestTimeoutUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestRequestTimeoutUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestRequestTimeoutUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestRequestTimeoutUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestRequestTimeoutUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestRequestTimeoutUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestRequestTimeoutUpdated represents a RequestTimeoutUpdated event raised by the BrevisRequest contract.
type BrevisRequestRequestTimeoutUpdated struct {
	From *big.Int
	To   *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterRequestTimeoutUpdated is a free log retrieval operation binding the contract event 0x87a73c061f18ffd513249d1d727921e40e348948b01e2979efb36ef4f5204a63.
//
// Solidity: event RequestTimeoutUpdated(uint256 from, uint256 to)
func (_BrevisRequest *BrevisRequestFilterer) FilterRequestTimeoutUpdated(opts *bind.FilterOpts) (*BrevisRequestRequestTimeoutUpdatedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "RequestTimeoutUpdated")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestRequestTimeoutUpdatedIterator{contract: _BrevisRequest.contract, event: "RequestTimeoutUpdated", logs: logs, sub: sub}, nil
}

// WatchRequestTimeoutUpdated is a free log subscription operation binding the contract event 0x87a73c061f18ffd513249d1d727921e40e348948b01e2979efb36ef4f5204a63.
//
// Solidity: event RequestTimeoutUpdated(uint256 from, uint256 to)
func (_BrevisRequest *BrevisRequestFilterer) WatchRequestTimeoutUpdated(opts *bind.WatchOpts, sink chan<- *BrevisRequestRequestTimeoutUpdated) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "RequestTimeoutUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestRequestTimeoutUpdated)
				if err := _BrevisRequest.contract.UnpackLog(event, "RequestTimeoutUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestTimeoutUpdated is a log parse operation binding the contract event 0x87a73c061f18ffd513249d1d727921e40e348948b01e2979efb36ef4f5204a63.
//
// Solidity: event RequestTimeoutUpdated(uint256 from, uint256 to)
func (_BrevisRequest *BrevisRequestFilterer) ParseRequestTimeoutUpdated(log types.Log) (*BrevisRequestRequestTimeoutUpdated, error) {
	event := new(BrevisRequestRequestTimeoutUpdated)
	if err := _BrevisRequest.contract.UnpackLog(event, "RequestTimeoutUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestRequestsCallbackFailedIterator is returned from FilterRequestsCallbackFailed and is used to iterate over the raw logs and unpacked data for RequestsCallbackFailed events raised by the BrevisRequest contract.
type BrevisRequestRequestsCallbackFailedIterator struct {
	Event *BrevisRequestRequestsCallbackFailed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestRequestsCallbackFailedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestRequestsCallbackFailed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestRequestsCallbackFailed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestRequestsCallbackFailedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestRequestsCallbackFailedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestRequestsCallbackFailed represents a RequestsCallbackFailed event raised by the BrevisRequest contract.
type BrevisRequestRequestsCallbackFailed struct {
	ProofIds [][32]byte
	Nonces   []uint64
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterRequestsCallbackFailed is a free log retrieval operation binding the contract event 0xf97038d0ee914b31475cdb033a5264b8f2c4d5a89fc292214bea2ac641b49e76.
//
// Solidity: event RequestsCallbackFailed(bytes32[] proofIds, uint64[] nonces)
func (_BrevisRequest *BrevisRequestFilterer) FilterRequestsCallbackFailed(opts *bind.FilterOpts) (*BrevisRequestRequestsCallbackFailedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "RequestsCallbackFailed")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestRequestsCallbackFailedIterator{contract: _BrevisRequest.contract, event: "RequestsCallbackFailed", logs: logs, sub: sub}, nil
}

// WatchRequestsCallbackFailed is a free log subscription operation binding the contract event 0xf97038d0ee914b31475cdb033a5264b8f2c4d5a89fc292214bea2ac641b49e76.
//
// Solidity: event RequestsCallbackFailed(bytes32[] proofIds, uint64[] nonces)
func (_BrevisRequest *BrevisRequestFilterer) WatchRequestsCallbackFailed(opts *bind.WatchOpts, sink chan<- *BrevisRequestRequestsCallbackFailed) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "RequestsCallbackFailed")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestRequestsCallbackFailed)
				if err := _BrevisRequest.contract.UnpackLog(event, "RequestsCallbackFailed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestsCallbackFailed is a log parse operation binding the contract event 0xf97038d0ee914b31475cdb033a5264b8f2c4d5a89fc292214bea2ac641b49e76.
//
// Solidity: event RequestsCallbackFailed(bytes32[] proofIds, uint64[] nonces)
func (_BrevisRequest *BrevisRequestFilterer) ParseRequestsCallbackFailed(log types.Log) (*BrevisRequestRequestsCallbackFailed, error) {
	event := new(BrevisRequestRequestsCallbackFailed)
	if err := _BrevisRequest.contract.UnpackLog(event, "RequestsCallbackFailed", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestRequestsFulfilledIterator is returned from FilterRequestsFulfilled and is used to iterate over the raw logs and unpacked data for RequestsFulfilled events raised by the BrevisRequest contract.
type BrevisRequestRequestsFulfilledIterator struct {
	Event *BrevisRequestRequestsFulfilled // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestRequestsFulfilledIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestRequestsFulfilled)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestRequestsFulfilled)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestRequestsFulfilledIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestRequestsFulfilledIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestRequestsFulfilled represents a RequestsFulfilled event raised by the BrevisRequest contract.
type BrevisRequestRequestsFulfilled struct {
	ProofIds [][32]byte
	Nonces   []uint64
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterRequestsFulfilled is a free log retrieval operation binding the contract event 0x5222b9309369092c135ac01f588e14730b87b05890b5c016dcb1f9b9a55d14f0.
//
// Solidity: event RequestsFulfilled(bytes32[] proofIds, uint64[] nonces)
func (_BrevisRequest *BrevisRequestFilterer) FilterRequestsFulfilled(opts *bind.FilterOpts) (*BrevisRequestRequestsFulfilledIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "RequestsFulfilled")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestRequestsFulfilledIterator{contract: _BrevisRequest.contract, event: "RequestsFulfilled", logs: logs, sub: sub}, nil
}

// WatchRequestsFulfilled is a free log subscription operation binding the contract event 0x5222b9309369092c135ac01f588e14730b87b05890b5c016dcb1f9b9a55d14f0.
//
// Solidity: event RequestsFulfilled(bytes32[] proofIds, uint64[] nonces)
func (_BrevisRequest *BrevisRequestFilterer) WatchRequestsFulfilled(opts *bind.WatchOpts, sink chan<- *BrevisRequestRequestsFulfilled) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "RequestsFulfilled")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestRequestsFulfilled)
				if err := _BrevisRequest.contract.UnpackLog(event, "RequestsFulfilled", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestsFulfilled is a log parse operation binding the contract event 0x5222b9309369092c135ac01f588e14730b87b05890b5c016dcb1f9b9a55d14f0.
//
// Solidity: event RequestsFulfilled(bytes32[] proofIds, uint64[] nonces)
func (_BrevisRequest *BrevisRequestFilterer) ParseRequestsFulfilled(log types.Log) (*BrevisRequestRequestsFulfilled, error) {
	event := new(BrevisRequestRequestsFulfilled)
	if err := _BrevisRequest.contract.UnpackLog(event, "RequestsFulfilled", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisRequestUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the BrevisRequest contract.
type BrevisRequestUnpausedIterator struct {
	Event *BrevisRequestUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BrevisRequestUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BrevisRequestUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BrevisRequestUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BrevisRequestUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BrevisRequestUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BrevisRequestUnpaused represents a Unpaused event raised by the BrevisRequest contract.
type BrevisRequestUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BrevisRequest *BrevisRequestFilterer) FilterUnpaused(opts *bind.FilterOpts) (*BrevisRequestUnpausedIterator, error) {

	logs, sub, err := _BrevisRequest.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &BrevisRequestUnpausedIterator{contract: _BrevisRequest.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BrevisRequest *BrevisRequestFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *BrevisRequestUnpaused) (event.Subscription, error) {

	logs, sub, err := _BrevisRequest.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BrevisRequestUnpaused)
				if err := _BrevisRequest.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_BrevisRequest *BrevisRequestFilterer) ParseUnpaused(log types.Log) (*BrevisRequestUnpaused, error) {
	event := new(BrevisRequestUnpaused)
	if err := _BrevisRequest.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BrevisZkAppMetaData contains all meta data concerning the BrevisZkApp contract.
var BrevisZkAppMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_appVkHashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_appCircuitOutputs\",\"type\":\"bytes[]\"}],\"name\":\"brevisBatchCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_appCircuitOutput\",\"type\":\"bytes\"}],\"name\":\"brevisCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"brevisRequest\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// BrevisZkAppABI is the input ABI used to generate the binding from.
// Deprecated: Use BrevisZkAppMetaData.ABI instead.
var BrevisZkAppABI = BrevisZkAppMetaData.ABI

// BrevisZkApp is an auto generated Go binding around an Ethereum contract.
type BrevisZkApp struct {
	BrevisZkAppCaller     // Read-only binding to the contract
	BrevisZkAppTransactor // Write-only binding to the contract
	BrevisZkAppFilterer   // Log filterer for contract events
}

// BrevisZkAppCaller is an auto generated read-only Go binding around an Ethereum contract.
type BrevisZkAppCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisZkAppTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BrevisZkAppTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisZkAppFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BrevisZkAppFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BrevisZkAppSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BrevisZkAppSession struct {
	Contract     *BrevisZkApp      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BrevisZkAppCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BrevisZkAppCallerSession struct {
	Contract *BrevisZkAppCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// BrevisZkAppTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BrevisZkAppTransactorSession struct {
	Contract     *BrevisZkAppTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// BrevisZkAppRaw is an auto generated low-level Go binding around an Ethereum contract.
type BrevisZkAppRaw struct {
	Contract *BrevisZkApp // Generic contract binding to access the raw methods on
}

// BrevisZkAppCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BrevisZkAppCallerRaw struct {
	Contract *BrevisZkAppCaller // Generic read-only contract binding to access the raw methods on
}

// BrevisZkAppTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BrevisZkAppTransactorRaw struct {
	Contract *BrevisZkAppTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBrevisZkApp creates a new instance of BrevisZkApp, bound to a specific deployed contract.
func NewBrevisZkApp(address common.Address, backend bind.ContractBackend) (*BrevisZkApp, error) {
	contract, err := bindBrevisZkApp(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BrevisZkApp{BrevisZkAppCaller: BrevisZkAppCaller{contract: contract}, BrevisZkAppTransactor: BrevisZkAppTransactor{contract: contract}, BrevisZkAppFilterer: BrevisZkAppFilterer{contract: contract}}, nil
}

// NewBrevisZkAppCaller creates a new read-only instance of BrevisZkApp, bound to a specific deployed contract.
func NewBrevisZkAppCaller(address common.Address, caller bind.ContractCaller) (*BrevisZkAppCaller, error) {
	contract, err := bindBrevisZkApp(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BrevisZkAppCaller{contract: contract}, nil
}

// NewBrevisZkAppTransactor creates a new write-only instance of BrevisZkApp, bound to a specific deployed contract.
func NewBrevisZkAppTransactor(address common.Address, transactor bind.ContractTransactor) (*BrevisZkAppTransactor, error) {
	contract, err := bindBrevisZkApp(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BrevisZkAppTransactor{contract: contract}, nil
}

// NewBrevisZkAppFilterer creates a new log filterer instance of BrevisZkApp, bound to a specific deployed contract.
func NewBrevisZkAppFilterer(address common.Address, filterer bind.ContractFilterer) (*BrevisZkAppFilterer, error) {
	contract, err := bindBrevisZkApp(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BrevisZkAppFilterer{contract: contract}, nil
}

// bindBrevisZkApp binds a generic wrapper to an already deployed contract.
func bindBrevisZkApp(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BrevisZkAppMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BrevisZkApp *BrevisZkAppRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BrevisZkApp.Contract.BrevisZkAppCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BrevisZkApp *BrevisZkAppRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisZkApp.Contract.BrevisZkAppTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BrevisZkApp *BrevisZkAppRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BrevisZkApp.Contract.BrevisZkAppTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BrevisZkApp *BrevisZkAppCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _BrevisZkApp.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BrevisZkApp *BrevisZkAppTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BrevisZkApp.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BrevisZkApp *BrevisZkAppTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BrevisZkApp.Contract.contract.Transact(opts, method, params...)
}

// BrevisRequest is a free data retrieval call binding the contract method 0x38931a31.
//
// Solidity: function brevisRequest() view returns(address)
func (_BrevisZkApp *BrevisZkAppCaller) BrevisRequest(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _BrevisZkApp.contract.Call(opts, &out, "brevisRequest")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// BrevisRequest is a free data retrieval call binding the contract method 0x38931a31.
//
// Solidity: function brevisRequest() view returns(address)
func (_BrevisZkApp *BrevisZkAppSession) BrevisRequest() (common.Address, error) {
	return _BrevisZkApp.Contract.BrevisRequest(&_BrevisZkApp.CallOpts)
}

// BrevisRequest is a free data retrieval call binding the contract method 0x38931a31.
//
// Solidity: function brevisRequest() view returns(address)
func (_BrevisZkApp *BrevisZkAppCallerSession) BrevisRequest() (common.Address, error) {
	return _BrevisZkApp.Contract.BrevisRequest(&_BrevisZkApp.CallOpts)
}

// BrevisBatchCallback is a paid mutator transaction binding the contract method 0x3bca02fc.
//
// Solidity: function brevisBatchCallback(bytes32[] _appVkHashes, bytes[] _appCircuitOutputs) returns()
func (_BrevisZkApp *BrevisZkAppTransactor) BrevisBatchCallback(opts *bind.TransactOpts, _appVkHashes [][32]byte, _appCircuitOutputs [][]byte) (*types.Transaction, error) {
	return _BrevisZkApp.contract.Transact(opts, "brevisBatchCallback", _appVkHashes, _appCircuitOutputs)
}

// BrevisBatchCallback is a paid mutator transaction binding the contract method 0x3bca02fc.
//
// Solidity: function brevisBatchCallback(bytes32[] _appVkHashes, bytes[] _appCircuitOutputs) returns()
func (_BrevisZkApp *BrevisZkAppSession) BrevisBatchCallback(_appVkHashes [][32]byte, _appCircuitOutputs [][]byte) (*types.Transaction, error) {
	return _BrevisZkApp.Contract.BrevisBatchCallback(&_BrevisZkApp.TransactOpts, _appVkHashes, _appCircuitOutputs)
}

// BrevisBatchCallback is a paid mutator transaction binding the contract method 0x3bca02fc.
//
// Solidity: function brevisBatchCallback(bytes32[] _appVkHashes, bytes[] _appCircuitOutputs) returns()
func (_BrevisZkApp *BrevisZkAppTransactorSession) BrevisBatchCallback(_appVkHashes [][32]byte, _appCircuitOutputs [][]byte) (*types.Transaction, error) {
	return _BrevisZkApp.Contract.BrevisBatchCallback(&_BrevisZkApp.TransactOpts, _appVkHashes, _appCircuitOutputs)
}

// BrevisCallback is a paid mutator transaction binding the contract method 0x79d6b6a2.
//
// Solidity: function brevisCallback(bytes32 _appVkHash, bytes _appCircuitOutput) returns()
func (_BrevisZkApp *BrevisZkAppTransactor) BrevisCallback(opts *bind.TransactOpts, _appVkHash [32]byte, _appCircuitOutput []byte) (*types.Transaction, error) {
	return _BrevisZkApp.contract.Transact(opts, "brevisCallback", _appVkHash, _appCircuitOutput)
}

// BrevisCallback is a paid mutator transaction binding the contract method 0x79d6b6a2.
//
// Solidity: function brevisCallback(bytes32 _appVkHash, bytes _appCircuitOutput) returns()
func (_BrevisZkApp *BrevisZkAppSession) BrevisCallback(_appVkHash [32]byte, _appCircuitOutput []byte) (*types.Transaction, error) {
	return _BrevisZkApp.Contract.BrevisCallback(&_BrevisZkApp.TransactOpts, _appVkHash, _appCircuitOutput)
}

// BrevisCallback is a paid mutator transaction binding the contract method 0x79d6b6a2.
//
// Solidity: function brevisCallback(bytes32 _appVkHash, bytes _appCircuitOutput) returns()
func (_BrevisZkApp *BrevisZkAppTransactorSession) BrevisCallback(_appVkHash [32]byte, _appCircuitOutput []byte) (*types.Transaction, error) {
	return _BrevisZkApp.Contract.BrevisCallback(&_BrevisZkApp.TransactOpts, _appVkHash, _appCircuitOutput)
}

// CommitteeRootMappingVerifierMetaData contains all meta data concerning the CommitteeRootMappingVerifier contract.
var CommitteeRootMappingVerifierMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[33]\",\"name\":\"input\",\"type\":\"uint256[33]\"}],\"name\":\"verifyCommitteeRootMappingProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"r\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x60808060405234610016576119f1908161001b8239f35b5f80fdfe6040608081526004361015610012575f80fd5b5f803560e01c63ab00dde614610026575f80fd5b346100bb576105203660031901126100bb5761004136610117565b9036606312156100bb576100536100d2565b908160c4913683116100bb57506044905b8282106100a25761009e8661008d878761007d36610158565b90610087366101d6565b92610608565b905190151581529081906020820190565b0390f35b602086916100b03685610196565b815201910190610064565b80fd5b634e487b7160e01b5f52604160045260245ffd5b604051906040820182811067ffffffffffffffff8211176100f257604052565b6100be565b604051906080820182811067ffffffffffffffff8211176100f257604052565b8060231215610154576101286100d2565b90816044918211610154576004905b8282106101445750505090565b8135815260209182019101610137565b5f80fd5b8060e31215610154576101696100d2565b90816101049182116101545760c4905b8282106101865750505090565b8135815260209182019101610179565b9080601f83011215610154576101aa6100d2565b80926040810192831161015457905b8282106101c65750505090565b81358152602091820191016101b9565b8061012312156101545760405190610420820182811067ffffffffffffffff8211176100f2576040528161052491821161015457610104905b82821061021c5750505090565b813581526020918201910161020f565b6102346100f7565b906080368337565b604051906060820182811067ffffffffffffffff8211176100f2576040526060368337565b604051906020820182811067ffffffffffffffff8211176100f2576040526020368337565b61028e6100d2565b906102976100d2565b604036823782526102a66100d2565b60403682376020830152565b6102ba6100f7565b906102c36100d2565b5f9081815281602082015283526102d8610286565b60208401526102e56100d2565b81815281602082015260408401526102fb6100d2565b9080825260208201526060830152565b634e487b7160e01b5f52603260045260245ffd5b1561032657565b60405162461bcd60e51b815260206004820152601760248201527f76657269666965722d61582d6774652d7072696d652d710000000000000000006044820152606490fd5b1561037257565b60405162461bcd60e51b815260206004820152601760248201527f76657269666965722d61592d6774652d7072696d652d710000000000000000006044820152606490fd5b156103be57565b60405162461bcd60e51b815260206004820152601860248201527f76657269666965722d6258302d6774652d7072696d652d7100000000000000006044820152606490fd5b1561040a57565b60405162461bcd60e51b815260206004820152601860248201527f76657269666965722d6259302d6774652d7072696d652d7100000000000000006044820152606490fd5b1561045657565b60405162461bcd60e51b815260206004820152601860248201527f76657269666965722d6258312d6774652d7072696d652d7100000000000000006044820152606490fd5b156104a257565b60405162461bcd60e51b815260206004820152601860248201527f76657269666965722d6259312d6774652d7072696d652d7100000000000000006044820152606490fd5b156104ee57565b60405162461bcd60e51b815260206004820152601760248201527f76657269666965722d63582d6774652d7072696d652d710000000000000000006044820152606490fd5b1561053a57565b60405162461bcd60e51b815260206004820152601760248201527f76657269666965722d63592d6774652d7072696d652d710000000000000000006044820152606490fd5b634e487b7160e01b5f52601160045260245ffd5b5f1981146105a15760010190565b61057f565b9060218110156105b75760051b0190565b61030b565b156105c357565b60405162461bcd60e51b815260206004820152601f60248201527f76657269666965722d6774652d736e61726b2d7363616c61722d6669656c64006044820152606490fd5b90919392936106156102b2565b9180516020809201516106266100d2565b9182528282015283526106376100d2565b938051518552610648815160200190565b5182860152610667826106596100d2565b920180515183525160200190565b51828201526106746100d2565b9485528185015280830193845280825192015161068f6100d2565b92835281830152604083019182526107437f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd476106ce818651511061031f565b6106dd8184875101511061036b565b6106eb8187515151106103b7565b6106fb8184885101515110610403565b6107128161070b88515160200190565b511061044f565b61072b81610724858951015160200190565b511061049b565b61073881855151106104e7565b828451015110610533565b5f5b6021811061139057509461138d949561137161075f611418565b9461136b61076b6100d2565b80955f82528582015f815261077e61022c565b9161078761023c565b907f305c9c1aa4a3294d7d6f331d65dc097fd9b9011350a6065eed3d56ad4d48a5e26107b16100d2565b935f85525f8b8601527f2d704aa2e65d5ad168e2ebdd814a37bf7f58961077a78e2ce2eea371cf886b0e8752527f05595e70b8c63dfb8fe2f8adb49c225ee5e6f783b5736f3221d423194db5585d8252610400898301917e7f03a8f871280b33c0292e973247afd9cddfa419e978678bde69323baece8383527f0e4ddacfcf167969963d2bb01ca92fa86b4bfd92c37917bad4ab760f0279625081519360408601948552610861898989896116a5565b7f2cbe10c7c83f6dbe1bc89736f5dc9a9b91e55be6941a4b99b058acd8001fb00486527f1500351867036612a9db15b6f7d4198993f31565af0610ed3fda8d92ffb5e67181528c83015185526108b9898989896116a5565b7f2ff215cfa1c7c99fc0b382d9d7225a0636ccd9a01be83959da430a3a25d4481f86527f2918236b7c008f70fc98cc3bcc41eb60fb8b85d02b4e83100de7a9a7eed34645815260408301518552610912898989896116a5565b7f0943a399c312616b46deee38e49b364b3449d7bab638b580df78aece26ecedf186527f11c937747adbd7b45585d385c0174241e937dce9fa818ca66d00f550b3f3d12881526060830151855261096b898989896116a5565b7f05dd54c0736f8a8d838a097e3151776cc6f602439ecc7833d223dc6cc69d585186527ee6465472f5b3647daa18848088f62f4fe1e57c401172d39f45b827bcc898f78152608083015185526109c3898989896116a5565b7f0d64a91e0e28a2e96b12a3211ebd9f66d854efbc1bd17fccc28e33993722b96d86527f0b30126ec8f40991e90ef34a78e10acb9848fe65e84547e64346fbaebafc9a98815260a08301518552610a1c898989896116a5565b7f08272a78392bca7c2597f09f39daf6f7129808e6a6b34a49239dbf2a264e4e3b86527f02ac17971af65a980f6ab150b8ebaf573008d90c0af4eeed28d50374e8eed16b815260c08301518552610a75898989896116a5565b7f19e3f8ff1265325376056bd2155edf79762433ec7b24c2196701da40ff2e6b3186527f0b33297cf3ae84083dab64e559bccd29e271c3e7d9ba307b7d623d223d091ead815260e08301518552610ace898989896116a5565b7f01341f47e05793a19ea7b92ff3b84c73f7223d56104d070f246e00eb1db7967986527f052fb71e652150885399cfb863b33f0dc0dfe9b279d0bf29df0fc403810fdb1781526101008301518552610b28898989896116a5565b7f04e2785630031d901e87c72d18c1e526142d7b79ee5b4360f5f9373d385aa1be86527f13fdbcc7f866114bdd363bc99c54b3ea0921b9b5526e46885291a00f8f9feea781526101208301518552610b82898989896116a5565b7f0bc888012014ac70c1692250c46020392de91756724c6c890edbc8d860450b8086527f02ce5d7f6c5c1ec90a48c08531305543ef94f25d0d03f67124280afb560406d481526101408301518552610bdc898989896116a5565b7f0aee169033d6ddce5c5dde351a6ce45eb60dc3018752274e14f68e3f19a5359686527f1481dacc3a815550ede26690b83395cb031c17fb4aca75baa0a74acc4042335181526101608301518552610c36898989896116a5565b7f1c24a404b575734133f0c03bbf71c74c5b03a34f1d0817662c7d9293eaecaad586527f10af37e497d439239dfdab04bce89b1eaeaa12bc5f327129816a7a3841863fdd81526101808301518552610c90898989896116a5565b7f14a256de1a2c7bb25672a1acc5406b90543c8a3b8c7c6e0a1895f019171141a886527f08f0539c9fd5ef363053e6560e4769e20e56dd0a510c30dce8adab0230c5fdb181526101a08301518552610cea898989896116a5565b7f082d61eb34a0a6544527e7db6b9bd16a8f6488733c83bee559ec5378191c93ba86527f144b7ab9c8fd2fb71b51c102820f2b08303be60f9fdd313e68f412d3f027a82081526101c08301518552610d44898989896116a5565b7f22510e5ce22c30374993b2a360ceed3bdc20bd64b8d14cb3baedf76ddbd8062386527f0c0c88dfbf63ebc976d642a63c3d22288c546570b101f0219b3e2f3af5bedcfb81526101e08301518552610d9e898989896116a5565b7f2c71d775cc194f6e13408a12a33cb48babccfee137654d1443371de1d0f30c0c86527f1ba219dea8d4ffd8339c1c10cda690451c10fb5058f36ce7e1407118d871cc8081526102008301518552610df8898989896116a5565b7f14e7d115c5cfbe3c075697f305b8660abf41c5725a40557d3e14c9703aef64c286527f0cbc84b02d09b3f498b122ab5819248195aea678e0a41e744967da6bd8d0ce1181526102208301518552610e52898989896116a5565b7f0332f7d5660e970f229a174367929acabfa2f9fdab763460fd7acebddd944dde86527f15be1ce817121a7c25340b8d9c50a584a179d3dffd489f54311a12f922a6942f81526102408301518552610eac898989896116a5565b7f0257933903a2e91846df829f8084008ddf5fc35dd8d4acdebd426bff0d97e2a386527f17e9653840e81e1a68076e0c5f8c89f61463791e918991df86c86f63dccd939181526102608301518552610f06898989896116a5565b7f106f1170be9c02c979b3d6e1d43737530d6bfc444c16df873400384d39e393be86527f1c2b9f619d809bb543e712ac0ee22cc3c6aa99ae73c97246c9769c9c98713fc581526102808301518552610f60898989896116a5565b7f131eb8c00ed76432c870a74c71365748a51807c021e678beb083b0e7e8b5b61186527f2491a76ab72146d0aeb330815df908ad5dd6cd86201e97d220b63d0d8d0f3ac481526102a08301518552610fba898989896116a5565b7f2561f4abb9fabeeb813dcc6d4d487d8f6e36fdd18805e785cccdf2b0a2ff085786527f2e6269f87539d6b464a25b6bd4522d1e2b78c3918f48e79de55dd640261faa4281526102c08301518552611014898989896116a5565b7f2e485df27f23a93b97e296061758e7dd3d34c4722c6fd7ae249433c55d259adc86527f1614f76a407ac31a5acb91266c2c7f54166ee17112e69f0b5e5fad32dafe5f6581526102e0830151855261106e898989896116a5565b7f153af4e0fe4af748819ca675d8781da95111510763de4bec8abf25bca637703b86527f0b1f5a812c51999ebc7ac97de6ab2409b894ad5fb02d45f0798acc2548344cb9815261030083015185526110c8898989896116a5565b7f2c69e0646f6bfc70dfd02cf64d0b781ab481cafbd190dba9ee603f8160c44dcd86527f126015936956b109beba47938f9808cd9eed7ba5fc4531e6f6f267cadb13f4f881526103208301518552611122898989896116a5565b7f22c6d8b6cf6965d431abf72b985b44f1d0831026a43d6dc8cbcb9ca85ab4a0bc86527f19fd6ce3da2b55331cdd361a63f29e95c52f07bcf9cbe355077e5141bf020d838152610340830151855261117c898989896116a5565b7f0cc996a6a427bcf59dad5cb6a2da92164e142372347a8ca5b1b3b32d8b20a0ef86527f232f08e45f51e15d57617fc960278b4dd236ed78e9014d43950751ea862841f1815261036083015185526111d6898989896116a5565b7f1e03c25c13870ae3e127e009be017aa0f47c7b53fc8636bd519ad68f035aa55c86527f04d8795eee1d4bcb8a4042ed861d91024ec5ce76c4fdac892d0c00479874519981526103808301518552611230898989896116a5565b7f2690cf34bdf3837f3036c3c61e73f94f8026f6a6e9be13695cf81ccebbac7ca886527f0db77d728541f6ab723d2dc8389a97864f9e61349120d35d76c004579c3fc10881526103a0830151855261128a898989896116a5565b7f10f3808b8fb7eb5be9d22fa5e7b4599e94116d5803607ae38bd3c637c10224f286527f06cb766b59e904c5b47098c0f98af9c4444f614cf303f1c939fd24b6bd60cc9c81526103c083015185526112e4898989896116a5565b7f1610f9fbade90d90feada79ae229d67175dee93355fbbf229133ce0d6e75e3a186527f1a3084c2af6e7f823d2044866e00b80af74b5586f26c9685943786f355712ddd81526103e0830151855261133e898989896116a5565b7f1b88a7f08e12e3e28b9b10c0c0cbfd8d7df8b8a8fae1840b33c1cd4d24c8b23c865252015190526116a5565b516116ec565b945190845190850151916060604087015195519601519661185d565b90565b806113c97f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000016113c26113ce948b6105a6565b51106105bc565b610593565b610745565b6113db6100f7565b906113e46100d2565b5f81525f602082015282526113f7610286565b6020830152611404610286565b6040830152611411610286565b6060830152565b6114206113d3565b906114296100d2565b7f0a3a3884405b8d1fe46693685f02ba163634fd63d14bf91b6a433825b9ed6b5a81526020907f111fc830b029cfb2c94e450b570cf3be3eac81076213c2dcb1e1059330c605bf82820152835261147e6100d2565b7f23ab779b99bf99c421500d8fe70c4e84fc1ff6eefdf3e92d8f581d046cb3eab781527f1611f26f3d9d6b19c4a418d02f19f6796be688f08507bc59ee5f9862dd46fa5b828201526114ce6100d2565b7f2d34a3d654ca9ea36195f8167d653fa7240b0af8acad4b224aed268f9d8756ff81527f178cda417a663a79267fba64b28caf8fc8484866bfe0f423cb8d3b7da164d7f98382015261151e6100d2565b91825282820152818401526115316100d2565b7f1f682eee4eeb25b38c3bff07fad9aaeb8c1ae87a95472a7819a57fd8b37a6e1581527f0db20bc4434468f4ce7f5888da80c6013c5392645400eee1ddbb77b0696ea1a7828201526115816100d2565b7f01979b2d16e0fb974244f72e399fd4d24be132523f4aeb010c75f26b6452d53c81527f21900fdcdfde4102dbbcd9525e925c0f4ea5317aefc7a1c350753b5c9741ebd5838201526115d16100d2565b9182528282015260408401526115e56100d2565b907f04969a13dd24e7586c1e7e668f9be1cfab2bfb7baf9e48cd94428a55b4cfb89882527f3026f4334a515ea181839681e5a601e08615013a7355b0a0ad1c6ffce279eb16818301526116366100d2565b907f0987e27c310f4a785adc7dfc5324848dc4b1b4957907733a04c889777c88a78582527f13c07cb3a59387f85f315e9b41060f8a993a3c3d22113439d63f9be212afc234818301526116876100d2565b9283528201526060830152565b9060048110156105b75760051b0190565b90929160608460806107cf19946007865a01fa156116ea57600660c0926020606096865185528187015182860152805160408601520151868401525a01fa156116ea57565bfe5b5f60206116f76100d2565b8281520152805190811580611767575b156117225750506117166100d2565b5f81525f602082015290565b602001517f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd479081900681039081116105a15761175c6100d2565b918252602082015290565b50602081015115611707565b60405190610320820182811067ffffffffffffffff8211176100f25760405260188252610300366020840137565b906006820291808304600614901517156105a157565b90600182018092116105a157565b90600282018092116105a157565b90600382018092116105a157565b90600482018092116105a157565b90600582018092116105a157565b80518210156105b75760209160051b010190565b1561181857565b60405162461bcd60e51b815260206004820152601560248201527f70616972696e672d6f70636f64652d6661696c656400000000000000000000006044820152606490fd5b949195969290939661186d6100f7565b9586526020978897888801526040870152606086015261188b6100f7565b93845285840152604083015260608201526118a4611773565b915f5b600481106118df575050506103006118bd610261565b9384920160086107cf195a01fa80156116ea576118d990611811565b51151590565b6119b191929394506118f0816117a1565b6118fa8285611694565b515161190682886117fd565b52866119128386611694565b510151611927611921836117b7565b886117fd565b526119328286611694565b515151611941611921836117c5565b5261195761194f8387611694565b515160200190565b51611964611921836117d3565b52866119708387611694565b51015151611980611921836117e1565b526119ab6119a561199e89611995868a611694565b51015160200190565b51926117ef565b876117fd565b52610593565b90849392916118a756fea26469706673582212207cfeb77e25c1fbfca65bab6160d1261a4a88ce543dd09d70d7385b44efd1e52e64736f6c63430008140033",
}

// CommitteeRootMappingVerifierABI is the input ABI used to generate the binding from.
// Deprecated: Use CommitteeRootMappingVerifierMetaData.ABI instead.
var CommitteeRootMappingVerifierABI = CommitteeRootMappingVerifierMetaData.ABI

// CommitteeRootMappingVerifierBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use CommitteeRootMappingVerifierMetaData.Bin instead.
var CommitteeRootMappingVerifierBin = CommitteeRootMappingVerifierMetaData.Bin

// DeployCommitteeRootMappingVerifier deploys a new Ethereum contract, binding an instance of CommitteeRootMappingVerifier to it.
func DeployCommitteeRootMappingVerifier(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *CommitteeRootMappingVerifier, error) {
	parsed, err := CommitteeRootMappingVerifierMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(CommitteeRootMappingVerifierBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &CommitteeRootMappingVerifier{CommitteeRootMappingVerifierCaller: CommitteeRootMappingVerifierCaller{contract: contract}, CommitteeRootMappingVerifierTransactor: CommitteeRootMappingVerifierTransactor{contract: contract}, CommitteeRootMappingVerifierFilterer: CommitteeRootMappingVerifierFilterer{contract: contract}}, nil
}

// CommitteeRootMappingVerifier is an auto generated Go binding around an Ethereum contract.
type CommitteeRootMappingVerifier struct {
	CommitteeRootMappingVerifierCaller     // Read-only binding to the contract
	CommitteeRootMappingVerifierTransactor // Write-only binding to the contract
	CommitteeRootMappingVerifierFilterer   // Log filterer for contract events
}

// CommitteeRootMappingVerifierCaller is an auto generated read-only Go binding around an Ethereum contract.
type CommitteeRootMappingVerifierCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CommitteeRootMappingVerifierTransactor is an auto generated write-only Go binding around an Ethereum contract.
type CommitteeRootMappingVerifierTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CommitteeRootMappingVerifierFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type CommitteeRootMappingVerifierFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CommitteeRootMappingVerifierSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type CommitteeRootMappingVerifierSession struct {
	Contract     *CommitteeRootMappingVerifier // Generic contract binding to set the session for
	CallOpts     bind.CallOpts                 // Call options to use throughout this session
	TransactOpts bind.TransactOpts             // Transaction auth options to use throughout this session
}

// CommitteeRootMappingVerifierCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type CommitteeRootMappingVerifierCallerSession struct {
	Contract *CommitteeRootMappingVerifierCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts                       // Call options to use throughout this session
}

// CommitteeRootMappingVerifierTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type CommitteeRootMappingVerifierTransactorSession struct {
	Contract     *CommitteeRootMappingVerifierTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts                       // Transaction auth options to use throughout this session
}

// CommitteeRootMappingVerifierRaw is an auto generated low-level Go binding around an Ethereum contract.
type CommitteeRootMappingVerifierRaw struct {
	Contract *CommitteeRootMappingVerifier // Generic contract binding to access the raw methods on
}

// CommitteeRootMappingVerifierCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type CommitteeRootMappingVerifierCallerRaw struct {
	Contract *CommitteeRootMappingVerifierCaller // Generic read-only contract binding to access the raw methods on
}

// CommitteeRootMappingVerifierTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type CommitteeRootMappingVerifierTransactorRaw struct {
	Contract *CommitteeRootMappingVerifierTransactor // Generic write-only contract binding to access the raw methods on
}

// NewCommitteeRootMappingVerifier creates a new instance of CommitteeRootMappingVerifier, bound to a specific deployed contract.
func NewCommitteeRootMappingVerifier(address common.Address, backend bind.ContractBackend) (*CommitteeRootMappingVerifier, error) {
	contract, err := bindCommitteeRootMappingVerifier(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &CommitteeRootMappingVerifier{CommitteeRootMappingVerifierCaller: CommitteeRootMappingVerifierCaller{contract: contract}, CommitteeRootMappingVerifierTransactor: CommitteeRootMappingVerifierTransactor{contract: contract}, CommitteeRootMappingVerifierFilterer: CommitteeRootMappingVerifierFilterer{contract: contract}}, nil
}

// NewCommitteeRootMappingVerifierCaller creates a new read-only instance of CommitteeRootMappingVerifier, bound to a specific deployed contract.
func NewCommitteeRootMappingVerifierCaller(address common.Address, caller bind.ContractCaller) (*CommitteeRootMappingVerifierCaller, error) {
	contract, err := bindCommitteeRootMappingVerifier(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &CommitteeRootMappingVerifierCaller{contract: contract}, nil
}

// NewCommitteeRootMappingVerifierTransactor creates a new write-only instance of CommitteeRootMappingVerifier, bound to a specific deployed contract.
func NewCommitteeRootMappingVerifierTransactor(address common.Address, transactor bind.ContractTransactor) (*CommitteeRootMappingVerifierTransactor, error) {
	contract, err := bindCommitteeRootMappingVerifier(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &CommitteeRootMappingVerifierTransactor{contract: contract}, nil
}

// NewCommitteeRootMappingVerifierFilterer creates a new log filterer instance of CommitteeRootMappingVerifier, bound to a specific deployed contract.
func NewCommitteeRootMappingVerifierFilterer(address common.Address, filterer bind.ContractFilterer) (*CommitteeRootMappingVerifierFilterer, error) {
	contract, err := bindCommitteeRootMappingVerifier(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &CommitteeRootMappingVerifierFilterer{contract: contract}, nil
}

// bindCommitteeRootMappingVerifier binds a generic wrapper to an already deployed contract.
func bindCommitteeRootMappingVerifier(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := CommitteeRootMappingVerifierMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_CommitteeRootMappingVerifier *CommitteeRootMappingVerifierRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _CommitteeRootMappingVerifier.Contract.CommitteeRootMappingVerifierCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_CommitteeRootMappingVerifier *CommitteeRootMappingVerifierRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CommitteeRootMappingVerifier.Contract.CommitteeRootMappingVerifierTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_CommitteeRootMappingVerifier *CommitteeRootMappingVerifierRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _CommitteeRootMappingVerifier.Contract.CommitteeRootMappingVerifierTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_CommitteeRootMappingVerifier *CommitteeRootMappingVerifierCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _CommitteeRootMappingVerifier.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_CommitteeRootMappingVerifier *CommitteeRootMappingVerifierTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CommitteeRootMappingVerifier.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_CommitteeRootMappingVerifier *CommitteeRootMappingVerifierTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _CommitteeRootMappingVerifier.Contract.contract.Transact(opts, method, params...)
}

// VerifyCommitteeRootMappingProof is a free data retrieval call binding the contract method 0xab00dde6.
//
// Solidity: function verifyCommitteeRootMappingProof(uint256[2] a, uint256[2][2] b, uint256[2] c, uint256[33] input) view returns(bool r)
func (_CommitteeRootMappingVerifier *CommitteeRootMappingVerifierCaller) VerifyCommitteeRootMappingProof(opts *bind.CallOpts, a [2]*big.Int, b [2][2]*big.Int, c [2]*big.Int, input [33]*big.Int) (bool, error) {
	var out []interface{}
	err := _CommitteeRootMappingVerifier.contract.Call(opts, &out, "verifyCommitteeRootMappingProof", a, b, c, input)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// VerifyCommitteeRootMappingProof is a free data retrieval call binding the contract method 0xab00dde6.
//
// Solidity: function verifyCommitteeRootMappingProof(uint256[2] a, uint256[2][2] b, uint256[2] c, uint256[33] input) view returns(bool r)
func (_CommitteeRootMappingVerifier *CommitteeRootMappingVerifierSession) VerifyCommitteeRootMappingProof(a [2]*big.Int, b [2][2]*big.Int, c [2]*big.Int, input [33]*big.Int) (bool, error) {
	return _CommitteeRootMappingVerifier.Contract.VerifyCommitteeRootMappingProof(&_CommitteeRootMappingVerifier.CallOpts, a, b, c, input)
}

// VerifyCommitteeRootMappingProof is a free data retrieval call binding the contract method 0xab00dde6.
//
// Solidity: function verifyCommitteeRootMappingProof(uint256[2] a, uint256[2][2] b, uint256[2] c, uint256[33] input) view returns(bool r)
func (_CommitteeRootMappingVerifier *CommitteeRootMappingVerifierCallerSession) VerifyCommitteeRootMappingProof(a [2]*big.Int, b [2][2]*big.Int, c [2]*big.Int, input [33]*big.Int) (bool, error) {
	return _CommitteeRootMappingVerifier.Contract.VerifyCommitteeRootMappingProof(&_CommitteeRootMappingVerifier.CallOpts, a, b, c, input)
}

// CommonMetaData contains all meta data concerning the Common contract.
var CommonMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea2646970667358221220a90e4625f375711452c9f5d92f5da7d2dad664e6ee96ea7951a6a9e3803b37ea64736f6c63430008140033",
}

// CommonABI is the input ABI used to generate the binding from.
// Deprecated: Use CommonMetaData.ABI instead.
var CommonABI = CommonMetaData.ABI

// CommonBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use CommonMetaData.Bin instead.
var CommonBin = CommonMetaData.Bin

// DeployCommon deploys a new Ethereum contract, binding an instance of Common to it.
func DeployCommon(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Common, error) {
	parsed, err := CommonMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(CommonBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Common{CommonCaller: CommonCaller{contract: contract}, CommonTransactor: CommonTransactor{contract: contract}, CommonFilterer: CommonFilterer{contract: contract}}, nil
}

// Common is an auto generated Go binding around an Ethereum contract.
type Common struct {
	CommonCaller     // Read-only binding to the contract
	CommonTransactor // Write-only binding to the contract
	CommonFilterer   // Log filterer for contract events
}

// CommonCaller is an auto generated read-only Go binding around an Ethereum contract.
type CommonCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CommonTransactor is an auto generated write-only Go binding around an Ethereum contract.
type CommonTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CommonFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type CommonFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CommonSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type CommonSession struct {
	Contract     *Common           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// CommonCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type CommonCallerSession struct {
	Contract *CommonCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// CommonTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type CommonTransactorSession struct {
	Contract     *CommonTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// CommonRaw is an auto generated low-level Go binding around an Ethereum contract.
type CommonRaw struct {
	Contract *Common // Generic contract binding to access the raw methods on
}

// CommonCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type CommonCallerRaw struct {
	Contract *CommonCaller // Generic read-only contract binding to access the raw methods on
}

// CommonTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type CommonTransactorRaw struct {
	Contract *CommonTransactor // Generic write-only contract binding to access the raw methods on
}

// NewCommon creates a new instance of Common, bound to a specific deployed contract.
func NewCommon(address common.Address, backend bind.ContractBackend) (*Common, error) {
	contract, err := bindCommon(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Common{CommonCaller: CommonCaller{contract: contract}, CommonTransactor: CommonTransactor{contract: contract}, CommonFilterer: CommonFilterer{contract: contract}}, nil
}

// NewCommonCaller creates a new read-only instance of Common, bound to a specific deployed contract.
func NewCommonCaller(address common.Address, caller bind.ContractCaller) (*CommonCaller, error) {
	contract, err := bindCommon(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &CommonCaller{contract: contract}, nil
}

// NewCommonTransactor creates a new write-only instance of Common, bound to a specific deployed contract.
func NewCommonTransactor(address common.Address, transactor bind.ContractTransactor) (*CommonTransactor, error) {
	contract, err := bindCommon(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &CommonTransactor{contract: contract}, nil
}

// NewCommonFilterer creates a new log filterer instance of Common, bound to a specific deployed contract.
func NewCommonFilterer(address common.Address, filterer bind.ContractFilterer) (*CommonFilterer, error) {
	contract, err := bindCommon(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &CommonFilterer{contract: contract}, nil
}

// bindCommon binds a generic wrapper to an already deployed contract.
func bindCommon(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := CommonMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Common *CommonRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Common.Contract.CommonCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Common *CommonRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Common.Contract.CommonTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Common *CommonRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Common.Contract.CommonTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Common *CommonCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Common.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Common *CommonTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Common.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Common *CommonTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Common.Contract.contract.Transact(opts, method, params...)
}

// ContextMetaData contains all meta data concerning the Context contract.
var ContextMetaData = &bind.MetaData{
	ABI: "[]",
}

// ContextABI is the input ABI used to generate the binding from.
// Deprecated: Use ContextMetaData.ABI instead.
var ContextABI = ContextMetaData.ABI

// Context is an auto generated Go binding around an Ethereum contract.
type Context struct {
	ContextCaller     // Read-only binding to the contract
	ContextTransactor // Write-only binding to the contract
	ContextFilterer   // Log filterer for contract events
}

// ContextCaller is an auto generated read-only Go binding around an Ethereum contract.
type ContextCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContextTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ContextTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContextFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ContextFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContextSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ContextSession struct {
	Contract     *Context          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ContextCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ContextCallerSession struct {
	Contract *ContextCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// ContextTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ContextTransactorSession struct {
	Contract     *ContextTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// ContextRaw is an auto generated low-level Go binding around an Ethereum contract.
type ContextRaw struct {
	Contract *Context // Generic contract binding to access the raw methods on
}

// ContextCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ContextCallerRaw struct {
	Contract *ContextCaller // Generic read-only contract binding to access the raw methods on
}

// ContextTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ContextTransactorRaw struct {
	Contract *ContextTransactor // Generic write-only contract binding to access the raw methods on
}

// NewContext creates a new instance of Context, bound to a specific deployed contract.
func NewContext(address common.Address, backend bind.ContractBackend) (*Context, error) {
	contract, err := bindContext(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Context{ContextCaller: ContextCaller{contract: contract}, ContextTransactor: ContextTransactor{contract: contract}, ContextFilterer: ContextFilterer{contract: contract}}, nil
}

// NewContextCaller creates a new read-only instance of Context, bound to a specific deployed contract.
func NewContextCaller(address common.Address, caller bind.ContractCaller) (*ContextCaller, error) {
	contract, err := bindContext(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ContextCaller{contract: contract}, nil
}

// NewContextTransactor creates a new write-only instance of Context, bound to a specific deployed contract.
func NewContextTransactor(address common.Address, transactor bind.ContractTransactor) (*ContextTransactor, error) {
	contract, err := bindContext(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ContextTransactor{contract: contract}, nil
}

// NewContextFilterer creates a new log filterer instance of Context, bound to a specific deployed contract.
func NewContextFilterer(address common.Address, filterer bind.ContractFilterer) (*ContextFilterer, error) {
	contract, err := bindContext(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ContextFilterer{contract: contract}, nil
}

// bindContext binds a generic wrapper to an already deployed contract.
func bindContext(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ContextMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Context *ContextRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Context.Contract.ContextCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Context *ContextRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Context.Contract.ContextTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Context *ContextRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Context.Contract.ContextTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Context *ContextCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Context.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Context *ContextTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Context.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Context *ContextTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Context.Contract.contract.Transact(opts, method, params...)
}

// CurrencyLibraryMetaData contains all meta data concerning the CurrencyLibrary contract.
var CurrencyLibraryMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"ERC20TransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NativeTransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NATIVE\",\"outputs\":[{\"internalType\":\"Currency\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x60808060405234601857606f908161001d823930815050f35b5f80fdfe60808060405260043610156011575f80fd5b5f3560e01c63a0cf0aea146023575f80fd5b5f366003190112603557805f60209252f35b5f80fdfea26469706673582212207c1f3b40944783cc503f197c1429c329f3ba9a0cfd3f490073aed42ef4d8109f64736f6c63430008140033",
}

// CurrencyLibraryABI is the input ABI used to generate the binding from.
// Deprecated: Use CurrencyLibraryMetaData.ABI instead.
var CurrencyLibraryABI = CurrencyLibraryMetaData.ABI

// CurrencyLibraryBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use CurrencyLibraryMetaData.Bin instead.
var CurrencyLibraryBin = CurrencyLibraryMetaData.Bin

// DeployCurrencyLibrary deploys a new Ethereum contract, binding an instance of CurrencyLibrary to it.
func DeployCurrencyLibrary(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *CurrencyLibrary, error) {
	parsed, err := CurrencyLibraryMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(CurrencyLibraryBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &CurrencyLibrary{CurrencyLibraryCaller: CurrencyLibraryCaller{contract: contract}, CurrencyLibraryTransactor: CurrencyLibraryTransactor{contract: contract}, CurrencyLibraryFilterer: CurrencyLibraryFilterer{contract: contract}}, nil
}

// CurrencyLibrary is an auto generated Go binding around an Ethereum contract.
type CurrencyLibrary struct {
	CurrencyLibraryCaller     // Read-only binding to the contract
	CurrencyLibraryTransactor // Write-only binding to the contract
	CurrencyLibraryFilterer   // Log filterer for contract events
}

// CurrencyLibraryCaller is an auto generated read-only Go binding around an Ethereum contract.
type CurrencyLibraryCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CurrencyLibraryTransactor is an auto generated write-only Go binding around an Ethereum contract.
type CurrencyLibraryTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CurrencyLibraryFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type CurrencyLibraryFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CurrencyLibrarySession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type CurrencyLibrarySession struct {
	Contract     *CurrencyLibrary  // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// CurrencyLibraryCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type CurrencyLibraryCallerSession struct {
	Contract *CurrencyLibraryCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts          // Call options to use throughout this session
}

// CurrencyLibraryTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type CurrencyLibraryTransactorSession struct {
	Contract     *CurrencyLibraryTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts          // Transaction auth options to use throughout this session
}

// CurrencyLibraryRaw is an auto generated low-level Go binding around an Ethereum contract.
type CurrencyLibraryRaw struct {
	Contract *CurrencyLibrary // Generic contract binding to access the raw methods on
}

// CurrencyLibraryCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type CurrencyLibraryCallerRaw struct {
	Contract *CurrencyLibraryCaller // Generic read-only contract binding to access the raw methods on
}

// CurrencyLibraryTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type CurrencyLibraryTransactorRaw struct {
	Contract *CurrencyLibraryTransactor // Generic write-only contract binding to access the raw methods on
}

// NewCurrencyLibrary creates a new instance of CurrencyLibrary, bound to a specific deployed contract.
func NewCurrencyLibrary(address common.Address, backend bind.ContractBackend) (*CurrencyLibrary, error) {
	contract, err := bindCurrencyLibrary(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &CurrencyLibrary{CurrencyLibraryCaller: CurrencyLibraryCaller{contract: contract}, CurrencyLibraryTransactor: CurrencyLibraryTransactor{contract: contract}, CurrencyLibraryFilterer: CurrencyLibraryFilterer{contract: contract}}, nil
}

// NewCurrencyLibraryCaller creates a new read-only instance of CurrencyLibrary, bound to a specific deployed contract.
func NewCurrencyLibraryCaller(address common.Address, caller bind.ContractCaller) (*CurrencyLibraryCaller, error) {
	contract, err := bindCurrencyLibrary(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &CurrencyLibraryCaller{contract: contract}, nil
}

// NewCurrencyLibraryTransactor creates a new write-only instance of CurrencyLibrary, bound to a specific deployed contract.
func NewCurrencyLibraryTransactor(address common.Address, transactor bind.ContractTransactor) (*CurrencyLibraryTransactor, error) {
	contract, err := bindCurrencyLibrary(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &CurrencyLibraryTransactor{contract: contract}, nil
}

// NewCurrencyLibraryFilterer creates a new log filterer instance of CurrencyLibrary, bound to a specific deployed contract.
func NewCurrencyLibraryFilterer(address common.Address, filterer bind.ContractFilterer) (*CurrencyLibraryFilterer, error) {
	contract, err := bindCurrencyLibrary(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &CurrencyLibraryFilterer{contract: contract}, nil
}

// bindCurrencyLibrary binds a generic wrapper to an already deployed contract.
func bindCurrencyLibrary(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := CurrencyLibraryMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_CurrencyLibrary *CurrencyLibraryRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _CurrencyLibrary.Contract.CurrencyLibraryCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_CurrencyLibrary *CurrencyLibraryRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CurrencyLibrary.Contract.CurrencyLibraryTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_CurrencyLibrary *CurrencyLibraryRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _CurrencyLibrary.Contract.CurrencyLibraryTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_CurrencyLibrary *CurrencyLibraryCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _CurrencyLibrary.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_CurrencyLibrary *CurrencyLibraryTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CurrencyLibrary.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_CurrencyLibrary *CurrencyLibraryTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _CurrencyLibrary.Contract.contract.Transact(opts, method, params...)
}

// NATIVE is a free data retrieval call binding the contract method 0xa0cf0aea.
//
// Solidity: function NATIVE() view returns(address)
func (_CurrencyLibrary *CurrencyLibraryCaller) NATIVE(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _CurrencyLibrary.contract.Call(opts, &out, "NATIVE")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// NATIVE is a free data retrieval call binding the contract method 0xa0cf0aea.
//
// Solidity: function NATIVE() view returns(address)
func (_CurrencyLibrary *CurrencyLibrarySession) NATIVE() (common.Address, error) {
	return _CurrencyLibrary.Contract.NATIVE(&_CurrencyLibrary.CallOpts)
}

// NATIVE is a free data retrieval call binding the contract method 0xa0cf0aea.
//
// Solidity: function NATIVE() view returns(address)
func (_CurrencyLibrary *CurrencyLibraryCallerSession) NATIVE() (common.Address, error) {
	return _CurrencyLibrary.Contract.NATIVE(&_CurrencyLibrary.CallOpts)
}

// ERC20MetaData contains all meta data concerning the ERC20 contract.
var ERC20MetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x608060405234620003055762000c95803803806200001d8162000309565b928339810190604081830312620003055780516001600160401b03908181116200030557836200004f9184016200032f565b916020938482015183811162000305576200006b92016200032f565b825182811162000210576003918254916001958684811c94168015620002fa575b88851014620002e6578190601f9485811162000293575b50889085831160011462000230575f9262000224575b50505f1982861b1c191690861b1783555b8051938411620002105760049586548681811c9116801562000205575b82821014620001f257838111620001aa575b50809285116001146200014057509383949184925f9562000134575b50501b925f19911b1c19161790555b6040516108f59081620003a08239f35b015193505f8062000115565b92919084601f198116885f52855f20955f905b898383106200018f575050501062000175575b50505050811b01905562000124565b01519060f8845f19921b161c191690555f80808062000166565b85870151895590970196948501948893509081019062000153565b875f52815f208480880160051c820192848910620001e8575b0160051c019087905b828110620001dc575050620000f9565b5f8155018790620001cc565b92508192620001c3565b602288634e487b7160e01b5f525260245ffd5b90607f1690620000e7565b634e487b7160e01b5f52604160045260245ffd5b015190505f80620000b9565b90889350601f19831691875f528a5f20925f5b8c8282106200027c575050841162000264575b505050811b018355620000ca565b01515f1983881b60f8161c191690555f808062000256565b8385015186558c9790950194938401930162000243565b909150855f52885f208580850160051c8201928b8610620002dc575b918a91869594930160051c01915b828110620002cd575050620000a3565b5f81558594508a9101620002bd565b92508192620002af565b634e487b7160e01b5f52602260045260245ffd5b93607f16936200008c565b5f80fd5b6040519190601f01601f191682016001600160401b038111838210176200021057604052565b919080601f84011215620003055782516001600160401b038111620002105760209062000365601f8201601f1916830162000309565b9281845282828701011162000305575f5b8181106200038b5750825f9394955001015290565b85810183015184820184015282016200037656fe6080604081815260049182361015610015575f80fd5b5f92833560e01c91826306fdde03146104aa57508163095ea7b31461048057816318160ddd1461046157816323b872dd14610397578163313ce5671461037b578163395093511461032c57816370a08231146102f657816395d89b41146101d7578163a457c2d71461011657508063a9059cbb146100e65763dd62ed3e1461009b575f80fd5b346100e257806003193601126100e257806020926100b76105cd565b6100bf6105e7565b6001600160a01b0391821683526001865283832091168252845220549051908152f35b5080fd5b50346100e257806003193601126100e25760209061010f6101056105cd565b602435903361061e565b5160018152f35b905082346101d457826003193601126101d4576101316105cd565b91836024359233815260016020528181206001600160a01b038616825260205220549082821061016b5760208561010f85850387336107c1565b608490602086519162461bcd60e51b8352820152602560248201527f45524332303a2064656372656173656420616c6c6f77616e63652062656c6f7760448201527f207a65726f0000000000000000000000000000000000000000000000000000006064820152fd5b80fd5b8383346100e257816003193601126100e257805190828454600181811c908083169283156102ec575b60209384841081146102d9578388529081156102bd5750600114610268575b505050829003601f01601f191682019267ffffffffffffffff8411838510176102555750829182610251925282610586565b0390f35b634e487b7160e01b815260418552602490fd5b8787529192508591837f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b5b8385106102a9575050505083010185808061021f565b805488860183015293019284908201610293565b60ff1916878501525050151560051b840101905085808061021f565b634e487b7160e01b895260228a52602489fd5b91607f1691610200565b5050346100e25760203660031901126100e257806020926001600160a01b0361031d6105cd565b16815280845220549051908152f35b5050346100e257806003193601126100e25761010f60209261037461034f6105cd565b91338152600186528481206001600160a01b03841682528652846024359120546105fd565b90336107c1565b5050346100e257816003193601126100e2576020905160128152f35b839150346100e25760603660031901126100e2576103b36105cd565b6103bb6105e7565b9184604435946001600160a01b038416815260016020528181203382526020522054905f1982036103f5575b60208661010f87878761061e565b84821061041e57509183916104136020969561010f950333836107c1565b9193948193506103e7565b606490602087519162461bcd60e51b8352820152601d60248201527f45524332303a20696e73756666696369656e7420616c6c6f77616e63650000006044820152fd5b5050346100e257816003193601126100e2576020906002549051908152f35b5050346100e257806003193601126100e25760209061010f6104a06105cd565b60243590336107c1565b8490843461058257826003193601126105825782600354600181811c90808316928315610578575b60209384841081146102d9578388529081156102bd575060011461052257505050829003601f01601f191682019267ffffffffffffffff8411838510176102555750829182610251925282610586565b600387529192508591837fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b5b838510610564575050505083010185808061021f565b80548886018301529301928490820161054e565b91607f16916104d2565b8280fd5b602080825282518183018190529093925f5b8281106105b957505060409293505f838284010152601f8019910116010190565b818101860151848201604001528501610598565b600435906001600160a01b03821682036105e357565b5f80fd5b602435906001600160a01b03821682036105e357565b9190820180921161060a57565b634e487b7160e01b5f52601160045260245ffd5b6001600160a01b038091169182156107565716918215610705575f8281528060205260408120549180831061069a57604082827fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef95876020965282865203828220558681522061068f8282546105fd565b9055604051908152a3565b60405162461bcd60e51b815260206004820152602660248201527f45524332303a207472616e7366657220616d6f756e742065786365656473206260448201527f616c616e636500000000000000000000000000000000000000000000000000006064820152608490fd5b60405162461bcd60e51b815260206004820152602360248201527f45524332303a207472616e7366657220746f20746865207a65726f206164647260448201526265737360e81b6064820152608490fd5b60405162461bcd60e51b815260206004820152602560248201527f45524332303a207472616e736665722066726f6d20746865207a65726f20616460448201527f64726573730000000000000000000000000000000000000000000000000000006064820152608490fd5b6001600160a01b0380911691821561086e571691821561081e5760207f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92591835f526001825260405f20855f5282528060405f2055604051908152a3565b60405162461bcd60e51b815260206004820152602260248201527f45524332303a20617070726f766520746f20746865207a65726f206164647265604482015261737360f01b6064820152608490fd5b60405162461bcd60e51b8152602060048201526024808201527f45524332303a20617070726f76652066726f6d20746865207a65726f206164646044820152637265737360e01b6064820152608490fdfea2646970667358221220ee6f9b29e27e07bbb0cca767b54305831223e002caaaf19329d5985d27164b8b64736f6c63430008140033",
}

// ERC20ABI is the input ABI used to generate the binding from.
// Deprecated: Use ERC20MetaData.ABI instead.
var ERC20ABI = ERC20MetaData.ABI

// ERC20Bin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use ERC20MetaData.Bin instead.
var ERC20Bin = ERC20MetaData.Bin

// DeployERC20 deploys a new Ethereum contract, binding an instance of ERC20 to it.
func DeployERC20(auth *bind.TransactOpts, backend bind.ContractBackend, name_ string, symbol_ string) (common.Address, *types.Transaction, *ERC20, error) {
	parsed, err := ERC20MetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(ERC20Bin), backend, name_, symbol_)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ERC20{ERC20Caller: ERC20Caller{contract: contract}, ERC20Transactor: ERC20Transactor{contract: contract}, ERC20Filterer: ERC20Filterer{contract: contract}}, nil
}

// ERC20 is an auto generated Go binding around an Ethereum contract.
type ERC20 struct {
	ERC20Caller     // Read-only binding to the contract
	ERC20Transactor // Write-only binding to the contract
	ERC20Filterer   // Log filterer for contract events
}

// ERC20Caller is an auto generated read-only Go binding around an Ethereum contract.
type ERC20Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20Transactor is an auto generated write-only Go binding around an Ethereum contract.
type ERC20Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ERC20Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ERC20Session struct {
	Contract     *ERC20            // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC20CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ERC20CallerSession struct {
	Contract *ERC20Caller  // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// ERC20TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ERC20TransactorSession struct {
	Contract     *ERC20Transactor  // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC20Raw is an auto generated low-level Go binding around an Ethereum contract.
type ERC20Raw struct {
	Contract *ERC20 // Generic contract binding to access the raw methods on
}

// ERC20CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ERC20CallerRaw struct {
	Contract *ERC20Caller // Generic read-only contract binding to access the raw methods on
}

// ERC20TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ERC20TransactorRaw struct {
	Contract *ERC20Transactor // Generic write-only contract binding to access the raw methods on
}

// NewERC20 creates a new instance of ERC20, bound to a specific deployed contract.
func NewERC20(address common.Address, backend bind.ContractBackend) (*ERC20, error) {
	contract, err := bindERC20(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC20{ERC20Caller: ERC20Caller{contract: contract}, ERC20Transactor: ERC20Transactor{contract: contract}, ERC20Filterer: ERC20Filterer{contract: contract}}, nil
}

// NewERC20Caller creates a new read-only instance of ERC20, bound to a specific deployed contract.
func NewERC20Caller(address common.Address, caller bind.ContractCaller) (*ERC20Caller, error) {
	contract, err := bindERC20(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20Caller{contract: contract}, nil
}

// NewERC20Transactor creates a new write-only instance of ERC20, bound to a specific deployed contract.
func NewERC20Transactor(address common.Address, transactor bind.ContractTransactor) (*ERC20Transactor, error) {
	contract, err := bindERC20(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20Transactor{contract: contract}, nil
}

// NewERC20Filterer creates a new log filterer instance of ERC20, bound to a specific deployed contract.
func NewERC20Filterer(address common.Address, filterer bind.ContractFilterer) (*ERC20Filterer, error) {
	contract, err := bindERC20(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC20Filterer{contract: contract}, nil
}

// bindERC20 binds a generic wrapper to an already deployed contract.
func bindERC20(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ERC20MetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20 *ERC20Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ERC20.Contract.ERC20Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20 *ERC20Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20.Contract.ERC20Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20 *ERC20Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20.Contract.ERC20Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20 *ERC20CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ERC20.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20 *ERC20TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20 *ERC20TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_ERC20 *ERC20Caller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var out []interface{}
	err := _ERC20.contract.Call(opts, &out, "allowance", owner, spender)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_ERC20 *ERC20Session) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _ERC20.Contract.Allowance(&_ERC20.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_ERC20 *ERC20CallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _ERC20.Contract.Allowance(&_ERC20.CallOpts, owner, spender)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_ERC20 *ERC20Caller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _ERC20.contract.Call(opts, &out, "balanceOf", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_ERC20 *ERC20Session) BalanceOf(account common.Address) (*big.Int, error) {
	return _ERC20.Contract.BalanceOf(&_ERC20.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_ERC20 *ERC20CallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _ERC20.Contract.BalanceOf(&_ERC20.CallOpts, account)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_ERC20 *ERC20Caller) Decimals(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _ERC20.contract.Call(opts, &out, "decimals")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_ERC20 *ERC20Session) Decimals() (uint8, error) {
	return _ERC20.Contract.Decimals(&_ERC20.CallOpts)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_ERC20 *ERC20CallerSession) Decimals() (uint8, error) {
	return _ERC20.Contract.Decimals(&_ERC20.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC20 *ERC20Caller) Name(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _ERC20.contract.Call(opts, &out, "name")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC20 *ERC20Session) Name() (string, error) {
	return _ERC20.Contract.Name(&_ERC20.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC20 *ERC20CallerSession) Name() (string, error) {
	return _ERC20.Contract.Name(&_ERC20.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC20 *ERC20Caller) Symbol(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _ERC20.contract.Call(opts, &out, "symbol")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC20 *ERC20Session) Symbol() (string, error) {
	return _ERC20.Contract.Symbol(&_ERC20.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC20 *ERC20CallerSession) Symbol() (string, error) {
	return _ERC20.Contract.Symbol(&_ERC20.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ERC20 *ERC20Caller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _ERC20.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ERC20 *ERC20Session) TotalSupply() (*big.Int, error) {
	return _ERC20.Contract.TotalSupply(&_ERC20.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ERC20 *ERC20CallerSession) TotalSupply() (*big.Int, error) {
	return _ERC20.Contract.TotalSupply(&_ERC20.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_ERC20 *ERC20Transactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.contract.Transact(opts, "approve", spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_ERC20 *ERC20Session) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.Approve(&_ERC20.TransactOpts, spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_ERC20 *ERC20TransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.Approve(&_ERC20.TransactOpts, spender, amount)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_ERC20 *ERC20Transactor) DecreaseAllowance(opts *bind.TransactOpts, spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _ERC20.contract.Transact(opts, "decreaseAllowance", spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_ERC20 *ERC20Session) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.DecreaseAllowance(&_ERC20.TransactOpts, spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_ERC20 *ERC20TransactorSession) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.DecreaseAllowance(&_ERC20.TransactOpts, spender, subtractedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_ERC20 *ERC20Transactor) IncreaseAllowance(opts *bind.TransactOpts, spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _ERC20.contract.Transact(opts, "increaseAllowance", spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_ERC20 *ERC20Session) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.IncreaseAllowance(&_ERC20.TransactOpts, spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_ERC20 *ERC20TransactorSession) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.IncreaseAllowance(&_ERC20.TransactOpts, spender, addedValue)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_ERC20 *ERC20Transactor) Transfer(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.contract.Transact(opts, "transfer", to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_ERC20 *ERC20Session) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.Transfer(&_ERC20.TransactOpts, to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_ERC20 *ERC20TransactorSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.Transfer(&_ERC20.TransactOpts, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_ERC20 *ERC20Transactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.contract.Transact(opts, "transferFrom", from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_ERC20 *ERC20Session) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.TransferFrom(&_ERC20.TransactOpts, from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_ERC20 *ERC20TransactorSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.TransferFrom(&_ERC20.TransactOpts, from, to, amount)
}

// ERC20ApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the ERC20 contract.
type ERC20ApprovalIterator struct {
	Event *ERC20Approval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20ApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20Approval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20Approval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20ApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20ApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20Approval represents a Approval event raised by the ERC20 contract.
type ERC20Approval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_ERC20 *ERC20Filterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*ERC20ApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _ERC20.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &ERC20ApprovalIterator{contract: _ERC20.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_ERC20 *ERC20Filterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *ERC20Approval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _ERC20.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20Approval)
				if err := _ERC20.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_ERC20 *ERC20Filterer) ParseApproval(log types.Log) (*ERC20Approval, error) {
	event := new(ERC20Approval)
	if err := _ERC20.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20TransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the ERC20 contract.
type ERC20TransferIterator struct {
	Event *ERC20Transfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20TransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20Transfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20Transfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20TransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20TransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20Transfer represents a Transfer event raised by the ERC20 contract.
type ERC20Transfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_ERC20 *ERC20Filterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*ERC20TransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _ERC20.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &ERC20TransferIterator{contract: _ERC20.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_ERC20 *ERC20Filterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *ERC20Transfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _ERC20.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20Transfer)
				if err := _ERC20.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_ERC20 *ERC20Filterer) ParseTransfer(log types.Log) (*ERC20Transfer, error) {
	event := new(ERC20Transfer)
	if err := _ERC20.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20BurnableMetaData contains all meta data concerning the ERC20Burnable contract.
var ERC20BurnableMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// ERC20BurnableABI is the input ABI used to generate the binding from.
// Deprecated: Use ERC20BurnableMetaData.ABI instead.
var ERC20BurnableABI = ERC20BurnableMetaData.ABI

// ERC20Burnable is an auto generated Go binding around an Ethereum contract.
type ERC20Burnable struct {
	ERC20BurnableCaller     // Read-only binding to the contract
	ERC20BurnableTransactor // Write-only binding to the contract
	ERC20BurnableFilterer   // Log filterer for contract events
}

// ERC20BurnableCaller is an auto generated read-only Go binding around an Ethereum contract.
type ERC20BurnableCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20BurnableTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ERC20BurnableTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20BurnableFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ERC20BurnableFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20BurnableSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ERC20BurnableSession struct {
	Contract     *ERC20Burnable    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC20BurnableCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ERC20BurnableCallerSession struct {
	Contract *ERC20BurnableCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// ERC20BurnableTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ERC20BurnableTransactorSession struct {
	Contract     *ERC20BurnableTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// ERC20BurnableRaw is an auto generated low-level Go binding around an Ethereum contract.
type ERC20BurnableRaw struct {
	Contract *ERC20Burnable // Generic contract binding to access the raw methods on
}

// ERC20BurnableCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ERC20BurnableCallerRaw struct {
	Contract *ERC20BurnableCaller // Generic read-only contract binding to access the raw methods on
}

// ERC20BurnableTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ERC20BurnableTransactorRaw struct {
	Contract *ERC20BurnableTransactor // Generic write-only contract binding to access the raw methods on
}

// NewERC20Burnable creates a new instance of ERC20Burnable, bound to a specific deployed contract.
func NewERC20Burnable(address common.Address, backend bind.ContractBackend) (*ERC20Burnable, error) {
	contract, err := bindERC20Burnable(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC20Burnable{ERC20BurnableCaller: ERC20BurnableCaller{contract: contract}, ERC20BurnableTransactor: ERC20BurnableTransactor{contract: contract}, ERC20BurnableFilterer: ERC20BurnableFilterer{contract: contract}}, nil
}

// NewERC20BurnableCaller creates a new read-only instance of ERC20Burnable, bound to a specific deployed contract.
func NewERC20BurnableCaller(address common.Address, caller bind.ContractCaller) (*ERC20BurnableCaller, error) {
	contract, err := bindERC20Burnable(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20BurnableCaller{contract: contract}, nil
}

// NewERC20BurnableTransactor creates a new write-only instance of ERC20Burnable, bound to a specific deployed contract.
func NewERC20BurnableTransactor(address common.Address, transactor bind.ContractTransactor) (*ERC20BurnableTransactor, error) {
	contract, err := bindERC20Burnable(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20BurnableTransactor{contract: contract}, nil
}

// NewERC20BurnableFilterer creates a new log filterer instance of ERC20Burnable, bound to a specific deployed contract.
func NewERC20BurnableFilterer(address common.Address, filterer bind.ContractFilterer) (*ERC20BurnableFilterer, error) {
	contract, err := bindERC20Burnable(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC20BurnableFilterer{contract: contract}, nil
}

// bindERC20Burnable binds a generic wrapper to an already deployed contract.
func bindERC20Burnable(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ERC20BurnableMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20Burnable *ERC20BurnableRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ERC20Burnable.Contract.ERC20BurnableCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20Burnable *ERC20BurnableRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.ERC20BurnableTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20Burnable *ERC20BurnableRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.ERC20BurnableTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20Burnable *ERC20BurnableCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ERC20Burnable.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20Burnable *ERC20BurnableTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20Burnable *ERC20BurnableTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_ERC20Burnable *ERC20BurnableCaller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var out []interface{}
	err := _ERC20Burnable.contract.Call(opts, &out, "allowance", owner, spender)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_ERC20Burnable *ERC20BurnableSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _ERC20Burnable.Contract.Allowance(&_ERC20Burnable.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_ERC20Burnable *ERC20BurnableCallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _ERC20Burnable.Contract.Allowance(&_ERC20Burnable.CallOpts, owner, spender)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_ERC20Burnable *ERC20BurnableCaller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _ERC20Burnable.contract.Call(opts, &out, "balanceOf", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_ERC20Burnable *ERC20BurnableSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _ERC20Burnable.Contract.BalanceOf(&_ERC20Burnable.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_ERC20Burnable *ERC20BurnableCallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _ERC20Burnable.Contract.BalanceOf(&_ERC20Burnable.CallOpts, account)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_ERC20Burnable *ERC20BurnableCaller) Decimals(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _ERC20Burnable.contract.Call(opts, &out, "decimals")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_ERC20Burnable *ERC20BurnableSession) Decimals() (uint8, error) {
	return _ERC20Burnable.Contract.Decimals(&_ERC20Burnable.CallOpts)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_ERC20Burnable *ERC20BurnableCallerSession) Decimals() (uint8, error) {
	return _ERC20Burnable.Contract.Decimals(&_ERC20Burnable.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC20Burnable *ERC20BurnableCaller) Name(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _ERC20Burnable.contract.Call(opts, &out, "name")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC20Burnable *ERC20BurnableSession) Name() (string, error) {
	return _ERC20Burnable.Contract.Name(&_ERC20Burnable.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC20Burnable *ERC20BurnableCallerSession) Name() (string, error) {
	return _ERC20Burnable.Contract.Name(&_ERC20Burnable.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC20Burnable *ERC20BurnableCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _ERC20Burnable.contract.Call(opts, &out, "symbol")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC20Burnable *ERC20BurnableSession) Symbol() (string, error) {
	return _ERC20Burnable.Contract.Symbol(&_ERC20Burnable.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC20Burnable *ERC20BurnableCallerSession) Symbol() (string, error) {
	return _ERC20Burnable.Contract.Symbol(&_ERC20Burnable.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ERC20Burnable *ERC20BurnableCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _ERC20Burnable.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ERC20Burnable *ERC20BurnableSession) TotalSupply() (*big.Int, error) {
	return _ERC20Burnable.Contract.TotalSupply(&_ERC20Burnable.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ERC20Burnable *ERC20BurnableCallerSession) TotalSupply() (*big.Int, error) {
	return _ERC20Burnable.Contract.TotalSupply(&_ERC20Burnable.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.contract.Transact(opts, "approve", spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_ERC20Burnable *ERC20BurnableSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.Approve(&_ERC20Burnable.TransactOpts, spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.Approve(&_ERC20Burnable.TransactOpts, spender, amount)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 amount) returns()
func (_ERC20Burnable *ERC20BurnableTransactor) Burn(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.contract.Transact(opts, "burn", amount)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 amount) returns()
func (_ERC20Burnable *ERC20BurnableSession) Burn(amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.Burn(&_ERC20Burnable.TransactOpts, amount)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 amount) returns()
func (_ERC20Burnable *ERC20BurnableTransactorSession) Burn(amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.Burn(&_ERC20Burnable.TransactOpts, amount)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x79cc6790.
//
// Solidity: function burnFrom(address account, uint256 amount) returns()
func (_ERC20Burnable *ERC20BurnableTransactor) BurnFrom(opts *bind.TransactOpts, account common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.contract.Transact(opts, "burnFrom", account, amount)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x79cc6790.
//
// Solidity: function burnFrom(address account, uint256 amount) returns()
func (_ERC20Burnable *ERC20BurnableSession) BurnFrom(account common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.BurnFrom(&_ERC20Burnable.TransactOpts, account, amount)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x79cc6790.
//
// Solidity: function burnFrom(address account, uint256 amount) returns()
func (_ERC20Burnable *ERC20BurnableTransactorSession) BurnFrom(account common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.BurnFrom(&_ERC20Burnable.TransactOpts, account, amount)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactor) DecreaseAllowance(opts *bind.TransactOpts, spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.contract.Transact(opts, "decreaseAllowance", spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_ERC20Burnable *ERC20BurnableSession) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.DecreaseAllowance(&_ERC20Burnable.TransactOpts, spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactorSession) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.DecreaseAllowance(&_ERC20Burnable.TransactOpts, spender, subtractedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactor) IncreaseAllowance(opts *bind.TransactOpts, spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.contract.Transact(opts, "increaseAllowance", spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_ERC20Burnable *ERC20BurnableSession) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.IncreaseAllowance(&_ERC20Burnable.TransactOpts, spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactorSession) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.IncreaseAllowance(&_ERC20Burnable.TransactOpts, spender, addedValue)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactor) Transfer(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.contract.Transact(opts, "transfer", to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_ERC20Burnable *ERC20BurnableSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.Transfer(&_ERC20Burnable.TransactOpts, to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactorSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.Transfer(&_ERC20Burnable.TransactOpts, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.contract.Transact(opts, "transferFrom", from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_ERC20Burnable *ERC20BurnableSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.TransferFrom(&_ERC20Burnable.TransactOpts, from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_ERC20Burnable *ERC20BurnableTransactorSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Burnable.Contract.TransferFrom(&_ERC20Burnable.TransactOpts, from, to, amount)
}

// ERC20BurnableApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the ERC20Burnable contract.
type ERC20BurnableApprovalIterator struct {
	Event *ERC20BurnableApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20BurnableApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20BurnableApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20BurnableApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20BurnableApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20BurnableApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20BurnableApproval represents a Approval event raised by the ERC20Burnable contract.
type ERC20BurnableApproval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_ERC20Burnable *ERC20BurnableFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*ERC20BurnableApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _ERC20Burnable.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &ERC20BurnableApprovalIterator{contract: _ERC20Burnable.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_ERC20Burnable *ERC20BurnableFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *ERC20BurnableApproval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _ERC20Burnable.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20BurnableApproval)
				if err := _ERC20Burnable.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_ERC20Burnable *ERC20BurnableFilterer) ParseApproval(log types.Log) (*ERC20BurnableApproval, error) {
	event := new(ERC20BurnableApproval)
	if err := _ERC20Burnable.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20BurnableTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the ERC20Burnable contract.
type ERC20BurnableTransferIterator struct {
	Event *ERC20BurnableTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20BurnableTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20BurnableTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20BurnableTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20BurnableTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20BurnableTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20BurnableTransfer represents a Transfer event raised by the ERC20Burnable contract.
type ERC20BurnableTransfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_ERC20Burnable *ERC20BurnableFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*ERC20BurnableTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _ERC20Burnable.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &ERC20BurnableTransferIterator{contract: _ERC20Burnable.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_ERC20Burnable *ERC20BurnableFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *ERC20BurnableTransfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _ERC20Burnable.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20BurnableTransfer)
				if err := _ERC20Burnable.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_ERC20Burnable *ERC20BurnableFilterer) ParseTransfer(log types.Log) (*ERC20BurnableTransfer, error) {
	event := new(ERC20BurnableTransfer)
	if err := _ERC20Burnable.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EthereumLightClientMetaData contains all meta data concerning the EthereumLightClient contract.
var EthereumLightClientMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"genesisTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"genesisValidatorsRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint64[]\",\"name\":\"_forkEpochs\",\"type\":\"uint64[]\"},{\"internalType\":\"bytes4[]\",\"name\":\"_forkVersions\",\"type\":\"bytes4[]\"},{\"internalType\":\"uint64\",\"name\":\"_finalizedSlot\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"syncCommitteeRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"syncCommitteePoseidonRoot\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_zkVerifier\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slot\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"executionStateRoot\",\"type\":\"bytes32\"}],\"name\":\"FinalityUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"epoch\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"forkVersion\",\"type\":\"bytes4\"}],\"name\":\"ForkVersionUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slot\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"executionStateRoot\",\"type\":\"bytes32\"}],\"name\":\"OptimisticUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"sszRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"poseidonRoot\",\"type\":\"bytes32\"}],\"name\":\"SyncCommitteeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addPausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"addProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bestValidUpdate\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"proposerIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"parentRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"bodyRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBeaconBlockHeader\",\"name\":\"beacon\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"stateRoot\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockHash\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockNumber\",\"type\":\"tuple\"}],\"internalType\":\"structExecutionPayload\",\"name\":\"execution\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"executionRoot\",\"type\":\"tuple\"}],\"internalType\":\"structHeaderWithExecution\",\"name\":\"attestedHeader\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"proposerIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"parentRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"bodyRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBeaconBlockHeader\",\"name\":\"beacon\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"stateRoot\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockHash\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockNumber\",\"type\":\"tuple\"}],\"internalType\":\"structExecutionPayload\",\"name\":\"execution\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"executionRoot\",\"type\":\"tuple\"}],\"internalType\":\"structHeaderWithExecution\",\"name\":\"finalizedHeader\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"nextSyncCommitteeRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"nextSyncCommitteePoseidonRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commitment\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIBeaconVerifier.Proof\",\"name\":\"nextSyncCommitteeRootMappingProof\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"participation\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"poseidonRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"commitment\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commitment\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIBeaconVerifier.Proof\",\"name\":\"proof\",\"type\":\"tuple\"}],\"internalType\":\"structSyncAggregate\",\"name\":\"syncAggregate\",\"type\":\"tuple\"},{\"internalType\":\"uint64\",\"name\":\"signatureSlot\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"forkVersion\",\"type\":\"bytes4\"}],\"name\":\"computeDomain\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"proposerIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"parentRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"bodyRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBeaconBlockHeader\",\"name\":\"header\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"domain\",\"type\":\"bytes32\"}],\"name\":\"computeSigningRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentSyncCommitteePoseidonRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentSyncCommitteeRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalizedExecutionStateRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalizedExecutionStateRootAndSlot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalizedSlot\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"forkEpochs\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"forkVersions\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isActiveProver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestFinalizedSlotAndCommitteeRoots\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"currentRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"nextRoot\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextSyncCommitteePoseidonRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextSyncCommitteeRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numPausers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numProvers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optimisticExecutionStateRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optimisticExecutionStateRootAndSlot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optimisticSlot\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pauserList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processLightClientForceUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"proposerIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"parentRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"bodyRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBeaconBlockHeader\",\"name\":\"beacon\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"stateRoot\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockHash\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockNumber\",\"type\":\"tuple\"}],\"internalType\":\"structExecutionPayload\",\"name\":\"execution\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"executionRoot\",\"type\":\"tuple\"}],\"internalType\":\"structHeaderWithExecution\",\"name\":\"attestedHeader\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"proposerIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"parentRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"bodyRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBeaconBlockHeader\",\"name\":\"beacon\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"stateRoot\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockHash\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockNumber\",\"type\":\"tuple\"}],\"internalType\":\"structExecutionPayload\",\"name\":\"execution\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"executionRoot\",\"type\":\"tuple\"}],\"internalType\":\"structHeaderWithExecution\",\"name\":\"finalizedHeader\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"finalityBranch\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"nextSyncCommitteeRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"nextSyncCommitteeBranch\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"nextSyncCommitteePoseidonRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commitment\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIBeaconVerifier.Proof\",\"name\":\"nextSyncCommitteeRootMappingProof\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"participation\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"poseidonRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"commitment\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commitment\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIBeaconVerifier.Proof\",\"name\":\"proof\",\"type\":\"tuple\"}],\"internalType\":\"structSyncAggregate\",\"name\":\"syncAggregate\",\"type\":\"tuple\"},{\"internalType\":\"uint64\",\"name\":\"signatureSlot\",\"type\":\"uint64\"}],\"internalType\":\"structLightClientUpdate\",\"name\":\"update\",\"type\":\"tuple\"}],\"name\":\"processLightClientUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proverStates\",\"outputs\":[{\"internalType\":\"enumBrevisAccess.ProverState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"provers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removePausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"removeProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"epoch\",\"type\":\"uint64\"},{\"internalType\":\"bytes4\",\"name\":\"forkVersion\",\"type\":\"bytes4\"}],\"name\":\"updateForkVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"signatureSlot\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"proposerIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"parentRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"bodyRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBeaconBlockHeader\",\"name\":\"header\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"participation\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"poseidonRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"commitment\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commitment\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIBeaconVerifier.Proof\",\"name\":\"proof\",\"type\":\"tuple\"}],\"internalType\":\"structSyncAggregate\",\"name\":\"syncAggregate\",\"type\":\"tuple\"}],\"name\":\"verifyCommitteeSignature\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zkVerifier\",\"outputs\":[{\"internalType\":\"contractIBeaconVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x604060c0815234620005805762005a14803803806200001e81620005c2565b9283398101906101008183031262000580578051602082015184830151919390916001600160401b038111620005805783019080601f830112156200058057815190620000756200006f83620005e8565b620005c2565b92602084848152016020819460051b830101918383116200058057602001905b828210620005a75750505060608501516001600160401b038111620005805785019181601f840112156200058057825192620000d56200006f85620005e8565b9260208486815201916020839660051b8201019182116200058057602001915b81831062000584575050506200010e6080870162000600565b9360a08701519560e060c08901519801519860018060a01b038a168a03620005805760805260a05251906001600160401b03821162000331576801000000000000000082116200033157603c5482603c5580831062000524575b5090603c5f5260205f20905f5b8160021c8110620004dc5750600319811681036200048a575b505090519190506001600160401b03821162000331576801000000000000000082116200033157603d5482603d558083106200042d575b5090603d5f5260205f20905f5b8160031c8110620003de57506007198116810362000387575b50505060018060401b031660018060401b03195f5416175f5560045560055560018060a01b03199060018060a01b031681603e541617603e55603f548251903360018060a01b0382167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a36001600160a81b0319163360ff60a01b19811691909117603f555f90815260208490528390205460ff1662000345575060415468010000000000000000811015620003315760018101806041558110156200031d5760415f5260205f2001903390825416179055335f5280602052805f20600160ff198254161790557f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f860208251338152a1516153e690816200062e823960805181614b9b015260a05181614c5f0152f35b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52604160045260245ffd5b62461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152606490fd5b5f925f5b600719831683038110620003a957505060031c01555f8080620001eb565b90936020620003d4600192875160e01c908560021b60031b9163ffffffff809116831b921b19161790565b950191016200038b565b5f805b60088110620003f8575083820155600101620001d2565b9490602062000423600192845160e01c908960021b60031b9163ffffffff809116831b921b19161790565b92019501620003e1565b6200046090603d5f5260205f20600780860160031c820192601c8760021b168062000467575b500160031c019062000615565b5f620001c5565b62000483905f198601908154905f199060200360031b1c169055565b5f62000453565b5f925f5b600319831683038110620004ac57505060021c01555f80806200018e565b8151919490916001916020916001600160401b03600686901b81811b19909316911690911b17950191016200048e565b5f805b60048110620004f657508382015560010162000175565b85519095916001916020916001600160401b0360068a901b81811b199092169216901b1792019501620004df565b6200055690603c5f5260205f20600380860160021c820192601887831b16806200055d575b500160021c019062000615565b5f62000168565b62000579905f198601908154905f199060200360031b1c169055565b5f62000549565b5f80fd5b82516001600160e01b0319811681036200058057815260209283019201620000f5565b60208091620005b68462000600565b81520191019062000095565b6040519190601f01601f191682016001600160401b038111838210176200033157604052565b6001600160401b038111620003315760051b60200190565b51906001600160401b03821682036200058057565b81811062000621575050565b5f81556001016200061556fe60806040526004361015610011575f80fd5b5f3560e01c8063031523dd14611b495780631242076614611b1a578063158535ff14611ae957806339536c8f14611acc5780633cf5ea9e14611aa65780633dd3f4aa146118bc5780633f4ba83a146117c457806343a6c5a61461179457806346fbf68e146114a35780634f4fef181461177757806358a16b441461175a5780635c975abb1461173557806365e700de14611718578063677625f2146115c057806367b49cc7146115a35780636b2c0f551461156c5780636ef8d66d14611553578063751f7f15146114e057806380f51c12146114a357806382dc1ec41461146c5780638456cb591461135d5780638da5cb5b14611337578063a036e799146112e8578063a1a9ad5514610e1a578063a4059e0714610dfd578063aae3913b14610dc5578063ab556e9f14610c7a578063ba67ee481461058c578063baa94ea214610546578063bcbaf77014610515578063c5190436146104f8578063d1802369146104d3578063d6df096d146104ad578063e153d79914610477578063e1861b081461045a578063e6c6fcec1461040b578063e79b7a51146103b5578063ec64842e1461036d578063f2fde38b14610279578063fabc74f5146102215763fd1190ea146101dc575f80fd5b3461021d57602036600319011261021d5760043560435481101561021d576001600160a01b0361020d6020926133b6565b9190546040519260031b1c168152f35b5f80fd5b3461021d57602036600319011261021d576001600160a01b036102426133eb565b165f52604260205260ff60405f2054166040516003821015610265576020918152f35b634e487b7160e01b5f52602160045260245ffd5b3461021d57602036600319011261021d576102926133eb565b603f54906001600160a01b03808316916102ad33841461375e565b16918215610302577fffffffffffffffffffffffff0000000000000000000000000000000000000000168217603f557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3005b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608490fd5b3461021d57602036600319011261021d576001600160a01b0361038e6133eb565b165f52604260205260ff60405f205416600381101561026557602090600160405191148152f35b3461021d576103c336613401565b6001600160a01b03906103db82603f5416331461375e565b5f5b815181101561040957806103ff846103f86104049486614d11565b511661512b565b614d03565b6103dd565b005b3461021d5761041936613401565b6001600160a01b039061043182603f5416331461375e565b5f5b815181101561040957806103ff8461044e6104559486614d11565b5116614f4d565b610433565b3461021d575f36600319011261021d576020600754604051908152f35b3461021d575f36600319011261021d5760606001600160401b035f54166004546006549060405192835260208301526040820152f35b3461021d575f36600319011261021d5760206001600160a01b03603e5416604051908152f35b3461021d575f36600319011261021d5760206001600160401b035f5416604051908152f35b3461021d575f36600319011261021d576020600154604051908152f35b3461021d57602036600319011261021d57600435603c5481101561021d576001600160401b0361020d60209261371f565b3461021d57602036600319011261021d57600435603d5481101561021d5761056f6020916136e0565b905460405160039290921b1c60e01b6001600160e01b0319168152f35b3461021d575f36600319011261021d576040516105a881613050565b6040516105b48161301a565b6001600160401b03600854818116835260401c1660208201526009546040820152600a549060609182820152600b54608082015282526040516105f681613050565b60405161060281613035565b600c548152604051806020600d54918281520190600d5f527fd7b6990105719101dabeb77144f2a3385c8033acd3af97e9423a695e81ad1eb5905f5b818110610c645750505081610654910382613086565b6020820152815260405161066781613035565b600e548152604051806020600f54918281520190600f5f527f8d1108e10bcb7c27dddfc02ed9d693a074039d026cf4ea4240b40f7d581ac802905f5b818110610c4e57505050816106b9910382613086565b602082015260208201526040516106cf81613035565b601054815260405180602060115491828152019060115f527f31ecc21a745e3968a04e9570e4425bc18fa8019c68028196b546d1669c200c68905f5b818110610c385750505081610721910382613086565b60208201526040820152602083015260405161073c81613035565b601254815260405180602060135491828152019060135f527f66de8ffda797e3de9c05e8fc57b3bf0ec28a930d40b0d285d93c06501cf6a090905f5b818110610c22575050508161078e910382613086565b602082015260408301526040516107a481613050565b6040516107b08161301a565b6001600160401b03601454818116835260401c166020820152601554604082015260165483820152601754608082015281526040516107ee81613050565b6040516107fa81613035565b601854815260405180602060195491828152019060195f527f944998273e477b495144fb8794c914197f3ccb46be2900f4698fd0ef743c9695905f5b818110610c0c575050508161084c910382613086565b6020820152815260405161085f81613035565b601a548152604051806020601b54918281520190601b5f527f3ad8aa4f87544323a9d1e5dd902f40c356527a7955687113db5f9a85ad579dc1905f5b818110610bf657505050816108b1910382613086565b602082015260208201526040516108c781613035565b601c548152604051806020601d54918281520190601d5f527f6d4407e7be21f808e6509aa9fa9143369579dd7d760fe20a2c09680fc146134f905f5b818110610be05750505081610919910382613086565b60208201526040820152602082015260405161093481613035565b601e548152604051806020601f54918281520190601f5f527fa03837a25210ee280c2113ff4b77ca23440b19d4866cca721c801278fd08d807905f5b818110610bca5750505081610986910382613086565b602082015260408201526021549160235490604051906109a58261306b565b60405160245f825b60028210610bb3575050506109c181613035565b8252604051936109d085613035565b84936026975f955b60029081881015610a00579060206001926109f28d61352a565b8152019a01960195986109d8565b50508787959295602084015260405180602a905f905b60028210610b9c57505050610a2a81613035565b604084015260405180602c905f905b60028210610b8557505050610a4d81613035565b8584015260405193610a5e8561306b565b6001600160401b03602e54168552602f5460208601526030546040860152604051610a888161306b565b610a9061348f565b815260405195610a9f87613035565b86956033995f975b600290818a1015610acf57906020600192610ac18f61352a565b8152019c019801979a610aa7565b5050610b2b975091610b4b604092610b7b95948c8c6020880152610af16134c4565b86880152610afd6134f7565b81880152808501968752610b396001600160401b03603b54169987519d8e9d8e6103809081815201906135a4565b8d810360208f0152906135a4565b99868c01528a01526080890190613674565b6001600160401b038151166101c088015260208101516101e0880152015161020086015251610220850190613674565b6103608301520390f35b825481526001928301929190910190602001610a39565b825481526001928301929190910190602001610a16565b8254815260019283019291909101906020016109ad565b8254845260209093019260019283019201610970565b8254845260209093019260019283019201610903565b825484526020909301926001928301920161089b565b8254845260209093019260019283019201610836565b8254845260209093019260019283019201610778565b825484526020909301926001928301920161070b565b82548452602090930192600192830192016106a3565b825484526020909301926001928301920161063e565b3461021d57604036600319011261021d57610c936130a7565b602435906001600160e01b031982169081830361021d57610cc06001600160a01b03603f5416331461375e565b8115610d8057603c5491600160401b9283811015610d6c57806001610ce89201603c5561371f565b926001600160401b038091169382549060031b9185831b921b1916179055603d5492831015610d6c577f3d992c45d9456d8ebe181b6a66a3721421393afaa297791373e7569c1abcc8af93610d4584600160409601603d556136e0565b63ffffffff829392549160031b9260e01c831b921b191617905582519182526020820152a1005b634e487b7160e01b5f52604160045260245ffd5b60405162461bcd60e51b815260206004820152601060248201527f62616420666f726b2076657273696f6e000000000000000000000000000000006044820152606490fd5b3461021d57602036600319011261021d576004356001600160e01b03198116810361021d57610df5602091614c44565b604051908152f35b3461021d575f36600319011261021d576020600454604051908152f35b3461021d575f36600319011261021d57610e406001600160a01b03603f5416331461375e565b610e48614b99565b6001600160401b0390815f541690620151808201908183116112d4578316111561128f57816008541690811561124a5782601454161115610e9c575b610e94610e8f6137a9565b614800565b610409613eb3565b610ebc906001600160401b03166001600160401b03196014541617601455565b610ef08160085460401c1667ffffffffffffffff60401b6014549160401b169067ffffffffffffffff60401b191617601455565b600954601555600a54601655600b54601755600c54601855600d54818111610d6c57600160401b90818111610d6c576019548160195580821061120a575b507fd7b6990105719101dabeb77144f2a3385c8033acd3af97e9423a695e81ad1eb58054905f915b8383106111d45750505050600e54601a55600f54828111610d6c57818111610d6c57601b5481601b55808210611194575b507f8d1108e10bcb7c27dddfc02ed9d693a074039d026cf4ea4240b40f7d581ac8028054905f915b83831061115e5750505050601054601c55601154828111610d6c57818111610d6c57601d5481601d5580821061111e575b507f31ecc21a745e3968a04e9570e4425bc18fa8019c68028196b546d1669c200c688054905f915b8383106110e85750505050601254601e55601354918211610d6c578111610d6c57601f5481601f558082106110a8575b507f66de8ffda797e3de9c05e8fc57b3bf0ec28a930d40b0d285d93c06501cf6a09090601f5f5281545f905b828210611072575050610e84565b60018091940191825494817fa03837a25210ee280c2113ff4b77ca23440b19d4866cca721c801278fd08d8070155019092611064565b817fa03837a25210ee280c2113ff4b77ca23440b19d4866cca721c801278fd08d80791820191015b8181106110dd5750611038565b5f81556001016110d0565b60018091920192835492817f6d4407e7be21f808e6509aa9fa9143369579dd7d760fe20a2c09680fc146134f0155019190611008565b817f6d4407e7be21f808e6509aa9fa9143369579dd7d760fe20a2c09680fc146134f91820191015b8181106111535750610fe0565b5f8155600101611146565b60018091920192835492817f3ad8aa4f87544323a9d1e5dd902f40c356527a7955687113db5f9a85ad579dc10155019190610faf565b817f3ad8aa4f87544323a9d1e5dd902f40c356527a7955687113db5f9a85ad579dc191820191015b8181106111c95750610f87565b5f81556001016111bc565b60018091920192835492817f944998273e477b495144fb8794c914197f3ccb46be2900f4698fd0ef743c96950155019190610f56565b817f944998273e477b495144fb8794c914197f3ccb46be2900f4698fd0ef743c969591820191015b81811061123f5750610f2e565b5f8155600101611232565b60405162461bcd60e51b815260206004820152601460248201527f6e6f20626573742076616c6964207570646174650000000000000000000000006044820152606490fd5b60405162461bcd60e51b815260206004820152601260248201527f74696d656f7574206e6f742070617373656400000000000000000000000000006044820152606490fd5b634e487b7160e01b5f52601160045260245ffd5b3461021d576112f636613401565b6001600160a01b039061130e82603f5416331461375e565b5f5b815181101561040957806103ff8461132b6113329486614d11565b5116615207565b611310565b3461021d575f36600319011261021d5760206001600160a01b03603f5416604051908152f35b3461021d575f36600319011261021d57335f5260206040815261138660ff60405f205416614f01565b603f5460ff8160a01c166114275760ff60a01b1974010000000000000000000000000000000000000000911617603f557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a25881604051338152a15f5b60435481101561040957806001600160a01b03611400611422936133b6565b90549060031b1c165f526042835260405f20600260ff19825416179055614d03565b6113e1565b60405162461bcd60e51b815260048101839052601060248201527f5061757361626c653a20706175736564000000000000000000000000000000006044820152606490fd5b3461021d57602036600319011261021d576104096114886133eb565b61149e6001600160a01b03603f5416331461375e565b61512b565b3461021d57602036600319011261021d576001600160a01b036114c46133eb565b165f526040602052602060ff60405f2054166040519015158152f35b3461021d57366003190160c0811261021d5760a01361021d576040516115058161301a565b6001600160401b03600435818116810361021d578252602435908116810361021d5781610df59160208094015260443560408201526064356060820152608435608082015260a43590614cd9565b3461021d575f36600319011261021d5761040933615207565b3461021d57602036600319011261021d576104096115886133eb565b61159e6001600160a01b03603f5416331461375e565b615207565b3461021d575f36600319011261021d576020600654604051908152f35b3461021d576115ce36613401565b603f54906001600160a01b03916115e8338483161461375e565b60ff9060a01c811615611710576002925b5f5b8351811015610409578161160f8286614d11565b511690815f52604260208181528560405f2054169160039283811015610265576116cb5760438054600160401b811015610d6c57611657816116779360018a940190556133b6565b90919082549060031b916001600160a01b03809116831b921b1916179055565b845f52815260405f2091881015610265576116c6937fef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd0396849260ff19815416888b16179055604051908152a1614d03565b6115fb565b60405162461bcd60e51b815260048101839052601160248201527f6163636f756e742069732070726f7665720000000000000000000000000000006044820152606490fd5b6001926115f9565b3461021d575f36600319011261021d576020600554604051908152f35b3461021d575f36600319011261021d57602060ff603f5460a01c166040519015158152f35b3461021d575f36600319011261021d576020604154604051908152f35b3461021d575f36600319011261021d576020604354604051908152f35b3461021d575f36600319011261021d57600354600254604080519283526001600160401b03909116602083015290f35b3461021d575f36600319011261021d57335f526020604081526117ed60ff60405f205416614f01565b603f5460ff8160a01c16156118775760ff60a01b1916603f557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa81604051338152a15f5b60435481101561040957806001600160a01b03611850611872936133b6565b90549060031b1c165f526042835260405f20600160ff19825416179055614d03565b611831565b60405162461bcd60e51b815260048101839052601460248201527f5061757361626c653a206e6f74207061757365640000000000000000000000006044820152606490fd5b3461021d5761026036600319011261021d576118d66130a7565b60a036602319011261021d576040516118ee8161301a565b6001600160401b0390602435828116810361021d57815260443592828416840361021d57602093848301526064356040830152608435606083015260a43560808301526101a060c31936011261021d576040519261194b8461306b565b60c435908116810361021d57835260e435848401526101043560408401526101403661012319011261021d576040516119838161306b565b36610143121561021d5760405161199981613035565b806101649136831161021d5787610124915b848310611a9757505050825236610183121561021d576040516119cd81613035565b806101e49236841161021d57905b88848310611a7f5791505083015236610203121561021d576040516119ff81613035565b806102249236841161021d578890915b848310611a7057505050604083015236610243121561021d5760405190611a3582613035565b816102649136831161021d57905b828210611a6157505050610409955060608201526060840152614375565b81358152908801908801611a43565b82358152918101918101611a0f565b604091611a8c368561328e565b8152019101906119db565b823581529181019181016119ab565b3461021d575f36600319011261021d5760206001600160401b0360025416604051908152f35b3461021d575f36600319011261021d576020600354604051908152f35b3461021d57602036600319011261021d5760043560415481101561021d576001600160a01b0361020d60209261336d565b3461021d575f36600319011261021d576001545f54604080519283526001600160401b03909116602083015290f35b3461021d5760031960203682011261021d57600435906001600160401b03821161021d576103c090823603011261021d57611b846080612ffe565b80600401356001600160401b03811161021d57611ba7906004369184010161318b565b60805260248101356001600160401b03811161021d57611bcd906004369184010161318b565b60a05260448101356001600160401b03811161021d57611bf390600436918401016130e8565b60c052606481013560e05260848101356001600160401b03811161021d57611c2190600436918401016130e8565b6101005260a481013561012052611c3b3660c483016132d3565b610140526101a03682900361020319011261021d576103a4611ca591604051611c638161306b565b611c7061020483016130bd565b815261022482013560208201526102448201356040820152611c963661026484016132d3565b606082015261016052016130bd565b61010060800152335f52604260205260ff60405f205416600381101561026557600103612fb9576101605151611ce3906001600160401b0316614b79565b611cf5611cee6137a9565b60806149da565b808015612fb2575b15612f6d5760016001600160401b0360e06080015151161115612f28576001600160401b03611d2a614b99565b8160805151511691829116119081612f11575b5015612ecc575f54608051515160065491821591908280612ebf575b80612ea4575b6001600160401b0382166001600160401b03841611908115612e9c575b5015612e575760c05151612cc35760a0515160600151612c7e575b61010051516129f0575050505060606080015115806129e5575b156129a0575b611df960805160405190611dca82613035565b600a82527f6f7074696d6973746963000000000000000000000000000000000000000000006020830152614604565b610180516080515161016051611e1a929091906001600160401b0316614375565b611f62575b8080611f41575b611ec7575b80611e41575b611e3757005b610e946080614800565b5060206080015151516001600160401b035f54166001600160401b03821611908115611e6e575b50611e31565b61010051511515915081611eba575b81611e9a575b5080611e90575b81611e68565b5060065415611e8a565b90506607ffffffffffff806080515151600d1c1691600d1c161481611e83565b60c0515115159150611e7d565b7f27eafee2f5b2c935fa7666d231360699c41fe21db57034136b1af3c43f13df896080516001600160401b03602082015151519182600355515116806001600160401b03196002541617600255611f3960405192839283602090939291936001600160401b0360408201951681520152565b0390a1611e2b565b506001600160401b036080515151166001600160401b036002541610611e26565b608051608081516001600160401b038151166008549067ffffffffffffffff60401b602084015160401b16916fffffffffffffffffffffffffffffffff1916171760085560408101516009556060810151600a550151600b556020810151602081518051600c5501518051906001600160401b038211610d6c57600160401b8211610d6c57600d5482600d5580831061295f575b50602001600d5f525f5b82811061292b575050506020808201518051600e5501518051906001600160401b038211610d6c57600160401b8211610d6c57600f5482600f558083106128ea575b50602001600f5f525f5b8281106128b657505050604001518051601055602001518051906001600160401b038211610d6c57600160401b8211610d6c5760115482601155808310612875575b5060200160115f525f5b82811061284157505050604001518051601255602001518051906001600160401b038211610d6c57600160401b8211610d6c5760135482601355808310612800575b5060200160135f525f5b8281106127cc57505050602060800151608081516121226001600160401b038251166001600160401b03166001600160401b03196014541617601455565b61215c6001600160401b0360208301511667ffffffffffffffff60401b6014549160401b169067ffffffffffffffff60401b191617601455565b604081015160155560608101516016550151601755602081015160208151805160185501518051906001600160401b038211610d6c57600160401b8211610d6c576019548260195580831061278b575b5060200160195f525f5b828110612757575050506020808201518051601a5501518051906001600160401b038211610d6c57600160401b8211610d6c57601b5482601b55808310612716575b50602001601b5f525f5b8281106126e257505050604001518051601c55602001518051906001600160401b038211610d6c57600160401b8211610d6c57601d5482601d558083106126a1575b50602001601d5f525f5b82811061266d57505050604001518051601e55602001518051906001600160401b038211610d6c57600160401b8211610d6c57601f5482601f5580831061262c575b50602001601f5f525f5b8281106125f857505060c051805191506001600160401b038211610d6c57600160401b8211610d6c57602054826020558083106125b7575b5060200160205f525f5b82811061258357505060e05160215550610100518051906001600160401b038211610d6c57600160401b8211610d6c5760225482602255808310612542575b5060200160225f525f5b82811061250e57505061012051602355506101405180515f5b600281106124f95750506020810151906026915f905b60028210156123925780515f5b6002811061237e5750506002602060019201940191019092612354565b600190602083519301928188015501612361565b5050905060408101515f5b600281106124e4575050606001515f5b600281106124cf575050606060e0608001516001600160401b038151166001600160401b0319602e541617602e556020810151602f556040810151603055015180515f5b600281106124ba5750506020810151906033915f905b60028210156124455780515f5b600281106124315750506002602060019201940191019092612407565b600190602083519301928188015501612414565b5050905060408101515f5b600281106124a5575050606001515f5b600281106124905750506001600160401b0361010060800151166001600160401b0319603b541617603b55611e1f565b60019060208351930192816039015501612460565b60019060208351930192816037015501612450565b600190602083519301928160310155016123f1565b6001906020835193019281602c0155016123ad565b6001906020835193019281602a01550161239d565b6001906020835193019281602401550161233e565b60019060208351930192817f61035b26e3e9eee00e0d72fd1ee8ddca6894550dca6916ea2ac6baa90d11e510015501612325565b7f61035b26e3e9eee00e0d72fd1ee8ddca6894550dca6916ea2ac6baa90d11e510908382015b818301811061257857505061231b565b5f8155600101612568565b60019060208351930192817fc97bfaf2f8ee708c303a06d134f5ecd8389ae0432af62dc132a24118292866bb0155016122dc565b7fc97bfaf2f8ee708c303a06d134f5ecd8389ae0432af62dc132a24118292866bb908382015b81830181106125ed5750506122d2565b5f81556001016125dd565b60019060208351930192817fa03837a25210ee280c2113ff4b77ca23440b19d4866cca721c801278fd08d80701550161229a565b7fa03837a25210ee280c2113ff4b77ca23440b19d4866cca721c801278fd08d807908382015b8183018110612662575050612290565b5f8155600101612652565b60019060208351930192817f6d4407e7be21f808e6509aa9fa9143369579dd7d760fe20a2c09680fc146134f01550161224e565b7f6d4407e7be21f808e6509aa9fa9143369579dd7d760fe20a2c09680fc146134f908382015b81830181106126d7575050612244565b5f81556001016126c7565b60019060208351930192817f3ad8aa4f87544323a9d1e5dd902f40c356527a7955687113db5f9a85ad579dc1015501612202565b7f3ad8aa4f87544323a9d1e5dd902f40c356527a7955687113db5f9a85ad579dc1908382015b818301811061274c5750506121f8565b5f815560010161273c565b60019060208351930192817f944998273e477b495144fb8794c914197f3ccb46be2900f4698fd0ef743c96950155016121b6565b7f944998273e477b495144fb8794c914197f3ccb46be2900f4698fd0ef743c9695908382015b81830181106127c15750506121ac565b5f81556001016127b1565b60019060208351930192817f66de8ffda797e3de9c05e8fc57b3bf0ec28a930d40b0d285d93c06501cf6a0900155016120e4565b7f66de8ffda797e3de9c05e8fc57b3bf0ec28a930d40b0d285d93c06501cf6a090908382015b81830181106128365750506120da565b5f8155600101612826565b60019060208351930192817f31ecc21a745e3968a04e9570e4425bc18fa8019c68028196b546d1669c200c68015501612098565b7f31ecc21a745e3968a04e9570e4425bc18fa8019c68028196b546d1669c200c68908382015b81830181106128ab57505061208e565b5f815560010161289b565b60019060208351930192817f8d1108e10bcb7c27dddfc02ed9d693a074039d026cf4ea4240b40f7d581ac80201550161204c565b7f8d1108e10bcb7c27dddfc02ed9d693a074039d026cf4ea4240b40f7d581ac802908382015b8183018110612920575050612042565b5f8155600101612910565b60019060208351930192817fd7b6990105719101dabeb77144f2a3385c8033acd3af97e9423a695e81ad1eb5015501612000565b7fd7b6990105719101dabeb77144f2a3385c8033acd3af97e9423a695e81ad1eb5908382015b8183018110612995575050611ff6565b5f8155600101612985565b60405162461bcd60e51b815260206004820152601c60248201527f6e6f206e6578742073796e6320636f6d6d69747465652070726f6f66000000006044820152606490fd5b506101205115611db1565b6607ffffffffffff8091600d1c1691600d1c16149081612c75575b50612c22575b5060e051610100516080515160600151935f9391929091905b8351851015612ad65760ff85116112d4576001851b15612ac2575f6020916001806037891c16148214612aaa57612a6e612a8191612a688989614d11565b51614cbc565b836040519282848094519384920161459d565b8101039060025afa15612a9f57612a995f5194614d03565b93612a2a565b6040513d5f823e3d90fd5b612a6e612a8191612abb8989614d11565b5190614cbc565b634e487b7160e01b5f52601260045260245ffd5b925092509203612bdd576001600160a01b03603e5416602060606080015161018460a0608001519160c06080015194612b2e6040519687958694637a53878160e01b8652600486015260248501526044840190613674565b5afa908115612a9f575f91612bae575b50611db75760405162461bcd60e51b815260206004820152602a60248201527f626164206e6578742073796e6320636f6d6d697474656520726f6f74206d617060448201527f70696e672070726f6f66000000000000000000000000000000000000000000006064820152608490fd5b612bd0915060203d602011612bd6575b612bc88183613086565b8101906142f9565b83612b3e565b503d612bbe565b60405162461bcd60e51b815260206004820152601d60248201527f626164206e6578742073796e6320636f6d6d69747465652070726f6f660000006044820152606490fd5b60e05103612c305782612a11565b60405162461bcd60e51b815260206004820152601760248201527f626164206e6578742073796e6320636f6d6d69747465650000000000000000006044820152606490fd5b90501584612a0b565b60405162461bcd60e51b815260206004820152600c60248201527f6e6f2066696e2070726f6f6600000000000000000000000000000000000000006044820152606490fd5b60a0515180516001600160401b0316612d29575060a051516060015115611d975760405162461bcd60e51b815260206004820152601e60248201527f67656e65736973206865616465722073686f756c6420626520656d70747900006044820152606490fd5b612d3a909693969592949195614d25565b9560406080015194606060805151015197965f975b8751891015612dbc5760ff89116112d4576001891b15612ac2575f60209160018060698d1c16148214612dab57612a6e612d8d91612a688d8d614d11565b8101039060025afa15612a9f57612da55f5198614d03565b97612d4f565b612a6e612d8d91612abb8d8d614d11565b9295989194975092955003612e125760a051604051612e0d91612dde82613035565b600982527f66696e616c697a656400000000000000000000000000000000000000000000006020830152614604565b611d97565b60405162461bcd60e51b815260206004820152600d60248201527f6261642066696e2070726f6f66000000000000000000000000000000000000006044820152606490fd5b60405162461bcd60e51b815260206004820152601960248201527f6261642061747420736c6f74206f7220636f6d6d6974746565000000000000006044820152606490fd5b905087611d7c565b506607ffffffffffff8082600d1c169083600d1c1614611d5f565b5061010051511515611d59565b60405162461bcd60e51b815260206004820152600860248201527f62616420736c6f740000000000000000000000000000000000000000000000006044820152606490fd5b60a05151516001600160401b031610905083611d3d565b60405162461bcd60e51b815260206004820152601860248201527f6e6f7420656e6f7567682070617274696369706174696f6e00000000000000006044820152606490fd5b60405162461bcd60e51b815260206004820152601260248201527f71756f72756d206e6f74207265616368656400000000000000000000000000006044820152606490fd5b5081611cfd565b60405162461bcd60e51b815260206004820152601260248201527f6e6f7420696e76616c69642070726f76657200000000000000000000000000006044820152606490fd5b61012081019081106001600160401b03821117610d6c57604052565b60a081019081106001600160401b03821117610d6c57604052565b604081019081106001600160401b03821117610d6c57604052565b606081019081106001600160401b03821117610d6c57604052565b608081019081106001600160401b03821117610d6c57604052565b90601f801991011681019081106001600160401b03821117610d6c57604052565b600435906001600160401b038216820361021d57565b35906001600160401b038216820361021d57565b6001600160401b038111610d6c5760051b60200190565b81601f8201121561021d578035916130ff836130d1565b9261310d6040519485613086565b808452602092838086019260051b82010192831161021d578301905b828210613137575050505090565b81358152908301908301613129565b919060408382031261021d576040519061315f82613035565b8193803583526020810135916001600160401b03831161021d5760209261318692016130e8565b910152565b91908281039260e0841261021d576040908151926131a884613050565b60a084961261021d5782516131bc8161301a565b6131c5836130bd565b81526131d3602084016130bd565b602082015283830135848201526060830135606082015260808301356080820152845260a08201356001600160401b039081811161021d57830160608184031261021d5784519061322382613050565b803583811161021d5784613238918301613146565b8252602081013583811161021d5784613252918301613146565b6020830152858101359083821161021d5761326f91859101613146565b85820152602086015260c083013590811161021d576131869201613146565b9080601f8301121561021d57604051916132a783613035565b82906040810192831161021d57905b8282106132c35750505090565b81358152602091820191016132b6565b9190916101408184031261021d576040928351916132f08361306b565b82946132fc838361328e565b845282605f8301121561021d57805161331481613035565b8060c084019185831161021d57838501905b83821061335457505092849261334a606096610100946131869760208b015261328e565b908701520161328e565b60208591613362898561328e565b815201910190613326565b6041548110156133a25760415f527f7c9785e8241615bc80415d89775984a1337d15dc1bf4ce50f41988b2a2b336a701905f90565b634e487b7160e01b5f52603260045260245ffd5b6043548110156133a25760435f527f9690ad99d6ce244efa8a0f6c2d04036d3b33a9474db32a71b71135c69510279301905f90565b600435906001600160a01b038216820361021d57565b60208060031983011261021d57600435916001600160401b03831161021d578060238401121561021d578260040135613439816130d1565b936134476040519586613086565b81855260248486019260051b82010192831161021d57602401905b828210613470575050505090565b81356001600160a01b038116810361021d578152908301908301613462565b6040519060315f835b600282106134ae575050506134ac82613035565b565b6001602081928554815201930191019091613498565b6040519060375f835b600282106134e1575050506134ac82613035565b60016020819285548152019301910190916134cd565b6040519060395f835b60028210613514575050506134ac82613035565b6001602081928554815201930191019091613500565b60405191905f835b60028210613546575050506134ac82613035565b6001602081928554815201930191019091613532565b6060906040830190805184526020928380920151946040838201528551809452019301915f5b828110613590575050505090565b835185529381019392810192600101613582565b61364a91608082516001600160401b0380825116845260208201511660208401526040810151604084015260608101516060840152015160808201526040613639602084015160e060a08501526136088151606060e087015261014086019061355c565b8361362660208401519260df199384898303016101008a015261355c565b920151908583030161012086015261355c565b9201519060c081840391015261355c565b90565b5f915b6002831061365d57505050565b600190825181526020809101920192019190613650565b919061368181845161364d565b60208381015193906040905f908483015b600283106136c4575050506134ac939450816136ba60609261010094015160c086019061364d565b015191019061364d565b8184826136d46001948c5161364d565b01980192019196613692565b90603d548210156133a257603d5f52601c8260031c7fece66cfdbd22e3f37d348a3d8e19074452862cd65fd4b9a11f0336d1ac6d1dc3019260021b1690565b90603c548210156133a257603c5f5260188260021c7fc6bb06cb7f92603de181bf256cd16846b93b752a170ff24824098b31aa008a7e019260031b1690565b1561376557565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b604080516137b681612ffe565b80928251926137c484613050565b8051926137d08461301a565b600854916001600160401b03808416865280602094831c168487015260095482870152600a549560609687820152600b546080820152875281519661381488613050565b82519761382089613035565b600c5489528351988987600d549b8c8152015f9b600d8d527fd7b6990105719101dabeb77144f2a3385c8033acd3af97e9423a695e81ad1eb5908d5b818110613e895750505081613872910382613086565b878201528152835161388381613035565b600e54815284518088600f54918281520190600f8d527f8d1108e10bcb7c27dddfc02ed9d693a074039d026cf4ea4240b40f7d581ac802908d5b818110613e7557505050816138d3910382613086565b878201528682015283516138e681613035565b60105481528451808860115491828152019060118d527f31ecc21a745e3968a04e9570e4425bc18fa8019c68028196b546d1669c200c68908d5b818110613e615750505081613936910382613086565b878201528482015285820152825161394d81613035565b60125481528351808760135491828152019060138c527f66de8ffda797e3de9c05e8fc57b3bf0ec28a930d40b0d285d93c06501cf6a090908c5b818110613e4d575050508161399d910382613086565b8682015283820152835281516139b281613050565b82516139bd8161301a565b826014548181168352851c168682015260155484820152601654888201526017546080820152815282516139f081613050565b83516139fb81613035565b60185481528451808860195491828152019060198d527f944998273e477b495144fb8794c914197f3ccb46be2900f4698fd0ef743c9695908d5b818110613e395750505081613a4b910382613086565b8782015281528351613a5c81613035565b601a54815284518088601b54918281520190601b8d527f3ad8aa4f87544323a9d1e5dd902f40c356527a7955687113db5f9a85ad579dc1908d5b818110613e255750505081613aac910382613086565b87820152868201528351613abf81613035565b601c54815284518088601d54918281520190601d8d527f6d4407e7be21f808e6509aa9fa9143369579dd7d760fe20a2c09680fc146134f908d5b818110613e115750505081613b0f910382613086565b8782015284820152858201528251613b2681613035565b601e54815283518087601f54918281520190601f8c527fa03837a25210ee280c2113ff4b77ca23440b19d4866cca721c801278fd08d807908c5b818110613dfd5750505081613b76910382613086565b81870152818401528385015281518454808252858952818601907fc97bfaf2f8ee708c303a06d134f5ecd8389ae0432af62dc132a24118292866bb908a5b818110613de95750505081613bca910382613086565b82840152602154868401528151808560225491828152019060228a527f61035b26e3e9eee00e0d72fd1ee8ddca6894550dca6916ea2ac6baa90d11e510908a5b818110613dd55750505081613c20910382613086565b608084015260235460a0840152815196613c398861306b565b8251602482825b60028210613dbf57505050613c5481613035565b8852825196613c6288613035565b879660269583985b600290818b1015613c91579089600192613c838b61352a565b815201980199019896613c6a565b50509398919750939891945085820152875180602a9086905b60028210613da957505050613cbe81613035565b818901528751602c85825b60028210613d9357505050613cdd81613035565b8682015260c0820152865195613cf28761306b565b80602e54168752602f548588015260305488880152875196613d138861306b565b613d1b61348f565b8852885197613d2989613035565b8897603396985b600290818b1015613d57579089600192613d498b61352a565b815201980199019896613d30565b50509398919550939891956101009750840152613d726134c4565b90830152613d7e6134f7565b8183015282015260e0840152603b5416910152565b8254815260019283019291909101908801613cc9565b8254815260019283019291909101908801613caa565b8254815260019283019291909101908801613c40565b825484529288019260019283019201613c0a565b825484529288019260019283019201613bb4565b82548452928a019260019283019201613b60565b82548452928b019260019283019201613af9565b82548452928b019260019283019201613a96565b82548452928b019260019283019201613a35565b82548452928a019260019283019201613987565b82548452928b019260019283019201613920565b82548452928b0192600192830192016138bd565b82548452928b01926001928301920161385c565b818110613ea8575050565b5f8155600101613e9d565b5f806008558060095580600a5580600b5580600c55600d5481600d55806142b7575b5080600e55600f5481600f5580614275575b50806010556011548160115580614233575b508060125560135481601355806141f1575b50806014558060155580601655806017558060185560195481601955806141af575b5080601a55601b5481601b558061416d575b5080601c55601d5481601d558061412b575b5080601e55601f5481601f55806140e9575b5060205481602055806140a7575b50806021556022548160225580614065575b508060235560245b6026811061405a575060265b602a81106140455750602a5b602c811061403a5750602c5b602e811061402f575080602e5580602f558060305560315b60338110614024575060335b6037811061400f575060375b60398110614004575060395b603b8110613ff95750603b55565b818155600101613feb565b818155600101613fdf565b8061401e600280930182613e9d565b01613fd3565b818155600101613fc7565b818155600101613faf565b818155600101613fa3565b80614054600280930182613e9d565b01613f97565b818155600101613f8b565b602282527f61035b26e3e9eee00e0d72fd1ee8ddca6894550dca6916ea2ac6baa90d11e510908101905b81811061409c5750613f83565b82815560010161408f565b602082527fc97bfaf2f8ee708c303a06d134f5ecd8389ae0432af62dc132a24118292866bb908101905b8181106140de5750613f71565b8281556001016140d1565b601f82527fa03837a25210ee280c2113ff4b77ca23440b19d4866cca721c801278fd08d807908101905b8181106141205750613f63565b828155600101614113565b601d82527f6d4407e7be21f808e6509aa9fa9143369579dd7d760fe20a2c09680fc146134f908101905b8181106141625750613f51565b828155600101614155565b601b82527f3ad8aa4f87544323a9d1e5dd902f40c356527a7955687113db5f9a85ad579dc1908101905b8181106141a45750613f3f565b828155600101614197565b601982527f944998273e477b495144fb8794c914197f3ccb46be2900f4698fd0ef743c9695908101905b8181106141e65750613f2d565b8281556001016141d9565b601382527f66de8ffda797e3de9c05e8fc57b3bf0ec28a930d40b0d285d93c06501cf6a090908101905b8181106142285750613f0b565b82815560010161421b565b601182527f31ecc21a745e3968a04e9570e4425bc18fa8019c68028196b546d1669c200c68908101905b81811061426a5750613ef9565b82815560010161425d565b600f82527f8d1108e10bcb7c27dddfc02ed9d693a074039d026cf4ea4240b40f7d581ac802908101905b8181106142ac5750613ee7565b82815560010161429f565b600d82527fd7b6990105719101dabeb77144f2a3385c8033acd3af97e9423a695e81ad1eb5908101905b8181106142ee5750613ed5565b8281556001016142e1565b9081602091031261021d5751801515810361021d5790565b9060016001600160401b03809316019182116112d457565b1561433057565b60405162461bcd60e51b815260206004820152601160248201527f62616420706f736569646f6e20726f6f740000000000000000000000000000006044820152606490fd5b6607ffffffffffff805f54600d1c169082600d1c169160065415155f1461453657818314801561451c575b156144d7576020936143ca6143c56707ffffffffffffff6143d0945b60051c16614bd3565b614c44565b90614cd9565b91036144bd576101c46005546143ea848601518214614329565b915b6001600160a01b03603e54166144426001600160401b038751169660606040820151910151906040519889978896630291ab6d60e51b885260048801526024870152604486015260648501526084840190613674565b5afa908115612a9f575f9161449f575b501561445a57565b60405162461bcd60e51b815260206004820152601160248201527f62616420626c73207369672070726f6f660000000000000000000000000000006044820152606490fd5b6144b7915060203d8111612bd657612bc88183613086565b5f614452565b6101c46007546144d1848601518214614329565b916143ec565b60405162461bcd60e51b815260206004820152601060248201527f6261642073696720706572696f642032000000000000000000000000000000006044820152606490fd5b506001600160401b0361452e83614311565b1683146143a0565b818303614558576020936143ca6143c56707ffffffffffffff6143d0946143bc565b60405162461bcd60e51b815260206004820152601060248201527f6261642073696720706572696f642031000000000000000000000000000000006044820152606490fd5b5f5b8381106145ae5750505f910152565b818101518382015260200161459f565b156145c65750565b6044604051809262461bcd60e51b8252602060048301526145f6815180928160248601526020868601910161459d565b601f01601f19168101030190fd5b9190916020908181015192604094858301608081519451015185855195015194935f945b86518610156146ae5760ff86116112d457600180871b15612ac25788915f916019891c81160361469d5761466361467591612a688a8c614d11565b838d519282848094519384920161459d565b8101039060025afa156146935761468d5f5195614d03565b94614628565b88513d5f823e3d90fd5b61466361467591612abb8a8c614d11565b9093979295506147129194508851907f626164206578656320726f6f742070726f6f66200000000000000000000000008883015288519561470c6034848b8d01996146fc818484018d61459d565b8101036014810186520184613086565b146145be565b5192515184845194015193925f935b85518510156147a75760ff85116112d457600180861b15612ac25787915f916012881c8116036147965761475c61476e91612a68898b614d11565b838c519282848094519384920161459d565b8101039060025afa1561478c576147865f5194614d03565b93614721565b87513d5f823e3d90fd5b61475c61476e91612abb898b614d11565b9450603a919350947f626164206578656320737461746520726f6f742070726f6f6620000000000000956147f06134ac9861470c959a519889948501525180928585019061459d565b810103601a810186520184613086565b602081019081515151906001600160401b0392838316926607ffffffffffff805f54600d1c1691600d1c16906006548681155f14614967575050810361492257827fdc7ba15c782b181b9d54a996db4ab8a32182bff2bfb09e4aca8ed9ea9e5380c7916148aa61488360a060606020980151948560065501519283600755614311565b91604051938493846040919493926001600160401b03606083019616825260208201520152565b0390a15b5101515151905f5492831681116148c457505050565b807f4d75bcddf849ad697dd4b9e37ec69f14240170e980101fcd9e57bb000527c24893836001556001600160401b031916175f5561491d60405192839283602090939291936001600160401b0360408201951681520152565b0390a1565b60405162461bcd60e51b815260206004820152600f60248201527f6d69736d6174636820706572696f6400000000000000000000000000000000006044820152606490fd5b61497660209693949294614311565b168114614986575b5050506148ae565b7fdc7ba15c782b181b9d54a996db4ab8a32182bff2bfb09e4aca8ed9ea9e5380c7926004556007546005556149cf61488360a06060850151948560065501519283600755614311565b0390a15f808061497e565b60e08201906001600160401b0391828151511615614b355760e08201614a038482515116614b79565b614a108584515116614b79565b15908015918015831503614b1f57505080614b0d575b614afc57614a3383614b43565b614a3c86614b43565b151581151503614af35750604083015151151560408601515115158103614af3578490614aae575b80915151169151511690818103614aa657505081815151511682845151511690818103614a9e575050816101008092015116920151161190565b109392505050565b119392505050565b50602083015151516607ffffffffffff90818086515151600d1c1691600d1c1614908060208801515151600d1c169087515151600d1c16148103614af3575083614a64565b94505050505090565b909350829150515116915151161090565b50838151511684835151161415614a26565b955095505050505081614b30575090565b905090565b5060e0015151161515919050565b60808101515115159081614b55575090565b905061010081515151916607ffffffffffff9182910151600d1c1691600d1c161490565b60036001600160401b03809216029081169081036112d457610400111590565b7f000000000000000000000000000000000000000000000000000000000000000042034281116112d457600c6001600160401b0391041690565b603d545f1992908381019081116112d4575b614bee8161371f565b906001600160401b03809154600393841b1c169085161015614c2c57508015614c18578301614be5565b60245f634e487b7160e01b81526011600452fd5b9250614c399193506136e0565b9054911b1c60e01b90565b5f614ca16020926040518481019163ffffffff60e01b1682527f0000000000000000000000000000000000000000000000000000000000000000604082015260408152614c9081613050565b60405192839283925192839161459d565b8101039060025afa15612a9f575f5160201c600760f81b1790565b91906040519260208401526040830152604082526134ac82613050565b614cf1612a6e602093614cec5f94614d25565b614cbc565b8101039060025afa15612a9f575f5190565b5f1981146112d45760010190565b80518210156133a25760209160051b010190565b6001600160401b0390614d53614d3d83835116614ed3565b614d4d6020948585015116614ed3565b90614cbc565b9180604092614d6a8451958681519485920161459d565b825f86819760029581010390855afa15614ebc5784518386614da9614d9788860151606087015190614cbc565b8389519282848094519384920161459d565b81010390865afa15614ec95785614dd8614dc68693835190614cbc565b8388519282848094519384920161459d565b81010390855afa15614ebc578285614e196080825194015187518481019182528389820152888152614e0981613050565b885192839283925192839161459d565b81010390855afa15614ebc5784518386614e56875183810190838252838a820152898152614e4681613050565b895192839283925192839161459d565b81010390865afa15614ec95785614e73614dc68693835190614cbc565b81010390855afa15614ebc5790614ea2614e908693845190614cbc565b8486519282848094519384920161459d565b810103915afa15614eb257505190565b51903d90823e3d90fd5b50505051903d90823e3d90fd5b84513d87823e3d90fd5b5f9081905b60208210614ee557505090565b600892831b60ff821617921c90614efb90614d03565b90614ed8565b15614f0857565b60405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f74207061757365720000000000000000000000006044820152606490fd5b6001600160a01b03809116915f9280845260429060209180835260409060ff82882054166003908181101561511757156150d3576043805490915f19918281019081116150bf578a5b845481101561507b57878b614faa836133b6565b905490861b1c1614614fc457614fbf90614d03565b614f96565b919293949596979899818310615056575b505050508154801561504257918493917fd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985989993019061502c615017836133b6565b6001600160a01b0382549160031b1b19169055565b55848252855220805460ff1916905551908152a1565b634e487b7160e01b89526031600452602489fd5b61507293615066611657936133b6565b9054911b1c16916133b6565b5f808080614fd5565b865162461bcd60e51b8152600481018a9052601060248201527f70726f766572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b634e487b7160e01b8b52601160045260248bfd5b825162461bcd60e51b815260048101869052601560248201527f6163636f756e74206973206e6f742070726f76657200000000000000000000006044820152606490fd5b634e487b7160e01b89526021600452602489fd5b6001600160a01b038116905f8281526040918260205260ff83832054166151c357604154600160401b8110156151af57927f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8949261519682936116578760016020990160415561336d565b83815281855220805460ff1916600117905551908152a1565b634e487b7160e01b83526041600452602483fd5b825162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152606490fd5b6001600160a01b03809116915f9280845260409060209180835260ff81872054161561536d57604180545f19808201979091881161535957885b83548110156153155781866152558361336d565b929054600393841b1c1614615273575061526e90614d03565b615241565b9293949596979890918183106152f0575b50505050815480156152dc57917fcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e969791849301906152c56150178361336d565b5583815281855220805460ff1916905551908152a1565b634e487b7160e01b88526031600452602488fd5b61530c936153006116579361336d565b9054911b1c169161336d565b5f808080615284565b845162461bcd60e51b815260048101889052601060248201527f706175736572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b634e487b7160e01b89526011600452602489fd5b5162461bcd60e51b815260048101839052601560248201527f4163636f756e74206973206e6f742070617573657200000000000000000000006044820152606490fdfea2646970667358221220cb2ddbc9ad025f7527674c91f125ba435b18fa35d272a8771ada8488959e690764736f6c63430008140033",
}

// EthereumLightClientABI is the input ABI used to generate the binding from.
// Deprecated: Use EthereumLightClientMetaData.ABI instead.
var EthereumLightClientABI = EthereumLightClientMetaData.ABI

// EthereumLightClientBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use EthereumLightClientMetaData.Bin instead.
var EthereumLightClientBin = EthereumLightClientMetaData.Bin

// DeployEthereumLightClient deploys a new Ethereum contract, binding an instance of EthereumLightClient to it.
func DeployEthereumLightClient(auth *bind.TransactOpts, backend bind.ContractBackend, genesisTime *big.Int, genesisValidatorsRoot [32]byte, _forkEpochs []uint64, _forkVersions [][4]byte, _finalizedSlot uint64, syncCommitteeRoot [32]byte, syncCommitteePoseidonRoot [32]byte, _zkVerifier common.Address) (common.Address, *types.Transaction, *EthereumLightClient, error) {
	parsed, err := EthereumLightClientMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(EthereumLightClientBin), backend, genesisTime, genesisValidatorsRoot, _forkEpochs, _forkVersions, _finalizedSlot, syncCommitteeRoot, syncCommitteePoseidonRoot, _zkVerifier)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &EthereumLightClient{EthereumLightClientCaller: EthereumLightClientCaller{contract: contract}, EthereumLightClientTransactor: EthereumLightClientTransactor{contract: contract}, EthereumLightClientFilterer: EthereumLightClientFilterer{contract: contract}}, nil
}

// EthereumLightClient is an auto generated Go binding around an Ethereum contract.
type EthereumLightClient struct {
	EthereumLightClientCaller     // Read-only binding to the contract
	EthereumLightClientTransactor // Write-only binding to the contract
	EthereumLightClientFilterer   // Log filterer for contract events
}

// EthereumLightClientCaller is an auto generated read-only Go binding around an Ethereum contract.
type EthereumLightClientCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// EthereumLightClientTransactor is an auto generated write-only Go binding around an Ethereum contract.
type EthereumLightClientTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// EthereumLightClientFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type EthereumLightClientFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// EthereumLightClientSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type EthereumLightClientSession struct {
	Contract     *EthereumLightClient // Generic contract binding to set the session for
	CallOpts     bind.CallOpts        // Call options to use throughout this session
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// EthereumLightClientCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type EthereumLightClientCallerSession struct {
	Contract *EthereumLightClientCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts              // Call options to use throughout this session
}

// EthereumLightClientTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type EthereumLightClientTransactorSession struct {
	Contract     *EthereumLightClientTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts              // Transaction auth options to use throughout this session
}

// EthereumLightClientRaw is an auto generated low-level Go binding around an Ethereum contract.
type EthereumLightClientRaw struct {
	Contract *EthereumLightClient // Generic contract binding to access the raw methods on
}

// EthereumLightClientCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type EthereumLightClientCallerRaw struct {
	Contract *EthereumLightClientCaller // Generic read-only contract binding to access the raw methods on
}

// EthereumLightClientTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type EthereumLightClientTransactorRaw struct {
	Contract *EthereumLightClientTransactor // Generic write-only contract binding to access the raw methods on
}

// NewEthereumLightClient creates a new instance of EthereumLightClient, bound to a specific deployed contract.
func NewEthereumLightClient(address common.Address, backend bind.ContractBackend) (*EthereumLightClient, error) {
	contract, err := bindEthereumLightClient(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &EthereumLightClient{EthereumLightClientCaller: EthereumLightClientCaller{contract: contract}, EthereumLightClientTransactor: EthereumLightClientTransactor{contract: contract}, EthereumLightClientFilterer: EthereumLightClientFilterer{contract: contract}}, nil
}

// NewEthereumLightClientCaller creates a new read-only instance of EthereumLightClient, bound to a specific deployed contract.
func NewEthereumLightClientCaller(address common.Address, caller bind.ContractCaller) (*EthereumLightClientCaller, error) {
	contract, err := bindEthereumLightClient(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &EthereumLightClientCaller{contract: contract}, nil
}

// NewEthereumLightClientTransactor creates a new write-only instance of EthereumLightClient, bound to a specific deployed contract.
func NewEthereumLightClientTransactor(address common.Address, transactor bind.ContractTransactor) (*EthereumLightClientTransactor, error) {
	contract, err := bindEthereumLightClient(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &EthereumLightClientTransactor{contract: contract}, nil
}

// NewEthereumLightClientFilterer creates a new log filterer instance of EthereumLightClient, bound to a specific deployed contract.
func NewEthereumLightClientFilterer(address common.Address, filterer bind.ContractFilterer) (*EthereumLightClientFilterer, error) {
	contract, err := bindEthereumLightClient(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &EthereumLightClientFilterer{contract: contract}, nil
}

// bindEthereumLightClient binds a generic wrapper to an already deployed contract.
func bindEthereumLightClient(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := EthereumLightClientMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_EthereumLightClient *EthereumLightClientRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _EthereumLightClient.Contract.EthereumLightClientCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_EthereumLightClient *EthereumLightClientRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.EthereumLightClientTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_EthereumLightClient *EthereumLightClientRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.EthereumLightClientTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_EthereumLightClient *EthereumLightClientCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _EthereumLightClient.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_EthereumLightClient *EthereumLightClientTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_EthereumLightClient *EthereumLightClientTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.contract.Transact(opts, method, params...)
}

// BestValidUpdate is a free data retrieval call binding the contract method 0xba67ee48.
//
// Solidity: function bestValidUpdate() view returns(((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])) attestedHeader, ((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])) finalizedHeader, bytes32 nextSyncCommitteeRoot, bytes32 nextSyncCommitteePoseidonRoot, (uint256[2],uint256[2][2],uint256[2],uint256[2]) nextSyncCommitteeRootMappingProof, (uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])) syncAggregate, uint64 signatureSlot)
func (_EthereumLightClient *EthereumLightClientCaller) BestValidUpdate(opts *bind.CallOpts) (struct {
	AttestedHeader                    HeaderWithExecution
	FinalizedHeader                   HeaderWithExecution
	NextSyncCommitteeRoot             [32]byte
	NextSyncCommitteePoseidonRoot     [32]byte
	NextSyncCommitteeRootMappingProof IBeaconVerifierProof
	SyncAggregate                     SyncAggregate
	SignatureSlot                     uint64
}, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "bestValidUpdate")

	outstruct := new(struct {
		AttestedHeader                    HeaderWithExecution
		FinalizedHeader                   HeaderWithExecution
		NextSyncCommitteeRoot             [32]byte
		NextSyncCommitteePoseidonRoot     [32]byte
		NextSyncCommitteeRootMappingProof IBeaconVerifierProof
		SyncAggregate                     SyncAggregate
		SignatureSlot                     uint64
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.AttestedHeader = *abi.ConvertType(out[0], new(HeaderWithExecution)).(*HeaderWithExecution)
	outstruct.FinalizedHeader = *abi.ConvertType(out[1], new(HeaderWithExecution)).(*HeaderWithExecution)
	outstruct.NextSyncCommitteeRoot = *abi.ConvertType(out[2], new([32]byte)).(*[32]byte)
	outstruct.NextSyncCommitteePoseidonRoot = *abi.ConvertType(out[3], new([32]byte)).(*[32]byte)
	outstruct.NextSyncCommitteeRootMappingProof = *abi.ConvertType(out[4], new(IBeaconVerifierProof)).(*IBeaconVerifierProof)
	outstruct.SyncAggregate = *abi.ConvertType(out[5], new(SyncAggregate)).(*SyncAggregate)
	outstruct.SignatureSlot = *abi.ConvertType(out[6], new(uint64)).(*uint64)

	return *outstruct, err

}

// BestValidUpdate is a free data retrieval call binding the contract method 0xba67ee48.
//
// Solidity: function bestValidUpdate() view returns(((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])) attestedHeader, ((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])) finalizedHeader, bytes32 nextSyncCommitteeRoot, bytes32 nextSyncCommitteePoseidonRoot, (uint256[2],uint256[2][2],uint256[2],uint256[2]) nextSyncCommitteeRootMappingProof, (uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])) syncAggregate, uint64 signatureSlot)
func (_EthereumLightClient *EthereumLightClientSession) BestValidUpdate() (struct {
	AttestedHeader                    HeaderWithExecution
	FinalizedHeader                   HeaderWithExecution
	NextSyncCommitteeRoot             [32]byte
	NextSyncCommitteePoseidonRoot     [32]byte
	NextSyncCommitteeRootMappingProof IBeaconVerifierProof
	SyncAggregate                     SyncAggregate
	SignatureSlot                     uint64
}, error) {
	return _EthereumLightClient.Contract.BestValidUpdate(&_EthereumLightClient.CallOpts)
}

// BestValidUpdate is a free data retrieval call binding the contract method 0xba67ee48.
//
// Solidity: function bestValidUpdate() view returns(((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])) attestedHeader, ((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])) finalizedHeader, bytes32 nextSyncCommitteeRoot, bytes32 nextSyncCommitteePoseidonRoot, (uint256[2],uint256[2][2],uint256[2],uint256[2]) nextSyncCommitteeRootMappingProof, (uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])) syncAggregate, uint64 signatureSlot)
func (_EthereumLightClient *EthereumLightClientCallerSession) BestValidUpdate() (struct {
	AttestedHeader                    HeaderWithExecution
	FinalizedHeader                   HeaderWithExecution
	NextSyncCommitteeRoot             [32]byte
	NextSyncCommitteePoseidonRoot     [32]byte
	NextSyncCommitteeRootMappingProof IBeaconVerifierProof
	SyncAggregate                     SyncAggregate
	SignatureSlot                     uint64
}, error) {
	return _EthereumLightClient.Contract.BestValidUpdate(&_EthereumLightClient.CallOpts)
}

// ComputeDomain is a free data retrieval call binding the contract method 0xaae3913b.
//
// Solidity: function computeDomain(bytes4 forkVersion) view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCaller) ComputeDomain(opts *bind.CallOpts, forkVersion [4]byte) ([32]byte, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "computeDomain", forkVersion)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// ComputeDomain is a free data retrieval call binding the contract method 0xaae3913b.
//
// Solidity: function computeDomain(bytes4 forkVersion) view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientSession) ComputeDomain(forkVersion [4]byte) ([32]byte, error) {
	return _EthereumLightClient.Contract.ComputeDomain(&_EthereumLightClient.CallOpts, forkVersion)
}

// ComputeDomain is a free data retrieval call binding the contract method 0xaae3913b.
//
// Solidity: function computeDomain(bytes4 forkVersion) view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCallerSession) ComputeDomain(forkVersion [4]byte) ([32]byte, error) {
	return _EthereumLightClient.Contract.ComputeDomain(&_EthereumLightClient.CallOpts, forkVersion)
}

// ComputeSigningRoot is a free data retrieval call binding the contract method 0x751f7f15.
//
// Solidity: function computeSigningRoot((uint64,uint64,bytes32,bytes32,bytes32) header, bytes32 domain) pure returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCaller) ComputeSigningRoot(opts *bind.CallOpts, header BeaconBlockHeader, domain [32]byte) ([32]byte, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "computeSigningRoot", header, domain)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// ComputeSigningRoot is a free data retrieval call binding the contract method 0x751f7f15.
//
// Solidity: function computeSigningRoot((uint64,uint64,bytes32,bytes32,bytes32) header, bytes32 domain) pure returns(bytes32)
func (_EthereumLightClient *EthereumLightClientSession) ComputeSigningRoot(header BeaconBlockHeader, domain [32]byte) ([32]byte, error) {
	return _EthereumLightClient.Contract.ComputeSigningRoot(&_EthereumLightClient.CallOpts, header, domain)
}

// ComputeSigningRoot is a free data retrieval call binding the contract method 0x751f7f15.
//
// Solidity: function computeSigningRoot((uint64,uint64,bytes32,bytes32,bytes32) header, bytes32 domain) pure returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCallerSession) ComputeSigningRoot(header BeaconBlockHeader, domain [32]byte) ([32]byte, error) {
	return _EthereumLightClient.Contract.ComputeSigningRoot(&_EthereumLightClient.CallOpts, header, domain)
}

// CurrentSyncCommitteePoseidonRoot is a free data retrieval call binding the contract method 0x65e700de.
//
// Solidity: function currentSyncCommitteePoseidonRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCaller) CurrentSyncCommitteePoseidonRoot(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "currentSyncCommitteePoseidonRoot")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// CurrentSyncCommitteePoseidonRoot is a free data retrieval call binding the contract method 0x65e700de.
//
// Solidity: function currentSyncCommitteePoseidonRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientSession) CurrentSyncCommitteePoseidonRoot() ([32]byte, error) {
	return _EthereumLightClient.Contract.CurrentSyncCommitteePoseidonRoot(&_EthereumLightClient.CallOpts)
}

// CurrentSyncCommitteePoseidonRoot is a free data retrieval call binding the contract method 0x65e700de.
//
// Solidity: function currentSyncCommitteePoseidonRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCallerSession) CurrentSyncCommitteePoseidonRoot() ([32]byte, error) {
	return _EthereumLightClient.Contract.CurrentSyncCommitteePoseidonRoot(&_EthereumLightClient.CallOpts)
}

// CurrentSyncCommitteeRoot is a free data retrieval call binding the contract method 0xa4059e07.
//
// Solidity: function currentSyncCommitteeRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCaller) CurrentSyncCommitteeRoot(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "currentSyncCommitteeRoot")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// CurrentSyncCommitteeRoot is a free data retrieval call binding the contract method 0xa4059e07.
//
// Solidity: function currentSyncCommitteeRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientSession) CurrentSyncCommitteeRoot() ([32]byte, error) {
	return _EthereumLightClient.Contract.CurrentSyncCommitteeRoot(&_EthereumLightClient.CallOpts)
}

// CurrentSyncCommitteeRoot is a free data retrieval call binding the contract method 0xa4059e07.
//
// Solidity: function currentSyncCommitteeRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCallerSession) CurrentSyncCommitteeRoot() ([32]byte, error) {
	return _EthereumLightClient.Contract.CurrentSyncCommitteeRoot(&_EthereumLightClient.CallOpts)
}

// FinalizedExecutionStateRoot is a free data retrieval call binding the contract method 0xc5190436.
//
// Solidity: function finalizedExecutionStateRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCaller) FinalizedExecutionStateRoot(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "finalizedExecutionStateRoot")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// FinalizedExecutionStateRoot is a free data retrieval call binding the contract method 0xc5190436.
//
// Solidity: function finalizedExecutionStateRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientSession) FinalizedExecutionStateRoot() ([32]byte, error) {
	return _EthereumLightClient.Contract.FinalizedExecutionStateRoot(&_EthereumLightClient.CallOpts)
}

// FinalizedExecutionStateRoot is a free data retrieval call binding the contract method 0xc5190436.
//
// Solidity: function finalizedExecutionStateRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCallerSession) FinalizedExecutionStateRoot() ([32]byte, error) {
	return _EthereumLightClient.Contract.FinalizedExecutionStateRoot(&_EthereumLightClient.CallOpts)
}

// FinalizedExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x12420766.
//
// Solidity: function finalizedExecutionStateRootAndSlot() view returns(bytes32 root, uint64 slot)
func (_EthereumLightClient *EthereumLightClientCaller) FinalizedExecutionStateRootAndSlot(opts *bind.CallOpts) (struct {
	Root [32]byte
	Slot uint64
}, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "finalizedExecutionStateRootAndSlot")

	outstruct := new(struct {
		Root [32]byte
		Slot uint64
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Root = *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)
	outstruct.Slot = *abi.ConvertType(out[1], new(uint64)).(*uint64)

	return *outstruct, err

}

// FinalizedExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x12420766.
//
// Solidity: function finalizedExecutionStateRootAndSlot() view returns(bytes32 root, uint64 slot)
func (_EthereumLightClient *EthereumLightClientSession) FinalizedExecutionStateRootAndSlot() (struct {
	Root [32]byte
	Slot uint64
}, error) {
	return _EthereumLightClient.Contract.FinalizedExecutionStateRootAndSlot(&_EthereumLightClient.CallOpts)
}

// FinalizedExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x12420766.
//
// Solidity: function finalizedExecutionStateRootAndSlot() view returns(bytes32 root, uint64 slot)
func (_EthereumLightClient *EthereumLightClientCallerSession) FinalizedExecutionStateRootAndSlot() (struct {
	Root [32]byte
	Slot uint64
}, error) {
	return _EthereumLightClient.Contract.FinalizedExecutionStateRootAndSlot(&_EthereumLightClient.CallOpts)
}

// FinalizedSlot is a free data retrieval call binding the contract method 0xd1802369.
//
// Solidity: function finalizedSlot() view returns(uint64)
func (_EthereumLightClient *EthereumLightClientCaller) FinalizedSlot(opts *bind.CallOpts) (uint64, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "finalizedSlot")

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// FinalizedSlot is a free data retrieval call binding the contract method 0xd1802369.
//
// Solidity: function finalizedSlot() view returns(uint64)
func (_EthereumLightClient *EthereumLightClientSession) FinalizedSlot() (uint64, error) {
	return _EthereumLightClient.Contract.FinalizedSlot(&_EthereumLightClient.CallOpts)
}

// FinalizedSlot is a free data retrieval call binding the contract method 0xd1802369.
//
// Solidity: function finalizedSlot() view returns(uint64)
func (_EthereumLightClient *EthereumLightClientCallerSession) FinalizedSlot() (uint64, error) {
	return _EthereumLightClient.Contract.FinalizedSlot(&_EthereumLightClient.CallOpts)
}

// ForkEpochs is a free data retrieval call binding the contract method 0xbcbaf770.
//
// Solidity: function forkEpochs(uint256 ) view returns(uint64)
func (_EthereumLightClient *EthereumLightClientCaller) ForkEpochs(opts *bind.CallOpts, arg0 *big.Int) (uint64, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "forkEpochs", arg0)

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// ForkEpochs is a free data retrieval call binding the contract method 0xbcbaf770.
//
// Solidity: function forkEpochs(uint256 ) view returns(uint64)
func (_EthereumLightClient *EthereumLightClientSession) ForkEpochs(arg0 *big.Int) (uint64, error) {
	return _EthereumLightClient.Contract.ForkEpochs(&_EthereumLightClient.CallOpts, arg0)
}

// ForkEpochs is a free data retrieval call binding the contract method 0xbcbaf770.
//
// Solidity: function forkEpochs(uint256 ) view returns(uint64)
func (_EthereumLightClient *EthereumLightClientCallerSession) ForkEpochs(arg0 *big.Int) (uint64, error) {
	return _EthereumLightClient.Contract.ForkEpochs(&_EthereumLightClient.CallOpts, arg0)
}

// ForkVersions is a free data retrieval call binding the contract method 0xbaa94ea2.
//
// Solidity: function forkVersions(uint256 ) view returns(bytes4)
func (_EthereumLightClient *EthereumLightClientCaller) ForkVersions(opts *bind.CallOpts, arg0 *big.Int) ([4]byte, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "forkVersions", arg0)

	if err != nil {
		return *new([4]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([4]byte)).(*[4]byte)

	return out0, err

}

// ForkVersions is a free data retrieval call binding the contract method 0xbaa94ea2.
//
// Solidity: function forkVersions(uint256 ) view returns(bytes4)
func (_EthereumLightClient *EthereumLightClientSession) ForkVersions(arg0 *big.Int) ([4]byte, error) {
	return _EthereumLightClient.Contract.ForkVersions(&_EthereumLightClient.CallOpts, arg0)
}

// ForkVersions is a free data retrieval call binding the contract method 0xbaa94ea2.
//
// Solidity: function forkVersions(uint256 ) view returns(bytes4)
func (_EthereumLightClient *EthereumLightClientCallerSession) ForkVersions(arg0 *big.Int) ([4]byte, error) {
	return _EthereumLightClient.Contract.ForkVersions(&_EthereumLightClient.CallOpts, arg0)
}

// IsActiveProver is a free data retrieval call binding the contract method 0xec64842e.
//
// Solidity: function isActiveProver(address _account) view returns(bool)
func (_EthereumLightClient *EthereumLightClientCaller) IsActiveProver(opts *bind.CallOpts, _account common.Address) (bool, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "isActiveProver", _account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsActiveProver is a free data retrieval call binding the contract method 0xec64842e.
//
// Solidity: function isActiveProver(address _account) view returns(bool)
func (_EthereumLightClient *EthereumLightClientSession) IsActiveProver(_account common.Address) (bool, error) {
	return _EthereumLightClient.Contract.IsActiveProver(&_EthereumLightClient.CallOpts, _account)
}

// IsActiveProver is a free data retrieval call binding the contract method 0xec64842e.
//
// Solidity: function isActiveProver(address _account) view returns(bool)
func (_EthereumLightClient *EthereumLightClientCallerSession) IsActiveProver(_account common.Address) (bool, error) {
	return _EthereumLightClient.Contract.IsActiveProver(&_EthereumLightClient.CallOpts, _account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_EthereumLightClient *EthereumLightClientCaller) IsPauser(opts *bind.CallOpts, account common.Address) (bool, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "isPauser", account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_EthereumLightClient *EthereumLightClientSession) IsPauser(account common.Address) (bool, error) {
	return _EthereumLightClient.Contract.IsPauser(&_EthereumLightClient.CallOpts, account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_EthereumLightClient *EthereumLightClientCallerSession) IsPauser(account common.Address) (bool, error) {
	return _EthereumLightClient.Contract.IsPauser(&_EthereumLightClient.CallOpts, account)
}

// LatestFinalizedSlotAndCommitteeRoots is a free data retrieval call binding the contract method 0xe153d799.
//
// Solidity: function latestFinalizedSlotAndCommitteeRoots() view returns(uint64 slot, bytes32 currentRoot, bytes32 nextRoot)
func (_EthereumLightClient *EthereumLightClientCaller) LatestFinalizedSlotAndCommitteeRoots(opts *bind.CallOpts) (struct {
	Slot        uint64
	CurrentRoot [32]byte
	NextRoot    [32]byte
}, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "latestFinalizedSlotAndCommitteeRoots")

	outstruct := new(struct {
		Slot        uint64
		CurrentRoot [32]byte
		NextRoot    [32]byte
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Slot = *abi.ConvertType(out[0], new(uint64)).(*uint64)
	outstruct.CurrentRoot = *abi.ConvertType(out[1], new([32]byte)).(*[32]byte)
	outstruct.NextRoot = *abi.ConvertType(out[2], new([32]byte)).(*[32]byte)

	return *outstruct, err

}

// LatestFinalizedSlotAndCommitteeRoots is a free data retrieval call binding the contract method 0xe153d799.
//
// Solidity: function latestFinalizedSlotAndCommitteeRoots() view returns(uint64 slot, bytes32 currentRoot, bytes32 nextRoot)
func (_EthereumLightClient *EthereumLightClientSession) LatestFinalizedSlotAndCommitteeRoots() (struct {
	Slot        uint64
	CurrentRoot [32]byte
	NextRoot    [32]byte
}, error) {
	return _EthereumLightClient.Contract.LatestFinalizedSlotAndCommitteeRoots(&_EthereumLightClient.CallOpts)
}

// LatestFinalizedSlotAndCommitteeRoots is a free data retrieval call binding the contract method 0xe153d799.
//
// Solidity: function latestFinalizedSlotAndCommitteeRoots() view returns(uint64 slot, bytes32 currentRoot, bytes32 nextRoot)
func (_EthereumLightClient *EthereumLightClientCallerSession) LatestFinalizedSlotAndCommitteeRoots() (struct {
	Slot        uint64
	CurrentRoot [32]byte
	NextRoot    [32]byte
}, error) {
	return _EthereumLightClient.Contract.LatestFinalizedSlotAndCommitteeRoots(&_EthereumLightClient.CallOpts)
}

// NextSyncCommitteePoseidonRoot is a free data retrieval call binding the contract method 0xe1861b08.
//
// Solidity: function nextSyncCommitteePoseidonRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCaller) NextSyncCommitteePoseidonRoot(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "nextSyncCommitteePoseidonRoot")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// NextSyncCommitteePoseidonRoot is a free data retrieval call binding the contract method 0xe1861b08.
//
// Solidity: function nextSyncCommitteePoseidonRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientSession) NextSyncCommitteePoseidonRoot() ([32]byte, error) {
	return _EthereumLightClient.Contract.NextSyncCommitteePoseidonRoot(&_EthereumLightClient.CallOpts)
}

// NextSyncCommitteePoseidonRoot is a free data retrieval call binding the contract method 0xe1861b08.
//
// Solidity: function nextSyncCommitteePoseidonRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCallerSession) NextSyncCommitteePoseidonRoot() ([32]byte, error) {
	return _EthereumLightClient.Contract.NextSyncCommitteePoseidonRoot(&_EthereumLightClient.CallOpts)
}

// NextSyncCommitteeRoot is a free data retrieval call binding the contract method 0x67b49cc7.
//
// Solidity: function nextSyncCommitteeRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCaller) NextSyncCommitteeRoot(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "nextSyncCommitteeRoot")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// NextSyncCommitteeRoot is a free data retrieval call binding the contract method 0x67b49cc7.
//
// Solidity: function nextSyncCommitteeRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientSession) NextSyncCommitteeRoot() ([32]byte, error) {
	return _EthereumLightClient.Contract.NextSyncCommitteeRoot(&_EthereumLightClient.CallOpts)
}

// NextSyncCommitteeRoot is a free data retrieval call binding the contract method 0x67b49cc7.
//
// Solidity: function nextSyncCommitteeRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCallerSession) NextSyncCommitteeRoot() ([32]byte, error) {
	return _EthereumLightClient.Contract.NextSyncCommitteeRoot(&_EthereumLightClient.CallOpts)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_EthereumLightClient *EthereumLightClientCaller) NumPausers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "numPausers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_EthereumLightClient *EthereumLightClientSession) NumPausers() (*big.Int, error) {
	return _EthereumLightClient.Contract.NumPausers(&_EthereumLightClient.CallOpts)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_EthereumLightClient *EthereumLightClientCallerSession) NumPausers() (*big.Int, error) {
	return _EthereumLightClient.Contract.NumPausers(&_EthereumLightClient.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_EthereumLightClient *EthereumLightClientCaller) NumProvers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "numProvers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_EthereumLightClient *EthereumLightClientSession) NumProvers() (*big.Int, error) {
	return _EthereumLightClient.Contract.NumProvers(&_EthereumLightClient.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_EthereumLightClient *EthereumLightClientCallerSession) NumProvers() (*big.Int, error) {
	return _EthereumLightClient.Contract.NumProvers(&_EthereumLightClient.CallOpts)
}

// OptimisticExecutionStateRoot is a free data retrieval call binding the contract method 0x39536c8f.
//
// Solidity: function optimisticExecutionStateRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCaller) OptimisticExecutionStateRoot(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "optimisticExecutionStateRoot")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// OptimisticExecutionStateRoot is a free data retrieval call binding the contract method 0x39536c8f.
//
// Solidity: function optimisticExecutionStateRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientSession) OptimisticExecutionStateRoot() ([32]byte, error) {
	return _EthereumLightClient.Contract.OptimisticExecutionStateRoot(&_EthereumLightClient.CallOpts)
}

// OptimisticExecutionStateRoot is a free data retrieval call binding the contract method 0x39536c8f.
//
// Solidity: function optimisticExecutionStateRoot() view returns(bytes32)
func (_EthereumLightClient *EthereumLightClientCallerSession) OptimisticExecutionStateRoot() ([32]byte, error) {
	return _EthereumLightClient.Contract.OptimisticExecutionStateRoot(&_EthereumLightClient.CallOpts)
}

// OptimisticExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x43a6c5a6.
//
// Solidity: function optimisticExecutionStateRootAndSlot() view returns(bytes32 root, uint64 slot)
func (_EthereumLightClient *EthereumLightClientCaller) OptimisticExecutionStateRootAndSlot(opts *bind.CallOpts) (struct {
	Root [32]byte
	Slot uint64
}, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "optimisticExecutionStateRootAndSlot")

	outstruct := new(struct {
		Root [32]byte
		Slot uint64
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Root = *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)
	outstruct.Slot = *abi.ConvertType(out[1], new(uint64)).(*uint64)

	return *outstruct, err

}

// OptimisticExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x43a6c5a6.
//
// Solidity: function optimisticExecutionStateRootAndSlot() view returns(bytes32 root, uint64 slot)
func (_EthereumLightClient *EthereumLightClientSession) OptimisticExecutionStateRootAndSlot() (struct {
	Root [32]byte
	Slot uint64
}, error) {
	return _EthereumLightClient.Contract.OptimisticExecutionStateRootAndSlot(&_EthereumLightClient.CallOpts)
}

// OptimisticExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x43a6c5a6.
//
// Solidity: function optimisticExecutionStateRootAndSlot() view returns(bytes32 root, uint64 slot)
func (_EthereumLightClient *EthereumLightClientCallerSession) OptimisticExecutionStateRootAndSlot() (struct {
	Root [32]byte
	Slot uint64
}, error) {
	return _EthereumLightClient.Contract.OptimisticExecutionStateRootAndSlot(&_EthereumLightClient.CallOpts)
}

// OptimisticSlot is a free data retrieval call binding the contract method 0x3cf5ea9e.
//
// Solidity: function optimisticSlot() view returns(uint64)
func (_EthereumLightClient *EthereumLightClientCaller) OptimisticSlot(opts *bind.CallOpts) (uint64, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "optimisticSlot")

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// OptimisticSlot is a free data retrieval call binding the contract method 0x3cf5ea9e.
//
// Solidity: function optimisticSlot() view returns(uint64)
func (_EthereumLightClient *EthereumLightClientSession) OptimisticSlot() (uint64, error) {
	return _EthereumLightClient.Contract.OptimisticSlot(&_EthereumLightClient.CallOpts)
}

// OptimisticSlot is a free data retrieval call binding the contract method 0x3cf5ea9e.
//
// Solidity: function optimisticSlot() view returns(uint64)
func (_EthereumLightClient *EthereumLightClientCallerSession) OptimisticSlot() (uint64, error) {
	return _EthereumLightClient.Contract.OptimisticSlot(&_EthereumLightClient.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_EthereumLightClient *EthereumLightClientCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_EthereumLightClient *EthereumLightClientSession) Owner() (common.Address, error) {
	return _EthereumLightClient.Contract.Owner(&_EthereumLightClient.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_EthereumLightClient *EthereumLightClientCallerSession) Owner() (common.Address, error) {
	return _EthereumLightClient.Contract.Owner(&_EthereumLightClient.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_EthereumLightClient *EthereumLightClientCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_EthereumLightClient *EthereumLightClientSession) Paused() (bool, error) {
	return _EthereumLightClient.Contract.Paused(&_EthereumLightClient.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_EthereumLightClient *EthereumLightClientCallerSession) Paused() (bool, error) {
	return _EthereumLightClient.Contract.Paused(&_EthereumLightClient.CallOpts)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_EthereumLightClient *EthereumLightClientCaller) PauserList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "pauserList", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_EthereumLightClient *EthereumLightClientSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _EthereumLightClient.Contract.PauserList(&_EthereumLightClient.CallOpts, arg0)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_EthereumLightClient *EthereumLightClientCallerSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _EthereumLightClient.Contract.PauserList(&_EthereumLightClient.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_EthereumLightClient *EthereumLightClientCaller) Pausers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "pausers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_EthereumLightClient *EthereumLightClientSession) Pausers(arg0 common.Address) (bool, error) {
	return _EthereumLightClient.Contract.Pausers(&_EthereumLightClient.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_EthereumLightClient *EthereumLightClientCallerSession) Pausers(arg0 common.Address) (bool, error) {
	return _EthereumLightClient.Contract.Pausers(&_EthereumLightClient.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_EthereumLightClient *EthereumLightClientCaller) ProverStates(opts *bind.CallOpts, arg0 common.Address) (uint8, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "proverStates", arg0)

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_EthereumLightClient *EthereumLightClientSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _EthereumLightClient.Contract.ProverStates(&_EthereumLightClient.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_EthereumLightClient *EthereumLightClientCallerSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _EthereumLightClient.Contract.ProverStates(&_EthereumLightClient.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_EthereumLightClient *EthereumLightClientCaller) Provers(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "provers", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_EthereumLightClient *EthereumLightClientSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _EthereumLightClient.Contract.Provers(&_EthereumLightClient.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_EthereumLightClient *EthereumLightClientCallerSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _EthereumLightClient.Contract.Provers(&_EthereumLightClient.CallOpts, arg0)
}

// VerifyCommitteeSignature is a free data retrieval call binding the contract method 0x3dd3f4aa.
//
// Solidity: function verifyCommitteeSignature(uint64 signatureSlot, (uint64,uint64,bytes32,bytes32,bytes32) header, (uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])) syncAggregate) view returns()
func (_EthereumLightClient *EthereumLightClientCaller) VerifyCommitteeSignature(opts *bind.CallOpts, signatureSlot uint64, header BeaconBlockHeader, syncAggregate SyncAggregate) error {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "verifyCommitteeSignature", signatureSlot, header, syncAggregate)

	if err != nil {
		return err
	}

	return err

}

// VerifyCommitteeSignature is a free data retrieval call binding the contract method 0x3dd3f4aa.
//
// Solidity: function verifyCommitteeSignature(uint64 signatureSlot, (uint64,uint64,bytes32,bytes32,bytes32) header, (uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])) syncAggregate) view returns()
func (_EthereumLightClient *EthereumLightClientSession) VerifyCommitteeSignature(signatureSlot uint64, header BeaconBlockHeader, syncAggregate SyncAggregate) error {
	return _EthereumLightClient.Contract.VerifyCommitteeSignature(&_EthereumLightClient.CallOpts, signatureSlot, header, syncAggregate)
}

// VerifyCommitteeSignature is a free data retrieval call binding the contract method 0x3dd3f4aa.
//
// Solidity: function verifyCommitteeSignature(uint64 signatureSlot, (uint64,uint64,bytes32,bytes32,bytes32) header, (uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])) syncAggregate) view returns()
func (_EthereumLightClient *EthereumLightClientCallerSession) VerifyCommitteeSignature(signatureSlot uint64, header BeaconBlockHeader, syncAggregate SyncAggregate) error {
	return _EthereumLightClient.Contract.VerifyCommitteeSignature(&_EthereumLightClient.CallOpts, signatureSlot, header, syncAggregate)
}

// ZkVerifier is a free data retrieval call binding the contract method 0xd6df096d.
//
// Solidity: function zkVerifier() view returns(address)
func (_EthereumLightClient *EthereumLightClientCaller) ZkVerifier(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _EthereumLightClient.contract.Call(opts, &out, "zkVerifier")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// ZkVerifier is a free data retrieval call binding the contract method 0xd6df096d.
//
// Solidity: function zkVerifier() view returns(address)
func (_EthereumLightClient *EthereumLightClientSession) ZkVerifier() (common.Address, error) {
	return _EthereumLightClient.Contract.ZkVerifier(&_EthereumLightClient.CallOpts)
}

// ZkVerifier is a free data retrieval call binding the contract method 0xd6df096d.
//
// Solidity: function zkVerifier() view returns(address)
func (_EthereumLightClient *EthereumLightClientCallerSession) ZkVerifier() (common.Address, error) {
	return _EthereumLightClient.Contract.ZkVerifier(&_EthereumLightClient.CallOpts)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_EthereumLightClient *EthereumLightClientTransactor) AddPauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.contract.Transact(opts, "addPauser", account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_EthereumLightClient *EthereumLightClientSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.AddPauser(&_EthereumLightClient.TransactOpts, account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_EthereumLightClient *EthereumLightClientTransactorSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.AddPauser(&_EthereumLightClient.TransactOpts, account)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_EthereumLightClient *EthereumLightClientTransactor) AddPausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.contract.Transact(opts, "addPausers", accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_EthereumLightClient *EthereumLightClientSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.AddPausers(&_EthereumLightClient.TransactOpts, accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_EthereumLightClient *EthereumLightClientTransactorSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.AddPausers(&_EthereumLightClient.TransactOpts, accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_EthereumLightClient *EthereumLightClientTransactor) AddProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.contract.Transact(opts, "addProvers", _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_EthereumLightClient *EthereumLightClientSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.AddProvers(&_EthereumLightClient.TransactOpts, _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_EthereumLightClient *EthereumLightClientTransactorSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.AddProvers(&_EthereumLightClient.TransactOpts, _accounts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_EthereumLightClient *EthereumLightClientTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _EthereumLightClient.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_EthereumLightClient *EthereumLightClientSession) Pause() (*types.Transaction, error) {
	return _EthereumLightClient.Contract.Pause(&_EthereumLightClient.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_EthereumLightClient *EthereumLightClientTransactorSession) Pause() (*types.Transaction, error) {
	return _EthereumLightClient.Contract.Pause(&_EthereumLightClient.TransactOpts)
}

// ProcessLightClientForceUpdate is a paid mutator transaction binding the contract method 0xa1a9ad55.
//
// Solidity: function processLightClientForceUpdate() returns()
func (_EthereumLightClient *EthereumLightClientTransactor) ProcessLightClientForceUpdate(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _EthereumLightClient.contract.Transact(opts, "processLightClientForceUpdate")
}

// ProcessLightClientForceUpdate is a paid mutator transaction binding the contract method 0xa1a9ad55.
//
// Solidity: function processLightClientForceUpdate() returns()
func (_EthereumLightClient *EthereumLightClientSession) ProcessLightClientForceUpdate() (*types.Transaction, error) {
	return _EthereumLightClient.Contract.ProcessLightClientForceUpdate(&_EthereumLightClient.TransactOpts)
}

// ProcessLightClientForceUpdate is a paid mutator transaction binding the contract method 0xa1a9ad55.
//
// Solidity: function processLightClientForceUpdate() returns()
func (_EthereumLightClient *EthereumLightClientTransactorSession) ProcessLightClientForceUpdate() (*types.Transaction, error) {
	return _EthereumLightClient.Contract.ProcessLightClientForceUpdate(&_EthereumLightClient.TransactOpts)
}

// ProcessLightClientUpdate is a paid mutator transaction binding the contract method 0x031523dd.
//
// Solidity: function processLightClientUpdate((((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])),((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])),bytes32[],bytes32,bytes32[],bytes32,(uint256[2],uint256[2][2],uint256[2],uint256[2]),(uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])),uint64) update) returns()
func (_EthereumLightClient *EthereumLightClientTransactor) ProcessLightClientUpdate(opts *bind.TransactOpts, update LightClientUpdate) (*types.Transaction, error) {
	return _EthereumLightClient.contract.Transact(opts, "processLightClientUpdate", update)
}

// ProcessLightClientUpdate is a paid mutator transaction binding the contract method 0x031523dd.
//
// Solidity: function processLightClientUpdate((((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])),((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])),bytes32[],bytes32,bytes32[],bytes32,(uint256[2],uint256[2][2],uint256[2],uint256[2]),(uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])),uint64) update) returns()
func (_EthereumLightClient *EthereumLightClientSession) ProcessLightClientUpdate(update LightClientUpdate) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.ProcessLightClientUpdate(&_EthereumLightClient.TransactOpts, update)
}

// ProcessLightClientUpdate is a paid mutator transaction binding the contract method 0x031523dd.
//
// Solidity: function processLightClientUpdate((((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])),((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])),bytes32[],bytes32,bytes32[],bytes32,(uint256[2],uint256[2][2],uint256[2],uint256[2]),(uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])),uint64) update) returns()
func (_EthereumLightClient *EthereumLightClientTransactorSession) ProcessLightClientUpdate(update LightClientUpdate) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.ProcessLightClientUpdate(&_EthereumLightClient.TransactOpts, update)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_EthereumLightClient *EthereumLightClientTransactor) RemovePauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.contract.Transact(opts, "removePauser", account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_EthereumLightClient *EthereumLightClientSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.RemovePauser(&_EthereumLightClient.TransactOpts, account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_EthereumLightClient *EthereumLightClientTransactorSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.RemovePauser(&_EthereumLightClient.TransactOpts, account)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_EthereumLightClient *EthereumLightClientTransactor) RemovePausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.contract.Transact(opts, "removePausers", accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_EthereumLightClient *EthereumLightClientSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.RemovePausers(&_EthereumLightClient.TransactOpts, accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_EthereumLightClient *EthereumLightClientTransactorSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.RemovePausers(&_EthereumLightClient.TransactOpts, accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_EthereumLightClient *EthereumLightClientTransactor) RemoveProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.contract.Transact(opts, "removeProvers", _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_EthereumLightClient *EthereumLightClientSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.RemoveProvers(&_EthereumLightClient.TransactOpts, _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_EthereumLightClient *EthereumLightClientTransactorSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.RemoveProvers(&_EthereumLightClient.TransactOpts, _accounts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_EthereumLightClient *EthereumLightClientTransactor) RenouncePauser(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _EthereumLightClient.contract.Transact(opts, "renouncePauser")
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_EthereumLightClient *EthereumLightClientSession) RenouncePauser() (*types.Transaction, error) {
	return _EthereumLightClient.Contract.RenouncePauser(&_EthereumLightClient.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_EthereumLightClient *EthereumLightClientTransactorSession) RenouncePauser() (*types.Transaction, error) {
	return _EthereumLightClient.Contract.RenouncePauser(&_EthereumLightClient.TransactOpts)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_EthereumLightClient *EthereumLightClientTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_EthereumLightClient *EthereumLightClientSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.TransferOwnership(&_EthereumLightClient.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_EthereumLightClient *EthereumLightClientTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.TransferOwnership(&_EthereumLightClient.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_EthereumLightClient *EthereumLightClientTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _EthereumLightClient.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_EthereumLightClient *EthereumLightClientSession) Unpause() (*types.Transaction, error) {
	return _EthereumLightClient.Contract.Unpause(&_EthereumLightClient.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_EthereumLightClient *EthereumLightClientTransactorSession) Unpause() (*types.Transaction, error) {
	return _EthereumLightClient.Contract.Unpause(&_EthereumLightClient.TransactOpts)
}

// UpdateForkVersion is a paid mutator transaction binding the contract method 0xab556e9f.
//
// Solidity: function updateForkVersion(uint64 epoch, bytes4 forkVersion) returns()
func (_EthereumLightClient *EthereumLightClientTransactor) UpdateForkVersion(opts *bind.TransactOpts, epoch uint64, forkVersion [4]byte) (*types.Transaction, error) {
	return _EthereumLightClient.contract.Transact(opts, "updateForkVersion", epoch, forkVersion)
}

// UpdateForkVersion is a paid mutator transaction binding the contract method 0xab556e9f.
//
// Solidity: function updateForkVersion(uint64 epoch, bytes4 forkVersion) returns()
func (_EthereumLightClient *EthereumLightClientSession) UpdateForkVersion(epoch uint64, forkVersion [4]byte) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.UpdateForkVersion(&_EthereumLightClient.TransactOpts, epoch, forkVersion)
}

// UpdateForkVersion is a paid mutator transaction binding the contract method 0xab556e9f.
//
// Solidity: function updateForkVersion(uint64 epoch, bytes4 forkVersion) returns()
func (_EthereumLightClient *EthereumLightClientTransactorSession) UpdateForkVersion(epoch uint64, forkVersion [4]byte) (*types.Transaction, error) {
	return _EthereumLightClient.Contract.UpdateForkVersion(&_EthereumLightClient.TransactOpts, epoch, forkVersion)
}

// EthereumLightClientFinalityUpdateIterator is returned from FilterFinalityUpdate and is used to iterate over the raw logs and unpacked data for FinalityUpdate events raised by the EthereumLightClient contract.
type EthereumLightClientFinalityUpdateIterator struct {
	Event *EthereumLightClientFinalityUpdate // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EthereumLightClientFinalityUpdateIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EthereumLightClientFinalityUpdate)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EthereumLightClientFinalityUpdate)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EthereumLightClientFinalityUpdateIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EthereumLightClientFinalityUpdateIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EthereumLightClientFinalityUpdate represents a FinalityUpdate event raised by the EthereumLightClient contract.
type EthereumLightClientFinalityUpdate struct {
	Slot               *big.Int
	ExecutionStateRoot [32]byte
	Raw                types.Log // Blockchain specific contextual infos
}

// FilterFinalityUpdate is a free log retrieval operation binding the contract event 0x4d75bcddf849ad697dd4b9e37ec69f14240170e980101fcd9e57bb000527c248.
//
// Solidity: event FinalityUpdate(uint256 slot, bytes32 executionStateRoot)
func (_EthereumLightClient *EthereumLightClientFilterer) FilterFinalityUpdate(opts *bind.FilterOpts) (*EthereumLightClientFinalityUpdateIterator, error) {

	logs, sub, err := _EthereumLightClient.contract.FilterLogs(opts, "FinalityUpdate")
	if err != nil {
		return nil, err
	}
	return &EthereumLightClientFinalityUpdateIterator{contract: _EthereumLightClient.contract, event: "FinalityUpdate", logs: logs, sub: sub}, nil
}

// WatchFinalityUpdate is a free log subscription operation binding the contract event 0x4d75bcddf849ad697dd4b9e37ec69f14240170e980101fcd9e57bb000527c248.
//
// Solidity: event FinalityUpdate(uint256 slot, bytes32 executionStateRoot)
func (_EthereumLightClient *EthereumLightClientFilterer) WatchFinalityUpdate(opts *bind.WatchOpts, sink chan<- *EthereumLightClientFinalityUpdate) (event.Subscription, error) {

	logs, sub, err := _EthereumLightClient.contract.WatchLogs(opts, "FinalityUpdate")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EthereumLightClientFinalityUpdate)
				if err := _EthereumLightClient.contract.UnpackLog(event, "FinalityUpdate", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFinalityUpdate is a log parse operation binding the contract event 0x4d75bcddf849ad697dd4b9e37ec69f14240170e980101fcd9e57bb000527c248.
//
// Solidity: event FinalityUpdate(uint256 slot, bytes32 executionStateRoot)
func (_EthereumLightClient *EthereumLightClientFilterer) ParseFinalityUpdate(log types.Log) (*EthereumLightClientFinalityUpdate, error) {
	event := new(EthereumLightClientFinalityUpdate)
	if err := _EthereumLightClient.contract.UnpackLog(event, "FinalityUpdate", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EthereumLightClientForkVersionUpdatedIterator is returned from FilterForkVersionUpdated and is used to iterate over the raw logs and unpacked data for ForkVersionUpdated events raised by the EthereumLightClient contract.
type EthereumLightClientForkVersionUpdatedIterator struct {
	Event *EthereumLightClientForkVersionUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EthereumLightClientForkVersionUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EthereumLightClientForkVersionUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EthereumLightClientForkVersionUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EthereumLightClientForkVersionUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EthereumLightClientForkVersionUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EthereumLightClientForkVersionUpdated represents a ForkVersionUpdated event raised by the EthereumLightClient contract.
type EthereumLightClientForkVersionUpdated struct {
	Epoch       uint64
	ForkVersion [4]byte
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterForkVersionUpdated is a free log retrieval operation binding the contract event 0x3d992c45d9456d8ebe181b6a66a3721421393afaa297791373e7569c1abcc8af.
//
// Solidity: event ForkVersionUpdated(uint64 epoch, bytes4 forkVersion)
func (_EthereumLightClient *EthereumLightClientFilterer) FilterForkVersionUpdated(opts *bind.FilterOpts) (*EthereumLightClientForkVersionUpdatedIterator, error) {

	logs, sub, err := _EthereumLightClient.contract.FilterLogs(opts, "ForkVersionUpdated")
	if err != nil {
		return nil, err
	}
	return &EthereumLightClientForkVersionUpdatedIterator{contract: _EthereumLightClient.contract, event: "ForkVersionUpdated", logs: logs, sub: sub}, nil
}

// WatchForkVersionUpdated is a free log subscription operation binding the contract event 0x3d992c45d9456d8ebe181b6a66a3721421393afaa297791373e7569c1abcc8af.
//
// Solidity: event ForkVersionUpdated(uint64 epoch, bytes4 forkVersion)
func (_EthereumLightClient *EthereumLightClientFilterer) WatchForkVersionUpdated(opts *bind.WatchOpts, sink chan<- *EthereumLightClientForkVersionUpdated) (event.Subscription, error) {

	logs, sub, err := _EthereumLightClient.contract.WatchLogs(opts, "ForkVersionUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EthereumLightClientForkVersionUpdated)
				if err := _EthereumLightClient.contract.UnpackLog(event, "ForkVersionUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseForkVersionUpdated is a log parse operation binding the contract event 0x3d992c45d9456d8ebe181b6a66a3721421393afaa297791373e7569c1abcc8af.
//
// Solidity: event ForkVersionUpdated(uint64 epoch, bytes4 forkVersion)
func (_EthereumLightClient *EthereumLightClientFilterer) ParseForkVersionUpdated(log types.Log) (*EthereumLightClientForkVersionUpdated, error) {
	event := new(EthereumLightClientForkVersionUpdated)
	if err := _EthereumLightClient.contract.UnpackLog(event, "ForkVersionUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EthereumLightClientOptimisticUpdateIterator is returned from FilterOptimisticUpdate and is used to iterate over the raw logs and unpacked data for OptimisticUpdate events raised by the EthereumLightClient contract.
type EthereumLightClientOptimisticUpdateIterator struct {
	Event *EthereumLightClientOptimisticUpdate // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EthereumLightClientOptimisticUpdateIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EthereumLightClientOptimisticUpdate)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EthereumLightClientOptimisticUpdate)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EthereumLightClientOptimisticUpdateIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EthereumLightClientOptimisticUpdateIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EthereumLightClientOptimisticUpdate represents a OptimisticUpdate event raised by the EthereumLightClient contract.
type EthereumLightClientOptimisticUpdate struct {
	Slot               *big.Int
	ExecutionStateRoot [32]byte
	Raw                types.Log // Blockchain specific contextual infos
}

// FilterOptimisticUpdate is a free log retrieval operation binding the contract event 0x27eafee2f5b2c935fa7666d231360699c41fe21db57034136b1af3c43f13df89.
//
// Solidity: event OptimisticUpdate(uint256 slot, bytes32 executionStateRoot)
func (_EthereumLightClient *EthereumLightClientFilterer) FilterOptimisticUpdate(opts *bind.FilterOpts) (*EthereumLightClientOptimisticUpdateIterator, error) {

	logs, sub, err := _EthereumLightClient.contract.FilterLogs(opts, "OptimisticUpdate")
	if err != nil {
		return nil, err
	}
	return &EthereumLightClientOptimisticUpdateIterator{contract: _EthereumLightClient.contract, event: "OptimisticUpdate", logs: logs, sub: sub}, nil
}

// WatchOptimisticUpdate is a free log subscription operation binding the contract event 0x27eafee2f5b2c935fa7666d231360699c41fe21db57034136b1af3c43f13df89.
//
// Solidity: event OptimisticUpdate(uint256 slot, bytes32 executionStateRoot)
func (_EthereumLightClient *EthereumLightClientFilterer) WatchOptimisticUpdate(opts *bind.WatchOpts, sink chan<- *EthereumLightClientOptimisticUpdate) (event.Subscription, error) {

	logs, sub, err := _EthereumLightClient.contract.WatchLogs(opts, "OptimisticUpdate")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EthereumLightClientOptimisticUpdate)
				if err := _EthereumLightClient.contract.UnpackLog(event, "OptimisticUpdate", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOptimisticUpdate is a log parse operation binding the contract event 0x27eafee2f5b2c935fa7666d231360699c41fe21db57034136b1af3c43f13df89.
//
// Solidity: event OptimisticUpdate(uint256 slot, bytes32 executionStateRoot)
func (_EthereumLightClient *EthereumLightClientFilterer) ParseOptimisticUpdate(log types.Log) (*EthereumLightClientOptimisticUpdate, error) {
	event := new(EthereumLightClientOptimisticUpdate)
	if err := _EthereumLightClient.contract.UnpackLog(event, "OptimisticUpdate", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EthereumLightClientOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the EthereumLightClient contract.
type EthereumLightClientOwnershipTransferredIterator struct {
	Event *EthereumLightClientOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EthereumLightClientOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EthereumLightClientOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EthereumLightClientOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EthereumLightClientOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EthereumLightClientOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EthereumLightClientOwnershipTransferred represents a OwnershipTransferred event raised by the EthereumLightClient contract.
type EthereumLightClientOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_EthereumLightClient *EthereumLightClientFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*EthereumLightClientOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _EthereumLightClient.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &EthereumLightClientOwnershipTransferredIterator{contract: _EthereumLightClient.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_EthereumLightClient *EthereumLightClientFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *EthereumLightClientOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _EthereumLightClient.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EthereumLightClientOwnershipTransferred)
				if err := _EthereumLightClient.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_EthereumLightClient *EthereumLightClientFilterer) ParseOwnershipTransferred(log types.Log) (*EthereumLightClientOwnershipTransferred, error) {
	event := new(EthereumLightClientOwnershipTransferred)
	if err := _EthereumLightClient.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EthereumLightClientPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the EthereumLightClient contract.
type EthereumLightClientPausedIterator struct {
	Event *EthereumLightClientPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EthereumLightClientPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EthereumLightClientPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EthereumLightClientPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EthereumLightClientPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EthereumLightClientPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EthereumLightClientPaused represents a Paused event raised by the EthereumLightClient contract.
type EthereumLightClientPaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) FilterPaused(opts *bind.FilterOpts) (*EthereumLightClientPausedIterator, error) {

	logs, sub, err := _EthereumLightClient.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &EthereumLightClientPausedIterator{contract: _EthereumLightClient.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *EthereumLightClientPaused) (event.Subscription, error) {

	logs, sub, err := _EthereumLightClient.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EthereumLightClientPaused)
				if err := _EthereumLightClient.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) ParsePaused(log types.Log) (*EthereumLightClientPaused, error) {
	event := new(EthereumLightClientPaused)
	if err := _EthereumLightClient.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EthereumLightClientPauserAddedIterator is returned from FilterPauserAdded and is used to iterate over the raw logs and unpacked data for PauserAdded events raised by the EthereumLightClient contract.
type EthereumLightClientPauserAddedIterator struct {
	Event *EthereumLightClientPauserAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EthereumLightClientPauserAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EthereumLightClientPauserAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EthereumLightClientPauserAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EthereumLightClientPauserAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EthereumLightClientPauserAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EthereumLightClientPauserAdded represents a PauserAdded event raised by the EthereumLightClient contract.
type EthereumLightClientPauserAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserAdded is a free log retrieval operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) FilterPauserAdded(opts *bind.FilterOpts) (*EthereumLightClientPauserAddedIterator, error) {

	logs, sub, err := _EthereumLightClient.contract.FilterLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return &EthereumLightClientPauserAddedIterator{contract: _EthereumLightClient.contract, event: "PauserAdded", logs: logs, sub: sub}, nil
}

// WatchPauserAdded is a free log subscription operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) WatchPauserAdded(opts *bind.WatchOpts, sink chan<- *EthereumLightClientPauserAdded) (event.Subscription, error) {

	logs, sub, err := _EthereumLightClient.contract.WatchLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EthereumLightClientPauserAdded)
				if err := _EthereumLightClient.contract.UnpackLog(event, "PauserAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserAdded is a log parse operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) ParsePauserAdded(log types.Log) (*EthereumLightClientPauserAdded, error) {
	event := new(EthereumLightClientPauserAdded)
	if err := _EthereumLightClient.contract.UnpackLog(event, "PauserAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EthereumLightClientPauserRemovedIterator is returned from FilterPauserRemoved and is used to iterate over the raw logs and unpacked data for PauserRemoved events raised by the EthereumLightClient contract.
type EthereumLightClientPauserRemovedIterator struct {
	Event *EthereumLightClientPauserRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EthereumLightClientPauserRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EthereumLightClientPauserRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EthereumLightClientPauserRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EthereumLightClientPauserRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EthereumLightClientPauserRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EthereumLightClientPauserRemoved represents a PauserRemoved event raised by the EthereumLightClient contract.
type EthereumLightClientPauserRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserRemoved is a free log retrieval operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) FilterPauserRemoved(opts *bind.FilterOpts) (*EthereumLightClientPauserRemovedIterator, error) {

	logs, sub, err := _EthereumLightClient.contract.FilterLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return &EthereumLightClientPauserRemovedIterator{contract: _EthereumLightClient.contract, event: "PauserRemoved", logs: logs, sub: sub}, nil
}

// WatchPauserRemoved is a free log subscription operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) WatchPauserRemoved(opts *bind.WatchOpts, sink chan<- *EthereumLightClientPauserRemoved) (event.Subscription, error) {

	logs, sub, err := _EthereumLightClient.contract.WatchLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EthereumLightClientPauserRemoved)
				if err := _EthereumLightClient.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserRemoved is a log parse operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) ParsePauserRemoved(log types.Log) (*EthereumLightClientPauserRemoved, error) {
	event := new(EthereumLightClientPauserRemoved)
	if err := _EthereumLightClient.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EthereumLightClientProverAddedIterator is returned from FilterProverAdded and is used to iterate over the raw logs and unpacked data for ProverAdded events raised by the EthereumLightClient contract.
type EthereumLightClientProverAddedIterator struct {
	Event *EthereumLightClientProverAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EthereumLightClientProverAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EthereumLightClientProverAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EthereumLightClientProverAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EthereumLightClientProverAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EthereumLightClientProverAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EthereumLightClientProverAdded represents a ProverAdded event raised by the EthereumLightClient contract.
type EthereumLightClientProverAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverAdded is a free log retrieval operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) FilterProverAdded(opts *bind.FilterOpts) (*EthereumLightClientProverAddedIterator, error) {

	logs, sub, err := _EthereumLightClient.contract.FilterLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return &EthereumLightClientProverAddedIterator{contract: _EthereumLightClient.contract, event: "ProverAdded", logs: logs, sub: sub}, nil
}

// WatchProverAdded is a free log subscription operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) WatchProverAdded(opts *bind.WatchOpts, sink chan<- *EthereumLightClientProverAdded) (event.Subscription, error) {

	logs, sub, err := _EthereumLightClient.contract.WatchLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EthereumLightClientProverAdded)
				if err := _EthereumLightClient.contract.UnpackLog(event, "ProverAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverAdded is a log parse operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) ParseProverAdded(log types.Log) (*EthereumLightClientProverAdded, error) {
	event := new(EthereumLightClientProverAdded)
	if err := _EthereumLightClient.contract.UnpackLog(event, "ProverAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EthereumLightClientProverRemovedIterator is returned from FilterProverRemoved and is used to iterate over the raw logs and unpacked data for ProverRemoved events raised by the EthereumLightClient contract.
type EthereumLightClientProverRemovedIterator struct {
	Event *EthereumLightClientProverRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EthereumLightClientProverRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EthereumLightClientProverRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EthereumLightClientProverRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EthereumLightClientProverRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EthereumLightClientProverRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EthereumLightClientProverRemoved represents a ProverRemoved event raised by the EthereumLightClient contract.
type EthereumLightClientProverRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverRemoved is a free log retrieval operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) FilterProverRemoved(opts *bind.FilterOpts) (*EthereumLightClientProverRemovedIterator, error) {

	logs, sub, err := _EthereumLightClient.contract.FilterLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return &EthereumLightClientProverRemovedIterator{contract: _EthereumLightClient.contract, event: "ProverRemoved", logs: logs, sub: sub}, nil
}

// WatchProverRemoved is a free log subscription operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) WatchProverRemoved(opts *bind.WatchOpts, sink chan<- *EthereumLightClientProverRemoved) (event.Subscription, error) {

	logs, sub, err := _EthereumLightClient.contract.WatchLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EthereumLightClientProverRemoved)
				if err := _EthereumLightClient.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverRemoved is a log parse operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) ParseProverRemoved(log types.Log) (*EthereumLightClientProverRemoved, error) {
	event := new(EthereumLightClientProverRemoved)
	if err := _EthereumLightClient.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EthereumLightClientSyncCommitteeUpdatedIterator is returned from FilterSyncCommitteeUpdated and is used to iterate over the raw logs and unpacked data for SyncCommitteeUpdated events raised by the EthereumLightClient contract.
type EthereumLightClientSyncCommitteeUpdatedIterator struct {
	Event *EthereumLightClientSyncCommitteeUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EthereumLightClientSyncCommitteeUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EthereumLightClientSyncCommitteeUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EthereumLightClientSyncCommitteeUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EthereumLightClientSyncCommitteeUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EthereumLightClientSyncCommitteeUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EthereumLightClientSyncCommitteeUpdated represents a SyncCommitteeUpdated event raised by the EthereumLightClient contract.
type EthereumLightClientSyncCommitteeUpdated struct {
	Period       *big.Int
	SszRoot      [32]byte
	PoseidonRoot [32]byte
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterSyncCommitteeUpdated is a free log retrieval operation binding the contract event 0xdc7ba15c782b181b9d54a996db4ab8a32182bff2bfb09e4aca8ed9ea9e5380c7.
//
// Solidity: event SyncCommitteeUpdated(uint256 period, bytes32 sszRoot, bytes32 poseidonRoot)
func (_EthereumLightClient *EthereumLightClientFilterer) FilterSyncCommitteeUpdated(opts *bind.FilterOpts) (*EthereumLightClientSyncCommitteeUpdatedIterator, error) {

	logs, sub, err := _EthereumLightClient.contract.FilterLogs(opts, "SyncCommitteeUpdated")
	if err != nil {
		return nil, err
	}
	return &EthereumLightClientSyncCommitteeUpdatedIterator{contract: _EthereumLightClient.contract, event: "SyncCommitteeUpdated", logs: logs, sub: sub}, nil
}

// WatchSyncCommitteeUpdated is a free log subscription operation binding the contract event 0xdc7ba15c782b181b9d54a996db4ab8a32182bff2bfb09e4aca8ed9ea9e5380c7.
//
// Solidity: event SyncCommitteeUpdated(uint256 period, bytes32 sszRoot, bytes32 poseidonRoot)
func (_EthereumLightClient *EthereumLightClientFilterer) WatchSyncCommitteeUpdated(opts *bind.WatchOpts, sink chan<- *EthereumLightClientSyncCommitteeUpdated) (event.Subscription, error) {

	logs, sub, err := _EthereumLightClient.contract.WatchLogs(opts, "SyncCommitteeUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EthereumLightClientSyncCommitteeUpdated)
				if err := _EthereumLightClient.contract.UnpackLog(event, "SyncCommitteeUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSyncCommitteeUpdated is a log parse operation binding the contract event 0xdc7ba15c782b181b9d54a996db4ab8a32182bff2bfb09e4aca8ed9ea9e5380c7.
//
// Solidity: event SyncCommitteeUpdated(uint256 period, bytes32 sszRoot, bytes32 poseidonRoot)
func (_EthereumLightClient *EthereumLightClientFilterer) ParseSyncCommitteeUpdated(log types.Log) (*EthereumLightClientSyncCommitteeUpdated, error) {
	event := new(EthereumLightClientSyncCommitteeUpdated)
	if err := _EthereumLightClient.contract.UnpackLog(event, "SyncCommitteeUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EthereumLightClientUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the EthereumLightClient contract.
type EthereumLightClientUnpausedIterator struct {
	Event *EthereumLightClientUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EthereumLightClientUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EthereumLightClientUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EthereumLightClientUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EthereumLightClientUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EthereumLightClientUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EthereumLightClientUnpaused represents a Unpaused event raised by the EthereumLightClient contract.
type EthereumLightClientUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) FilterUnpaused(opts *bind.FilterOpts) (*EthereumLightClientUnpausedIterator, error) {

	logs, sub, err := _EthereumLightClient.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &EthereumLightClientUnpausedIterator{contract: _EthereumLightClient.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *EthereumLightClientUnpaused) (event.Subscription, error) {

	logs, sub, err := _EthereumLightClient.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EthereumLightClientUnpaused)
				if err := _EthereumLightClient.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_EthereumLightClient *EthereumLightClientFilterer) ParseUnpaused(log types.Log) (*EthereumLightClientUnpaused, error) {
	event := new(EthereumLightClientUnpaused)
	if err := _EthereumLightClient.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// FeeLibraryMetaData contains all meta data concerning the FeeLibrary contract.
var FeeLibraryMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"DYNAMIC_FEE_FLAG\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HOOK_SWAP_FEE_FLAG\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HOOK_WITHDRAW_FEE_FLAG\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STATIC_FEE_MASK\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x608080604052346100195760e0908161001e823930815050f35b5f80fdfe60808060405260043610156011575f80fd5b5f90813560e01c9081634f7deff714608f57508063c7a97b4e146077578063d11e7dee14605f5763f26ef49d146045575f80fd5b80600319360112605c576020604051628000008152f35b80fd5b5080600319360112605c576020604051624000008152f35b5080600319360112605c576020604051620fffff8152f35b90508160031936011260a657806220000060209252f35b5080fdfea2646970667358221220d40de33af200db2108593e465bba47dc273a323509668f3b87e6580e05b1f1b364736f6c63430008140033",
}

// FeeLibraryABI is the input ABI used to generate the binding from.
// Deprecated: Use FeeLibraryMetaData.ABI instead.
var FeeLibraryABI = FeeLibraryMetaData.ABI

// FeeLibraryBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use FeeLibraryMetaData.Bin instead.
var FeeLibraryBin = FeeLibraryMetaData.Bin

// DeployFeeLibrary deploys a new Ethereum contract, binding an instance of FeeLibrary to it.
func DeployFeeLibrary(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *FeeLibrary, error) {
	parsed, err := FeeLibraryMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(FeeLibraryBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &FeeLibrary{FeeLibraryCaller: FeeLibraryCaller{contract: contract}, FeeLibraryTransactor: FeeLibraryTransactor{contract: contract}, FeeLibraryFilterer: FeeLibraryFilterer{contract: contract}}, nil
}

// FeeLibrary is an auto generated Go binding around an Ethereum contract.
type FeeLibrary struct {
	FeeLibraryCaller     // Read-only binding to the contract
	FeeLibraryTransactor // Write-only binding to the contract
	FeeLibraryFilterer   // Log filterer for contract events
}

// FeeLibraryCaller is an auto generated read-only Go binding around an Ethereum contract.
type FeeLibraryCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FeeLibraryTransactor is an auto generated write-only Go binding around an Ethereum contract.
type FeeLibraryTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FeeLibraryFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type FeeLibraryFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FeeLibrarySession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type FeeLibrarySession struct {
	Contract     *FeeLibrary       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// FeeLibraryCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type FeeLibraryCallerSession struct {
	Contract *FeeLibraryCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// FeeLibraryTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type FeeLibraryTransactorSession struct {
	Contract     *FeeLibraryTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// FeeLibraryRaw is an auto generated low-level Go binding around an Ethereum contract.
type FeeLibraryRaw struct {
	Contract *FeeLibrary // Generic contract binding to access the raw methods on
}

// FeeLibraryCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type FeeLibraryCallerRaw struct {
	Contract *FeeLibraryCaller // Generic read-only contract binding to access the raw methods on
}

// FeeLibraryTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type FeeLibraryTransactorRaw struct {
	Contract *FeeLibraryTransactor // Generic write-only contract binding to access the raw methods on
}

// NewFeeLibrary creates a new instance of FeeLibrary, bound to a specific deployed contract.
func NewFeeLibrary(address common.Address, backend bind.ContractBackend) (*FeeLibrary, error) {
	contract, err := bindFeeLibrary(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &FeeLibrary{FeeLibraryCaller: FeeLibraryCaller{contract: contract}, FeeLibraryTransactor: FeeLibraryTransactor{contract: contract}, FeeLibraryFilterer: FeeLibraryFilterer{contract: contract}}, nil
}

// NewFeeLibraryCaller creates a new read-only instance of FeeLibrary, bound to a specific deployed contract.
func NewFeeLibraryCaller(address common.Address, caller bind.ContractCaller) (*FeeLibraryCaller, error) {
	contract, err := bindFeeLibrary(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &FeeLibraryCaller{contract: contract}, nil
}

// NewFeeLibraryTransactor creates a new write-only instance of FeeLibrary, bound to a specific deployed contract.
func NewFeeLibraryTransactor(address common.Address, transactor bind.ContractTransactor) (*FeeLibraryTransactor, error) {
	contract, err := bindFeeLibrary(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &FeeLibraryTransactor{contract: contract}, nil
}

// NewFeeLibraryFilterer creates a new log filterer instance of FeeLibrary, bound to a specific deployed contract.
func NewFeeLibraryFilterer(address common.Address, filterer bind.ContractFilterer) (*FeeLibraryFilterer, error) {
	contract, err := bindFeeLibrary(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &FeeLibraryFilterer{contract: contract}, nil
}

// bindFeeLibrary binds a generic wrapper to an already deployed contract.
func bindFeeLibrary(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := FeeLibraryMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_FeeLibrary *FeeLibraryRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _FeeLibrary.Contract.FeeLibraryCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_FeeLibrary *FeeLibraryRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _FeeLibrary.Contract.FeeLibraryTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_FeeLibrary *FeeLibraryRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _FeeLibrary.Contract.FeeLibraryTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_FeeLibrary *FeeLibraryCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _FeeLibrary.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_FeeLibrary *FeeLibraryTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _FeeLibrary.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_FeeLibrary *FeeLibraryTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _FeeLibrary.Contract.contract.Transact(opts, method, params...)
}

// DYNAMICFEEFLAG is a free data retrieval call binding the contract method 0xf26ef49d.
//
// Solidity: function DYNAMIC_FEE_FLAG() view returns(uint24)
func (_FeeLibrary *FeeLibraryCaller) DYNAMICFEEFLAG(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _FeeLibrary.contract.Call(opts, &out, "DYNAMIC_FEE_FLAG")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DYNAMICFEEFLAG is a free data retrieval call binding the contract method 0xf26ef49d.
//
// Solidity: function DYNAMIC_FEE_FLAG() view returns(uint24)
func (_FeeLibrary *FeeLibrarySession) DYNAMICFEEFLAG() (*big.Int, error) {
	return _FeeLibrary.Contract.DYNAMICFEEFLAG(&_FeeLibrary.CallOpts)
}

// DYNAMICFEEFLAG is a free data retrieval call binding the contract method 0xf26ef49d.
//
// Solidity: function DYNAMIC_FEE_FLAG() view returns(uint24)
func (_FeeLibrary *FeeLibraryCallerSession) DYNAMICFEEFLAG() (*big.Int, error) {
	return _FeeLibrary.Contract.DYNAMICFEEFLAG(&_FeeLibrary.CallOpts)
}

// HOOKSWAPFEEFLAG is a free data retrieval call binding the contract method 0xd11e7dee.
//
// Solidity: function HOOK_SWAP_FEE_FLAG() view returns(uint24)
func (_FeeLibrary *FeeLibraryCaller) HOOKSWAPFEEFLAG(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _FeeLibrary.contract.Call(opts, &out, "HOOK_SWAP_FEE_FLAG")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// HOOKSWAPFEEFLAG is a free data retrieval call binding the contract method 0xd11e7dee.
//
// Solidity: function HOOK_SWAP_FEE_FLAG() view returns(uint24)
func (_FeeLibrary *FeeLibrarySession) HOOKSWAPFEEFLAG() (*big.Int, error) {
	return _FeeLibrary.Contract.HOOKSWAPFEEFLAG(&_FeeLibrary.CallOpts)
}

// HOOKSWAPFEEFLAG is a free data retrieval call binding the contract method 0xd11e7dee.
//
// Solidity: function HOOK_SWAP_FEE_FLAG() view returns(uint24)
func (_FeeLibrary *FeeLibraryCallerSession) HOOKSWAPFEEFLAG() (*big.Int, error) {
	return _FeeLibrary.Contract.HOOKSWAPFEEFLAG(&_FeeLibrary.CallOpts)
}

// HOOKWITHDRAWFEEFLAG is a free data retrieval call binding the contract method 0x4f7deff7.
//
// Solidity: function HOOK_WITHDRAW_FEE_FLAG() view returns(uint24)
func (_FeeLibrary *FeeLibraryCaller) HOOKWITHDRAWFEEFLAG(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _FeeLibrary.contract.Call(opts, &out, "HOOK_WITHDRAW_FEE_FLAG")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// HOOKWITHDRAWFEEFLAG is a free data retrieval call binding the contract method 0x4f7deff7.
//
// Solidity: function HOOK_WITHDRAW_FEE_FLAG() view returns(uint24)
func (_FeeLibrary *FeeLibrarySession) HOOKWITHDRAWFEEFLAG() (*big.Int, error) {
	return _FeeLibrary.Contract.HOOKWITHDRAWFEEFLAG(&_FeeLibrary.CallOpts)
}

// HOOKWITHDRAWFEEFLAG is a free data retrieval call binding the contract method 0x4f7deff7.
//
// Solidity: function HOOK_WITHDRAW_FEE_FLAG() view returns(uint24)
func (_FeeLibrary *FeeLibraryCallerSession) HOOKWITHDRAWFEEFLAG() (*big.Int, error) {
	return _FeeLibrary.Contract.HOOKWITHDRAWFEEFLAG(&_FeeLibrary.CallOpts)
}

// STATICFEEMASK is a free data retrieval call binding the contract method 0xc7a97b4e.
//
// Solidity: function STATIC_FEE_MASK() view returns(uint24)
func (_FeeLibrary *FeeLibraryCaller) STATICFEEMASK(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _FeeLibrary.contract.Call(opts, &out, "STATIC_FEE_MASK")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// STATICFEEMASK is a free data retrieval call binding the contract method 0xc7a97b4e.
//
// Solidity: function STATIC_FEE_MASK() view returns(uint24)
func (_FeeLibrary *FeeLibrarySession) STATICFEEMASK() (*big.Int, error) {
	return _FeeLibrary.Contract.STATICFEEMASK(&_FeeLibrary.CallOpts)
}

// STATICFEEMASK is a free data retrieval call binding the contract method 0xc7a97b4e.
//
// Solidity: function STATIC_FEE_MASK() view returns(uint24)
func (_FeeLibrary *FeeLibraryCallerSession) STATICFEEMASK() (*big.Int, error) {
	return _FeeLibrary.Contract.STATICFEEMASK(&_FeeLibrary.CallOpts)
}

// FeeVaultMetaData contains all meta data concerning the FeeVault contract.
var FeeVaultMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeCollector\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"FeeCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"FeeCollectorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"collectFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeCollector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeCollector\",\"type\":\"address\"}],\"name\":\"setFeeCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
	Bin: "0x6080346100a457601f6104e938819003918201601f19168301916001600160401b038311848410176100a8578084926020946040528339810103126100a457516001600160a01b0390818116908190036100a4575f5460018060a01b03199033828216175f55604051933391167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3600154161760015561042c90816100bd8239f35b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe60806040818152600480361015610020575b505050361561001e575f80fd5b005b5f92833560e01c9081637ff7b0d214610224575080638da5cb5b146101fe578063a42dce8014610178578063c415b95c1461014c5763f2fde38b03610011573461014857602036600319011261014857610078610391565b908354906001600160a01b03808316936100933386146103ab565b169384156100df57505073ffffffffffffffffffffffffffffffffffffffff1916821783557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b906020608492519162461bcd60e51b8352820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152fd5b8280fd5b5050346101745781600319360112610174576020906001600160a01b03600154169051908152f35b5080fd5b505034610174576020366003190112610174577f5d16ad41baeb009cd23eb8f6c7cde5c2e0cd5acf4a33926ab488875c37c37f38906101b5610391565b6001600160a01b036101cb8186541633146103ab565b806001549216908173ffffffffffffffffffffffffffffffffffffffff198416176001558351921682526020820152a180f35b5050346101745781600319360112610174576001600160a01b0360209254169051908152f35b848484346101485781600319360112610148578035906024356001600160a01b03958682169687830361038d5760015416330361034c575084808085819461c350f13d156103475767ffffffffffffffff3d81811161033457855191601f8201601f19908116603f011683019081118382101761032157865281528560203d92013e5b156102de57507ff10cda68996dfb656d49ab0db3c62cc5f0849710633671a337171c3ad9255186929382519182526020820152a180f35b606490602084519162461bcd60e51b8352820152601260248201527f73656e64206e6174697665206661696c656400000000000000000000000000006044820152fd5b634e487b7160e01b885260418552602488fd5b634e487b7160e01b875260418452602487fd5b6102a7565b62461bcd60e51b8152602083820152601160248201527f6e6f742066656520636f6c6c6563746f720000000000000000000000000000006044820152606490fd5b8680fd5b600435906001600160a01b03821682036103a757565b5f80fd5b156103b257565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fdfea264697066735822122050074f8378aad9f9dcd9800401cb61634df4ab69789ded3bdec520a69a906b5d64736f6c63430008140033",
}

// FeeVaultABI is the input ABI used to generate the binding from.
// Deprecated: Use FeeVaultMetaData.ABI instead.
var FeeVaultABI = FeeVaultMetaData.ABI

// FeeVaultBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use FeeVaultMetaData.Bin instead.
var FeeVaultBin = FeeVaultMetaData.Bin

// DeployFeeVault deploys a new Ethereum contract, binding an instance of FeeVault to it.
func DeployFeeVault(auth *bind.TransactOpts, backend bind.ContractBackend, _feeCollector common.Address) (common.Address, *types.Transaction, *FeeVault, error) {
	parsed, err := FeeVaultMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(FeeVaultBin), backend, _feeCollector)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &FeeVault{FeeVaultCaller: FeeVaultCaller{contract: contract}, FeeVaultTransactor: FeeVaultTransactor{contract: contract}, FeeVaultFilterer: FeeVaultFilterer{contract: contract}}, nil
}

// FeeVault is an auto generated Go binding around an Ethereum contract.
type FeeVault struct {
	FeeVaultCaller     // Read-only binding to the contract
	FeeVaultTransactor // Write-only binding to the contract
	FeeVaultFilterer   // Log filterer for contract events
}

// FeeVaultCaller is an auto generated read-only Go binding around an Ethereum contract.
type FeeVaultCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FeeVaultTransactor is an auto generated write-only Go binding around an Ethereum contract.
type FeeVaultTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FeeVaultFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type FeeVaultFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FeeVaultSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type FeeVaultSession struct {
	Contract     *FeeVault         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// FeeVaultCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type FeeVaultCallerSession struct {
	Contract *FeeVaultCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// FeeVaultTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type FeeVaultTransactorSession struct {
	Contract     *FeeVaultTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// FeeVaultRaw is an auto generated low-level Go binding around an Ethereum contract.
type FeeVaultRaw struct {
	Contract *FeeVault // Generic contract binding to access the raw methods on
}

// FeeVaultCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type FeeVaultCallerRaw struct {
	Contract *FeeVaultCaller // Generic read-only contract binding to access the raw methods on
}

// FeeVaultTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type FeeVaultTransactorRaw struct {
	Contract *FeeVaultTransactor // Generic write-only contract binding to access the raw methods on
}

// NewFeeVault creates a new instance of FeeVault, bound to a specific deployed contract.
func NewFeeVault(address common.Address, backend bind.ContractBackend) (*FeeVault, error) {
	contract, err := bindFeeVault(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &FeeVault{FeeVaultCaller: FeeVaultCaller{contract: contract}, FeeVaultTransactor: FeeVaultTransactor{contract: contract}, FeeVaultFilterer: FeeVaultFilterer{contract: contract}}, nil
}

// NewFeeVaultCaller creates a new read-only instance of FeeVault, bound to a specific deployed contract.
func NewFeeVaultCaller(address common.Address, caller bind.ContractCaller) (*FeeVaultCaller, error) {
	contract, err := bindFeeVault(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &FeeVaultCaller{contract: contract}, nil
}

// NewFeeVaultTransactor creates a new write-only instance of FeeVault, bound to a specific deployed contract.
func NewFeeVaultTransactor(address common.Address, transactor bind.ContractTransactor) (*FeeVaultTransactor, error) {
	contract, err := bindFeeVault(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &FeeVaultTransactor{contract: contract}, nil
}

// NewFeeVaultFilterer creates a new log filterer instance of FeeVault, bound to a specific deployed contract.
func NewFeeVaultFilterer(address common.Address, filterer bind.ContractFilterer) (*FeeVaultFilterer, error) {
	contract, err := bindFeeVault(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &FeeVaultFilterer{contract: contract}, nil
}

// bindFeeVault binds a generic wrapper to an already deployed contract.
func bindFeeVault(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := FeeVaultMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_FeeVault *FeeVaultRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _FeeVault.Contract.FeeVaultCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_FeeVault *FeeVaultRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _FeeVault.Contract.FeeVaultTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_FeeVault *FeeVaultRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _FeeVault.Contract.FeeVaultTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_FeeVault *FeeVaultCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _FeeVault.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_FeeVault *FeeVaultTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _FeeVault.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_FeeVault *FeeVaultTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _FeeVault.Contract.contract.Transact(opts, method, params...)
}

// FeeCollector is a free data retrieval call binding the contract method 0xc415b95c.
//
// Solidity: function feeCollector() view returns(address)
func (_FeeVault *FeeVaultCaller) FeeCollector(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _FeeVault.contract.Call(opts, &out, "feeCollector")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// FeeCollector is a free data retrieval call binding the contract method 0xc415b95c.
//
// Solidity: function feeCollector() view returns(address)
func (_FeeVault *FeeVaultSession) FeeCollector() (common.Address, error) {
	return _FeeVault.Contract.FeeCollector(&_FeeVault.CallOpts)
}

// FeeCollector is a free data retrieval call binding the contract method 0xc415b95c.
//
// Solidity: function feeCollector() view returns(address)
func (_FeeVault *FeeVaultCallerSession) FeeCollector() (common.Address, error) {
	return _FeeVault.Contract.FeeCollector(&_FeeVault.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_FeeVault *FeeVaultCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _FeeVault.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_FeeVault *FeeVaultSession) Owner() (common.Address, error) {
	return _FeeVault.Contract.Owner(&_FeeVault.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_FeeVault *FeeVaultCallerSession) Owner() (common.Address, error) {
	return _FeeVault.Contract.Owner(&_FeeVault.CallOpts)
}

// CollectFee is a paid mutator transaction binding the contract method 0x7ff7b0d2.
//
// Solidity: function collectFee(uint256 _amount, address _to) returns()
func (_FeeVault *FeeVaultTransactor) CollectFee(opts *bind.TransactOpts, _amount *big.Int, _to common.Address) (*types.Transaction, error) {
	return _FeeVault.contract.Transact(opts, "collectFee", _amount, _to)
}

// CollectFee is a paid mutator transaction binding the contract method 0x7ff7b0d2.
//
// Solidity: function collectFee(uint256 _amount, address _to) returns()
func (_FeeVault *FeeVaultSession) CollectFee(_amount *big.Int, _to common.Address) (*types.Transaction, error) {
	return _FeeVault.Contract.CollectFee(&_FeeVault.TransactOpts, _amount, _to)
}

// CollectFee is a paid mutator transaction binding the contract method 0x7ff7b0d2.
//
// Solidity: function collectFee(uint256 _amount, address _to) returns()
func (_FeeVault *FeeVaultTransactorSession) CollectFee(_amount *big.Int, _to common.Address) (*types.Transaction, error) {
	return _FeeVault.Contract.CollectFee(&_FeeVault.TransactOpts, _amount, _to)
}

// SetFeeCollector is a paid mutator transaction binding the contract method 0xa42dce80.
//
// Solidity: function setFeeCollector(address _feeCollector) returns()
func (_FeeVault *FeeVaultTransactor) SetFeeCollector(opts *bind.TransactOpts, _feeCollector common.Address) (*types.Transaction, error) {
	return _FeeVault.contract.Transact(opts, "setFeeCollector", _feeCollector)
}

// SetFeeCollector is a paid mutator transaction binding the contract method 0xa42dce80.
//
// Solidity: function setFeeCollector(address _feeCollector) returns()
func (_FeeVault *FeeVaultSession) SetFeeCollector(_feeCollector common.Address) (*types.Transaction, error) {
	return _FeeVault.Contract.SetFeeCollector(&_FeeVault.TransactOpts, _feeCollector)
}

// SetFeeCollector is a paid mutator transaction binding the contract method 0xa42dce80.
//
// Solidity: function setFeeCollector(address _feeCollector) returns()
func (_FeeVault *FeeVaultTransactorSession) SetFeeCollector(_feeCollector common.Address) (*types.Transaction, error) {
	return _FeeVault.Contract.SetFeeCollector(&_FeeVault.TransactOpts, _feeCollector)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_FeeVault *FeeVaultTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _FeeVault.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_FeeVault *FeeVaultSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _FeeVault.Contract.TransferOwnership(&_FeeVault.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_FeeVault *FeeVaultTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _FeeVault.Contract.TransferOwnership(&_FeeVault.TransactOpts, newOwner)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_FeeVault *FeeVaultTransactor) Receive(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _FeeVault.contract.RawTransact(opts, nil) // calldata is disallowed for receive function
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_FeeVault *FeeVaultSession) Receive() (*types.Transaction, error) {
	return _FeeVault.Contract.Receive(&_FeeVault.TransactOpts)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_FeeVault *FeeVaultTransactorSession) Receive() (*types.Transaction, error) {
	return _FeeVault.Contract.Receive(&_FeeVault.TransactOpts)
}

// FeeVaultFeeCollectedIterator is returned from FilterFeeCollected and is used to iterate over the raw logs and unpacked data for FeeCollected events raised by the FeeVault contract.
type FeeVaultFeeCollectedIterator struct {
	Event *FeeVaultFeeCollected // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FeeVaultFeeCollectedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FeeVaultFeeCollected)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FeeVaultFeeCollected)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FeeVaultFeeCollectedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FeeVaultFeeCollectedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FeeVaultFeeCollected represents a FeeCollected event raised by the FeeVault contract.
type FeeVaultFeeCollected struct {
	Amount   *big.Int
	Receiver common.Address
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterFeeCollected is a free log retrieval operation binding the contract event 0xf10cda68996dfb656d49ab0db3c62cc5f0849710633671a337171c3ad9255186.
//
// Solidity: event FeeCollected(uint256 amount, address receiver)
func (_FeeVault *FeeVaultFilterer) FilterFeeCollected(opts *bind.FilterOpts) (*FeeVaultFeeCollectedIterator, error) {

	logs, sub, err := _FeeVault.contract.FilterLogs(opts, "FeeCollected")
	if err != nil {
		return nil, err
	}
	return &FeeVaultFeeCollectedIterator{contract: _FeeVault.contract, event: "FeeCollected", logs: logs, sub: sub}, nil
}

// WatchFeeCollected is a free log subscription operation binding the contract event 0xf10cda68996dfb656d49ab0db3c62cc5f0849710633671a337171c3ad9255186.
//
// Solidity: event FeeCollected(uint256 amount, address receiver)
func (_FeeVault *FeeVaultFilterer) WatchFeeCollected(opts *bind.WatchOpts, sink chan<- *FeeVaultFeeCollected) (event.Subscription, error) {

	logs, sub, err := _FeeVault.contract.WatchLogs(opts, "FeeCollected")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FeeVaultFeeCollected)
				if err := _FeeVault.contract.UnpackLog(event, "FeeCollected", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFeeCollected is a log parse operation binding the contract event 0xf10cda68996dfb656d49ab0db3c62cc5f0849710633671a337171c3ad9255186.
//
// Solidity: event FeeCollected(uint256 amount, address receiver)
func (_FeeVault *FeeVaultFilterer) ParseFeeCollected(log types.Log) (*FeeVaultFeeCollected, error) {
	event := new(FeeVaultFeeCollected)
	if err := _FeeVault.contract.UnpackLog(event, "FeeCollected", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// FeeVaultFeeCollectorUpdatedIterator is returned from FilterFeeCollectorUpdated and is used to iterate over the raw logs and unpacked data for FeeCollectorUpdated events raised by the FeeVault contract.
type FeeVaultFeeCollectorUpdatedIterator struct {
	Event *FeeVaultFeeCollectorUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FeeVaultFeeCollectorUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FeeVaultFeeCollectorUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FeeVaultFeeCollectorUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FeeVaultFeeCollectorUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FeeVaultFeeCollectorUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FeeVaultFeeCollectorUpdated represents a FeeCollectorUpdated event raised by the FeeVault contract.
type FeeVaultFeeCollectorUpdated struct {
	From common.Address
	To   common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterFeeCollectorUpdated is a free log retrieval operation binding the contract event 0x5d16ad41baeb009cd23eb8f6c7cde5c2e0cd5acf4a33926ab488875c37c37f38.
//
// Solidity: event FeeCollectorUpdated(address from, address to)
func (_FeeVault *FeeVaultFilterer) FilterFeeCollectorUpdated(opts *bind.FilterOpts) (*FeeVaultFeeCollectorUpdatedIterator, error) {

	logs, sub, err := _FeeVault.contract.FilterLogs(opts, "FeeCollectorUpdated")
	if err != nil {
		return nil, err
	}
	return &FeeVaultFeeCollectorUpdatedIterator{contract: _FeeVault.contract, event: "FeeCollectorUpdated", logs: logs, sub: sub}, nil
}

// WatchFeeCollectorUpdated is a free log subscription operation binding the contract event 0x5d16ad41baeb009cd23eb8f6c7cde5c2e0cd5acf4a33926ab488875c37c37f38.
//
// Solidity: event FeeCollectorUpdated(address from, address to)
func (_FeeVault *FeeVaultFilterer) WatchFeeCollectorUpdated(opts *bind.WatchOpts, sink chan<- *FeeVaultFeeCollectorUpdated) (event.Subscription, error) {

	logs, sub, err := _FeeVault.contract.WatchLogs(opts, "FeeCollectorUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FeeVaultFeeCollectorUpdated)
				if err := _FeeVault.contract.UnpackLog(event, "FeeCollectorUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFeeCollectorUpdated is a log parse operation binding the contract event 0x5d16ad41baeb009cd23eb8f6c7cde5c2e0cd5acf4a33926ab488875c37c37f38.
//
// Solidity: event FeeCollectorUpdated(address from, address to)
func (_FeeVault *FeeVaultFilterer) ParseFeeCollectorUpdated(log types.Log) (*FeeVaultFeeCollectorUpdated, error) {
	event := new(FeeVaultFeeCollectorUpdated)
	if err := _FeeVault.contract.UnpackLog(event, "FeeCollectorUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// FeeVaultOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the FeeVault contract.
type FeeVaultOwnershipTransferredIterator struct {
	Event *FeeVaultOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FeeVaultOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FeeVaultOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FeeVaultOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FeeVaultOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FeeVaultOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FeeVaultOwnershipTransferred represents a OwnershipTransferred event raised by the FeeVault contract.
type FeeVaultOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_FeeVault *FeeVaultFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*FeeVaultOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _FeeVault.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &FeeVaultOwnershipTransferredIterator{contract: _FeeVault.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_FeeVault *FeeVaultFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *FeeVaultOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _FeeVault.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FeeVaultOwnershipTransferred)
				if err := _FeeVault.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_FeeVault *FeeVaultFilterer) ParseOwnershipTransferred(log types.Log) (*FeeVaultOwnershipTransferred, error) {
	event := new(FeeVaultOwnershipTransferred)
	if err := _FeeVault.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// FixedPoint128MetaData contains all meta data concerning the FixedPoint128 contract.
var FixedPoint128MetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea264697066735822122058137079b05a69c108e8ea72d4489ce277c03499928f0a65b81f98b79e997fae64736f6c63430008140033",
}

// FixedPoint128ABI is the input ABI used to generate the binding from.
// Deprecated: Use FixedPoint128MetaData.ABI instead.
var FixedPoint128ABI = FixedPoint128MetaData.ABI

// FixedPoint128Bin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use FixedPoint128MetaData.Bin instead.
var FixedPoint128Bin = FixedPoint128MetaData.Bin

// DeployFixedPoint128 deploys a new Ethereum contract, binding an instance of FixedPoint128 to it.
func DeployFixedPoint128(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *FixedPoint128, error) {
	parsed, err := FixedPoint128MetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(FixedPoint128Bin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &FixedPoint128{FixedPoint128Caller: FixedPoint128Caller{contract: contract}, FixedPoint128Transactor: FixedPoint128Transactor{contract: contract}, FixedPoint128Filterer: FixedPoint128Filterer{contract: contract}}, nil
}

// FixedPoint128 is an auto generated Go binding around an Ethereum contract.
type FixedPoint128 struct {
	FixedPoint128Caller     // Read-only binding to the contract
	FixedPoint128Transactor // Write-only binding to the contract
	FixedPoint128Filterer   // Log filterer for contract events
}

// FixedPoint128Caller is an auto generated read-only Go binding around an Ethereum contract.
type FixedPoint128Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FixedPoint128Transactor is an auto generated write-only Go binding around an Ethereum contract.
type FixedPoint128Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FixedPoint128Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type FixedPoint128Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FixedPoint128Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type FixedPoint128Session struct {
	Contract     *FixedPoint128    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// FixedPoint128CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type FixedPoint128CallerSession struct {
	Contract *FixedPoint128Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// FixedPoint128TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type FixedPoint128TransactorSession struct {
	Contract     *FixedPoint128Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// FixedPoint128Raw is an auto generated low-level Go binding around an Ethereum contract.
type FixedPoint128Raw struct {
	Contract *FixedPoint128 // Generic contract binding to access the raw methods on
}

// FixedPoint128CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type FixedPoint128CallerRaw struct {
	Contract *FixedPoint128Caller // Generic read-only contract binding to access the raw methods on
}

// FixedPoint128TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type FixedPoint128TransactorRaw struct {
	Contract *FixedPoint128Transactor // Generic write-only contract binding to access the raw methods on
}

// NewFixedPoint128 creates a new instance of FixedPoint128, bound to a specific deployed contract.
func NewFixedPoint128(address common.Address, backend bind.ContractBackend) (*FixedPoint128, error) {
	contract, err := bindFixedPoint128(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &FixedPoint128{FixedPoint128Caller: FixedPoint128Caller{contract: contract}, FixedPoint128Transactor: FixedPoint128Transactor{contract: contract}, FixedPoint128Filterer: FixedPoint128Filterer{contract: contract}}, nil
}

// NewFixedPoint128Caller creates a new read-only instance of FixedPoint128, bound to a specific deployed contract.
func NewFixedPoint128Caller(address common.Address, caller bind.ContractCaller) (*FixedPoint128Caller, error) {
	contract, err := bindFixedPoint128(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &FixedPoint128Caller{contract: contract}, nil
}

// NewFixedPoint128Transactor creates a new write-only instance of FixedPoint128, bound to a specific deployed contract.
func NewFixedPoint128Transactor(address common.Address, transactor bind.ContractTransactor) (*FixedPoint128Transactor, error) {
	contract, err := bindFixedPoint128(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &FixedPoint128Transactor{contract: contract}, nil
}

// NewFixedPoint128Filterer creates a new log filterer instance of FixedPoint128, bound to a specific deployed contract.
func NewFixedPoint128Filterer(address common.Address, filterer bind.ContractFilterer) (*FixedPoint128Filterer, error) {
	contract, err := bindFixedPoint128(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &FixedPoint128Filterer{contract: contract}, nil
}

// bindFixedPoint128 binds a generic wrapper to an already deployed contract.
func bindFixedPoint128(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := FixedPoint128MetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_FixedPoint128 *FixedPoint128Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _FixedPoint128.Contract.FixedPoint128Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_FixedPoint128 *FixedPoint128Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _FixedPoint128.Contract.FixedPoint128Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_FixedPoint128 *FixedPoint128Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _FixedPoint128.Contract.FixedPoint128Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_FixedPoint128 *FixedPoint128CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _FixedPoint128.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_FixedPoint128 *FixedPoint128TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _FixedPoint128.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_FixedPoint128 *FixedPoint128TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _FixedPoint128.Contract.contract.Transact(opts, method, params...)
}

// FixedPoint96MetaData contains all meta data concerning the FixedPoint96 contract.
var FixedPoint96MetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212202f0c93e43c9b19ca4163b311ea6a376d3780b335025a9ae1a3b76228d695223c64736f6c63430008140033",
}

// FixedPoint96ABI is the input ABI used to generate the binding from.
// Deprecated: Use FixedPoint96MetaData.ABI instead.
var FixedPoint96ABI = FixedPoint96MetaData.ABI

// FixedPoint96Bin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use FixedPoint96MetaData.Bin instead.
var FixedPoint96Bin = FixedPoint96MetaData.Bin

// DeployFixedPoint96 deploys a new Ethereum contract, binding an instance of FixedPoint96 to it.
func DeployFixedPoint96(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *FixedPoint96, error) {
	parsed, err := FixedPoint96MetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(FixedPoint96Bin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &FixedPoint96{FixedPoint96Caller: FixedPoint96Caller{contract: contract}, FixedPoint96Transactor: FixedPoint96Transactor{contract: contract}, FixedPoint96Filterer: FixedPoint96Filterer{contract: contract}}, nil
}

// FixedPoint96 is an auto generated Go binding around an Ethereum contract.
type FixedPoint96 struct {
	FixedPoint96Caller     // Read-only binding to the contract
	FixedPoint96Transactor // Write-only binding to the contract
	FixedPoint96Filterer   // Log filterer for contract events
}

// FixedPoint96Caller is an auto generated read-only Go binding around an Ethereum contract.
type FixedPoint96Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FixedPoint96Transactor is an auto generated write-only Go binding around an Ethereum contract.
type FixedPoint96Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FixedPoint96Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type FixedPoint96Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FixedPoint96Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type FixedPoint96Session struct {
	Contract     *FixedPoint96     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// FixedPoint96CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type FixedPoint96CallerSession struct {
	Contract *FixedPoint96Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// FixedPoint96TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type FixedPoint96TransactorSession struct {
	Contract     *FixedPoint96Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// FixedPoint96Raw is an auto generated low-level Go binding around an Ethereum contract.
type FixedPoint96Raw struct {
	Contract *FixedPoint96 // Generic contract binding to access the raw methods on
}

// FixedPoint96CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type FixedPoint96CallerRaw struct {
	Contract *FixedPoint96Caller // Generic read-only contract binding to access the raw methods on
}

// FixedPoint96TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type FixedPoint96TransactorRaw struct {
	Contract *FixedPoint96Transactor // Generic write-only contract binding to access the raw methods on
}

// NewFixedPoint96 creates a new instance of FixedPoint96, bound to a specific deployed contract.
func NewFixedPoint96(address common.Address, backend bind.ContractBackend) (*FixedPoint96, error) {
	contract, err := bindFixedPoint96(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &FixedPoint96{FixedPoint96Caller: FixedPoint96Caller{contract: contract}, FixedPoint96Transactor: FixedPoint96Transactor{contract: contract}, FixedPoint96Filterer: FixedPoint96Filterer{contract: contract}}, nil
}

// NewFixedPoint96Caller creates a new read-only instance of FixedPoint96, bound to a specific deployed contract.
func NewFixedPoint96Caller(address common.Address, caller bind.ContractCaller) (*FixedPoint96Caller, error) {
	contract, err := bindFixedPoint96(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &FixedPoint96Caller{contract: contract}, nil
}

// NewFixedPoint96Transactor creates a new write-only instance of FixedPoint96, bound to a specific deployed contract.
func NewFixedPoint96Transactor(address common.Address, transactor bind.ContractTransactor) (*FixedPoint96Transactor, error) {
	contract, err := bindFixedPoint96(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &FixedPoint96Transactor{contract: contract}, nil
}

// NewFixedPoint96Filterer creates a new log filterer instance of FixedPoint96, bound to a specific deployed contract.
func NewFixedPoint96Filterer(address common.Address, filterer bind.ContractFilterer) (*FixedPoint96Filterer, error) {
	contract, err := bindFixedPoint96(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &FixedPoint96Filterer{contract: contract}, nil
}

// bindFixedPoint96 binds a generic wrapper to an already deployed contract.
func bindFixedPoint96(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := FixedPoint96MetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_FixedPoint96 *FixedPoint96Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _FixedPoint96.Contract.FixedPoint96Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_FixedPoint96 *FixedPoint96Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _FixedPoint96.Contract.FixedPoint96Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_FixedPoint96 *FixedPoint96Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _FixedPoint96.Contract.FixedPoint96Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_FixedPoint96 *FixedPoint96CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _FixedPoint96.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_FixedPoint96 *FixedPoint96TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _FixedPoint96.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_FixedPoint96 *FixedPoint96TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _FixedPoint96.Contract.contract.Transact(opts, method, params...)
}

// FullMathMetaData contains all meta data concerning the FullMath contract.
var FullMathMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212202ed6c61bfc87c4068cd8caa5fabe7ead9f25d431c779d05d4e8ad802f88f306c64736f6c63430008140033",
}

// FullMathABI is the input ABI used to generate the binding from.
// Deprecated: Use FullMathMetaData.ABI instead.
var FullMathABI = FullMathMetaData.ABI

// FullMathBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use FullMathMetaData.Bin instead.
var FullMathBin = FullMathMetaData.Bin

// DeployFullMath deploys a new Ethereum contract, binding an instance of FullMath to it.
func DeployFullMath(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *FullMath, error) {
	parsed, err := FullMathMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(FullMathBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &FullMath{FullMathCaller: FullMathCaller{contract: contract}, FullMathTransactor: FullMathTransactor{contract: contract}, FullMathFilterer: FullMathFilterer{contract: contract}}, nil
}

// FullMath is an auto generated Go binding around an Ethereum contract.
type FullMath struct {
	FullMathCaller     // Read-only binding to the contract
	FullMathTransactor // Write-only binding to the contract
	FullMathFilterer   // Log filterer for contract events
}

// FullMathCaller is an auto generated read-only Go binding around an Ethereum contract.
type FullMathCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FullMathTransactor is an auto generated write-only Go binding around an Ethereum contract.
type FullMathTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FullMathFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type FullMathFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FullMathSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type FullMathSession struct {
	Contract     *FullMath         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// FullMathCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type FullMathCallerSession struct {
	Contract *FullMathCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// FullMathTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type FullMathTransactorSession struct {
	Contract     *FullMathTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// FullMathRaw is an auto generated low-level Go binding around an Ethereum contract.
type FullMathRaw struct {
	Contract *FullMath // Generic contract binding to access the raw methods on
}

// FullMathCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type FullMathCallerRaw struct {
	Contract *FullMathCaller // Generic read-only contract binding to access the raw methods on
}

// FullMathTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type FullMathTransactorRaw struct {
	Contract *FullMathTransactor // Generic write-only contract binding to access the raw methods on
}

// NewFullMath creates a new instance of FullMath, bound to a specific deployed contract.
func NewFullMath(address common.Address, backend bind.ContractBackend) (*FullMath, error) {
	contract, err := bindFullMath(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &FullMath{FullMathCaller: FullMathCaller{contract: contract}, FullMathTransactor: FullMathTransactor{contract: contract}, FullMathFilterer: FullMathFilterer{contract: contract}}, nil
}

// NewFullMathCaller creates a new read-only instance of FullMath, bound to a specific deployed contract.
func NewFullMathCaller(address common.Address, caller bind.ContractCaller) (*FullMathCaller, error) {
	contract, err := bindFullMath(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &FullMathCaller{contract: contract}, nil
}

// NewFullMathTransactor creates a new write-only instance of FullMath, bound to a specific deployed contract.
func NewFullMathTransactor(address common.Address, transactor bind.ContractTransactor) (*FullMathTransactor, error) {
	contract, err := bindFullMath(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &FullMathTransactor{contract: contract}, nil
}

// NewFullMathFilterer creates a new log filterer instance of FullMath, bound to a specific deployed contract.
func NewFullMathFilterer(address common.Address, filterer bind.ContractFilterer) (*FullMathFilterer, error) {
	contract, err := bindFullMath(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &FullMathFilterer{contract: contract}, nil
}

// bindFullMath binds a generic wrapper to an already deployed contract.
func bindFullMath(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := FullMathMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_FullMath *FullMathRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _FullMath.Contract.FullMathCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_FullMath *FullMathRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _FullMath.Contract.FullMathTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_FullMath *FullMathRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _FullMath.Contract.FullMathTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_FullMath *FullMathCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _FullMath.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_FullMath *FullMathTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _FullMath.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_FullMath *FullMathTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _FullMath.Contract.contract.Transact(opts, method, params...)
}

// HelpersMetaData contains all meta data concerning the Helpers contract.
var HelpersMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea2646970667358221220886aea72f095839daeed114144d16b954abd9d734b4750b386e897a8b737905064736f6c63430008140033",
}

// HelpersABI is the input ABI used to generate the binding from.
// Deprecated: Use HelpersMetaData.ABI instead.
var HelpersABI = HelpersMetaData.ABI

// HelpersBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use HelpersMetaData.Bin instead.
var HelpersBin = HelpersMetaData.Bin

// DeployHelpers deploys a new Ethereum contract, binding an instance of Helpers to it.
func DeployHelpers(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Helpers, error) {
	parsed, err := HelpersMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(HelpersBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Helpers{HelpersCaller: HelpersCaller{contract: contract}, HelpersTransactor: HelpersTransactor{contract: contract}, HelpersFilterer: HelpersFilterer{contract: contract}}, nil
}

// Helpers is an auto generated Go binding around an Ethereum contract.
type Helpers struct {
	HelpersCaller     // Read-only binding to the contract
	HelpersTransactor // Write-only binding to the contract
	HelpersFilterer   // Log filterer for contract events
}

// HelpersCaller is an auto generated read-only Go binding around an Ethereum contract.
type HelpersCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// HelpersTransactor is an auto generated write-only Go binding around an Ethereum contract.
type HelpersTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// HelpersFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type HelpersFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// HelpersSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type HelpersSession struct {
	Contract     *Helpers          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// HelpersCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type HelpersCallerSession struct {
	Contract *HelpersCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// HelpersTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type HelpersTransactorSession struct {
	Contract     *HelpersTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// HelpersRaw is an auto generated low-level Go binding around an Ethereum contract.
type HelpersRaw struct {
	Contract *Helpers // Generic contract binding to access the raw methods on
}

// HelpersCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type HelpersCallerRaw struct {
	Contract *HelpersCaller // Generic read-only contract binding to access the raw methods on
}

// HelpersTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type HelpersTransactorRaw struct {
	Contract *HelpersTransactor // Generic write-only contract binding to access the raw methods on
}

// NewHelpers creates a new instance of Helpers, bound to a specific deployed contract.
func NewHelpers(address common.Address, backend bind.ContractBackend) (*Helpers, error) {
	contract, err := bindHelpers(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Helpers{HelpersCaller: HelpersCaller{contract: contract}, HelpersTransactor: HelpersTransactor{contract: contract}, HelpersFilterer: HelpersFilterer{contract: contract}}, nil
}

// NewHelpersCaller creates a new read-only instance of Helpers, bound to a specific deployed contract.
func NewHelpersCaller(address common.Address, caller bind.ContractCaller) (*HelpersCaller, error) {
	contract, err := bindHelpers(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &HelpersCaller{contract: contract}, nil
}

// NewHelpersTransactor creates a new write-only instance of Helpers, bound to a specific deployed contract.
func NewHelpersTransactor(address common.Address, transactor bind.ContractTransactor) (*HelpersTransactor, error) {
	contract, err := bindHelpers(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &HelpersTransactor{contract: contract}, nil
}

// NewHelpersFilterer creates a new log filterer instance of Helpers, bound to a specific deployed contract.
func NewHelpersFilterer(address common.Address, filterer bind.ContractFilterer) (*HelpersFilterer, error) {
	contract, err := bindHelpers(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &HelpersFilterer{contract: contract}, nil
}

// bindHelpers binds a generic wrapper to an already deployed contract.
func bindHelpers(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := HelpersMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Helpers *HelpersRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Helpers.Contract.HelpersCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Helpers *HelpersRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Helpers.Contract.HelpersTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Helpers *HelpersRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Helpers.Contract.HelpersTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Helpers *HelpersCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Helpers.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Helpers *HelpersTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Helpers.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Helpers *HelpersTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Helpers.Contract.contract.Transact(opts, method, params...)
}

// HooksMetaData contains all meta data concerning the Hooks contract.
var HooksMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hooks\",\"type\":\"address\"}],\"name\":\"HookAddressNotValid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidHookResponse\",\"type\":\"error\"}]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea264697066735822122042d822709753692908c3058f202b48f96b62bfdacbf6217ead2bdf2975ee0ad064736f6c63430008140033",
}

// HooksABI is the input ABI used to generate the binding from.
// Deprecated: Use HooksMetaData.ABI instead.
var HooksABI = HooksMetaData.ABI

// HooksBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use HooksMetaData.Bin instead.
var HooksBin = HooksMetaData.Bin

// DeployHooks deploys a new Ethereum contract, binding an instance of Hooks to it.
func DeployHooks(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Hooks, error) {
	parsed, err := HooksMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(HooksBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Hooks{HooksCaller: HooksCaller{contract: contract}, HooksTransactor: HooksTransactor{contract: contract}, HooksFilterer: HooksFilterer{contract: contract}}, nil
}

// Hooks is an auto generated Go binding around an Ethereum contract.
type Hooks struct {
	HooksCaller     // Read-only binding to the contract
	HooksTransactor // Write-only binding to the contract
	HooksFilterer   // Log filterer for contract events
}

// HooksCaller is an auto generated read-only Go binding around an Ethereum contract.
type HooksCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// HooksTransactor is an auto generated write-only Go binding around an Ethereum contract.
type HooksTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// HooksFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type HooksFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// HooksSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type HooksSession struct {
	Contract     *Hooks            // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// HooksCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type HooksCallerSession struct {
	Contract *HooksCaller  // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// HooksTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type HooksTransactorSession struct {
	Contract     *HooksTransactor  // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// HooksRaw is an auto generated low-level Go binding around an Ethereum contract.
type HooksRaw struct {
	Contract *Hooks // Generic contract binding to access the raw methods on
}

// HooksCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type HooksCallerRaw struct {
	Contract *HooksCaller // Generic read-only contract binding to access the raw methods on
}

// HooksTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type HooksTransactorRaw struct {
	Contract *HooksTransactor // Generic write-only contract binding to access the raw methods on
}

// NewHooks creates a new instance of Hooks, bound to a specific deployed contract.
func NewHooks(address common.Address, backend bind.ContractBackend) (*Hooks, error) {
	contract, err := bindHooks(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Hooks{HooksCaller: HooksCaller{contract: contract}, HooksTransactor: HooksTransactor{contract: contract}, HooksFilterer: HooksFilterer{contract: contract}}, nil
}

// NewHooksCaller creates a new read-only instance of Hooks, bound to a specific deployed contract.
func NewHooksCaller(address common.Address, caller bind.ContractCaller) (*HooksCaller, error) {
	contract, err := bindHooks(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &HooksCaller{contract: contract}, nil
}

// NewHooksTransactor creates a new write-only instance of Hooks, bound to a specific deployed contract.
func NewHooksTransactor(address common.Address, transactor bind.ContractTransactor) (*HooksTransactor, error) {
	contract, err := bindHooks(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &HooksTransactor{contract: contract}, nil
}

// NewHooksFilterer creates a new log filterer instance of Hooks, bound to a specific deployed contract.
func NewHooksFilterer(address common.Address, filterer bind.ContractFilterer) (*HooksFilterer, error) {
	contract, err := bindHooks(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &HooksFilterer{contract: contract}, nil
}

// bindHooks binds a generic wrapper to an already deployed contract.
func bindHooks(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := HooksMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Hooks *HooksRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Hooks.Contract.HooksCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Hooks *HooksRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Hooks.Contract.HooksTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Hooks *HooksRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Hooks.Contract.HooksTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Hooks *HooksCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Hooks.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Hooks *HooksTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Hooks.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Hooks *HooksTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Hooks.Contract.contract.Transact(opts, method, params...)
}

// IAnchorBlocksMetaData contains all meta data concerning the IAnchorBlocks contract.
var IAnchorBlocksMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"}],\"name\":\"blocks\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// IAnchorBlocksABI is the input ABI used to generate the binding from.
// Deprecated: Use IAnchorBlocksMetaData.ABI instead.
var IAnchorBlocksABI = IAnchorBlocksMetaData.ABI

// IAnchorBlocks is an auto generated Go binding around an Ethereum contract.
type IAnchorBlocks struct {
	IAnchorBlocksCaller     // Read-only binding to the contract
	IAnchorBlocksTransactor // Write-only binding to the contract
	IAnchorBlocksFilterer   // Log filterer for contract events
}

// IAnchorBlocksCaller is an auto generated read-only Go binding around an Ethereum contract.
type IAnchorBlocksCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAnchorBlocksTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IAnchorBlocksTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAnchorBlocksFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IAnchorBlocksFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAnchorBlocksSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IAnchorBlocksSession struct {
	Contract     *IAnchorBlocks    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IAnchorBlocksCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IAnchorBlocksCallerSession struct {
	Contract *IAnchorBlocksCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// IAnchorBlocksTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IAnchorBlocksTransactorSession struct {
	Contract     *IAnchorBlocksTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// IAnchorBlocksRaw is an auto generated low-level Go binding around an Ethereum contract.
type IAnchorBlocksRaw struct {
	Contract *IAnchorBlocks // Generic contract binding to access the raw methods on
}

// IAnchorBlocksCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IAnchorBlocksCallerRaw struct {
	Contract *IAnchorBlocksCaller // Generic read-only contract binding to access the raw methods on
}

// IAnchorBlocksTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IAnchorBlocksTransactorRaw struct {
	Contract *IAnchorBlocksTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIAnchorBlocks creates a new instance of IAnchorBlocks, bound to a specific deployed contract.
func NewIAnchorBlocks(address common.Address, backend bind.ContractBackend) (*IAnchorBlocks, error) {
	contract, err := bindIAnchorBlocks(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IAnchorBlocks{IAnchorBlocksCaller: IAnchorBlocksCaller{contract: contract}, IAnchorBlocksTransactor: IAnchorBlocksTransactor{contract: contract}, IAnchorBlocksFilterer: IAnchorBlocksFilterer{contract: contract}}, nil
}

// NewIAnchorBlocksCaller creates a new read-only instance of IAnchorBlocks, bound to a specific deployed contract.
func NewIAnchorBlocksCaller(address common.Address, caller bind.ContractCaller) (*IAnchorBlocksCaller, error) {
	contract, err := bindIAnchorBlocks(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IAnchorBlocksCaller{contract: contract}, nil
}

// NewIAnchorBlocksTransactor creates a new write-only instance of IAnchorBlocks, bound to a specific deployed contract.
func NewIAnchorBlocksTransactor(address common.Address, transactor bind.ContractTransactor) (*IAnchorBlocksTransactor, error) {
	contract, err := bindIAnchorBlocks(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IAnchorBlocksTransactor{contract: contract}, nil
}

// NewIAnchorBlocksFilterer creates a new log filterer instance of IAnchorBlocks, bound to a specific deployed contract.
func NewIAnchorBlocksFilterer(address common.Address, filterer bind.ContractFilterer) (*IAnchorBlocksFilterer, error) {
	contract, err := bindIAnchorBlocks(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IAnchorBlocksFilterer{contract: contract}, nil
}

// bindIAnchorBlocks binds a generic wrapper to an already deployed contract.
func bindIAnchorBlocks(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IAnchorBlocksMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IAnchorBlocks *IAnchorBlocksRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IAnchorBlocks.Contract.IAnchorBlocksCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IAnchorBlocks *IAnchorBlocksRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAnchorBlocks.Contract.IAnchorBlocksTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IAnchorBlocks *IAnchorBlocksRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IAnchorBlocks.Contract.IAnchorBlocksTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IAnchorBlocks *IAnchorBlocksCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IAnchorBlocks.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IAnchorBlocks *IAnchorBlocksTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAnchorBlocks.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IAnchorBlocks *IAnchorBlocksTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IAnchorBlocks.Contract.contract.Transact(opts, method, params...)
}

// Blocks is a free data retrieval call binding the contract method 0xf25b3f99.
//
// Solidity: function blocks(uint256 blockNum) view returns(bytes32)
func (_IAnchorBlocks *IAnchorBlocksCaller) Blocks(opts *bind.CallOpts, blockNum *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _IAnchorBlocks.contract.Call(opts, &out, "blocks", blockNum)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// Blocks is a free data retrieval call binding the contract method 0xf25b3f99.
//
// Solidity: function blocks(uint256 blockNum) view returns(bytes32)
func (_IAnchorBlocks *IAnchorBlocksSession) Blocks(blockNum *big.Int) ([32]byte, error) {
	return _IAnchorBlocks.Contract.Blocks(&_IAnchorBlocks.CallOpts, blockNum)
}

// Blocks is a free data retrieval call binding the contract method 0xf25b3f99.
//
// Solidity: function blocks(uint256 blockNum) view returns(bytes32)
func (_IAnchorBlocks *IAnchorBlocksCallerSession) Blocks(blockNum *big.Int) ([32]byte, error) {
	return _IAnchorBlocks.Contract.Blocks(&_IAnchorBlocks.CallOpts, blockNum)
}

// IAvsSigsVerifierMetaData contains all meta data concerning the IAvsSigsVerifier contract.
var IAvsSigsVerifierMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"msgHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"blockNum\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"uint32[]\",\"name\":\"nonSignerQuorumBitmapIndices\",\"type\":\"uint32[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"X\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Y\",\"type\":\"uint256\"}],\"internalType\":\"structIAvsSigsVerifier.BN254_G1Point[]\",\"name\":\"nonSignerPubkeys\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"X\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Y\",\"type\":\"uint256\"}],\"internalType\":\"structIAvsSigsVerifier.BN254_G1Point[]\",\"name\":\"quorumApks\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"X\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"Y\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIAvsSigsVerifier.BN254_G2Point\",\"name\":\"apkG2\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"X\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Y\",\"type\":\"uint256\"}],\"internalType\":\"structIAvsSigsVerifier.BN254_G1Point\",\"name\":\"sigma\",\"type\":\"tuple\"},{\"internalType\":\"uint32[]\",\"name\":\"quorumApkIndices\",\"type\":\"uint32[]\"},{\"internalType\":\"uint32[]\",\"name\":\"totalStakeIndices\",\"type\":\"uint32[]\"},{\"internalType\":\"uint32[][]\",\"name\":\"nonSignerStakeIndices\",\"type\":\"uint32[][]\"}],\"internalType\":\"structIAvsSigsVerifier.NonSignerStakesAndSignature\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"verifySigs\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// IAvsSigsVerifierABI is the input ABI used to generate the binding from.
// Deprecated: Use IAvsSigsVerifierMetaData.ABI instead.
var IAvsSigsVerifierABI = IAvsSigsVerifierMetaData.ABI

// IAvsSigsVerifier is an auto generated Go binding around an Ethereum contract.
type IAvsSigsVerifier struct {
	IAvsSigsVerifierCaller     // Read-only binding to the contract
	IAvsSigsVerifierTransactor // Write-only binding to the contract
	IAvsSigsVerifierFilterer   // Log filterer for contract events
}

// IAvsSigsVerifierCaller is an auto generated read-only Go binding around an Ethereum contract.
type IAvsSigsVerifierCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAvsSigsVerifierTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IAvsSigsVerifierTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAvsSigsVerifierFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IAvsSigsVerifierFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAvsSigsVerifierSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IAvsSigsVerifierSession struct {
	Contract     *IAvsSigsVerifier // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IAvsSigsVerifierCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IAvsSigsVerifierCallerSession struct {
	Contract *IAvsSigsVerifierCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts           // Call options to use throughout this session
}

// IAvsSigsVerifierTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IAvsSigsVerifierTransactorSession struct {
	Contract     *IAvsSigsVerifierTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts           // Transaction auth options to use throughout this session
}

// IAvsSigsVerifierRaw is an auto generated low-level Go binding around an Ethereum contract.
type IAvsSigsVerifierRaw struct {
	Contract *IAvsSigsVerifier // Generic contract binding to access the raw methods on
}

// IAvsSigsVerifierCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IAvsSigsVerifierCallerRaw struct {
	Contract *IAvsSigsVerifierCaller // Generic read-only contract binding to access the raw methods on
}

// IAvsSigsVerifierTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IAvsSigsVerifierTransactorRaw struct {
	Contract *IAvsSigsVerifierTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIAvsSigsVerifier creates a new instance of IAvsSigsVerifier, bound to a specific deployed contract.
func NewIAvsSigsVerifier(address common.Address, backend bind.ContractBackend) (*IAvsSigsVerifier, error) {
	contract, err := bindIAvsSigsVerifier(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IAvsSigsVerifier{IAvsSigsVerifierCaller: IAvsSigsVerifierCaller{contract: contract}, IAvsSigsVerifierTransactor: IAvsSigsVerifierTransactor{contract: contract}, IAvsSigsVerifierFilterer: IAvsSigsVerifierFilterer{contract: contract}}, nil
}

// NewIAvsSigsVerifierCaller creates a new read-only instance of IAvsSigsVerifier, bound to a specific deployed contract.
func NewIAvsSigsVerifierCaller(address common.Address, caller bind.ContractCaller) (*IAvsSigsVerifierCaller, error) {
	contract, err := bindIAvsSigsVerifier(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IAvsSigsVerifierCaller{contract: contract}, nil
}

// NewIAvsSigsVerifierTransactor creates a new write-only instance of IAvsSigsVerifier, bound to a specific deployed contract.
func NewIAvsSigsVerifierTransactor(address common.Address, transactor bind.ContractTransactor) (*IAvsSigsVerifierTransactor, error) {
	contract, err := bindIAvsSigsVerifier(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IAvsSigsVerifierTransactor{contract: contract}, nil
}

// NewIAvsSigsVerifierFilterer creates a new log filterer instance of IAvsSigsVerifier, bound to a specific deployed contract.
func NewIAvsSigsVerifierFilterer(address common.Address, filterer bind.ContractFilterer) (*IAvsSigsVerifierFilterer, error) {
	contract, err := bindIAvsSigsVerifier(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IAvsSigsVerifierFilterer{contract: contract}, nil
}

// bindIAvsSigsVerifier binds a generic wrapper to an already deployed contract.
func bindIAvsSigsVerifier(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IAvsSigsVerifierMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IAvsSigsVerifier *IAvsSigsVerifierRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IAvsSigsVerifier.Contract.IAvsSigsVerifierCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IAvsSigsVerifier *IAvsSigsVerifierRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAvsSigsVerifier.Contract.IAvsSigsVerifierTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IAvsSigsVerifier *IAvsSigsVerifierRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IAvsSigsVerifier.Contract.IAvsSigsVerifierTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IAvsSigsVerifier *IAvsSigsVerifierCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IAvsSigsVerifier.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IAvsSigsVerifier *IAvsSigsVerifierTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAvsSigsVerifier.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IAvsSigsVerifier *IAvsSigsVerifierTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IAvsSigsVerifier.Contract.contract.Transact(opts, method, params...)
}

// VerifySigs is a free data retrieval call binding the contract method 0x8539e132.
//
// Solidity: function verifySigs(bytes32 msgHash, uint64 blockNum, (uint32[],(uint256,uint256)[],(uint256,uint256)[],(uint256[2],uint256[2]),(uint256,uint256),uint32[],uint32[],uint32[][]) params) view returns()
func (_IAvsSigsVerifier *IAvsSigsVerifierCaller) VerifySigs(opts *bind.CallOpts, msgHash [32]byte, blockNum uint64, params IAvsSigsVerifierNonSignerStakesAndSignature) error {
	var out []interface{}
	err := _IAvsSigsVerifier.contract.Call(opts, &out, "verifySigs", msgHash, blockNum, params)

	if err != nil {
		return err
	}

	return err

}

// VerifySigs is a free data retrieval call binding the contract method 0x8539e132.
//
// Solidity: function verifySigs(bytes32 msgHash, uint64 blockNum, (uint32[],(uint256,uint256)[],(uint256,uint256)[],(uint256[2],uint256[2]),(uint256,uint256),uint32[],uint32[],uint32[][]) params) view returns()
func (_IAvsSigsVerifier *IAvsSigsVerifierSession) VerifySigs(msgHash [32]byte, blockNum uint64, params IAvsSigsVerifierNonSignerStakesAndSignature) error {
	return _IAvsSigsVerifier.Contract.VerifySigs(&_IAvsSigsVerifier.CallOpts, msgHash, blockNum, params)
}

// VerifySigs is a free data retrieval call binding the contract method 0x8539e132.
//
// Solidity: function verifySigs(bytes32 msgHash, uint64 blockNum, (uint32[],(uint256,uint256)[],(uint256,uint256)[],(uint256[2],uint256[2]),(uint256,uint256),uint32[],uint32[],uint32[][]) params) view returns()
func (_IAvsSigsVerifier *IAvsSigsVerifierCallerSession) VerifySigs(msgHash [32]byte, blockNum uint64, params IAvsSigsVerifierNonSignerStakesAndSignature) error {
	return _IAvsSigsVerifier.Contract.VerifySigs(&_IAvsSigsVerifier.CallOpts, msgHash, blockNum, params)
}

// IBeaconVerifierMetaData contains all meta data concerning the IBeaconVerifier contract.
var IBeaconVerifierMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"signingRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"syncCommitteePoseidonRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"participation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commitment\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commitment\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIBeaconVerifier.Proof\",\"name\":\"p\",\"type\":\"tuple\"}],\"name\":\"verifySignatureProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sszRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"poseidonRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commitment\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIBeaconVerifier.Proof\",\"name\":\"p\",\"type\":\"tuple\"}],\"name\":\"verifySyncCommitteeRootMappingProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// IBeaconVerifierABI is the input ABI used to generate the binding from.
// Deprecated: Use IBeaconVerifierMetaData.ABI instead.
var IBeaconVerifierABI = IBeaconVerifierMetaData.ABI

// IBeaconVerifier is an auto generated Go binding around an Ethereum contract.
type IBeaconVerifier struct {
	IBeaconVerifierCaller     // Read-only binding to the contract
	IBeaconVerifierTransactor // Write-only binding to the contract
	IBeaconVerifierFilterer   // Log filterer for contract events
}

// IBeaconVerifierCaller is an auto generated read-only Go binding around an Ethereum contract.
type IBeaconVerifierCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBeaconVerifierTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IBeaconVerifierTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBeaconVerifierFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IBeaconVerifierFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBeaconVerifierSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IBeaconVerifierSession struct {
	Contract     *IBeaconVerifier  // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IBeaconVerifierCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IBeaconVerifierCallerSession struct {
	Contract *IBeaconVerifierCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts          // Call options to use throughout this session
}

// IBeaconVerifierTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IBeaconVerifierTransactorSession struct {
	Contract     *IBeaconVerifierTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts          // Transaction auth options to use throughout this session
}

// IBeaconVerifierRaw is an auto generated low-level Go binding around an Ethereum contract.
type IBeaconVerifierRaw struct {
	Contract *IBeaconVerifier // Generic contract binding to access the raw methods on
}

// IBeaconVerifierCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IBeaconVerifierCallerRaw struct {
	Contract *IBeaconVerifierCaller // Generic read-only contract binding to access the raw methods on
}

// IBeaconVerifierTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IBeaconVerifierTransactorRaw struct {
	Contract *IBeaconVerifierTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIBeaconVerifier creates a new instance of IBeaconVerifier, bound to a specific deployed contract.
func NewIBeaconVerifier(address common.Address, backend bind.ContractBackend) (*IBeaconVerifier, error) {
	contract, err := bindIBeaconVerifier(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IBeaconVerifier{IBeaconVerifierCaller: IBeaconVerifierCaller{contract: contract}, IBeaconVerifierTransactor: IBeaconVerifierTransactor{contract: contract}, IBeaconVerifierFilterer: IBeaconVerifierFilterer{contract: contract}}, nil
}

// NewIBeaconVerifierCaller creates a new read-only instance of IBeaconVerifier, bound to a specific deployed contract.
func NewIBeaconVerifierCaller(address common.Address, caller bind.ContractCaller) (*IBeaconVerifierCaller, error) {
	contract, err := bindIBeaconVerifier(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IBeaconVerifierCaller{contract: contract}, nil
}

// NewIBeaconVerifierTransactor creates a new write-only instance of IBeaconVerifier, bound to a specific deployed contract.
func NewIBeaconVerifierTransactor(address common.Address, transactor bind.ContractTransactor) (*IBeaconVerifierTransactor, error) {
	contract, err := bindIBeaconVerifier(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IBeaconVerifierTransactor{contract: contract}, nil
}

// NewIBeaconVerifierFilterer creates a new log filterer instance of IBeaconVerifier, bound to a specific deployed contract.
func NewIBeaconVerifierFilterer(address common.Address, filterer bind.ContractFilterer) (*IBeaconVerifierFilterer, error) {
	contract, err := bindIBeaconVerifier(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IBeaconVerifierFilterer{contract: contract}, nil
}

// bindIBeaconVerifier binds a generic wrapper to an already deployed contract.
func bindIBeaconVerifier(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IBeaconVerifierMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBeaconVerifier *IBeaconVerifierRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBeaconVerifier.Contract.IBeaconVerifierCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBeaconVerifier *IBeaconVerifierRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBeaconVerifier.Contract.IBeaconVerifierTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBeaconVerifier *IBeaconVerifierRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBeaconVerifier.Contract.IBeaconVerifierTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBeaconVerifier *IBeaconVerifierCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBeaconVerifier.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBeaconVerifier *IBeaconVerifierTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBeaconVerifier.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBeaconVerifier *IBeaconVerifierTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBeaconVerifier.Contract.contract.Transact(opts, method, params...)
}

// VerifySignatureProof is a free data retrieval call binding the contract method 0x52356da0.
//
// Solidity: function verifySignatureProof(bytes32 signingRoot, bytes32 syncCommitteePoseidonRoot, uint256 participation, uint256 commitment, (uint256[2],uint256[2][2],uint256[2],uint256[2]) p) view returns(bool)
func (_IBeaconVerifier *IBeaconVerifierCaller) VerifySignatureProof(opts *bind.CallOpts, signingRoot [32]byte, syncCommitteePoseidonRoot [32]byte, participation *big.Int, commitment *big.Int, p IBeaconVerifierProof) (bool, error) {
	var out []interface{}
	err := _IBeaconVerifier.contract.Call(opts, &out, "verifySignatureProof", signingRoot, syncCommitteePoseidonRoot, participation, commitment, p)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// VerifySignatureProof is a free data retrieval call binding the contract method 0x52356da0.
//
// Solidity: function verifySignatureProof(bytes32 signingRoot, bytes32 syncCommitteePoseidonRoot, uint256 participation, uint256 commitment, (uint256[2],uint256[2][2],uint256[2],uint256[2]) p) view returns(bool)
func (_IBeaconVerifier *IBeaconVerifierSession) VerifySignatureProof(signingRoot [32]byte, syncCommitteePoseidonRoot [32]byte, participation *big.Int, commitment *big.Int, p IBeaconVerifierProof) (bool, error) {
	return _IBeaconVerifier.Contract.VerifySignatureProof(&_IBeaconVerifier.CallOpts, signingRoot, syncCommitteePoseidonRoot, participation, commitment, p)
}

// VerifySignatureProof is a free data retrieval call binding the contract method 0x52356da0.
//
// Solidity: function verifySignatureProof(bytes32 signingRoot, bytes32 syncCommitteePoseidonRoot, uint256 participation, uint256 commitment, (uint256[2],uint256[2][2],uint256[2],uint256[2]) p) view returns(bool)
func (_IBeaconVerifier *IBeaconVerifierCallerSession) VerifySignatureProof(signingRoot [32]byte, syncCommitteePoseidonRoot [32]byte, participation *big.Int, commitment *big.Int, p IBeaconVerifierProof) (bool, error) {
	return _IBeaconVerifier.Contract.VerifySignatureProof(&_IBeaconVerifier.CallOpts, signingRoot, syncCommitteePoseidonRoot, participation, commitment, p)
}

// VerifySyncCommitteeRootMappingProof is a free data retrieval call binding the contract method 0x7a538781.
//
// Solidity: function verifySyncCommitteeRootMappingProof(bytes32 sszRoot, bytes32 poseidonRoot, (uint256[2],uint256[2][2],uint256[2],uint256[2]) p) view returns(bool)
func (_IBeaconVerifier *IBeaconVerifierCaller) VerifySyncCommitteeRootMappingProof(opts *bind.CallOpts, sszRoot [32]byte, poseidonRoot [32]byte, p IBeaconVerifierProof) (bool, error) {
	var out []interface{}
	err := _IBeaconVerifier.contract.Call(opts, &out, "verifySyncCommitteeRootMappingProof", sszRoot, poseidonRoot, p)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// VerifySyncCommitteeRootMappingProof is a free data retrieval call binding the contract method 0x7a538781.
//
// Solidity: function verifySyncCommitteeRootMappingProof(bytes32 sszRoot, bytes32 poseidonRoot, (uint256[2],uint256[2][2],uint256[2],uint256[2]) p) view returns(bool)
func (_IBeaconVerifier *IBeaconVerifierSession) VerifySyncCommitteeRootMappingProof(sszRoot [32]byte, poseidonRoot [32]byte, p IBeaconVerifierProof) (bool, error) {
	return _IBeaconVerifier.Contract.VerifySyncCommitteeRootMappingProof(&_IBeaconVerifier.CallOpts, sszRoot, poseidonRoot, p)
}

// VerifySyncCommitteeRootMappingProof is a free data retrieval call binding the contract method 0x7a538781.
//
// Solidity: function verifySyncCommitteeRootMappingProof(bytes32 sszRoot, bytes32 poseidonRoot, (uint256[2],uint256[2][2],uint256[2],uint256[2]) p) view returns(bool)
func (_IBeaconVerifier *IBeaconVerifierCallerSession) VerifySyncCommitteeRootMappingProof(sszRoot [32]byte, poseidonRoot [32]byte, p IBeaconVerifierProof) (bool, error) {
	return _IBeaconVerifier.Contract.VerifySyncCommitteeRootMappingProof(&_IBeaconVerifier.CallOpts, sszRoot, poseidonRoot, p)
}

// IBlockChunksMetaData contains all meta data concerning the IBlockChunks contract.
var IBlockChunksMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"startBlockNumber\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"prevHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"numFinal\",\"type\":\"uint32\"}],\"name\":\"UpdateEvent\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"startBlockNumber\",\"type\":\"uint32\"}],\"name\":\"historicalRoots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"claimedBlkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"prevHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"numFinal\",\"type\":\"uint32\"},{\"internalType\":\"bytes32[7]\",\"name\":\"merkleProof\",\"type\":\"bytes32[7]\"}],\"internalType\":\"structIBlockChunks.BlockHashWitness\",\"name\":\"witness\",\"type\":\"tuple\"}],\"name\":\"isBlockHashValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"nextRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"nextNumFinal\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"}],\"name\":\"updateOld\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"}],\"name\":\"updateRecent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IBlockChunksABI is the input ABI used to generate the binding from.
// Deprecated: Use IBlockChunksMetaData.ABI instead.
var IBlockChunksABI = IBlockChunksMetaData.ABI

// IBlockChunks is an auto generated Go binding around an Ethereum contract.
type IBlockChunks struct {
	IBlockChunksCaller     // Read-only binding to the contract
	IBlockChunksTransactor // Write-only binding to the contract
	IBlockChunksFilterer   // Log filterer for contract events
}

// IBlockChunksCaller is an auto generated read-only Go binding around an Ethereum contract.
type IBlockChunksCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBlockChunksTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IBlockChunksTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBlockChunksFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IBlockChunksFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBlockChunksSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IBlockChunksSession struct {
	Contract     *IBlockChunks     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IBlockChunksCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IBlockChunksCallerSession struct {
	Contract *IBlockChunksCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// IBlockChunksTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IBlockChunksTransactorSession struct {
	Contract     *IBlockChunksTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// IBlockChunksRaw is an auto generated low-level Go binding around an Ethereum contract.
type IBlockChunksRaw struct {
	Contract *IBlockChunks // Generic contract binding to access the raw methods on
}

// IBlockChunksCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IBlockChunksCallerRaw struct {
	Contract *IBlockChunksCaller // Generic read-only contract binding to access the raw methods on
}

// IBlockChunksTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IBlockChunksTransactorRaw struct {
	Contract *IBlockChunksTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIBlockChunks creates a new instance of IBlockChunks, bound to a specific deployed contract.
func NewIBlockChunks(address common.Address, backend bind.ContractBackend) (*IBlockChunks, error) {
	contract, err := bindIBlockChunks(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IBlockChunks{IBlockChunksCaller: IBlockChunksCaller{contract: contract}, IBlockChunksTransactor: IBlockChunksTransactor{contract: contract}, IBlockChunksFilterer: IBlockChunksFilterer{contract: contract}}, nil
}

// NewIBlockChunksCaller creates a new read-only instance of IBlockChunks, bound to a specific deployed contract.
func NewIBlockChunksCaller(address common.Address, caller bind.ContractCaller) (*IBlockChunksCaller, error) {
	contract, err := bindIBlockChunks(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IBlockChunksCaller{contract: contract}, nil
}

// NewIBlockChunksTransactor creates a new write-only instance of IBlockChunks, bound to a specific deployed contract.
func NewIBlockChunksTransactor(address common.Address, transactor bind.ContractTransactor) (*IBlockChunksTransactor, error) {
	contract, err := bindIBlockChunks(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IBlockChunksTransactor{contract: contract}, nil
}

// NewIBlockChunksFilterer creates a new log filterer instance of IBlockChunks, bound to a specific deployed contract.
func NewIBlockChunksFilterer(address common.Address, filterer bind.ContractFilterer) (*IBlockChunksFilterer, error) {
	contract, err := bindIBlockChunks(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IBlockChunksFilterer{contract: contract}, nil
}

// bindIBlockChunks binds a generic wrapper to an already deployed contract.
func bindIBlockChunks(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IBlockChunksMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBlockChunks *IBlockChunksRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBlockChunks.Contract.IBlockChunksCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBlockChunks *IBlockChunksRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBlockChunks.Contract.IBlockChunksTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBlockChunks *IBlockChunksRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBlockChunks.Contract.IBlockChunksTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBlockChunks *IBlockChunksCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBlockChunks.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBlockChunks *IBlockChunksTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBlockChunks.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBlockChunks *IBlockChunksTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBlockChunks.Contract.contract.Transact(opts, method, params...)
}

// HistoricalRoots is a free data retrieval call binding the contract method 0xb551a187.
//
// Solidity: function historicalRoots(uint64 chainId, uint32 startBlockNumber) view returns(bytes32)
func (_IBlockChunks *IBlockChunksCaller) HistoricalRoots(opts *bind.CallOpts, chainId uint64, startBlockNumber uint32) ([32]byte, error) {
	var out []interface{}
	err := _IBlockChunks.contract.Call(opts, &out, "historicalRoots", chainId, startBlockNumber)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// HistoricalRoots is a free data retrieval call binding the contract method 0xb551a187.
//
// Solidity: function historicalRoots(uint64 chainId, uint32 startBlockNumber) view returns(bytes32)
func (_IBlockChunks *IBlockChunksSession) HistoricalRoots(chainId uint64, startBlockNumber uint32) ([32]byte, error) {
	return _IBlockChunks.Contract.HistoricalRoots(&_IBlockChunks.CallOpts, chainId, startBlockNumber)
}

// HistoricalRoots is a free data retrieval call binding the contract method 0xb551a187.
//
// Solidity: function historicalRoots(uint64 chainId, uint32 startBlockNumber) view returns(bytes32)
func (_IBlockChunks *IBlockChunksCallerSession) HistoricalRoots(chainId uint64, startBlockNumber uint32) ([32]byte, error) {
	return _IBlockChunks.Contract.HistoricalRoots(&_IBlockChunks.CallOpts, chainId, startBlockNumber)
}

// IsBlockHashValid is a free data retrieval call binding the contract method 0x544f73a4.
//
// Solidity: function isBlockHashValid((uint64,uint32,bytes32,bytes32,uint32,bytes32[7]) witness) view returns(bool)
func (_IBlockChunks *IBlockChunksCaller) IsBlockHashValid(opts *bind.CallOpts, witness IBlockChunksBlockHashWitness) (bool, error) {
	var out []interface{}
	err := _IBlockChunks.contract.Call(opts, &out, "isBlockHashValid", witness)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsBlockHashValid is a free data retrieval call binding the contract method 0x544f73a4.
//
// Solidity: function isBlockHashValid((uint64,uint32,bytes32,bytes32,uint32,bytes32[7]) witness) view returns(bool)
func (_IBlockChunks *IBlockChunksSession) IsBlockHashValid(witness IBlockChunksBlockHashWitness) (bool, error) {
	return _IBlockChunks.Contract.IsBlockHashValid(&_IBlockChunks.CallOpts, witness)
}

// IsBlockHashValid is a free data retrieval call binding the contract method 0x544f73a4.
//
// Solidity: function isBlockHashValid((uint64,uint32,bytes32,bytes32,uint32,bytes32[7]) witness) view returns(bool)
func (_IBlockChunks *IBlockChunksCallerSession) IsBlockHashValid(witness IBlockChunksBlockHashWitness) (bool, error) {
	return _IBlockChunks.Contract.IsBlockHashValid(&_IBlockChunks.CallOpts, witness)
}

// UpdateOld is a paid mutator transaction binding the contract method 0x52cfc560.
//
// Solidity: function updateOld(uint64 chainId, bytes32 nextRoot, uint32 nextNumFinal, bytes proofData) returns()
func (_IBlockChunks *IBlockChunksTransactor) UpdateOld(opts *bind.TransactOpts, chainId uint64, nextRoot [32]byte, nextNumFinal uint32, proofData []byte) (*types.Transaction, error) {
	return _IBlockChunks.contract.Transact(opts, "updateOld", chainId, nextRoot, nextNumFinal, proofData)
}

// UpdateOld is a paid mutator transaction binding the contract method 0x52cfc560.
//
// Solidity: function updateOld(uint64 chainId, bytes32 nextRoot, uint32 nextNumFinal, bytes proofData) returns()
func (_IBlockChunks *IBlockChunksSession) UpdateOld(chainId uint64, nextRoot [32]byte, nextNumFinal uint32, proofData []byte) (*types.Transaction, error) {
	return _IBlockChunks.Contract.UpdateOld(&_IBlockChunks.TransactOpts, chainId, nextRoot, nextNumFinal, proofData)
}

// UpdateOld is a paid mutator transaction binding the contract method 0x52cfc560.
//
// Solidity: function updateOld(uint64 chainId, bytes32 nextRoot, uint32 nextNumFinal, bytes proofData) returns()
func (_IBlockChunks *IBlockChunksTransactorSession) UpdateOld(chainId uint64, nextRoot [32]byte, nextNumFinal uint32, proofData []byte) (*types.Transaction, error) {
	return _IBlockChunks.Contract.UpdateOld(&_IBlockChunks.TransactOpts, chainId, nextRoot, nextNumFinal, proofData)
}

// UpdateRecent is a paid mutator transaction binding the contract method 0x50a26d48.
//
// Solidity: function updateRecent(uint64 chainId, bytes proofData) returns()
func (_IBlockChunks *IBlockChunksTransactor) UpdateRecent(opts *bind.TransactOpts, chainId uint64, proofData []byte) (*types.Transaction, error) {
	return _IBlockChunks.contract.Transact(opts, "updateRecent", chainId, proofData)
}

// UpdateRecent is a paid mutator transaction binding the contract method 0x50a26d48.
//
// Solidity: function updateRecent(uint64 chainId, bytes proofData) returns()
func (_IBlockChunks *IBlockChunksSession) UpdateRecent(chainId uint64, proofData []byte) (*types.Transaction, error) {
	return _IBlockChunks.Contract.UpdateRecent(&_IBlockChunks.TransactOpts, chainId, proofData)
}

// UpdateRecent is a paid mutator transaction binding the contract method 0x50a26d48.
//
// Solidity: function updateRecent(uint64 chainId, bytes proofData) returns()
func (_IBlockChunks *IBlockChunksTransactorSession) UpdateRecent(chainId uint64, proofData []byte) (*types.Transaction, error) {
	return _IBlockChunks.Contract.UpdateRecent(&_IBlockChunks.TransactOpts, chainId, proofData)
}

// IBlockChunksUpdateEventIterator is returned from FilterUpdateEvent and is used to iterate over the raw logs and unpacked data for UpdateEvent events raised by the IBlockChunks contract.
type IBlockChunksUpdateEventIterator struct {
	Event *IBlockChunksUpdateEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IBlockChunksUpdateEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IBlockChunksUpdateEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IBlockChunksUpdateEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IBlockChunksUpdateEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IBlockChunksUpdateEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IBlockChunksUpdateEvent represents a UpdateEvent event raised by the IBlockChunks contract.
type IBlockChunksUpdateEvent struct {
	ChainId          uint64
	StartBlockNumber uint32
	PrevHash         [32]byte
	Root             [32]byte
	NumFinal         uint32
	Raw              types.Log // Blockchain specific contextual infos
}

// FilterUpdateEvent is a free log retrieval operation binding the contract event 0xa946b3d79b3150fec8e4d9ccc6100de98308a472f1ba57d23aeda162bb86e33e.
//
// Solidity: event UpdateEvent(uint64 chainId, uint32 startBlockNumber, bytes32 prevHash, bytes32 root, uint32 numFinal)
func (_IBlockChunks *IBlockChunksFilterer) FilterUpdateEvent(opts *bind.FilterOpts) (*IBlockChunksUpdateEventIterator, error) {

	logs, sub, err := _IBlockChunks.contract.FilterLogs(opts, "UpdateEvent")
	if err != nil {
		return nil, err
	}
	return &IBlockChunksUpdateEventIterator{contract: _IBlockChunks.contract, event: "UpdateEvent", logs: logs, sub: sub}, nil
}

// WatchUpdateEvent is a free log subscription operation binding the contract event 0xa946b3d79b3150fec8e4d9ccc6100de98308a472f1ba57d23aeda162bb86e33e.
//
// Solidity: event UpdateEvent(uint64 chainId, uint32 startBlockNumber, bytes32 prevHash, bytes32 root, uint32 numFinal)
func (_IBlockChunks *IBlockChunksFilterer) WatchUpdateEvent(opts *bind.WatchOpts, sink chan<- *IBlockChunksUpdateEvent) (event.Subscription, error) {

	logs, sub, err := _IBlockChunks.contract.WatchLogs(opts, "UpdateEvent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IBlockChunksUpdateEvent)
				if err := _IBlockChunks.contract.UnpackLog(event, "UpdateEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdateEvent is a log parse operation binding the contract event 0xa946b3d79b3150fec8e4d9ccc6100de98308a472f1ba57d23aeda162bb86e33e.
//
// Solidity: event UpdateEvent(uint64 chainId, uint32 startBlockNumber, bytes32 prevHash, bytes32 root, uint32 numFinal)
func (_IBlockChunks *IBlockChunksFilterer) ParseUpdateEvent(log types.Log) (*IBlockChunksUpdateEvent, error) {
	event := new(IBlockChunksUpdateEvent)
	if err := _IBlockChunks.contract.UnpackLog(event, "UpdateEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IBrevisAppMetaData contains all meta data concerning the IBrevisApp contract.
var IBrevisAppMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_appVkHashs\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_appCircuitOutputs\",\"type\":\"bytes[]\"}],\"name\":\"brevisBatchCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_appCircuitOutput\",\"type\":\"bytes\"}],\"name\":\"brevisCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IBrevisAppABI is the input ABI used to generate the binding from.
// Deprecated: Use IBrevisAppMetaData.ABI instead.
var IBrevisAppABI = IBrevisAppMetaData.ABI

// IBrevisApp is an auto generated Go binding around an Ethereum contract.
type IBrevisApp struct {
	IBrevisAppCaller     // Read-only binding to the contract
	IBrevisAppTransactor // Write-only binding to the contract
	IBrevisAppFilterer   // Log filterer for contract events
}

// IBrevisAppCaller is an auto generated read-only Go binding around an Ethereum contract.
type IBrevisAppCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBrevisAppTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IBrevisAppTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBrevisAppFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IBrevisAppFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBrevisAppSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IBrevisAppSession struct {
	Contract     *IBrevisApp       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IBrevisAppCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IBrevisAppCallerSession struct {
	Contract *IBrevisAppCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// IBrevisAppTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IBrevisAppTransactorSession struct {
	Contract     *IBrevisAppTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// IBrevisAppRaw is an auto generated low-level Go binding around an Ethereum contract.
type IBrevisAppRaw struct {
	Contract *IBrevisApp // Generic contract binding to access the raw methods on
}

// IBrevisAppCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IBrevisAppCallerRaw struct {
	Contract *IBrevisAppCaller // Generic read-only contract binding to access the raw methods on
}

// IBrevisAppTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IBrevisAppTransactorRaw struct {
	Contract *IBrevisAppTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIBrevisApp creates a new instance of IBrevisApp, bound to a specific deployed contract.
func NewIBrevisApp(address common.Address, backend bind.ContractBackend) (*IBrevisApp, error) {
	contract, err := bindIBrevisApp(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IBrevisApp{IBrevisAppCaller: IBrevisAppCaller{contract: contract}, IBrevisAppTransactor: IBrevisAppTransactor{contract: contract}, IBrevisAppFilterer: IBrevisAppFilterer{contract: contract}}, nil
}

// NewIBrevisAppCaller creates a new read-only instance of IBrevisApp, bound to a specific deployed contract.
func NewIBrevisAppCaller(address common.Address, caller bind.ContractCaller) (*IBrevisAppCaller, error) {
	contract, err := bindIBrevisApp(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IBrevisAppCaller{contract: contract}, nil
}

// NewIBrevisAppTransactor creates a new write-only instance of IBrevisApp, bound to a specific deployed contract.
func NewIBrevisAppTransactor(address common.Address, transactor bind.ContractTransactor) (*IBrevisAppTransactor, error) {
	contract, err := bindIBrevisApp(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IBrevisAppTransactor{contract: contract}, nil
}

// NewIBrevisAppFilterer creates a new log filterer instance of IBrevisApp, bound to a specific deployed contract.
func NewIBrevisAppFilterer(address common.Address, filterer bind.ContractFilterer) (*IBrevisAppFilterer, error) {
	contract, err := bindIBrevisApp(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IBrevisAppFilterer{contract: contract}, nil
}

// bindIBrevisApp binds a generic wrapper to an already deployed contract.
func bindIBrevisApp(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IBrevisAppMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBrevisApp *IBrevisAppRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBrevisApp.Contract.IBrevisAppCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBrevisApp *IBrevisAppRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBrevisApp.Contract.IBrevisAppTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBrevisApp *IBrevisAppRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBrevisApp.Contract.IBrevisAppTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBrevisApp *IBrevisAppCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBrevisApp.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBrevisApp *IBrevisAppTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBrevisApp.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBrevisApp *IBrevisAppTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBrevisApp.Contract.contract.Transact(opts, method, params...)
}

// BrevisBatchCallback is a paid mutator transaction binding the contract method 0x3bca02fc.
//
// Solidity: function brevisBatchCallback(bytes32[] _appVkHashs, bytes[] _appCircuitOutputs) returns()
func (_IBrevisApp *IBrevisAppTransactor) BrevisBatchCallback(opts *bind.TransactOpts, _appVkHashs [][32]byte, _appCircuitOutputs [][]byte) (*types.Transaction, error) {
	return _IBrevisApp.contract.Transact(opts, "brevisBatchCallback", _appVkHashs, _appCircuitOutputs)
}

// BrevisBatchCallback is a paid mutator transaction binding the contract method 0x3bca02fc.
//
// Solidity: function brevisBatchCallback(bytes32[] _appVkHashs, bytes[] _appCircuitOutputs) returns()
func (_IBrevisApp *IBrevisAppSession) BrevisBatchCallback(_appVkHashs [][32]byte, _appCircuitOutputs [][]byte) (*types.Transaction, error) {
	return _IBrevisApp.Contract.BrevisBatchCallback(&_IBrevisApp.TransactOpts, _appVkHashs, _appCircuitOutputs)
}

// BrevisBatchCallback is a paid mutator transaction binding the contract method 0x3bca02fc.
//
// Solidity: function brevisBatchCallback(bytes32[] _appVkHashs, bytes[] _appCircuitOutputs) returns()
func (_IBrevisApp *IBrevisAppTransactorSession) BrevisBatchCallback(_appVkHashs [][32]byte, _appCircuitOutputs [][]byte) (*types.Transaction, error) {
	return _IBrevisApp.Contract.BrevisBatchCallback(&_IBrevisApp.TransactOpts, _appVkHashs, _appCircuitOutputs)
}

// BrevisCallback is a paid mutator transaction binding the contract method 0x79d6b6a2.
//
// Solidity: function brevisCallback(bytes32 _appVkHash, bytes _appCircuitOutput) returns()
func (_IBrevisApp *IBrevisAppTransactor) BrevisCallback(opts *bind.TransactOpts, _appVkHash [32]byte, _appCircuitOutput []byte) (*types.Transaction, error) {
	return _IBrevisApp.contract.Transact(opts, "brevisCallback", _appVkHash, _appCircuitOutput)
}

// BrevisCallback is a paid mutator transaction binding the contract method 0x79d6b6a2.
//
// Solidity: function brevisCallback(bytes32 _appVkHash, bytes _appCircuitOutput) returns()
func (_IBrevisApp *IBrevisAppSession) BrevisCallback(_appVkHash [32]byte, _appCircuitOutput []byte) (*types.Transaction, error) {
	return _IBrevisApp.Contract.BrevisCallback(&_IBrevisApp.TransactOpts, _appVkHash, _appCircuitOutput)
}

// BrevisCallback is a paid mutator transaction binding the contract method 0x79d6b6a2.
//
// Solidity: function brevisCallback(bytes32 _appVkHash, bytes _appCircuitOutput) returns()
func (_IBrevisApp *IBrevisAppTransactorSession) BrevisCallback(_appVkHash [32]byte, _appCircuitOutput []byte) (*types.Transaction, error) {
	return _IBrevisApp.Contract.BrevisCallback(&_IBrevisApp.TransactOpts, _appVkHash, _appCircuitOutput)
}

// IBrevisDisputeMetaData contains all meta data concerning the IBrevisDispute contract.
var IBrevisDisputeMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"proofId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"enumIBrevisTypes.DisputeStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"AskFor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"ChallengeWindowUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"proofId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"name\":\"DataAvailabilityProofPosted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"proofId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"name\":\"DataValidityProofProofPosted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amtAskForData\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amtAskForProof\",\"type\":\"uint256\"}],\"name\":\"DisputeDepositsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"proofId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"done\",\"type\":\"bool\"}],\"name\":\"RequestDataPosted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"ResponseTimeoutUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"askForDataAvailabilityProof\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"askForDataValidityProof\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"askForRequestData\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChallengeWindow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_requestKey\",\"type\":\"bytes32\"}],\"name\":\"getDisputeStatus\",\"outputs\":[{\"internalType\":\"enumIBrevisTypes.DisputeStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_requestKey\",\"type\":\"bytes32\"}],\"name\":\"getResponseDeadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"}],\"name\":\"postDataAvailabilityProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"}],\"name\":\"postDataValidityProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes[]\",\"name\":\"_requestData\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_done\",\"type\":\"bool\"}],\"name\":\"postRequestData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IBrevisDisputeABI is the input ABI used to generate the binding from.
// Deprecated: Use IBrevisDisputeMetaData.ABI instead.
var IBrevisDisputeABI = IBrevisDisputeMetaData.ABI

// IBrevisDispute is an auto generated Go binding around an Ethereum contract.
type IBrevisDispute struct {
	IBrevisDisputeCaller     // Read-only binding to the contract
	IBrevisDisputeTransactor // Write-only binding to the contract
	IBrevisDisputeFilterer   // Log filterer for contract events
}

// IBrevisDisputeCaller is an auto generated read-only Go binding around an Ethereum contract.
type IBrevisDisputeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBrevisDisputeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IBrevisDisputeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBrevisDisputeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IBrevisDisputeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBrevisDisputeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IBrevisDisputeSession struct {
	Contract     *IBrevisDispute   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IBrevisDisputeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IBrevisDisputeCallerSession struct {
	Contract *IBrevisDisputeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// IBrevisDisputeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IBrevisDisputeTransactorSession struct {
	Contract     *IBrevisDisputeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// IBrevisDisputeRaw is an auto generated low-level Go binding around an Ethereum contract.
type IBrevisDisputeRaw struct {
	Contract *IBrevisDispute // Generic contract binding to access the raw methods on
}

// IBrevisDisputeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IBrevisDisputeCallerRaw struct {
	Contract *IBrevisDisputeCaller // Generic read-only contract binding to access the raw methods on
}

// IBrevisDisputeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IBrevisDisputeTransactorRaw struct {
	Contract *IBrevisDisputeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIBrevisDispute creates a new instance of IBrevisDispute, bound to a specific deployed contract.
func NewIBrevisDispute(address common.Address, backend bind.ContractBackend) (*IBrevisDispute, error) {
	contract, err := bindIBrevisDispute(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IBrevisDispute{IBrevisDisputeCaller: IBrevisDisputeCaller{contract: contract}, IBrevisDisputeTransactor: IBrevisDisputeTransactor{contract: contract}, IBrevisDisputeFilterer: IBrevisDisputeFilterer{contract: contract}}, nil
}

// NewIBrevisDisputeCaller creates a new read-only instance of IBrevisDispute, bound to a specific deployed contract.
func NewIBrevisDisputeCaller(address common.Address, caller bind.ContractCaller) (*IBrevisDisputeCaller, error) {
	contract, err := bindIBrevisDispute(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IBrevisDisputeCaller{contract: contract}, nil
}

// NewIBrevisDisputeTransactor creates a new write-only instance of IBrevisDispute, bound to a specific deployed contract.
func NewIBrevisDisputeTransactor(address common.Address, transactor bind.ContractTransactor) (*IBrevisDisputeTransactor, error) {
	contract, err := bindIBrevisDispute(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IBrevisDisputeTransactor{contract: contract}, nil
}

// NewIBrevisDisputeFilterer creates a new log filterer instance of IBrevisDispute, bound to a specific deployed contract.
func NewIBrevisDisputeFilterer(address common.Address, filterer bind.ContractFilterer) (*IBrevisDisputeFilterer, error) {
	contract, err := bindIBrevisDispute(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IBrevisDisputeFilterer{contract: contract}, nil
}

// bindIBrevisDispute binds a generic wrapper to an already deployed contract.
func bindIBrevisDispute(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IBrevisDisputeMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBrevisDispute *IBrevisDisputeRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBrevisDispute.Contract.IBrevisDisputeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBrevisDispute *IBrevisDisputeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBrevisDispute.Contract.IBrevisDisputeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBrevisDispute *IBrevisDisputeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBrevisDispute.Contract.IBrevisDisputeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBrevisDispute *IBrevisDisputeCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBrevisDispute.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBrevisDispute *IBrevisDisputeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBrevisDispute.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBrevisDispute *IBrevisDisputeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBrevisDispute.Contract.contract.Transact(opts, method, params...)
}

// GetChallengeWindow is a free data retrieval call binding the contract method 0x6a50c71e.
//
// Solidity: function getChallengeWindow() view returns(uint256)
func (_IBrevisDispute *IBrevisDisputeCaller) GetChallengeWindow(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IBrevisDispute.contract.Call(opts, &out, "getChallengeWindow")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetChallengeWindow is a free data retrieval call binding the contract method 0x6a50c71e.
//
// Solidity: function getChallengeWindow() view returns(uint256)
func (_IBrevisDispute *IBrevisDisputeSession) GetChallengeWindow() (*big.Int, error) {
	return _IBrevisDispute.Contract.GetChallengeWindow(&_IBrevisDispute.CallOpts)
}

// GetChallengeWindow is a free data retrieval call binding the contract method 0x6a50c71e.
//
// Solidity: function getChallengeWindow() view returns(uint256)
func (_IBrevisDispute *IBrevisDisputeCallerSession) GetChallengeWindow() (*big.Int, error) {
	return _IBrevisDispute.Contract.GetChallengeWindow(&_IBrevisDispute.CallOpts)
}

// GetDisputeStatus is a free data retrieval call binding the contract method 0xb2ec2476.
//
// Solidity: function getDisputeStatus(bytes32 _requestKey) view returns(uint8)
func (_IBrevisDispute *IBrevisDisputeCaller) GetDisputeStatus(opts *bind.CallOpts, _requestKey [32]byte) (uint8, error) {
	var out []interface{}
	err := _IBrevisDispute.contract.Call(opts, &out, "getDisputeStatus", _requestKey)

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// GetDisputeStatus is a free data retrieval call binding the contract method 0xb2ec2476.
//
// Solidity: function getDisputeStatus(bytes32 _requestKey) view returns(uint8)
func (_IBrevisDispute *IBrevisDisputeSession) GetDisputeStatus(_requestKey [32]byte) (uint8, error) {
	return _IBrevisDispute.Contract.GetDisputeStatus(&_IBrevisDispute.CallOpts, _requestKey)
}

// GetDisputeStatus is a free data retrieval call binding the contract method 0xb2ec2476.
//
// Solidity: function getDisputeStatus(bytes32 _requestKey) view returns(uint8)
func (_IBrevisDispute *IBrevisDisputeCallerSession) GetDisputeStatus(_requestKey [32]byte) (uint8, error) {
	return _IBrevisDispute.Contract.GetDisputeStatus(&_IBrevisDispute.CallOpts, _requestKey)
}

// GetResponseDeadline is a free data retrieval call binding the contract method 0x239fd760.
//
// Solidity: function getResponseDeadline(bytes32 _requestKey) view returns(uint256)
func (_IBrevisDispute *IBrevisDisputeCaller) GetResponseDeadline(opts *bind.CallOpts, _requestKey [32]byte) (*big.Int, error) {
	var out []interface{}
	err := _IBrevisDispute.contract.Call(opts, &out, "getResponseDeadline", _requestKey)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetResponseDeadline is a free data retrieval call binding the contract method 0x239fd760.
//
// Solidity: function getResponseDeadline(bytes32 _requestKey) view returns(uint256)
func (_IBrevisDispute *IBrevisDisputeSession) GetResponseDeadline(_requestKey [32]byte) (*big.Int, error) {
	return _IBrevisDispute.Contract.GetResponseDeadline(&_IBrevisDispute.CallOpts, _requestKey)
}

// GetResponseDeadline is a free data retrieval call binding the contract method 0x239fd760.
//
// Solidity: function getResponseDeadline(bytes32 _requestKey) view returns(uint256)
func (_IBrevisDispute *IBrevisDisputeCallerSession) GetResponseDeadline(_requestKey [32]byte) (*big.Int, error) {
	return _IBrevisDispute.Contract.GetResponseDeadline(&_IBrevisDispute.CallOpts, _requestKey)
}

// AskForDataAvailabilityProof is a paid mutator transaction binding the contract method 0xd3c22a3a.
//
// Solidity: function askForDataAvailabilityProof(bytes32 _proofId, uint64 _nonce) payable returns()
func (_IBrevisDispute *IBrevisDisputeTransactor) AskForDataAvailabilityProof(opts *bind.TransactOpts, _proofId [32]byte, _nonce uint64) (*types.Transaction, error) {
	return _IBrevisDispute.contract.Transact(opts, "askForDataAvailabilityProof", _proofId, _nonce)
}

// AskForDataAvailabilityProof is a paid mutator transaction binding the contract method 0xd3c22a3a.
//
// Solidity: function askForDataAvailabilityProof(bytes32 _proofId, uint64 _nonce) payable returns()
func (_IBrevisDispute *IBrevisDisputeSession) AskForDataAvailabilityProof(_proofId [32]byte, _nonce uint64) (*types.Transaction, error) {
	return _IBrevisDispute.Contract.AskForDataAvailabilityProof(&_IBrevisDispute.TransactOpts, _proofId, _nonce)
}

// AskForDataAvailabilityProof is a paid mutator transaction binding the contract method 0xd3c22a3a.
//
// Solidity: function askForDataAvailabilityProof(bytes32 _proofId, uint64 _nonce) payable returns()
func (_IBrevisDispute *IBrevisDisputeTransactorSession) AskForDataAvailabilityProof(_proofId [32]byte, _nonce uint64) (*types.Transaction, error) {
	return _IBrevisDispute.Contract.AskForDataAvailabilityProof(&_IBrevisDispute.TransactOpts, _proofId, _nonce)
}

// AskForDataValidityProof is a paid mutator transaction binding the contract method 0x2b256c68.
//
// Solidity: function askForDataValidityProof(bytes32 _proofId, uint64 _nonce) payable returns()
func (_IBrevisDispute *IBrevisDisputeTransactor) AskForDataValidityProof(opts *bind.TransactOpts, _proofId [32]byte, _nonce uint64) (*types.Transaction, error) {
	return _IBrevisDispute.contract.Transact(opts, "askForDataValidityProof", _proofId, _nonce)
}

// AskForDataValidityProof is a paid mutator transaction binding the contract method 0x2b256c68.
//
// Solidity: function askForDataValidityProof(bytes32 _proofId, uint64 _nonce) payable returns()
func (_IBrevisDispute *IBrevisDisputeSession) AskForDataValidityProof(_proofId [32]byte, _nonce uint64) (*types.Transaction, error) {
	return _IBrevisDispute.Contract.AskForDataValidityProof(&_IBrevisDispute.TransactOpts, _proofId, _nonce)
}

// AskForDataValidityProof is a paid mutator transaction binding the contract method 0x2b256c68.
//
// Solidity: function askForDataValidityProof(bytes32 _proofId, uint64 _nonce) payable returns()
func (_IBrevisDispute *IBrevisDisputeTransactorSession) AskForDataValidityProof(_proofId [32]byte, _nonce uint64) (*types.Transaction, error) {
	return _IBrevisDispute.Contract.AskForDataValidityProof(&_IBrevisDispute.TransactOpts, _proofId, _nonce)
}

// AskForRequestData is a paid mutator transaction binding the contract method 0xac225f54.
//
// Solidity: function askForRequestData(bytes32 _proofId, uint64 _nonce) payable returns()
func (_IBrevisDispute *IBrevisDisputeTransactor) AskForRequestData(opts *bind.TransactOpts, _proofId [32]byte, _nonce uint64) (*types.Transaction, error) {
	return _IBrevisDispute.contract.Transact(opts, "askForRequestData", _proofId, _nonce)
}

// AskForRequestData is a paid mutator transaction binding the contract method 0xac225f54.
//
// Solidity: function askForRequestData(bytes32 _proofId, uint64 _nonce) payable returns()
func (_IBrevisDispute *IBrevisDisputeSession) AskForRequestData(_proofId [32]byte, _nonce uint64) (*types.Transaction, error) {
	return _IBrevisDispute.Contract.AskForRequestData(&_IBrevisDispute.TransactOpts, _proofId, _nonce)
}

// AskForRequestData is a paid mutator transaction binding the contract method 0xac225f54.
//
// Solidity: function askForRequestData(bytes32 _proofId, uint64 _nonce) payable returns()
func (_IBrevisDispute *IBrevisDisputeTransactorSession) AskForRequestData(_proofId [32]byte, _nonce uint64) (*types.Transaction, error) {
	return _IBrevisDispute.Contract.AskForRequestData(&_IBrevisDispute.TransactOpts, _proofId, _nonce)
}

// PostDataAvailabilityProof is a paid mutator transaction binding the contract method 0xeab8d3a7.
//
// Solidity: function postDataAvailabilityProof(bytes32 _proofId, uint64 _nonce, bytes _proof) returns()
func (_IBrevisDispute *IBrevisDisputeTransactor) PostDataAvailabilityProof(opts *bind.TransactOpts, _proofId [32]byte, _nonce uint64, _proof []byte) (*types.Transaction, error) {
	return _IBrevisDispute.contract.Transact(opts, "postDataAvailabilityProof", _proofId, _nonce, _proof)
}

// PostDataAvailabilityProof is a paid mutator transaction binding the contract method 0xeab8d3a7.
//
// Solidity: function postDataAvailabilityProof(bytes32 _proofId, uint64 _nonce, bytes _proof) returns()
func (_IBrevisDispute *IBrevisDisputeSession) PostDataAvailabilityProof(_proofId [32]byte, _nonce uint64, _proof []byte) (*types.Transaction, error) {
	return _IBrevisDispute.Contract.PostDataAvailabilityProof(&_IBrevisDispute.TransactOpts, _proofId, _nonce, _proof)
}

// PostDataAvailabilityProof is a paid mutator transaction binding the contract method 0xeab8d3a7.
//
// Solidity: function postDataAvailabilityProof(bytes32 _proofId, uint64 _nonce, bytes _proof) returns()
func (_IBrevisDispute *IBrevisDisputeTransactorSession) PostDataAvailabilityProof(_proofId [32]byte, _nonce uint64, _proof []byte) (*types.Transaction, error) {
	return _IBrevisDispute.Contract.PostDataAvailabilityProof(&_IBrevisDispute.TransactOpts, _proofId, _nonce, _proof)
}

// PostDataValidityProof is a paid mutator transaction binding the contract method 0xc5d12914.
//
// Solidity: function postDataValidityProof(bytes32 _proofId, uint64 _nonce, uint64 _chainId, bytes _proof) returns()
func (_IBrevisDispute *IBrevisDisputeTransactor) PostDataValidityProof(opts *bind.TransactOpts, _proofId [32]byte, _nonce uint64, _chainId uint64, _proof []byte) (*types.Transaction, error) {
	return _IBrevisDispute.contract.Transact(opts, "postDataValidityProof", _proofId, _nonce, _chainId, _proof)
}

// PostDataValidityProof is a paid mutator transaction binding the contract method 0xc5d12914.
//
// Solidity: function postDataValidityProof(bytes32 _proofId, uint64 _nonce, uint64 _chainId, bytes _proof) returns()
func (_IBrevisDispute *IBrevisDisputeSession) PostDataValidityProof(_proofId [32]byte, _nonce uint64, _chainId uint64, _proof []byte) (*types.Transaction, error) {
	return _IBrevisDispute.Contract.PostDataValidityProof(&_IBrevisDispute.TransactOpts, _proofId, _nonce, _chainId, _proof)
}

// PostDataValidityProof is a paid mutator transaction binding the contract method 0xc5d12914.
//
// Solidity: function postDataValidityProof(bytes32 _proofId, uint64 _nonce, uint64 _chainId, bytes _proof) returns()
func (_IBrevisDispute *IBrevisDisputeTransactorSession) PostDataValidityProof(_proofId [32]byte, _nonce uint64, _chainId uint64, _proof []byte) (*types.Transaction, error) {
	return _IBrevisDispute.Contract.PostDataValidityProof(&_IBrevisDispute.TransactOpts, _proofId, _nonce, _chainId, _proof)
}

// PostRequestData is a paid mutator transaction binding the contract method 0x95b40861.
//
// Solidity: function postRequestData(bytes32 _proofId, uint64 _nonce, bytes[] _requestData, uint256 _index, bool _done) returns()
func (_IBrevisDispute *IBrevisDisputeTransactor) PostRequestData(opts *bind.TransactOpts, _proofId [32]byte, _nonce uint64, _requestData [][]byte, _index *big.Int, _done bool) (*types.Transaction, error) {
	return _IBrevisDispute.contract.Transact(opts, "postRequestData", _proofId, _nonce, _requestData, _index, _done)
}

// PostRequestData is a paid mutator transaction binding the contract method 0x95b40861.
//
// Solidity: function postRequestData(bytes32 _proofId, uint64 _nonce, bytes[] _requestData, uint256 _index, bool _done) returns()
func (_IBrevisDispute *IBrevisDisputeSession) PostRequestData(_proofId [32]byte, _nonce uint64, _requestData [][]byte, _index *big.Int, _done bool) (*types.Transaction, error) {
	return _IBrevisDispute.Contract.PostRequestData(&_IBrevisDispute.TransactOpts, _proofId, _nonce, _requestData, _index, _done)
}

// PostRequestData is a paid mutator transaction binding the contract method 0x95b40861.
//
// Solidity: function postRequestData(bytes32 _proofId, uint64 _nonce, bytes[] _requestData, uint256 _index, bool _done) returns()
func (_IBrevisDispute *IBrevisDisputeTransactorSession) PostRequestData(_proofId [32]byte, _nonce uint64, _requestData [][]byte, _index *big.Int, _done bool) (*types.Transaction, error) {
	return _IBrevisDispute.Contract.PostRequestData(&_IBrevisDispute.TransactOpts, _proofId, _nonce, _requestData, _index, _done)
}

// IBrevisDisputeAskForIterator is returned from FilterAskFor and is used to iterate over the raw logs and unpacked data for AskFor events raised by the IBrevisDispute contract.
type IBrevisDisputeAskForIterator struct {
	Event *IBrevisDisputeAskFor // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IBrevisDisputeAskForIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IBrevisDisputeAskFor)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IBrevisDisputeAskFor)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IBrevisDisputeAskForIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IBrevisDisputeAskForIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IBrevisDisputeAskFor represents a AskFor event raised by the IBrevisDispute contract.
type IBrevisDisputeAskFor struct {
	ProofId [32]byte
	Nonce   uint64
	Status  uint8
	From    common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterAskFor is a free log retrieval operation binding the contract event 0x305b29c3917a30a5ca5ffefad1a2fd5b6468f8bf644b95831f9097c61e4c7ab6.
//
// Solidity: event AskFor(bytes32 indexed proofId, uint64 nonce, uint8 status, address from)
func (_IBrevisDispute *IBrevisDisputeFilterer) FilterAskFor(opts *bind.FilterOpts, proofId [][32]byte) (*IBrevisDisputeAskForIterator, error) {

	var proofIdRule []interface{}
	for _, proofIdItem := range proofId {
		proofIdRule = append(proofIdRule, proofIdItem)
	}

	logs, sub, err := _IBrevisDispute.contract.FilterLogs(opts, "AskFor", proofIdRule)
	if err != nil {
		return nil, err
	}
	return &IBrevisDisputeAskForIterator{contract: _IBrevisDispute.contract, event: "AskFor", logs: logs, sub: sub}, nil
}

// WatchAskFor is a free log subscription operation binding the contract event 0x305b29c3917a30a5ca5ffefad1a2fd5b6468f8bf644b95831f9097c61e4c7ab6.
//
// Solidity: event AskFor(bytes32 indexed proofId, uint64 nonce, uint8 status, address from)
func (_IBrevisDispute *IBrevisDisputeFilterer) WatchAskFor(opts *bind.WatchOpts, sink chan<- *IBrevisDisputeAskFor, proofId [][32]byte) (event.Subscription, error) {

	var proofIdRule []interface{}
	for _, proofIdItem := range proofId {
		proofIdRule = append(proofIdRule, proofIdItem)
	}

	logs, sub, err := _IBrevisDispute.contract.WatchLogs(opts, "AskFor", proofIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IBrevisDisputeAskFor)
				if err := _IBrevisDispute.contract.UnpackLog(event, "AskFor", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAskFor is a log parse operation binding the contract event 0x305b29c3917a30a5ca5ffefad1a2fd5b6468f8bf644b95831f9097c61e4c7ab6.
//
// Solidity: event AskFor(bytes32 indexed proofId, uint64 nonce, uint8 status, address from)
func (_IBrevisDispute *IBrevisDisputeFilterer) ParseAskFor(log types.Log) (*IBrevisDisputeAskFor, error) {
	event := new(IBrevisDisputeAskFor)
	if err := _IBrevisDispute.contract.UnpackLog(event, "AskFor", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IBrevisDisputeChallengeWindowUpdatedIterator is returned from FilterChallengeWindowUpdated and is used to iterate over the raw logs and unpacked data for ChallengeWindowUpdated events raised by the IBrevisDispute contract.
type IBrevisDisputeChallengeWindowUpdatedIterator struct {
	Event *IBrevisDisputeChallengeWindowUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IBrevisDisputeChallengeWindowUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IBrevisDisputeChallengeWindowUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IBrevisDisputeChallengeWindowUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IBrevisDisputeChallengeWindowUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IBrevisDisputeChallengeWindowUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IBrevisDisputeChallengeWindowUpdated represents a ChallengeWindowUpdated event raised by the IBrevisDispute contract.
type IBrevisDisputeChallengeWindowUpdated struct {
	From *big.Int
	To   *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterChallengeWindowUpdated is a free log retrieval operation binding the contract event 0xedb9338f4b0faf2b899d2d7f54b90753d2a8ebb34936e381edb91b091c3e45a7.
//
// Solidity: event ChallengeWindowUpdated(uint256 from, uint256 to)
func (_IBrevisDispute *IBrevisDisputeFilterer) FilterChallengeWindowUpdated(opts *bind.FilterOpts) (*IBrevisDisputeChallengeWindowUpdatedIterator, error) {

	logs, sub, err := _IBrevisDispute.contract.FilterLogs(opts, "ChallengeWindowUpdated")
	if err != nil {
		return nil, err
	}
	return &IBrevisDisputeChallengeWindowUpdatedIterator{contract: _IBrevisDispute.contract, event: "ChallengeWindowUpdated", logs: logs, sub: sub}, nil
}

// WatchChallengeWindowUpdated is a free log subscription operation binding the contract event 0xedb9338f4b0faf2b899d2d7f54b90753d2a8ebb34936e381edb91b091c3e45a7.
//
// Solidity: event ChallengeWindowUpdated(uint256 from, uint256 to)
func (_IBrevisDispute *IBrevisDisputeFilterer) WatchChallengeWindowUpdated(opts *bind.WatchOpts, sink chan<- *IBrevisDisputeChallengeWindowUpdated) (event.Subscription, error) {

	logs, sub, err := _IBrevisDispute.contract.WatchLogs(opts, "ChallengeWindowUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IBrevisDisputeChallengeWindowUpdated)
				if err := _IBrevisDispute.contract.UnpackLog(event, "ChallengeWindowUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseChallengeWindowUpdated is a log parse operation binding the contract event 0xedb9338f4b0faf2b899d2d7f54b90753d2a8ebb34936e381edb91b091c3e45a7.
//
// Solidity: event ChallengeWindowUpdated(uint256 from, uint256 to)
func (_IBrevisDispute *IBrevisDisputeFilterer) ParseChallengeWindowUpdated(log types.Log) (*IBrevisDisputeChallengeWindowUpdated, error) {
	event := new(IBrevisDisputeChallengeWindowUpdated)
	if err := _IBrevisDispute.contract.UnpackLog(event, "ChallengeWindowUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IBrevisDisputeDataAvailabilityProofPostedIterator is returned from FilterDataAvailabilityProofPosted and is used to iterate over the raw logs and unpacked data for DataAvailabilityProofPosted events raised by the IBrevisDispute contract.
type IBrevisDisputeDataAvailabilityProofPostedIterator struct {
	Event *IBrevisDisputeDataAvailabilityProofPosted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IBrevisDisputeDataAvailabilityProofPostedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IBrevisDisputeDataAvailabilityProofPosted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IBrevisDisputeDataAvailabilityProofPosted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IBrevisDisputeDataAvailabilityProofPostedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IBrevisDisputeDataAvailabilityProofPostedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IBrevisDisputeDataAvailabilityProofPosted represents a DataAvailabilityProofPosted event raised by the IBrevisDispute contract.
type IBrevisDisputeDataAvailabilityProofPosted struct {
	ProofId [32]byte
	Nonce   uint64
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterDataAvailabilityProofPosted is a free log retrieval operation binding the contract event 0xa38ccf08432b738adb9d381dbd7ae7ad1aac98357a2a14233bf755a2aa898e2e.
//
// Solidity: event DataAvailabilityProofPosted(bytes32 indexed proofId, uint64 nonce)
func (_IBrevisDispute *IBrevisDisputeFilterer) FilterDataAvailabilityProofPosted(opts *bind.FilterOpts, proofId [][32]byte) (*IBrevisDisputeDataAvailabilityProofPostedIterator, error) {

	var proofIdRule []interface{}
	for _, proofIdItem := range proofId {
		proofIdRule = append(proofIdRule, proofIdItem)
	}

	logs, sub, err := _IBrevisDispute.contract.FilterLogs(opts, "DataAvailabilityProofPosted", proofIdRule)
	if err != nil {
		return nil, err
	}
	return &IBrevisDisputeDataAvailabilityProofPostedIterator{contract: _IBrevisDispute.contract, event: "DataAvailabilityProofPosted", logs: logs, sub: sub}, nil
}

// WatchDataAvailabilityProofPosted is a free log subscription operation binding the contract event 0xa38ccf08432b738adb9d381dbd7ae7ad1aac98357a2a14233bf755a2aa898e2e.
//
// Solidity: event DataAvailabilityProofPosted(bytes32 indexed proofId, uint64 nonce)
func (_IBrevisDispute *IBrevisDisputeFilterer) WatchDataAvailabilityProofPosted(opts *bind.WatchOpts, sink chan<- *IBrevisDisputeDataAvailabilityProofPosted, proofId [][32]byte) (event.Subscription, error) {

	var proofIdRule []interface{}
	for _, proofIdItem := range proofId {
		proofIdRule = append(proofIdRule, proofIdItem)
	}

	logs, sub, err := _IBrevisDispute.contract.WatchLogs(opts, "DataAvailabilityProofPosted", proofIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IBrevisDisputeDataAvailabilityProofPosted)
				if err := _IBrevisDispute.contract.UnpackLog(event, "DataAvailabilityProofPosted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDataAvailabilityProofPosted is a log parse operation binding the contract event 0xa38ccf08432b738adb9d381dbd7ae7ad1aac98357a2a14233bf755a2aa898e2e.
//
// Solidity: event DataAvailabilityProofPosted(bytes32 indexed proofId, uint64 nonce)
func (_IBrevisDispute *IBrevisDisputeFilterer) ParseDataAvailabilityProofPosted(log types.Log) (*IBrevisDisputeDataAvailabilityProofPosted, error) {
	event := new(IBrevisDisputeDataAvailabilityProofPosted)
	if err := _IBrevisDispute.contract.UnpackLog(event, "DataAvailabilityProofPosted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IBrevisDisputeDataValidityProofProofPostedIterator is returned from FilterDataValidityProofProofPosted and is used to iterate over the raw logs and unpacked data for DataValidityProofProofPosted events raised by the IBrevisDispute contract.
type IBrevisDisputeDataValidityProofProofPostedIterator struct {
	Event *IBrevisDisputeDataValidityProofProofPosted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IBrevisDisputeDataValidityProofProofPostedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IBrevisDisputeDataValidityProofProofPosted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IBrevisDisputeDataValidityProofProofPosted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IBrevisDisputeDataValidityProofProofPostedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IBrevisDisputeDataValidityProofProofPostedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IBrevisDisputeDataValidityProofProofPosted represents a DataValidityProofProofPosted event raised by the IBrevisDispute contract.
type IBrevisDisputeDataValidityProofProofPosted struct {
	ProofId [32]byte
	Nonce   uint64
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterDataValidityProofProofPosted is a free log retrieval operation binding the contract event 0x8474e871e3a8323ba71f5ce5c3c9da0d547fd033dd9274cce4380339a9cdccc6.
//
// Solidity: event DataValidityProofProofPosted(bytes32 indexed proofId, uint64 nonce)
func (_IBrevisDispute *IBrevisDisputeFilterer) FilterDataValidityProofProofPosted(opts *bind.FilterOpts, proofId [][32]byte) (*IBrevisDisputeDataValidityProofProofPostedIterator, error) {

	var proofIdRule []interface{}
	for _, proofIdItem := range proofId {
		proofIdRule = append(proofIdRule, proofIdItem)
	}

	logs, sub, err := _IBrevisDispute.contract.FilterLogs(opts, "DataValidityProofProofPosted", proofIdRule)
	if err != nil {
		return nil, err
	}
	return &IBrevisDisputeDataValidityProofProofPostedIterator{contract: _IBrevisDispute.contract, event: "DataValidityProofProofPosted", logs: logs, sub: sub}, nil
}

// WatchDataValidityProofProofPosted is a free log subscription operation binding the contract event 0x8474e871e3a8323ba71f5ce5c3c9da0d547fd033dd9274cce4380339a9cdccc6.
//
// Solidity: event DataValidityProofProofPosted(bytes32 indexed proofId, uint64 nonce)
func (_IBrevisDispute *IBrevisDisputeFilterer) WatchDataValidityProofProofPosted(opts *bind.WatchOpts, sink chan<- *IBrevisDisputeDataValidityProofProofPosted, proofId [][32]byte) (event.Subscription, error) {

	var proofIdRule []interface{}
	for _, proofIdItem := range proofId {
		proofIdRule = append(proofIdRule, proofIdItem)
	}

	logs, sub, err := _IBrevisDispute.contract.WatchLogs(opts, "DataValidityProofProofPosted", proofIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IBrevisDisputeDataValidityProofProofPosted)
				if err := _IBrevisDispute.contract.UnpackLog(event, "DataValidityProofProofPosted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDataValidityProofProofPosted is a log parse operation binding the contract event 0x8474e871e3a8323ba71f5ce5c3c9da0d547fd033dd9274cce4380339a9cdccc6.
//
// Solidity: event DataValidityProofProofPosted(bytes32 indexed proofId, uint64 nonce)
func (_IBrevisDispute *IBrevisDisputeFilterer) ParseDataValidityProofProofPosted(log types.Log) (*IBrevisDisputeDataValidityProofProofPosted, error) {
	event := new(IBrevisDisputeDataValidityProofProofPosted)
	if err := _IBrevisDispute.contract.UnpackLog(event, "DataValidityProofProofPosted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IBrevisDisputeDisputeDepositsUpdatedIterator is returned from FilterDisputeDepositsUpdated and is used to iterate over the raw logs and unpacked data for DisputeDepositsUpdated events raised by the IBrevisDispute contract.
type IBrevisDisputeDisputeDepositsUpdatedIterator struct {
	Event *IBrevisDisputeDisputeDepositsUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IBrevisDisputeDisputeDepositsUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IBrevisDisputeDisputeDepositsUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IBrevisDisputeDisputeDepositsUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IBrevisDisputeDisputeDepositsUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IBrevisDisputeDisputeDepositsUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IBrevisDisputeDisputeDepositsUpdated represents a DisputeDepositsUpdated event raised by the IBrevisDispute contract.
type IBrevisDisputeDisputeDepositsUpdated struct {
	AmtAskForData  *big.Int
	AmtAskForProof *big.Int
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterDisputeDepositsUpdated is a free log retrieval operation binding the contract event 0x56ca37d8947ac20c2d621aba1b4f339d6293d1bd4183930bcaf29dbf41e26af2.
//
// Solidity: event DisputeDepositsUpdated(uint256 amtAskForData, uint256 amtAskForProof)
func (_IBrevisDispute *IBrevisDisputeFilterer) FilterDisputeDepositsUpdated(opts *bind.FilterOpts) (*IBrevisDisputeDisputeDepositsUpdatedIterator, error) {

	logs, sub, err := _IBrevisDispute.contract.FilterLogs(opts, "DisputeDepositsUpdated")
	if err != nil {
		return nil, err
	}
	return &IBrevisDisputeDisputeDepositsUpdatedIterator{contract: _IBrevisDispute.contract, event: "DisputeDepositsUpdated", logs: logs, sub: sub}, nil
}

// WatchDisputeDepositsUpdated is a free log subscription operation binding the contract event 0x56ca37d8947ac20c2d621aba1b4f339d6293d1bd4183930bcaf29dbf41e26af2.
//
// Solidity: event DisputeDepositsUpdated(uint256 amtAskForData, uint256 amtAskForProof)
func (_IBrevisDispute *IBrevisDisputeFilterer) WatchDisputeDepositsUpdated(opts *bind.WatchOpts, sink chan<- *IBrevisDisputeDisputeDepositsUpdated) (event.Subscription, error) {

	logs, sub, err := _IBrevisDispute.contract.WatchLogs(opts, "DisputeDepositsUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IBrevisDisputeDisputeDepositsUpdated)
				if err := _IBrevisDispute.contract.UnpackLog(event, "DisputeDepositsUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDisputeDepositsUpdated is a log parse operation binding the contract event 0x56ca37d8947ac20c2d621aba1b4f339d6293d1bd4183930bcaf29dbf41e26af2.
//
// Solidity: event DisputeDepositsUpdated(uint256 amtAskForData, uint256 amtAskForProof)
func (_IBrevisDispute *IBrevisDisputeFilterer) ParseDisputeDepositsUpdated(log types.Log) (*IBrevisDisputeDisputeDepositsUpdated, error) {
	event := new(IBrevisDisputeDisputeDepositsUpdated)
	if err := _IBrevisDispute.contract.UnpackLog(event, "DisputeDepositsUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IBrevisDisputeRequestDataPostedIterator is returned from FilterRequestDataPosted and is used to iterate over the raw logs and unpacked data for RequestDataPosted events raised by the IBrevisDispute contract.
type IBrevisDisputeRequestDataPostedIterator struct {
	Event *IBrevisDisputeRequestDataPosted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IBrevisDisputeRequestDataPostedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IBrevisDisputeRequestDataPosted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IBrevisDisputeRequestDataPosted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IBrevisDisputeRequestDataPostedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IBrevisDisputeRequestDataPostedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IBrevisDisputeRequestDataPosted represents a RequestDataPosted event raised by the IBrevisDispute contract.
type IBrevisDisputeRequestDataPosted struct {
	ProofId [32]byte
	Nonce   uint64
	Data    [][]byte
	Index   *big.Int
	Done    bool
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRequestDataPosted is a free log retrieval operation binding the contract event 0x635ae6660d964e1393ed692ae764226ddeb8878df97a22e762559a7485f34874.
//
// Solidity: event RequestDataPosted(bytes32 indexed proofId, uint64 nonce, bytes[] data, uint256 index, bool done)
func (_IBrevisDispute *IBrevisDisputeFilterer) FilterRequestDataPosted(opts *bind.FilterOpts, proofId [][32]byte) (*IBrevisDisputeRequestDataPostedIterator, error) {

	var proofIdRule []interface{}
	for _, proofIdItem := range proofId {
		proofIdRule = append(proofIdRule, proofIdItem)
	}

	logs, sub, err := _IBrevisDispute.contract.FilterLogs(opts, "RequestDataPosted", proofIdRule)
	if err != nil {
		return nil, err
	}
	return &IBrevisDisputeRequestDataPostedIterator{contract: _IBrevisDispute.contract, event: "RequestDataPosted", logs: logs, sub: sub}, nil
}

// WatchRequestDataPosted is a free log subscription operation binding the contract event 0x635ae6660d964e1393ed692ae764226ddeb8878df97a22e762559a7485f34874.
//
// Solidity: event RequestDataPosted(bytes32 indexed proofId, uint64 nonce, bytes[] data, uint256 index, bool done)
func (_IBrevisDispute *IBrevisDisputeFilterer) WatchRequestDataPosted(opts *bind.WatchOpts, sink chan<- *IBrevisDisputeRequestDataPosted, proofId [][32]byte) (event.Subscription, error) {

	var proofIdRule []interface{}
	for _, proofIdItem := range proofId {
		proofIdRule = append(proofIdRule, proofIdItem)
	}

	logs, sub, err := _IBrevisDispute.contract.WatchLogs(opts, "RequestDataPosted", proofIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IBrevisDisputeRequestDataPosted)
				if err := _IBrevisDispute.contract.UnpackLog(event, "RequestDataPosted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestDataPosted is a log parse operation binding the contract event 0x635ae6660d964e1393ed692ae764226ddeb8878df97a22e762559a7485f34874.
//
// Solidity: event RequestDataPosted(bytes32 indexed proofId, uint64 nonce, bytes[] data, uint256 index, bool done)
func (_IBrevisDispute *IBrevisDisputeFilterer) ParseRequestDataPosted(log types.Log) (*IBrevisDisputeRequestDataPosted, error) {
	event := new(IBrevisDisputeRequestDataPosted)
	if err := _IBrevisDispute.contract.UnpackLog(event, "RequestDataPosted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IBrevisDisputeResponseTimeoutUpdatedIterator is returned from FilterResponseTimeoutUpdated and is used to iterate over the raw logs and unpacked data for ResponseTimeoutUpdated events raised by the IBrevisDispute contract.
type IBrevisDisputeResponseTimeoutUpdatedIterator struct {
	Event *IBrevisDisputeResponseTimeoutUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IBrevisDisputeResponseTimeoutUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IBrevisDisputeResponseTimeoutUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IBrevisDisputeResponseTimeoutUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IBrevisDisputeResponseTimeoutUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IBrevisDisputeResponseTimeoutUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IBrevisDisputeResponseTimeoutUpdated represents a ResponseTimeoutUpdated event raised by the IBrevisDispute contract.
type IBrevisDisputeResponseTimeoutUpdated struct {
	From *big.Int
	To   *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterResponseTimeoutUpdated is a free log retrieval operation binding the contract event 0x86fe7fc31f35681a1ed77325f0cf24935a5d25b1861e7ce9ceed9cb67f222270.
//
// Solidity: event ResponseTimeoutUpdated(uint256 from, uint256 to)
func (_IBrevisDispute *IBrevisDisputeFilterer) FilterResponseTimeoutUpdated(opts *bind.FilterOpts) (*IBrevisDisputeResponseTimeoutUpdatedIterator, error) {

	logs, sub, err := _IBrevisDispute.contract.FilterLogs(opts, "ResponseTimeoutUpdated")
	if err != nil {
		return nil, err
	}
	return &IBrevisDisputeResponseTimeoutUpdatedIterator{contract: _IBrevisDispute.contract, event: "ResponseTimeoutUpdated", logs: logs, sub: sub}, nil
}

// WatchResponseTimeoutUpdated is a free log subscription operation binding the contract event 0x86fe7fc31f35681a1ed77325f0cf24935a5d25b1861e7ce9ceed9cb67f222270.
//
// Solidity: event ResponseTimeoutUpdated(uint256 from, uint256 to)
func (_IBrevisDispute *IBrevisDisputeFilterer) WatchResponseTimeoutUpdated(opts *bind.WatchOpts, sink chan<- *IBrevisDisputeResponseTimeoutUpdated) (event.Subscription, error) {

	logs, sub, err := _IBrevisDispute.contract.WatchLogs(opts, "ResponseTimeoutUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IBrevisDisputeResponseTimeoutUpdated)
				if err := _IBrevisDispute.contract.UnpackLog(event, "ResponseTimeoutUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseResponseTimeoutUpdated is a log parse operation binding the contract event 0x86fe7fc31f35681a1ed77325f0cf24935a5d25b1861e7ce9ceed9cb67f222270.
//
// Solidity: event ResponseTimeoutUpdated(uint256 from, uint256 to)
func (_IBrevisDispute *IBrevisDisputeFilterer) ParseResponseTimeoutUpdated(log types.Log) (*IBrevisDisputeResponseTimeoutUpdated, error) {
	event := new(IBrevisDisputeResponseTimeoutUpdated)
	if err := _IBrevisDispute.contract.UnpackLog(event, "ResponseTimeoutUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IBrevisProofMetaData contains all meta data concerning the IBrevisProof contract.
var IBrevisProofMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32[]\",\"name\":\"_requestIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"_proofWithPubInputs\",\"type\":\"bytes\"}],\"name\":\"submitAggProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_proofWithPubInputs\",\"type\":\"bytes\"}],\"name\":\"submitProof\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appVkHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"commitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"vkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"smtRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBrevis.ProofData[]\",\"name\":\"_proofDataArray\",\"type\":\"tuple[]\"}],\"name\":\"validateAggProofData\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"commitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"vkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"smtRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBrevis.ProofData\",\"name\":\"_proofData\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint8\",\"name\":\"_nodeIndex\",\"type\":\"uint8\"}],\"name\":\"validateAggProofData\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_requestId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_appVkHash\",\"type\":\"bytes32\"}],\"name\":\"validateProofAppData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// IBrevisProofABI is the input ABI used to generate the binding from.
// Deprecated: Use IBrevisProofMetaData.ABI instead.
var IBrevisProofABI = IBrevisProofMetaData.ABI

// IBrevisProof is an auto generated Go binding around an Ethereum contract.
type IBrevisProof struct {
	IBrevisProofCaller     // Read-only binding to the contract
	IBrevisProofTransactor // Write-only binding to the contract
	IBrevisProofFilterer   // Log filterer for contract events
}

// IBrevisProofCaller is an auto generated read-only Go binding around an Ethereum contract.
type IBrevisProofCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBrevisProofTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IBrevisProofTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBrevisProofFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IBrevisProofFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBrevisProofSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IBrevisProofSession struct {
	Contract     *IBrevisProof     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IBrevisProofCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IBrevisProofCallerSession struct {
	Contract *IBrevisProofCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// IBrevisProofTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IBrevisProofTransactorSession struct {
	Contract     *IBrevisProofTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// IBrevisProofRaw is an auto generated low-level Go binding around an Ethereum contract.
type IBrevisProofRaw struct {
	Contract *IBrevisProof // Generic contract binding to access the raw methods on
}

// IBrevisProofCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IBrevisProofCallerRaw struct {
	Contract *IBrevisProofCaller // Generic read-only contract binding to access the raw methods on
}

// IBrevisProofTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IBrevisProofTransactorRaw struct {
	Contract *IBrevisProofTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIBrevisProof creates a new instance of IBrevisProof, bound to a specific deployed contract.
func NewIBrevisProof(address common.Address, backend bind.ContractBackend) (*IBrevisProof, error) {
	contract, err := bindIBrevisProof(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IBrevisProof{IBrevisProofCaller: IBrevisProofCaller{contract: contract}, IBrevisProofTransactor: IBrevisProofTransactor{contract: contract}, IBrevisProofFilterer: IBrevisProofFilterer{contract: contract}}, nil
}

// NewIBrevisProofCaller creates a new read-only instance of IBrevisProof, bound to a specific deployed contract.
func NewIBrevisProofCaller(address common.Address, caller bind.ContractCaller) (*IBrevisProofCaller, error) {
	contract, err := bindIBrevisProof(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IBrevisProofCaller{contract: contract}, nil
}

// NewIBrevisProofTransactor creates a new write-only instance of IBrevisProof, bound to a specific deployed contract.
func NewIBrevisProofTransactor(address common.Address, transactor bind.ContractTransactor) (*IBrevisProofTransactor, error) {
	contract, err := bindIBrevisProof(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IBrevisProofTransactor{contract: contract}, nil
}

// NewIBrevisProofFilterer creates a new log filterer instance of IBrevisProof, bound to a specific deployed contract.
func NewIBrevisProofFilterer(address common.Address, filterer bind.ContractFilterer) (*IBrevisProofFilterer, error) {
	contract, err := bindIBrevisProof(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IBrevisProofFilterer{contract: contract}, nil
}

// bindIBrevisProof binds a generic wrapper to an already deployed contract.
func bindIBrevisProof(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IBrevisProofMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBrevisProof *IBrevisProofRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBrevisProof.Contract.IBrevisProofCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBrevisProof *IBrevisProofRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBrevisProof.Contract.IBrevisProofTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBrevisProof *IBrevisProofRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBrevisProof.Contract.IBrevisProofTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBrevisProof *IBrevisProofCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBrevisProof.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBrevisProof *IBrevisProofTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBrevisProof.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBrevisProof *IBrevisProofTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBrevisProof.Contract.contract.Transact(opts, method, params...)
}

// ValidateAggProofData is a free data retrieval call binding the contract method 0x3bda38a3.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray) view returns()
func (_IBrevisProof *IBrevisProofCaller) ValidateAggProofData(opts *bind.CallOpts, _chainId uint64, _proofDataArray []BrevisProofData) error {
	var out []interface{}
	err := _IBrevisProof.contract.Call(opts, &out, "validateAggProofData", _chainId, _proofDataArray)

	if err != nil {
		return err
	}

	return err

}

// ValidateAggProofData is a free data retrieval call binding the contract method 0x3bda38a3.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray) view returns()
func (_IBrevisProof *IBrevisProofSession) ValidateAggProofData(_chainId uint64, _proofDataArray []BrevisProofData) error {
	return _IBrevisProof.Contract.ValidateAggProofData(&_IBrevisProof.CallOpts, _chainId, _proofDataArray)
}

// ValidateAggProofData is a free data retrieval call binding the contract method 0x3bda38a3.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32)[] _proofDataArray) view returns()
func (_IBrevisProof *IBrevisProofCallerSession) ValidateAggProofData(_chainId uint64, _proofDataArray []BrevisProofData) error {
	return _IBrevisProof.Contract.ValidateAggProofData(&_IBrevisProof.CallOpts, _chainId, _proofDataArray)
}

// ValidateAggProofData0 is a free data retrieval call binding the contract method 0x7b1cc450.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32) _proofData, bytes32 _merkleRoot, bytes32[] _merkleProof, uint8 _nodeIndex) view returns()
func (_IBrevisProof *IBrevisProofCaller) ValidateAggProofData0(opts *bind.CallOpts, _chainId uint64, _proofData BrevisProofData, _merkleRoot [32]byte, _merkleProof [][32]byte, _nodeIndex uint8) error {
	var out []interface{}
	err := _IBrevisProof.contract.Call(opts, &out, "validateAggProofData0", _chainId, _proofData, _merkleRoot, _merkleProof, _nodeIndex)

	if err != nil {
		return err
	}

	return err

}

// ValidateAggProofData0 is a free data retrieval call binding the contract method 0x7b1cc450.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32) _proofData, bytes32 _merkleRoot, bytes32[] _merkleProof, uint8 _nodeIndex) view returns()
func (_IBrevisProof *IBrevisProofSession) ValidateAggProofData0(_chainId uint64, _proofData BrevisProofData, _merkleRoot [32]byte, _merkleProof [][32]byte, _nodeIndex uint8) error {
	return _IBrevisProof.Contract.ValidateAggProofData0(&_IBrevisProof.CallOpts, _chainId, _proofData, _merkleRoot, _merkleProof, _nodeIndex)
}

// ValidateAggProofData0 is a free data retrieval call binding the contract method 0x7b1cc450.
//
// Solidity: function validateAggProofData(uint64 _chainId, (bytes32,bytes32,bytes32,bytes32,bytes32) _proofData, bytes32 _merkleRoot, bytes32[] _merkleProof, uint8 _nodeIndex) view returns()
func (_IBrevisProof *IBrevisProofCallerSession) ValidateAggProofData0(_chainId uint64, _proofData BrevisProofData, _merkleRoot [32]byte, _merkleProof [][32]byte, _nodeIndex uint8) error {
	return _IBrevisProof.Contract.ValidateAggProofData0(&_IBrevisProof.CallOpts, _chainId, _proofData, _merkleRoot, _merkleProof, _nodeIndex)
}

// ValidateProofAppData is a free data retrieval call binding the contract method 0x90178370.
//
// Solidity: function validateProofAppData(bytes32 _requestId, bytes32 _appCommitHash, bytes32 _appVkHash) view returns(bool)
func (_IBrevisProof *IBrevisProofCaller) ValidateProofAppData(opts *bind.CallOpts, _requestId [32]byte, _appCommitHash [32]byte, _appVkHash [32]byte) (bool, error) {
	var out []interface{}
	err := _IBrevisProof.contract.Call(opts, &out, "validateProofAppData", _requestId, _appCommitHash, _appVkHash)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// ValidateProofAppData is a free data retrieval call binding the contract method 0x90178370.
//
// Solidity: function validateProofAppData(bytes32 _requestId, bytes32 _appCommitHash, bytes32 _appVkHash) view returns(bool)
func (_IBrevisProof *IBrevisProofSession) ValidateProofAppData(_requestId [32]byte, _appCommitHash [32]byte, _appVkHash [32]byte) (bool, error) {
	return _IBrevisProof.Contract.ValidateProofAppData(&_IBrevisProof.CallOpts, _requestId, _appCommitHash, _appVkHash)
}

// ValidateProofAppData is a free data retrieval call binding the contract method 0x90178370.
//
// Solidity: function validateProofAppData(bytes32 _requestId, bytes32 _appCommitHash, bytes32 _appVkHash) view returns(bool)
func (_IBrevisProof *IBrevisProofCallerSession) ValidateProofAppData(_requestId [32]byte, _appCommitHash [32]byte, _appVkHash [32]byte) (bool, error) {
	return _IBrevisProof.Contract.ValidateProofAppData(&_IBrevisProof.CallOpts, _requestId, _appCommitHash, _appVkHash)
}

// SubmitAggProof is a paid mutator transaction binding the contract method 0xb4f7a727.
//
// Solidity: function submitAggProof(uint64 _chainId, bytes32[] _requestIds, bytes _proofWithPubInputs) returns()
func (_IBrevisProof *IBrevisProofTransactor) SubmitAggProof(opts *bind.TransactOpts, _chainId uint64, _requestIds [][32]byte, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _IBrevisProof.contract.Transact(opts, "submitAggProof", _chainId, _requestIds, _proofWithPubInputs)
}

// SubmitAggProof is a paid mutator transaction binding the contract method 0xb4f7a727.
//
// Solidity: function submitAggProof(uint64 _chainId, bytes32[] _requestIds, bytes _proofWithPubInputs) returns()
func (_IBrevisProof *IBrevisProofSession) SubmitAggProof(_chainId uint64, _requestIds [][32]byte, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _IBrevisProof.Contract.SubmitAggProof(&_IBrevisProof.TransactOpts, _chainId, _requestIds, _proofWithPubInputs)
}

// SubmitAggProof is a paid mutator transaction binding the contract method 0xb4f7a727.
//
// Solidity: function submitAggProof(uint64 _chainId, bytes32[] _requestIds, bytes _proofWithPubInputs) returns()
func (_IBrevisProof *IBrevisProofTransactorSession) SubmitAggProof(_chainId uint64, _requestIds [][32]byte, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _IBrevisProof.Contract.SubmitAggProof(&_IBrevisProof.TransactOpts, _chainId, _requestIds, _proofWithPubInputs)
}

// SubmitProof is a paid mutator transaction binding the contract method 0xe0440953.
//
// Solidity: function submitProof(uint64 _chainId, bytes _proofWithPubInputs) returns(bytes32 requestId, bytes32 appCommitHash, bytes32 appVkHash)
func (_IBrevisProof *IBrevisProofTransactor) SubmitProof(opts *bind.TransactOpts, _chainId uint64, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _IBrevisProof.contract.Transact(opts, "submitProof", _chainId, _proofWithPubInputs)
}

// SubmitProof is a paid mutator transaction binding the contract method 0xe0440953.
//
// Solidity: function submitProof(uint64 _chainId, bytes _proofWithPubInputs) returns(bytes32 requestId, bytes32 appCommitHash, bytes32 appVkHash)
func (_IBrevisProof *IBrevisProofSession) SubmitProof(_chainId uint64, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _IBrevisProof.Contract.SubmitProof(&_IBrevisProof.TransactOpts, _chainId, _proofWithPubInputs)
}

// SubmitProof is a paid mutator transaction binding the contract method 0xe0440953.
//
// Solidity: function submitProof(uint64 _chainId, bytes _proofWithPubInputs) returns(bytes32 requestId, bytes32 appCommitHash, bytes32 appVkHash)
func (_IBrevisProof *IBrevisProofTransactorSession) SubmitProof(_chainId uint64, _proofWithPubInputs []byte) (*types.Transaction, error) {
	return _IBrevisProof.Contract.SubmitProof(&_IBrevisProof.TransactOpts, _chainId, _proofWithPubInputs)
}

// IBrevisRequestMetaData contains all meta data concerning the IBrevisRequest contract.
var IBrevisRequestMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"_appCommitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_appVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_appChallengeWindow\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_option\",\"type\":\"uint8\"}],\"name\":\"validateOpAppData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_proofIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint64[]\",\"name\":\"_nonces\",\"type\":\"uint64[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_appCommitHashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_appVkHashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"_appChallengeWindow\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_option\",\"type\":\"uint8\"}],\"name\":\"validateOpAppData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// IBrevisRequestABI is the input ABI used to generate the binding from.
// Deprecated: Use IBrevisRequestMetaData.ABI instead.
var IBrevisRequestABI = IBrevisRequestMetaData.ABI

// IBrevisRequest is an auto generated Go binding around an Ethereum contract.
type IBrevisRequest struct {
	IBrevisRequestCaller     // Read-only binding to the contract
	IBrevisRequestTransactor // Write-only binding to the contract
	IBrevisRequestFilterer   // Log filterer for contract events
}

// IBrevisRequestCaller is an auto generated read-only Go binding around an Ethereum contract.
type IBrevisRequestCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBrevisRequestTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IBrevisRequestTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBrevisRequestFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IBrevisRequestFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBrevisRequestSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IBrevisRequestSession struct {
	Contract     *IBrevisRequest   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IBrevisRequestCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IBrevisRequestCallerSession struct {
	Contract *IBrevisRequestCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// IBrevisRequestTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IBrevisRequestTransactorSession struct {
	Contract     *IBrevisRequestTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// IBrevisRequestRaw is an auto generated low-level Go binding around an Ethereum contract.
type IBrevisRequestRaw struct {
	Contract *IBrevisRequest // Generic contract binding to access the raw methods on
}

// IBrevisRequestCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IBrevisRequestCallerRaw struct {
	Contract *IBrevisRequestCaller // Generic read-only contract binding to access the raw methods on
}

// IBrevisRequestTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IBrevisRequestTransactorRaw struct {
	Contract *IBrevisRequestTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIBrevisRequest creates a new instance of IBrevisRequest, bound to a specific deployed contract.
func NewIBrevisRequest(address common.Address, backend bind.ContractBackend) (*IBrevisRequest, error) {
	contract, err := bindIBrevisRequest(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IBrevisRequest{IBrevisRequestCaller: IBrevisRequestCaller{contract: contract}, IBrevisRequestTransactor: IBrevisRequestTransactor{contract: contract}, IBrevisRequestFilterer: IBrevisRequestFilterer{contract: contract}}, nil
}

// NewIBrevisRequestCaller creates a new read-only instance of IBrevisRequest, bound to a specific deployed contract.
func NewIBrevisRequestCaller(address common.Address, caller bind.ContractCaller) (*IBrevisRequestCaller, error) {
	contract, err := bindIBrevisRequest(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IBrevisRequestCaller{contract: contract}, nil
}

// NewIBrevisRequestTransactor creates a new write-only instance of IBrevisRequest, bound to a specific deployed contract.
func NewIBrevisRequestTransactor(address common.Address, transactor bind.ContractTransactor) (*IBrevisRequestTransactor, error) {
	contract, err := bindIBrevisRequest(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IBrevisRequestTransactor{contract: contract}, nil
}

// NewIBrevisRequestFilterer creates a new log filterer instance of IBrevisRequest, bound to a specific deployed contract.
func NewIBrevisRequestFilterer(address common.Address, filterer bind.ContractFilterer) (*IBrevisRequestFilterer, error) {
	contract, err := bindIBrevisRequest(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IBrevisRequestFilterer{contract: contract}, nil
}

// bindIBrevisRequest binds a generic wrapper to an already deployed contract.
func bindIBrevisRequest(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IBrevisRequestMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBrevisRequest *IBrevisRequestRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBrevisRequest.Contract.IBrevisRequestCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBrevisRequest *IBrevisRequestRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBrevisRequest.Contract.IBrevisRequestTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBrevisRequest *IBrevisRequestRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBrevisRequest.Contract.IBrevisRequestTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBrevisRequest *IBrevisRequestCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBrevisRequest.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBrevisRequest *IBrevisRequestTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBrevisRequest.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBrevisRequest *IBrevisRequestTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBrevisRequest.Contract.contract.Transact(opts, method, params...)
}

// ValidateOpAppData is a free data retrieval call binding the contract method 0x54eee2f0.
//
// Solidity: function validateOpAppData(bytes32 _proofId, uint64 _nonce, bytes32 _appCommitHash, bytes32 _appVkHash, uint256 _appChallengeWindow, uint8 _option) view returns(bool)
func (_IBrevisRequest *IBrevisRequestCaller) ValidateOpAppData(opts *bind.CallOpts, _proofId [32]byte, _nonce uint64, _appCommitHash [32]byte, _appVkHash [32]byte, _appChallengeWindow *big.Int, _option uint8) (bool, error) {
	var out []interface{}
	err := _IBrevisRequest.contract.Call(opts, &out, "validateOpAppData", _proofId, _nonce, _appCommitHash, _appVkHash, _appChallengeWindow, _option)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// ValidateOpAppData is a free data retrieval call binding the contract method 0x54eee2f0.
//
// Solidity: function validateOpAppData(bytes32 _proofId, uint64 _nonce, bytes32 _appCommitHash, bytes32 _appVkHash, uint256 _appChallengeWindow, uint8 _option) view returns(bool)
func (_IBrevisRequest *IBrevisRequestSession) ValidateOpAppData(_proofId [32]byte, _nonce uint64, _appCommitHash [32]byte, _appVkHash [32]byte, _appChallengeWindow *big.Int, _option uint8) (bool, error) {
	return _IBrevisRequest.Contract.ValidateOpAppData(&_IBrevisRequest.CallOpts, _proofId, _nonce, _appCommitHash, _appVkHash, _appChallengeWindow, _option)
}

// ValidateOpAppData is a free data retrieval call binding the contract method 0x54eee2f0.
//
// Solidity: function validateOpAppData(bytes32 _proofId, uint64 _nonce, bytes32 _appCommitHash, bytes32 _appVkHash, uint256 _appChallengeWindow, uint8 _option) view returns(bool)
func (_IBrevisRequest *IBrevisRequestCallerSession) ValidateOpAppData(_proofId [32]byte, _nonce uint64, _appCommitHash [32]byte, _appVkHash [32]byte, _appChallengeWindow *big.Int, _option uint8) (bool, error) {
	return _IBrevisRequest.Contract.ValidateOpAppData(&_IBrevisRequest.CallOpts, _proofId, _nonce, _appCommitHash, _appVkHash, _appChallengeWindow, _option)
}

// ValidateOpAppData0 is a free data retrieval call binding the contract method 0xa90f4bd7.
//
// Solidity: function validateOpAppData(bytes32[] _proofIds, uint64[] _nonces, bytes32[] _appCommitHashes, bytes32[] _appVkHashes, uint256 _appChallengeWindow, uint8 _option) view returns(bool)
func (_IBrevisRequest *IBrevisRequestCaller) ValidateOpAppData0(opts *bind.CallOpts, _proofIds [][32]byte, _nonces []uint64, _appCommitHashes [][32]byte, _appVkHashes [][32]byte, _appChallengeWindow *big.Int, _option uint8) (bool, error) {
	var out []interface{}
	err := _IBrevisRequest.contract.Call(opts, &out, "validateOpAppData0", _proofIds, _nonces, _appCommitHashes, _appVkHashes, _appChallengeWindow, _option)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// ValidateOpAppData0 is a free data retrieval call binding the contract method 0xa90f4bd7.
//
// Solidity: function validateOpAppData(bytes32[] _proofIds, uint64[] _nonces, bytes32[] _appCommitHashes, bytes32[] _appVkHashes, uint256 _appChallengeWindow, uint8 _option) view returns(bool)
func (_IBrevisRequest *IBrevisRequestSession) ValidateOpAppData0(_proofIds [][32]byte, _nonces []uint64, _appCommitHashes [][32]byte, _appVkHashes [][32]byte, _appChallengeWindow *big.Int, _option uint8) (bool, error) {
	return _IBrevisRequest.Contract.ValidateOpAppData0(&_IBrevisRequest.CallOpts, _proofIds, _nonces, _appCommitHashes, _appVkHashes, _appChallengeWindow, _option)
}

// ValidateOpAppData0 is a free data retrieval call binding the contract method 0xa90f4bd7.
//
// Solidity: function validateOpAppData(bytes32[] _proofIds, uint64[] _nonces, bytes32[] _appCommitHashes, bytes32[] _appVkHashes, uint256 _appChallengeWindow, uint8 _option) view returns(bool)
func (_IBrevisRequest *IBrevisRequestCallerSession) ValidateOpAppData0(_proofIds [][32]byte, _nonces []uint64, _appCommitHashes [][32]byte, _appVkHashes [][32]byte, _appChallengeWindow *big.Int, _option uint8) (bool, error) {
	return _IBrevisRequest.Contract.ValidateOpAppData0(&_IBrevisRequest.CallOpts, _proofIds, _nonces, _appCommitHashes, _appVkHashes, _appChallengeWindow, _option)
}

// IBrevisTypesMetaData contains all meta data concerning the IBrevisTypes contract.
var IBrevisTypesMetaData = &bind.MetaData{
	ABI: "[]",
}

// IBrevisTypesABI is the input ABI used to generate the binding from.
// Deprecated: Use IBrevisTypesMetaData.ABI instead.
var IBrevisTypesABI = IBrevisTypesMetaData.ABI

// IBrevisTypes is an auto generated Go binding around an Ethereum contract.
type IBrevisTypes struct {
	IBrevisTypesCaller     // Read-only binding to the contract
	IBrevisTypesTransactor // Write-only binding to the contract
	IBrevisTypesFilterer   // Log filterer for contract events
}

// IBrevisTypesCaller is an auto generated read-only Go binding around an Ethereum contract.
type IBrevisTypesCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBrevisTypesTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IBrevisTypesTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBrevisTypesFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IBrevisTypesFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBrevisTypesSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IBrevisTypesSession struct {
	Contract     *IBrevisTypes     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IBrevisTypesCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IBrevisTypesCallerSession struct {
	Contract *IBrevisTypesCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// IBrevisTypesTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IBrevisTypesTransactorSession struct {
	Contract     *IBrevisTypesTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// IBrevisTypesRaw is an auto generated low-level Go binding around an Ethereum contract.
type IBrevisTypesRaw struct {
	Contract *IBrevisTypes // Generic contract binding to access the raw methods on
}

// IBrevisTypesCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IBrevisTypesCallerRaw struct {
	Contract *IBrevisTypesCaller // Generic read-only contract binding to access the raw methods on
}

// IBrevisTypesTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IBrevisTypesTransactorRaw struct {
	Contract *IBrevisTypesTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIBrevisTypes creates a new instance of IBrevisTypes, bound to a specific deployed contract.
func NewIBrevisTypes(address common.Address, backend bind.ContractBackend) (*IBrevisTypes, error) {
	contract, err := bindIBrevisTypes(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IBrevisTypes{IBrevisTypesCaller: IBrevisTypesCaller{contract: contract}, IBrevisTypesTransactor: IBrevisTypesTransactor{contract: contract}, IBrevisTypesFilterer: IBrevisTypesFilterer{contract: contract}}, nil
}

// NewIBrevisTypesCaller creates a new read-only instance of IBrevisTypes, bound to a specific deployed contract.
func NewIBrevisTypesCaller(address common.Address, caller bind.ContractCaller) (*IBrevisTypesCaller, error) {
	contract, err := bindIBrevisTypes(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IBrevisTypesCaller{contract: contract}, nil
}

// NewIBrevisTypesTransactor creates a new write-only instance of IBrevisTypes, bound to a specific deployed contract.
func NewIBrevisTypesTransactor(address common.Address, transactor bind.ContractTransactor) (*IBrevisTypesTransactor, error) {
	contract, err := bindIBrevisTypes(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IBrevisTypesTransactor{contract: contract}, nil
}

// NewIBrevisTypesFilterer creates a new log filterer instance of IBrevisTypes, bound to a specific deployed contract.
func NewIBrevisTypesFilterer(address common.Address, filterer bind.ContractFilterer) (*IBrevisTypesFilterer, error) {
	contract, err := bindIBrevisTypes(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IBrevisTypesFilterer{contract: contract}, nil
}

// bindIBrevisTypes binds a generic wrapper to an already deployed contract.
func bindIBrevisTypes(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IBrevisTypesMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBrevisTypes *IBrevisTypesRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBrevisTypes.Contract.IBrevisTypesCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBrevisTypes *IBrevisTypesRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBrevisTypes.Contract.IBrevisTypesTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBrevisTypes *IBrevisTypesRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBrevisTypes.Contract.IBrevisTypesTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBrevisTypes *IBrevisTypesCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBrevisTypes.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBrevisTypes *IBrevisTypesTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBrevisTypes.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBrevisTypes *IBrevisTypesTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBrevisTypes.Contract.contract.Transact(opts, method, params...)
}

// IBvnSigsVerifierMetaData contains all meta data concerning the IBvnSigsVerifier contract.
var IBvnSigsVerifierMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_msgHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes[]\",\"name\":\"_sigs\",\"type\":\"bytes[]\"},{\"internalType\":\"address[]\",\"name\":\"_signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_powers\",\"type\":\"uint256[]\"}],\"name\":\"verifySigs\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_msg\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"_sigs\",\"type\":\"bytes[]\"},{\"internalType\":\"address[]\",\"name\":\"_signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_powers\",\"type\":\"uint256[]\"}],\"name\":\"verifySigs\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// IBvnSigsVerifierABI is the input ABI used to generate the binding from.
// Deprecated: Use IBvnSigsVerifierMetaData.ABI instead.
var IBvnSigsVerifierABI = IBvnSigsVerifierMetaData.ABI

// IBvnSigsVerifier is an auto generated Go binding around an Ethereum contract.
type IBvnSigsVerifier struct {
	IBvnSigsVerifierCaller     // Read-only binding to the contract
	IBvnSigsVerifierTransactor // Write-only binding to the contract
	IBvnSigsVerifierFilterer   // Log filterer for contract events
}

// IBvnSigsVerifierCaller is an auto generated read-only Go binding around an Ethereum contract.
type IBvnSigsVerifierCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBvnSigsVerifierTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IBvnSigsVerifierTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBvnSigsVerifierFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IBvnSigsVerifierFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBvnSigsVerifierSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IBvnSigsVerifierSession struct {
	Contract     *IBvnSigsVerifier // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IBvnSigsVerifierCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IBvnSigsVerifierCallerSession struct {
	Contract *IBvnSigsVerifierCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts           // Call options to use throughout this session
}

// IBvnSigsVerifierTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IBvnSigsVerifierTransactorSession struct {
	Contract     *IBvnSigsVerifierTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts           // Transaction auth options to use throughout this session
}

// IBvnSigsVerifierRaw is an auto generated low-level Go binding around an Ethereum contract.
type IBvnSigsVerifierRaw struct {
	Contract *IBvnSigsVerifier // Generic contract binding to access the raw methods on
}

// IBvnSigsVerifierCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IBvnSigsVerifierCallerRaw struct {
	Contract *IBvnSigsVerifierCaller // Generic read-only contract binding to access the raw methods on
}

// IBvnSigsVerifierTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IBvnSigsVerifierTransactorRaw struct {
	Contract *IBvnSigsVerifierTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIBvnSigsVerifier creates a new instance of IBvnSigsVerifier, bound to a specific deployed contract.
func NewIBvnSigsVerifier(address common.Address, backend bind.ContractBackend) (*IBvnSigsVerifier, error) {
	contract, err := bindIBvnSigsVerifier(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IBvnSigsVerifier{IBvnSigsVerifierCaller: IBvnSigsVerifierCaller{contract: contract}, IBvnSigsVerifierTransactor: IBvnSigsVerifierTransactor{contract: contract}, IBvnSigsVerifierFilterer: IBvnSigsVerifierFilterer{contract: contract}}, nil
}

// NewIBvnSigsVerifierCaller creates a new read-only instance of IBvnSigsVerifier, bound to a specific deployed contract.
func NewIBvnSigsVerifierCaller(address common.Address, caller bind.ContractCaller) (*IBvnSigsVerifierCaller, error) {
	contract, err := bindIBvnSigsVerifier(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IBvnSigsVerifierCaller{contract: contract}, nil
}

// NewIBvnSigsVerifierTransactor creates a new write-only instance of IBvnSigsVerifier, bound to a specific deployed contract.
func NewIBvnSigsVerifierTransactor(address common.Address, transactor bind.ContractTransactor) (*IBvnSigsVerifierTransactor, error) {
	contract, err := bindIBvnSigsVerifier(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IBvnSigsVerifierTransactor{contract: contract}, nil
}

// NewIBvnSigsVerifierFilterer creates a new log filterer instance of IBvnSigsVerifier, bound to a specific deployed contract.
func NewIBvnSigsVerifierFilterer(address common.Address, filterer bind.ContractFilterer) (*IBvnSigsVerifierFilterer, error) {
	contract, err := bindIBvnSigsVerifier(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IBvnSigsVerifierFilterer{contract: contract}, nil
}

// bindIBvnSigsVerifier binds a generic wrapper to an already deployed contract.
func bindIBvnSigsVerifier(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IBvnSigsVerifierMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBvnSigsVerifier *IBvnSigsVerifierRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBvnSigsVerifier.Contract.IBvnSigsVerifierCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBvnSigsVerifier *IBvnSigsVerifierRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBvnSigsVerifier.Contract.IBvnSigsVerifierTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBvnSigsVerifier *IBvnSigsVerifierRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBvnSigsVerifier.Contract.IBvnSigsVerifierTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBvnSigsVerifier *IBvnSigsVerifierCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBvnSigsVerifier.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBvnSigsVerifier *IBvnSigsVerifierTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBvnSigsVerifier.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBvnSigsVerifier *IBvnSigsVerifierTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBvnSigsVerifier.Contract.contract.Transact(opts, method, params...)
}

// VerifySigs is a free data retrieval call binding the contract method 0x3d42a890.
//
// Solidity: function verifySigs(bytes32 _msgHash, bytes[] _sigs, address[] _signers, uint256[] _powers) view returns()
func (_IBvnSigsVerifier *IBvnSigsVerifierCaller) VerifySigs(opts *bind.CallOpts, _msgHash [32]byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) error {
	var out []interface{}
	err := _IBvnSigsVerifier.contract.Call(opts, &out, "verifySigs", _msgHash, _sigs, _signers, _powers)

	if err != nil {
		return err
	}

	return err

}

// VerifySigs is a free data retrieval call binding the contract method 0x3d42a890.
//
// Solidity: function verifySigs(bytes32 _msgHash, bytes[] _sigs, address[] _signers, uint256[] _powers) view returns()
func (_IBvnSigsVerifier *IBvnSigsVerifierSession) VerifySigs(_msgHash [32]byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) error {
	return _IBvnSigsVerifier.Contract.VerifySigs(&_IBvnSigsVerifier.CallOpts, _msgHash, _sigs, _signers, _powers)
}

// VerifySigs is a free data retrieval call binding the contract method 0x3d42a890.
//
// Solidity: function verifySigs(bytes32 _msgHash, bytes[] _sigs, address[] _signers, uint256[] _powers) view returns()
func (_IBvnSigsVerifier *IBvnSigsVerifierCallerSession) VerifySigs(_msgHash [32]byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) error {
	return _IBvnSigsVerifier.Contract.VerifySigs(&_IBvnSigsVerifier.CallOpts, _msgHash, _sigs, _signers, _powers)
}

// VerifySigs0 is a free data retrieval call binding the contract method 0x682dbc22.
//
// Solidity: function verifySigs(bytes _msg, bytes[] _sigs, address[] _signers, uint256[] _powers) view returns()
func (_IBvnSigsVerifier *IBvnSigsVerifierCaller) VerifySigs0(opts *bind.CallOpts, _msg []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) error {
	var out []interface{}
	err := _IBvnSigsVerifier.contract.Call(opts, &out, "verifySigs0", _msg, _sigs, _signers, _powers)

	if err != nil {
		return err
	}

	return err

}

// VerifySigs0 is a free data retrieval call binding the contract method 0x682dbc22.
//
// Solidity: function verifySigs(bytes _msg, bytes[] _sigs, address[] _signers, uint256[] _powers) view returns()
func (_IBvnSigsVerifier *IBvnSigsVerifierSession) VerifySigs0(_msg []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) error {
	return _IBvnSigsVerifier.Contract.VerifySigs0(&_IBvnSigsVerifier.CallOpts, _msg, _sigs, _signers, _powers)
}

// VerifySigs0 is a free data retrieval call binding the contract method 0x682dbc22.
//
// Solidity: function verifySigs(bytes _msg, bytes[] _sigs, address[] _signers, uint256[] _powers) view returns()
func (_IBvnSigsVerifier *IBvnSigsVerifierCallerSession) VerifySigs0(_msg []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) error {
	return _IBvnSigsVerifier.Contract.VerifySigs0(&_IBvnSigsVerifier.CallOpts, _msg, _sigs, _signers, _powers)
}

// IDynamicFeeManagerMetaData contains all meta data concerning the IDynamicFeeManager contract.
var IDynamicFeeManagerMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"zeroForOne\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"amountSpecified\",\"type\":\"int256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"structIPoolManager.SwapParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"getFee\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IDynamicFeeManagerABI is the input ABI used to generate the binding from.
// Deprecated: Use IDynamicFeeManagerMetaData.ABI instead.
var IDynamicFeeManagerABI = IDynamicFeeManagerMetaData.ABI

// IDynamicFeeManager is an auto generated Go binding around an Ethereum contract.
type IDynamicFeeManager struct {
	IDynamicFeeManagerCaller     // Read-only binding to the contract
	IDynamicFeeManagerTransactor // Write-only binding to the contract
	IDynamicFeeManagerFilterer   // Log filterer for contract events
}

// IDynamicFeeManagerCaller is an auto generated read-only Go binding around an Ethereum contract.
type IDynamicFeeManagerCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IDynamicFeeManagerTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IDynamicFeeManagerTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IDynamicFeeManagerFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IDynamicFeeManagerFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IDynamicFeeManagerSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IDynamicFeeManagerSession struct {
	Contract     *IDynamicFeeManager // Generic contract binding to set the session for
	CallOpts     bind.CallOpts       // Call options to use throughout this session
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// IDynamicFeeManagerCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IDynamicFeeManagerCallerSession struct {
	Contract *IDynamicFeeManagerCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts             // Call options to use throughout this session
}

// IDynamicFeeManagerTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IDynamicFeeManagerTransactorSession struct {
	Contract     *IDynamicFeeManagerTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts             // Transaction auth options to use throughout this session
}

// IDynamicFeeManagerRaw is an auto generated low-level Go binding around an Ethereum contract.
type IDynamicFeeManagerRaw struct {
	Contract *IDynamicFeeManager // Generic contract binding to access the raw methods on
}

// IDynamicFeeManagerCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IDynamicFeeManagerCallerRaw struct {
	Contract *IDynamicFeeManagerCaller // Generic read-only contract binding to access the raw methods on
}

// IDynamicFeeManagerTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IDynamicFeeManagerTransactorRaw struct {
	Contract *IDynamicFeeManagerTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIDynamicFeeManager creates a new instance of IDynamicFeeManager, bound to a specific deployed contract.
func NewIDynamicFeeManager(address common.Address, backend bind.ContractBackend) (*IDynamicFeeManager, error) {
	contract, err := bindIDynamicFeeManager(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IDynamicFeeManager{IDynamicFeeManagerCaller: IDynamicFeeManagerCaller{contract: contract}, IDynamicFeeManagerTransactor: IDynamicFeeManagerTransactor{contract: contract}, IDynamicFeeManagerFilterer: IDynamicFeeManagerFilterer{contract: contract}}, nil
}

// NewIDynamicFeeManagerCaller creates a new read-only instance of IDynamicFeeManager, bound to a specific deployed contract.
func NewIDynamicFeeManagerCaller(address common.Address, caller bind.ContractCaller) (*IDynamicFeeManagerCaller, error) {
	contract, err := bindIDynamicFeeManager(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IDynamicFeeManagerCaller{contract: contract}, nil
}

// NewIDynamicFeeManagerTransactor creates a new write-only instance of IDynamicFeeManager, bound to a specific deployed contract.
func NewIDynamicFeeManagerTransactor(address common.Address, transactor bind.ContractTransactor) (*IDynamicFeeManagerTransactor, error) {
	contract, err := bindIDynamicFeeManager(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IDynamicFeeManagerTransactor{contract: contract}, nil
}

// NewIDynamicFeeManagerFilterer creates a new log filterer instance of IDynamicFeeManager, bound to a specific deployed contract.
func NewIDynamicFeeManagerFilterer(address common.Address, filterer bind.ContractFilterer) (*IDynamicFeeManagerFilterer, error) {
	contract, err := bindIDynamicFeeManager(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IDynamicFeeManagerFilterer{contract: contract}, nil
}

// bindIDynamicFeeManager binds a generic wrapper to an already deployed contract.
func bindIDynamicFeeManager(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IDynamicFeeManagerMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IDynamicFeeManager *IDynamicFeeManagerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IDynamicFeeManager.Contract.IDynamicFeeManagerCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IDynamicFeeManager *IDynamicFeeManagerRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IDynamicFeeManager.Contract.IDynamicFeeManagerTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IDynamicFeeManager *IDynamicFeeManagerRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IDynamicFeeManager.Contract.IDynamicFeeManagerTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IDynamicFeeManager *IDynamicFeeManagerCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IDynamicFeeManager.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IDynamicFeeManager *IDynamicFeeManagerTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IDynamicFeeManager.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IDynamicFeeManager *IDynamicFeeManagerTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IDynamicFeeManager.Contract.contract.Transact(opts, method, params...)
}

// GetFee is a paid mutator transaction binding the contract method 0x2ab7a3e2.
//
// Solidity: function getFee(address sender, (address,address,uint24,int24,address) key, (bool,int256,uint160) params, bytes data) returns(uint24)
func (_IDynamicFeeManager *IDynamicFeeManagerTransactor) GetFee(opts *bind.TransactOpts, sender common.Address, key PoolKey, params IPoolManagerSwapParams, data []byte) (*types.Transaction, error) {
	return _IDynamicFeeManager.contract.Transact(opts, "getFee", sender, key, params, data)
}

// GetFee is a paid mutator transaction binding the contract method 0x2ab7a3e2.
//
// Solidity: function getFee(address sender, (address,address,uint24,int24,address) key, (bool,int256,uint160) params, bytes data) returns(uint24)
func (_IDynamicFeeManager *IDynamicFeeManagerSession) GetFee(sender common.Address, key PoolKey, params IPoolManagerSwapParams, data []byte) (*types.Transaction, error) {
	return _IDynamicFeeManager.Contract.GetFee(&_IDynamicFeeManager.TransactOpts, sender, key, params, data)
}

// GetFee is a paid mutator transaction binding the contract method 0x2ab7a3e2.
//
// Solidity: function getFee(address sender, (address,address,uint24,int24,address) key, (bool,int256,uint160) params, bytes data) returns(uint24)
func (_IDynamicFeeManager *IDynamicFeeManagerTransactorSession) GetFee(sender common.Address, key PoolKey, params IPoolManagerSwapParams, data []byte) (*types.Transaction, error) {
	return _IDynamicFeeManager.Contract.GetFee(&_IDynamicFeeManager.TransactOpts, sender, key, params, data)
}

// IERC1155MetaData contains all meta data concerning the IERC1155 contract.
var IERC1155MetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// IERC1155ABI is the input ABI used to generate the binding from.
// Deprecated: Use IERC1155MetaData.ABI instead.
var IERC1155ABI = IERC1155MetaData.ABI

// IERC1155 is an auto generated Go binding around an Ethereum contract.
type IERC1155 struct {
	IERC1155Caller     // Read-only binding to the contract
	IERC1155Transactor // Write-only binding to the contract
	IERC1155Filterer   // Log filterer for contract events
}

// IERC1155Caller is an auto generated read-only Go binding around an Ethereum contract.
type IERC1155Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC1155Transactor is an auto generated write-only Go binding around an Ethereum contract.
type IERC1155Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC1155Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IERC1155Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC1155Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IERC1155Session struct {
	Contract     *IERC1155         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC1155CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IERC1155CallerSession struct {
	Contract *IERC1155Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// IERC1155TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IERC1155TransactorSession struct {
	Contract     *IERC1155Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// IERC1155Raw is an auto generated low-level Go binding around an Ethereum contract.
type IERC1155Raw struct {
	Contract *IERC1155 // Generic contract binding to access the raw methods on
}

// IERC1155CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IERC1155CallerRaw struct {
	Contract *IERC1155Caller // Generic read-only contract binding to access the raw methods on
}

// IERC1155TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IERC1155TransactorRaw struct {
	Contract *IERC1155Transactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC1155 creates a new instance of IERC1155, bound to a specific deployed contract.
func NewIERC1155(address common.Address, backend bind.ContractBackend) (*IERC1155, error) {
	contract, err := bindIERC1155(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC1155{IERC1155Caller: IERC1155Caller{contract: contract}, IERC1155Transactor: IERC1155Transactor{contract: contract}, IERC1155Filterer: IERC1155Filterer{contract: contract}}, nil
}

// NewIERC1155Caller creates a new read-only instance of IERC1155, bound to a specific deployed contract.
func NewIERC1155Caller(address common.Address, caller bind.ContractCaller) (*IERC1155Caller, error) {
	contract, err := bindIERC1155(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC1155Caller{contract: contract}, nil
}

// NewIERC1155Transactor creates a new write-only instance of IERC1155, bound to a specific deployed contract.
func NewIERC1155Transactor(address common.Address, transactor bind.ContractTransactor) (*IERC1155Transactor, error) {
	contract, err := bindIERC1155(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC1155Transactor{contract: contract}, nil
}

// NewIERC1155Filterer creates a new log filterer instance of IERC1155, bound to a specific deployed contract.
func NewIERC1155Filterer(address common.Address, filterer bind.ContractFilterer) (*IERC1155Filterer, error) {
	contract, err := bindIERC1155(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC1155Filterer{contract: contract}, nil
}

// bindIERC1155 binds a generic wrapper to an already deployed contract.
func bindIERC1155(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IERC1155MetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC1155 *IERC1155Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC1155.Contract.IERC1155Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC1155 *IERC1155Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC1155.Contract.IERC1155Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC1155 *IERC1155Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC1155.Contract.IERC1155Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC1155 *IERC1155CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC1155.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC1155 *IERC1155TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC1155.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC1155 *IERC1155TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC1155.Contract.contract.Transact(opts, method, params...)
}

// BalanceOf is a free data retrieval call binding the contract method 0x00fdd58e.
//
// Solidity: function balanceOf(address account, uint256 id) view returns(uint256)
func (_IERC1155 *IERC1155Caller) BalanceOf(opts *bind.CallOpts, account common.Address, id *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _IERC1155.contract.Call(opts, &out, "balanceOf", account, id)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x00fdd58e.
//
// Solidity: function balanceOf(address account, uint256 id) view returns(uint256)
func (_IERC1155 *IERC1155Session) BalanceOf(account common.Address, id *big.Int) (*big.Int, error) {
	return _IERC1155.Contract.BalanceOf(&_IERC1155.CallOpts, account, id)
}

// BalanceOf is a free data retrieval call binding the contract method 0x00fdd58e.
//
// Solidity: function balanceOf(address account, uint256 id) view returns(uint256)
func (_IERC1155 *IERC1155CallerSession) BalanceOf(account common.Address, id *big.Int) (*big.Int, error) {
	return _IERC1155.Contract.BalanceOf(&_IERC1155.CallOpts, account, id)
}

// BalanceOfBatch is a free data retrieval call binding the contract method 0x4e1273f4.
//
// Solidity: function balanceOfBatch(address[] accounts, uint256[] ids) view returns(uint256[])
func (_IERC1155 *IERC1155Caller) BalanceOfBatch(opts *bind.CallOpts, accounts []common.Address, ids []*big.Int) ([]*big.Int, error) {
	var out []interface{}
	err := _IERC1155.contract.Call(opts, &out, "balanceOfBatch", accounts, ids)

	if err != nil {
		return *new([]*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new([]*big.Int)).(*[]*big.Int)

	return out0, err

}

// BalanceOfBatch is a free data retrieval call binding the contract method 0x4e1273f4.
//
// Solidity: function balanceOfBatch(address[] accounts, uint256[] ids) view returns(uint256[])
func (_IERC1155 *IERC1155Session) BalanceOfBatch(accounts []common.Address, ids []*big.Int) ([]*big.Int, error) {
	return _IERC1155.Contract.BalanceOfBatch(&_IERC1155.CallOpts, accounts, ids)
}

// BalanceOfBatch is a free data retrieval call binding the contract method 0x4e1273f4.
//
// Solidity: function balanceOfBatch(address[] accounts, uint256[] ids) view returns(uint256[])
func (_IERC1155 *IERC1155CallerSession) BalanceOfBatch(accounts []common.Address, ids []*big.Int) ([]*big.Int, error) {
	return _IERC1155.Contract.BalanceOfBatch(&_IERC1155.CallOpts, accounts, ids)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address account, address operator) view returns(bool)
func (_IERC1155 *IERC1155Caller) IsApprovedForAll(opts *bind.CallOpts, account common.Address, operator common.Address) (bool, error) {
	var out []interface{}
	err := _IERC1155.contract.Call(opts, &out, "isApprovedForAll", account, operator)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address account, address operator) view returns(bool)
func (_IERC1155 *IERC1155Session) IsApprovedForAll(account common.Address, operator common.Address) (bool, error) {
	return _IERC1155.Contract.IsApprovedForAll(&_IERC1155.CallOpts, account, operator)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address account, address operator) view returns(bool)
func (_IERC1155 *IERC1155CallerSession) IsApprovedForAll(account common.Address, operator common.Address) (bool, error) {
	return _IERC1155.Contract.IsApprovedForAll(&_IERC1155.CallOpts, account, operator)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IERC1155 *IERC1155Caller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _IERC1155.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IERC1155 *IERC1155Session) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _IERC1155.Contract.SupportsInterface(&_IERC1155.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IERC1155 *IERC1155CallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _IERC1155.Contract.SupportsInterface(&_IERC1155.CallOpts, interfaceId)
}

// SafeBatchTransferFrom is a paid mutator transaction binding the contract method 0x2eb2c2d6.
//
// Solidity: function safeBatchTransferFrom(address from, address to, uint256[] ids, uint256[] amounts, bytes data) returns()
func (_IERC1155 *IERC1155Transactor) SafeBatchTransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, ids []*big.Int, amounts []*big.Int, data []byte) (*types.Transaction, error) {
	return _IERC1155.contract.Transact(opts, "safeBatchTransferFrom", from, to, ids, amounts, data)
}

// SafeBatchTransferFrom is a paid mutator transaction binding the contract method 0x2eb2c2d6.
//
// Solidity: function safeBatchTransferFrom(address from, address to, uint256[] ids, uint256[] amounts, bytes data) returns()
func (_IERC1155 *IERC1155Session) SafeBatchTransferFrom(from common.Address, to common.Address, ids []*big.Int, amounts []*big.Int, data []byte) (*types.Transaction, error) {
	return _IERC1155.Contract.SafeBatchTransferFrom(&_IERC1155.TransactOpts, from, to, ids, amounts, data)
}

// SafeBatchTransferFrom is a paid mutator transaction binding the contract method 0x2eb2c2d6.
//
// Solidity: function safeBatchTransferFrom(address from, address to, uint256[] ids, uint256[] amounts, bytes data) returns()
func (_IERC1155 *IERC1155TransactorSession) SafeBatchTransferFrom(from common.Address, to common.Address, ids []*big.Int, amounts []*big.Int, data []byte) (*types.Transaction, error) {
	return _IERC1155.Contract.SafeBatchTransferFrom(&_IERC1155.TransactOpts, from, to, ids, amounts, data)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0xf242432a.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes data) returns()
func (_IERC1155 *IERC1155Transactor) SafeTransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, id *big.Int, amount *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC1155.contract.Transact(opts, "safeTransferFrom", from, to, id, amount, data)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0xf242432a.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes data) returns()
func (_IERC1155 *IERC1155Session) SafeTransferFrom(from common.Address, to common.Address, id *big.Int, amount *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC1155.Contract.SafeTransferFrom(&_IERC1155.TransactOpts, from, to, id, amount, data)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0xf242432a.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes data) returns()
func (_IERC1155 *IERC1155TransactorSession) SafeTransferFrom(from common.Address, to common.Address, id *big.Int, amount *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC1155.Contract.SafeTransferFrom(&_IERC1155.TransactOpts, from, to, id, amount, data)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_IERC1155 *IERC1155Transactor) SetApprovalForAll(opts *bind.TransactOpts, operator common.Address, approved bool) (*types.Transaction, error) {
	return _IERC1155.contract.Transact(opts, "setApprovalForAll", operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_IERC1155 *IERC1155Session) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _IERC1155.Contract.SetApprovalForAll(&_IERC1155.TransactOpts, operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_IERC1155 *IERC1155TransactorSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _IERC1155.Contract.SetApprovalForAll(&_IERC1155.TransactOpts, operator, approved)
}

// IERC1155ApprovalForAllIterator is returned from FilterApprovalForAll and is used to iterate over the raw logs and unpacked data for ApprovalForAll events raised by the IERC1155 contract.
type IERC1155ApprovalForAllIterator struct {
	Event *IERC1155ApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC1155ApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC1155ApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC1155ApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC1155ApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC1155ApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC1155ApprovalForAll represents a ApprovalForAll event raised by the IERC1155 contract.
type IERC1155ApprovalForAll struct {
	Account  common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApprovalForAll is a free log retrieval operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed account, address indexed operator, bool approved)
func (_IERC1155 *IERC1155Filterer) FilterApprovalForAll(opts *bind.FilterOpts, account []common.Address, operator []common.Address) (*IERC1155ApprovalForAllIterator, error) {

	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _IERC1155.contract.FilterLogs(opts, "ApprovalForAll", accountRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return &IERC1155ApprovalForAllIterator{contract: _IERC1155.contract, event: "ApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchApprovalForAll is a free log subscription operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed account, address indexed operator, bool approved)
func (_IERC1155 *IERC1155Filterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *IERC1155ApprovalForAll, account []common.Address, operator []common.Address) (event.Subscription, error) {

	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _IERC1155.contract.WatchLogs(opts, "ApprovalForAll", accountRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC1155ApprovalForAll)
				if err := _IERC1155.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApprovalForAll is a log parse operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed account, address indexed operator, bool approved)
func (_IERC1155 *IERC1155Filterer) ParseApprovalForAll(log types.Log) (*IERC1155ApprovalForAll, error) {
	event := new(IERC1155ApprovalForAll)
	if err := _IERC1155.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC1155TransferBatchIterator is returned from FilterTransferBatch and is used to iterate over the raw logs and unpacked data for TransferBatch events raised by the IERC1155 contract.
type IERC1155TransferBatchIterator struct {
	Event *IERC1155TransferBatch // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC1155TransferBatchIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC1155TransferBatch)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC1155TransferBatch)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC1155TransferBatchIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC1155TransferBatchIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC1155TransferBatch represents a TransferBatch event raised by the IERC1155 contract.
type IERC1155TransferBatch struct {
	Operator common.Address
	From     common.Address
	To       common.Address
	Ids      []*big.Int
	Values   []*big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterTransferBatch is a free log retrieval operation binding the contract event 0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb.
//
// Solidity: event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values)
func (_IERC1155 *IERC1155Filterer) FilterTransferBatch(opts *bind.FilterOpts, operator []common.Address, from []common.Address, to []common.Address) (*IERC1155TransferBatchIterator, error) {

	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC1155.contract.FilterLogs(opts, "TransferBatch", operatorRule, fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &IERC1155TransferBatchIterator{contract: _IERC1155.contract, event: "TransferBatch", logs: logs, sub: sub}, nil
}

// WatchTransferBatch is a free log subscription operation binding the contract event 0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb.
//
// Solidity: event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values)
func (_IERC1155 *IERC1155Filterer) WatchTransferBatch(opts *bind.WatchOpts, sink chan<- *IERC1155TransferBatch, operator []common.Address, from []common.Address, to []common.Address) (event.Subscription, error) {

	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC1155.contract.WatchLogs(opts, "TransferBatch", operatorRule, fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC1155TransferBatch)
				if err := _IERC1155.contract.UnpackLog(event, "TransferBatch", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransferBatch is a log parse operation binding the contract event 0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb.
//
// Solidity: event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values)
func (_IERC1155 *IERC1155Filterer) ParseTransferBatch(log types.Log) (*IERC1155TransferBatch, error) {
	event := new(IERC1155TransferBatch)
	if err := _IERC1155.contract.UnpackLog(event, "TransferBatch", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC1155TransferSingleIterator is returned from FilterTransferSingle and is used to iterate over the raw logs and unpacked data for TransferSingle events raised by the IERC1155 contract.
type IERC1155TransferSingleIterator struct {
	Event *IERC1155TransferSingle // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC1155TransferSingleIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC1155TransferSingle)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC1155TransferSingle)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC1155TransferSingleIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC1155TransferSingleIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC1155TransferSingle represents a TransferSingle event raised by the IERC1155 contract.
type IERC1155TransferSingle struct {
	Operator common.Address
	From     common.Address
	To       common.Address
	Id       *big.Int
	Value    *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterTransferSingle is a free log retrieval operation binding the contract event 0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62.
//
// Solidity: event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value)
func (_IERC1155 *IERC1155Filterer) FilterTransferSingle(opts *bind.FilterOpts, operator []common.Address, from []common.Address, to []common.Address) (*IERC1155TransferSingleIterator, error) {

	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC1155.contract.FilterLogs(opts, "TransferSingle", operatorRule, fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &IERC1155TransferSingleIterator{contract: _IERC1155.contract, event: "TransferSingle", logs: logs, sub: sub}, nil
}

// WatchTransferSingle is a free log subscription operation binding the contract event 0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62.
//
// Solidity: event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value)
func (_IERC1155 *IERC1155Filterer) WatchTransferSingle(opts *bind.WatchOpts, sink chan<- *IERC1155TransferSingle, operator []common.Address, from []common.Address, to []common.Address) (event.Subscription, error) {

	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC1155.contract.WatchLogs(opts, "TransferSingle", operatorRule, fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC1155TransferSingle)
				if err := _IERC1155.contract.UnpackLog(event, "TransferSingle", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransferSingle is a log parse operation binding the contract event 0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62.
//
// Solidity: event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value)
func (_IERC1155 *IERC1155Filterer) ParseTransferSingle(log types.Log) (*IERC1155TransferSingle, error) {
	event := new(IERC1155TransferSingle)
	if err := _IERC1155.contract.UnpackLog(event, "TransferSingle", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC1155URIIterator is returned from FilterURI and is used to iterate over the raw logs and unpacked data for URI events raised by the IERC1155 contract.
type IERC1155URIIterator struct {
	Event *IERC1155URI // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC1155URIIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC1155URI)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC1155URI)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC1155URIIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC1155URIIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC1155URI represents a URI event raised by the IERC1155 contract.
type IERC1155URI struct {
	Value string
	Id    *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterURI is a free log retrieval operation binding the contract event 0x6bb7ff708619ba0610cba295a58592e0451dee2622938c8755667688daf3529b.
//
// Solidity: event URI(string value, uint256 indexed id)
func (_IERC1155 *IERC1155Filterer) FilterURI(opts *bind.FilterOpts, id []*big.Int) (*IERC1155URIIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _IERC1155.contract.FilterLogs(opts, "URI", idRule)
	if err != nil {
		return nil, err
	}
	return &IERC1155URIIterator{contract: _IERC1155.contract, event: "URI", logs: logs, sub: sub}, nil
}

// WatchURI is a free log subscription operation binding the contract event 0x6bb7ff708619ba0610cba295a58592e0451dee2622938c8755667688daf3529b.
//
// Solidity: event URI(string value, uint256 indexed id)
func (_IERC1155 *IERC1155Filterer) WatchURI(opts *bind.WatchOpts, sink chan<- *IERC1155URI, id []*big.Int) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _IERC1155.contract.WatchLogs(opts, "URI", idRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC1155URI)
				if err := _IERC1155.contract.UnpackLog(event, "URI", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseURI is a log parse operation binding the contract event 0x6bb7ff708619ba0610cba295a58592e0451dee2622938c8755667688daf3529b.
//
// Solidity: event URI(string value, uint256 indexed id)
func (_IERC1155 *IERC1155Filterer) ParseURI(log types.Log) (*IERC1155URI, error) {
	event := new(IERC1155URI)
	if err := _IERC1155.contract.UnpackLog(event, "URI", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC165MetaData contains all meta data concerning the IERC165 contract.
var IERC165MetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// IERC165ABI is the input ABI used to generate the binding from.
// Deprecated: Use IERC165MetaData.ABI instead.
var IERC165ABI = IERC165MetaData.ABI

// IERC165 is an auto generated Go binding around an Ethereum contract.
type IERC165 struct {
	IERC165Caller     // Read-only binding to the contract
	IERC165Transactor // Write-only binding to the contract
	IERC165Filterer   // Log filterer for contract events
}

// IERC165Caller is an auto generated read-only Go binding around an Ethereum contract.
type IERC165Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC165Transactor is an auto generated write-only Go binding around an Ethereum contract.
type IERC165Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC165Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IERC165Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC165Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IERC165Session struct {
	Contract     *IERC165          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC165CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IERC165CallerSession struct {
	Contract *IERC165Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// IERC165TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IERC165TransactorSession struct {
	Contract     *IERC165Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// IERC165Raw is an auto generated low-level Go binding around an Ethereum contract.
type IERC165Raw struct {
	Contract *IERC165 // Generic contract binding to access the raw methods on
}

// IERC165CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IERC165CallerRaw struct {
	Contract *IERC165Caller // Generic read-only contract binding to access the raw methods on
}

// IERC165TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IERC165TransactorRaw struct {
	Contract *IERC165Transactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC165 creates a new instance of IERC165, bound to a specific deployed contract.
func NewIERC165(address common.Address, backend bind.ContractBackend) (*IERC165, error) {
	contract, err := bindIERC165(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC165{IERC165Caller: IERC165Caller{contract: contract}, IERC165Transactor: IERC165Transactor{contract: contract}, IERC165Filterer: IERC165Filterer{contract: contract}}, nil
}

// NewIERC165Caller creates a new read-only instance of IERC165, bound to a specific deployed contract.
func NewIERC165Caller(address common.Address, caller bind.ContractCaller) (*IERC165Caller, error) {
	contract, err := bindIERC165(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC165Caller{contract: contract}, nil
}

// NewIERC165Transactor creates a new write-only instance of IERC165, bound to a specific deployed contract.
func NewIERC165Transactor(address common.Address, transactor bind.ContractTransactor) (*IERC165Transactor, error) {
	contract, err := bindIERC165(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC165Transactor{contract: contract}, nil
}

// NewIERC165Filterer creates a new log filterer instance of IERC165, bound to a specific deployed contract.
func NewIERC165Filterer(address common.Address, filterer bind.ContractFilterer) (*IERC165Filterer, error) {
	contract, err := bindIERC165(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC165Filterer{contract: contract}, nil
}

// bindIERC165 binds a generic wrapper to an already deployed contract.
func bindIERC165(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IERC165MetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC165 *IERC165Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC165.Contract.IERC165Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC165 *IERC165Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC165.Contract.IERC165Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC165 *IERC165Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC165.Contract.IERC165Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC165 *IERC165CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC165.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC165 *IERC165TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC165.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC165 *IERC165TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC165.Contract.contract.Transact(opts, method, params...)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IERC165 *IERC165Caller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _IERC165.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IERC165 *IERC165Session) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _IERC165.Contract.SupportsInterface(&_IERC165.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IERC165 *IERC165CallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _IERC165.Contract.SupportsInterface(&_IERC165.CallOpts, interfaceId)
}

// IERC20MetaData contains all meta data concerning the IERC20 contract.
var IERC20MetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IERC20ABI is the input ABI used to generate the binding from.
// Deprecated: Use IERC20MetaData.ABI instead.
var IERC20ABI = IERC20MetaData.ABI

// IERC20 is an auto generated Go binding around an Ethereum contract.
type IERC20 struct {
	IERC20Caller     // Read-only binding to the contract
	IERC20Transactor // Write-only binding to the contract
	IERC20Filterer   // Log filterer for contract events
}

// IERC20Caller is an auto generated read-only Go binding around an Ethereum contract.
type IERC20Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20Transactor is an auto generated write-only Go binding around an Ethereum contract.
type IERC20Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IERC20Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IERC20Session struct {
	Contract     *IERC20           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC20CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IERC20CallerSession struct {
	Contract *IERC20Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// IERC20TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IERC20TransactorSession struct {
	Contract     *IERC20Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC20Raw is an auto generated low-level Go binding around an Ethereum contract.
type IERC20Raw struct {
	Contract *IERC20 // Generic contract binding to access the raw methods on
}

// IERC20CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IERC20CallerRaw struct {
	Contract *IERC20Caller // Generic read-only contract binding to access the raw methods on
}

// IERC20TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IERC20TransactorRaw struct {
	Contract *IERC20Transactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC20 creates a new instance of IERC20, bound to a specific deployed contract.
func NewIERC20(address common.Address, backend bind.ContractBackend) (*IERC20, error) {
	contract, err := bindIERC20(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC20{IERC20Caller: IERC20Caller{contract: contract}, IERC20Transactor: IERC20Transactor{contract: contract}, IERC20Filterer: IERC20Filterer{contract: contract}}, nil
}

// NewIERC20Caller creates a new read-only instance of IERC20, bound to a specific deployed contract.
func NewIERC20Caller(address common.Address, caller bind.ContractCaller) (*IERC20Caller, error) {
	contract, err := bindIERC20(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20Caller{contract: contract}, nil
}

// NewIERC20Transactor creates a new write-only instance of IERC20, bound to a specific deployed contract.
func NewIERC20Transactor(address common.Address, transactor bind.ContractTransactor) (*IERC20Transactor, error) {
	contract, err := bindIERC20(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20Transactor{contract: contract}, nil
}

// NewIERC20Filterer creates a new log filterer instance of IERC20, bound to a specific deployed contract.
func NewIERC20Filterer(address common.Address, filterer bind.ContractFilterer) (*IERC20Filterer, error) {
	contract, err := bindIERC20(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC20Filterer{contract: contract}, nil
}

// bindIERC20 binds a generic wrapper to an already deployed contract.
func bindIERC20(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IERC20MetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20 *IERC20Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20.Contract.IERC20Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20 *IERC20Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20.Contract.IERC20Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20 *IERC20Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20.Contract.IERC20Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20 *IERC20CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20 *IERC20TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20 *IERC20TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20 *IERC20Caller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IERC20.contract.Call(opts, &out, "allowance", owner, spender)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20 *IERC20Session) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _IERC20.Contract.Allowance(&_IERC20.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20 *IERC20CallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _IERC20.Contract.Allowance(&_IERC20.CallOpts, owner, spender)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20 *IERC20Caller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IERC20.contract.Call(opts, &out, "balanceOf", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20 *IERC20Session) BalanceOf(account common.Address) (*big.Int, error) {
	return _IERC20.Contract.BalanceOf(&_IERC20.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20 *IERC20CallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _IERC20.Contract.BalanceOf(&_IERC20.CallOpts, account)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20 *IERC20Caller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IERC20.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20 *IERC20Session) TotalSupply() (*big.Int, error) {
	return _IERC20.Contract.TotalSupply(&_IERC20.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20 *IERC20CallerSession) TotalSupply() (*big.Int, error) {
	return _IERC20.Contract.TotalSupply(&_IERC20.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20 *IERC20Transactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.contract.Transact(opts, "approve", spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20 *IERC20Session) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.Approve(&_IERC20.TransactOpts, spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20 *IERC20TransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.Approve(&_IERC20.TransactOpts, spender, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20Transactor) Transfer(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.contract.Transact(opts, "transfer", to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20Session) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.Transfer(&_IERC20.TransactOpts, to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20TransactorSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.Transfer(&_IERC20.TransactOpts, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20Transactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.contract.Transact(opts, "transferFrom", from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20Session) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.TransferFrom(&_IERC20.TransactOpts, from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20TransactorSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.TransferFrom(&_IERC20.TransactOpts, from, to, amount)
}

// IERC20ApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the IERC20 contract.
type IERC20ApprovalIterator struct {
	Event *IERC20Approval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20ApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20Approval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20Approval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20ApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20ApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20Approval represents a Approval event raised by the IERC20 contract.
type IERC20Approval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20 *IERC20Filterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*IERC20ApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _IERC20.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &IERC20ApprovalIterator{contract: _IERC20.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20 *IERC20Filterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *IERC20Approval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _IERC20.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20Approval)
				if err := _IERC20.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20 *IERC20Filterer) ParseApproval(log types.Log) (*IERC20Approval, error) {
	event := new(IERC20Approval)
	if err := _IERC20.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC20TransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the IERC20 contract.
type IERC20TransferIterator struct {
	Event *IERC20Transfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20TransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20Transfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20Transfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20TransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20TransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20Transfer represents a Transfer event raised by the IERC20 contract.
type IERC20Transfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20 *IERC20Filterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*IERC20TransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &IERC20TransferIterator{contract: _IERC20.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20 *IERC20Filterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *IERC20Transfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20Transfer)
				if err := _IERC20.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20 *IERC20Filterer) ParseTransfer(log types.Log) (*IERC20Transfer, error) {
	event := new(IERC20Transfer)
	if err := _IERC20.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC20MetadataMetaData contains all meta data concerning the IERC20Metadata contract.
var IERC20MetadataMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IERC20MetadataABI is the input ABI used to generate the binding from.
// Deprecated: Use IERC20MetadataMetaData.ABI instead.
var IERC20MetadataABI = IERC20MetadataMetaData.ABI

// IERC20Metadata is an auto generated Go binding around an Ethereum contract.
type IERC20Metadata struct {
	IERC20MetadataCaller     // Read-only binding to the contract
	IERC20MetadataTransactor // Write-only binding to the contract
	IERC20MetadataFilterer   // Log filterer for contract events
}

// IERC20MetadataCaller is an auto generated read-only Go binding around an Ethereum contract.
type IERC20MetadataCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20MetadataTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IERC20MetadataTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20MetadataFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IERC20MetadataFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20MetadataSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IERC20MetadataSession struct {
	Contract     *IERC20Metadata   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC20MetadataCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IERC20MetadataCallerSession struct {
	Contract *IERC20MetadataCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// IERC20MetadataTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IERC20MetadataTransactorSession struct {
	Contract     *IERC20MetadataTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// IERC20MetadataRaw is an auto generated low-level Go binding around an Ethereum contract.
type IERC20MetadataRaw struct {
	Contract *IERC20Metadata // Generic contract binding to access the raw methods on
}

// IERC20MetadataCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IERC20MetadataCallerRaw struct {
	Contract *IERC20MetadataCaller // Generic read-only contract binding to access the raw methods on
}

// IERC20MetadataTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IERC20MetadataTransactorRaw struct {
	Contract *IERC20MetadataTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC20Metadata creates a new instance of IERC20Metadata, bound to a specific deployed contract.
func NewIERC20Metadata(address common.Address, backend bind.ContractBackend) (*IERC20Metadata, error) {
	contract, err := bindIERC20Metadata(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC20Metadata{IERC20MetadataCaller: IERC20MetadataCaller{contract: contract}, IERC20MetadataTransactor: IERC20MetadataTransactor{contract: contract}, IERC20MetadataFilterer: IERC20MetadataFilterer{contract: contract}}, nil
}

// NewIERC20MetadataCaller creates a new read-only instance of IERC20Metadata, bound to a specific deployed contract.
func NewIERC20MetadataCaller(address common.Address, caller bind.ContractCaller) (*IERC20MetadataCaller, error) {
	contract, err := bindIERC20Metadata(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20MetadataCaller{contract: contract}, nil
}

// NewIERC20MetadataTransactor creates a new write-only instance of IERC20Metadata, bound to a specific deployed contract.
func NewIERC20MetadataTransactor(address common.Address, transactor bind.ContractTransactor) (*IERC20MetadataTransactor, error) {
	contract, err := bindIERC20Metadata(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20MetadataTransactor{contract: contract}, nil
}

// NewIERC20MetadataFilterer creates a new log filterer instance of IERC20Metadata, bound to a specific deployed contract.
func NewIERC20MetadataFilterer(address common.Address, filterer bind.ContractFilterer) (*IERC20MetadataFilterer, error) {
	contract, err := bindIERC20Metadata(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC20MetadataFilterer{contract: contract}, nil
}

// bindIERC20Metadata binds a generic wrapper to an already deployed contract.
func bindIERC20Metadata(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IERC20MetadataMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20Metadata *IERC20MetadataRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20Metadata.Contract.IERC20MetadataCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20Metadata *IERC20MetadataRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.IERC20MetadataTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20Metadata *IERC20MetadataRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.IERC20MetadataTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20Metadata *IERC20MetadataCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20Metadata.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20Metadata *IERC20MetadataTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20Metadata *IERC20MetadataTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20Metadata *IERC20MetadataCaller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IERC20Metadata.contract.Call(opts, &out, "allowance", owner, spender)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20Metadata *IERC20MetadataSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _IERC20Metadata.Contract.Allowance(&_IERC20Metadata.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20Metadata *IERC20MetadataCallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _IERC20Metadata.Contract.Allowance(&_IERC20Metadata.CallOpts, owner, spender)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20Metadata *IERC20MetadataCaller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IERC20Metadata.contract.Call(opts, &out, "balanceOf", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20Metadata *IERC20MetadataSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _IERC20Metadata.Contract.BalanceOf(&_IERC20Metadata.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20Metadata *IERC20MetadataCallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _IERC20Metadata.Contract.BalanceOf(&_IERC20Metadata.CallOpts, account)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_IERC20Metadata *IERC20MetadataCaller) Decimals(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _IERC20Metadata.contract.Call(opts, &out, "decimals")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_IERC20Metadata *IERC20MetadataSession) Decimals() (uint8, error) {
	return _IERC20Metadata.Contract.Decimals(&_IERC20Metadata.CallOpts)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_IERC20Metadata *IERC20MetadataCallerSession) Decimals() (uint8, error) {
	return _IERC20Metadata.Contract.Decimals(&_IERC20Metadata.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_IERC20Metadata *IERC20MetadataCaller) Name(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _IERC20Metadata.contract.Call(opts, &out, "name")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_IERC20Metadata *IERC20MetadataSession) Name() (string, error) {
	return _IERC20Metadata.Contract.Name(&_IERC20Metadata.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_IERC20Metadata *IERC20MetadataCallerSession) Name() (string, error) {
	return _IERC20Metadata.Contract.Name(&_IERC20Metadata.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_IERC20Metadata *IERC20MetadataCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _IERC20Metadata.contract.Call(opts, &out, "symbol")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_IERC20Metadata *IERC20MetadataSession) Symbol() (string, error) {
	return _IERC20Metadata.Contract.Symbol(&_IERC20Metadata.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_IERC20Metadata *IERC20MetadataCallerSession) Symbol() (string, error) {
	return _IERC20Metadata.Contract.Symbol(&_IERC20Metadata.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20Metadata *IERC20MetadataCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IERC20Metadata.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20Metadata *IERC20MetadataSession) TotalSupply() (*big.Int, error) {
	return _IERC20Metadata.Contract.TotalSupply(&_IERC20Metadata.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20Metadata *IERC20MetadataCallerSession) TotalSupply() (*big.Int, error) {
	return _IERC20Metadata.Contract.TotalSupply(&_IERC20Metadata.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataTransactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.contract.Transact(opts, "approve", spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.Approve(&_IERC20Metadata.TransactOpts, spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataTransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.Approve(&_IERC20Metadata.TransactOpts, spender, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataTransactor) Transfer(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.contract.Transact(opts, "transfer", to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.Transfer(&_IERC20Metadata.TransactOpts, to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataTransactorSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.Transfer(&_IERC20Metadata.TransactOpts, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.contract.Transact(opts, "transferFrom", from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.TransferFrom(&_IERC20Metadata.TransactOpts, from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20Metadata *IERC20MetadataTransactorSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Metadata.Contract.TransferFrom(&_IERC20Metadata.TransactOpts, from, to, amount)
}

// IERC20MetadataApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the IERC20Metadata contract.
type IERC20MetadataApprovalIterator struct {
	Event *IERC20MetadataApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20MetadataApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20MetadataApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20MetadataApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20MetadataApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20MetadataApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20MetadataApproval represents a Approval event raised by the IERC20Metadata contract.
type IERC20MetadataApproval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20Metadata *IERC20MetadataFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*IERC20MetadataApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _IERC20Metadata.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &IERC20MetadataApprovalIterator{contract: _IERC20Metadata.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20Metadata *IERC20MetadataFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *IERC20MetadataApproval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _IERC20Metadata.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20MetadataApproval)
				if err := _IERC20Metadata.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20Metadata *IERC20MetadataFilterer) ParseApproval(log types.Log) (*IERC20MetadataApproval, error) {
	event := new(IERC20MetadataApproval)
	if err := _IERC20Metadata.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC20MetadataTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the IERC20Metadata contract.
type IERC20MetadataTransferIterator struct {
	Event *IERC20MetadataTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20MetadataTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20MetadataTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20MetadataTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20MetadataTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20MetadataTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20MetadataTransfer represents a Transfer event raised by the IERC20Metadata contract.
type IERC20MetadataTransfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20Metadata *IERC20MetadataFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*IERC20MetadataTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20Metadata.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &IERC20MetadataTransferIterator{contract: _IERC20Metadata.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20Metadata *IERC20MetadataFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *IERC20MetadataTransfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20Metadata.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20MetadataTransfer)
				if err := _IERC20Metadata.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20Metadata *IERC20MetadataFilterer) ParseTransfer(log types.Log) (*IERC20MetadataTransfer, error) {
	event := new(IERC20MetadataTransfer)
	if err := _IERC20Metadata.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC20MinimalMetaData contains all meta data concerning the IERC20Minimal contract.
var IERC20MinimalMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IERC20MinimalABI is the input ABI used to generate the binding from.
// Deprecated: Use IERC20MinimalMetaData.ABI instead.
var IERC20MinimalABI = IERC20MinimalMetaData.ABI

// IERC20Minimal is an auto generated Go binding around an Ethereum contract.
type IERC20Minimal struct {
	IERC20MinimalCaller     // Read-only binding to the contract
	IERC20MinimalTransactor // Write-only binding to the contract
	IERC20MinimalFilterer   // Log filterer for contract events
}

// IERC20MinimalCaller is an auto generated read-only Go binding around an Ethereum contract.
type IERC20MinimalCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20MinimalTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IERC20MinimalTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20MinimalFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IERC20MinimalFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20MinimalSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IERC20MinimalSession struct {
	Contract     *IERC20Minimal    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC20MinimalCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IERC20MinimalCallerSession struct {
	Contract *IERC20MinimalCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// IERC20MinimalTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IERC20MinimalTransactorSession struct {
	Contract     *IERC20MinimalTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// IERC20MinimalRaw is an auto generated low-level Go binding around an Ethereum contract.
type IERC20MinimalRaw struct {
	Contract *IERC20Minimal // Generic contract binding to access the raw methods on
}

// IERC20MinimalCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IERC20MinimalCallerRaw struct {
	Contract *IERC20MinimalCaller // Generic read-only contract binding to access the raw methods on
}

// IERC20MinimalTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IERC20MinimalTransactorRaw struct {
	Contract *IERC20MinimalTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC20Minimal creates a new instance of IERC20Minimal, bound to a specific deployed contract.
func NewIERC20Minimal(address common.Address, backend bind.ContractBackend) (*IERC20Minimal, error) {
	contract, err := bindIERC20Minimal(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC20Minimal{IERC20MinimalCaller: IERC20MinimalCaller{contract: contract}, IERC20MinimalTransactor: IERC20MinimalTransactor{contract: contract}, IERC20MinimalFilterer: IERC20MinimalFilterer{contract: contract}}, nil
}

// NewIERC20MinimalCaller creates a new read-only instance of IERC20Minimal, bound to a specific deployed contract.
func NewIERC20MinimalCaller(address common.Address, caller bind.ContractCaller) (*IERC20MinimalCaller, error) {
	contract, err := bindIERC20Minimal(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20MinimalCaller{contract: contract}, nil
}

// NewIERC20MinimalTransactor creates a new write-only instance of IERC20Minimal, bound to a specific deployed contract.
func NewIERC20MinimalTransactor(address common.Address, transactor bind.ContractTransactor) (*IERC20MinimalTransactor, error) {
	contract, err := bindIERC20Minimal(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20MinimalTransactor{contract: contract}, nil
}

// NewIERC20MinimalFilterer creates a new log filterer instance of IERC20Minimal, bound to a specific deployed contract.
func NewIERC20MinimalFilterer(address common.Address, filterer bind.ContractFilterer) (*IERC20MinimalFilterer, error) {
	contract, err := bindIERC20Minimal(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC20MinimalFilterer{contract: contract}, nil
}

// bindIERC20Minimal binds a generic wrapper to an already deployed contract.
func bindIERC20Minimal(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IERC20MinimalMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20Minimal *IERC20MinimalRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20Minimal.Contract.IERC20MinimalCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20Minimal *IERC20MinimalRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20Minimal.Contract.IERC20MinimalTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20Minimal *IERC20MinimalRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20Minimal.Contract.IERC20MinimalTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20Minimal *IERC20MinimalCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20Minimal.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20Minimal *IERC20MinimalTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20Minimal.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20Minimal *IERC20MinimalTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20Minimal.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20Minimal *IERC20MinimalCaller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IERC20Minimal.contract.Call(opts, &out, "allowance", owner, spender)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20Minimal *IERC20MinimalSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _IERC20Minimal.Contract.Allowance(&_IERC20Minimal.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20Minimal *IERC20MinimalCallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _IERC20Minimal.Contract.Allowance(&_IERC20Minimal.CallOpts, owner, spender)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20Minimal *IERC20MinimalCaller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IERC20Minimal.contract.Call(opts, &out, "balanceOf", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20Minimal *IERC20MinimalSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _IERC20Minimal.Contract.BalanceOf(&_IERC20Minimal.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20Minimal *IERC20MinimalCallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _IERC20Minimal.Contract.BalanceOf(&_IERC20Minimal.CallOpts, account)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20Minimal *IERC20MinimalTransactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Minimal.contract.Transact(opts, "approve", spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20Minimal *IERC20MinimalSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Minimal.Contract.Approve(&_IERC20Minimal.TransactOpts, spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20Minimal *IERC20MinimalTransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Minimal.Contract.Approve(&_IERC20Minimal.TransactOpts, spender, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address recipient, uint256 amount) returns(bool)
func (_IERC20Minimal *IERC20MinimalTransactor) Transfer(opts *bind.TransactOpts, recipient common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Minimal.contract.Transact(opts, "transfer", recipient, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address recipient, uint256 amount) returns(bool)
func (_IERC20Minimal *IERC20MinimalSession) Transfer(recipient common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Minimal.Contract.Transfer(&_IERC20Minimal.TransactOpts, recipient, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address recipient, uint256 amount) returns(bool)
func (_IERC20Minimal *IERC20MinimalTransactorSession) Transfer(recipient common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Minimal.Contract.Transfer(&_IERC20Minimal.TransactOpts, recipient, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address sender, address recipient, uint256 amount) returns(bool)
func (_IERC20Minimal *IERC20MinimalTransactor) TransferFrom(opts *bind.TransactOpts, sender common.Address, recipient common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Minimal.contract.Transact(opts, "transferFrom", sender, recipient, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address sender, address recipient, uint256 amount) returns(bool)
func (_IERC20Minimal *IERC20MinimalSession) TransferFrom(sender common.Address, recipient common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Minimal.Contract.TransferFrom(&_IERC20Minimal.TransactOpts, sender, recipient, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address sender, address recipient, uint256 amount) returns(bool)
func (_IERC20Minimal *IERC20MinimalTransactorSession) TransferFrom(sender common.Address, recipient common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Minimal.Contract.TransferFrom(&_IERC20Minimal.TransactOpts, sender, recipient, amount)
}

// IERC20MinimalApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the IERC20Minimal contract.
type IERC20MinimalApprovalIterator struct {
	Event *IERC20MinimalApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20MinimalApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20MinimalApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20MinimalApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20MinimalApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20MinimalApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20MinimalApproval represents a Approval event raised by the IERC20Minimal contract.
type IERC20MinimalApproval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20Minimal *IERC20MinimalFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*IERC20MinimalApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _IERC20Minimal.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &IERC20MinimalApprovalIterator{contract: _IERC20Minimal.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20Minimal *IERC20MinimalFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *IERC20MinimalApproval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _IERC20Minimal.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20MinimalApproval)
				if err := _IERC20Minimal.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20Minimal *IERC20MinimalFilterer) ParseApproval(log types.Log) (*IERC20MinimalApproval, error) {
	event := new(IERC20MinimalApproval)
	if err := _IERC20Minimal.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC20MinimalTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the IERC20Minimal contract.
type IERC20MinimalTransferIterator struct {
	Event *IERC20MinimalTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20MinimalTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20MinimalTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20MinimalTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20MinimalTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20MinimalTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20MinimalTransfer represents a Transfer event raised by the IERC20Minimal contract.
type IERC20MinimalTransfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20Minimal *IERC20MinimalFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*IERC20MinimalTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20Minimal.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &IERC20MinimalTransferIterator{contract: _IERC20Minimal.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20Minimal *IERC20MinimalFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *IERC20MinimalTransfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20Minimal.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20MinimalTransfer)
				if err := _IERC20Minimal.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20Minimal *IERC20MinimalFilterer) ParseTransfer(log types.Log) (*IERC20MinimalTransfer, error) {
	event := new(IERC20MinimalTransfer)
	if err := _IERC20Minimal.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IEthereumLightClientMetaData contains all meta data concerning the IEthereumLightClient contract.
var IEthereumLightClientMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"finalizedExecutionStateRootAndSlot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optimisticExecutionStateRootAndSlot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// IEthereumLightClientABI is the input ABI used to generate the binding from.
// Deprecated: Use IEthereumLightClientMetaData.ABI instead.
var IEthereumLightClientABI = IEthereumLightClientMetaData.ABI

// IEthereumLightClient is an auto generated Go binding around an Ethereum contract.
type IEthereumLightClient struct {
	IEthereumLightClientCaller     // Read-only binding to the contract
	IEthereumLightClientTransactor // Write-only binding to the contract
	IEthereumLightClientFilterer   // Log filterer for contract events
}

// IEthereumLightClientCaller is an auto generated read-only Go binding around an Ethereum contract.
type IEthereumLightClientCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IEthereumLightClientTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IEthereumLightClientTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IEthereumLightClientFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IEthereumLightClientFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IEthereumLightClientSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IEthereumLightClientSession struct {
	Contract     *IEthereumLightClient // Generic contract binding to set the session for
	CallOpts     bind.CallOpts         // Call options to use throughout this session
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// IEthereumLightClientCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IEthereumLightClientCallerSession struct {
	Contract *IEthereumLightClientCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts               // Call options to use throughout this session
}

// IEthereumLightClientTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IEthereumLightClientTransactorSession struct {
	Contract     *IEthereumLightClientTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts               // Transaction auth options to use throughout this session
}

// IEthereumLightClientRaw is an auto generated low-level Go binding around an Ethereum contract.
type IEthereumLightClientRaw struct {
	Contract *IEthereumLightClient // Generic contract binding to access the raw methods on
}

// IEthereumLightClientCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IEthereumLightClientCallerRaw struct {
	Contract *IEthereumLightClientCaller // Generic read-only contract binding to access the raw methods on
}

// IEthereumLightClientTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IEthereumLightClientTransactorRaw struct {
	Contract *IEthereumLightClientTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIEthereumLightClient creates a new instance of IEthereumLightClient, bound to a specific deployed contract.
func NewIEthereumLightClient(address common.Address, backend bind.ContractBackend) (*IEthereumLightClient, error) {
	contract, err := bindIEthereumLightClient(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IEthereumLightClient{IEthereumLightClientCaller: IEthereumLightClientCaller{contract: contract}, IEthereumLightClientTransactor: IEthereumLightClientTransactor{contract: contract}, IEthereumLightClientFilterer: IEthereumLightClientFilterer{contract: contract}}, nil
}

// NewIEthereumLightClientCaller creates a new read-only instance of IEthereumLightClient, bound to a specific deployed contract.
func NewIEthereumLightClientCaller(address common.Address, caller bind.ContractCaller) (*IEthereumLightClientCaller, error) {
	contract, err := bindIEthereumLightClient(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IEthereumLightClientCaller{contract: contract}, nil
}

// NewIEthereumLightClientTransactor creates a new write-only instance of IEthereumLightClient, bound to a specific deployed contract.
func NewIEthereumLightClientTransactor(address common.Address, transactor bind.ContractTransactor) (*IEthereumLightClientTransactor, error) {
	contract, err := bindIEthereumLightClient(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IEthereumLightClientTransactor{contract: contract}, nil
}

// NewIEthereumLightClientFilterer creates a new log filterer instance of IEthereumLightClient, bound to a specific deployed contract.
func NewIEthereumLightClientFilterer(address common.Address, filterer bind.ContractFilterer) (*IEthereumLightClientFilterer, error) {
	contract, err := bindIEthereumLightClient(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IEthereumLightClientFilterer{contract: contract}, nil
}

// bindIEthereumLightClient binds a generic wrapper to an already deployed contract.
func bindIEthereumLightClient(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IEthereumLightClientMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IEthereumLightClient *IEthereumLightClientRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IEthereumLightClient.Contract.IEthereumLightClientCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IEthereumLightClient *IEthereumLightClientRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IEthereumLightClient.Contract.IEthereumLightClientTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IEthereumLightClient *IEthereumLightClientRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IEthereumLightClient.Contract.IEthereumLightClientTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IEthereumLightClient *IEthereumLightClientCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IEthereumLightClient.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IEthereumLightClient *IEthereumLightClientTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IEthereumLightClient.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IEthereumLightClient *IEthereumLightClientTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IEthereumLightClient.Contract.contract.Transact(opts, method, params...)
}

// FinalizedExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x12420766.
//
// Solidity: function finalizedExecutionStateRootAndSlot() view returns(bytes32 root, uint64 slot)
func (_IEthereumLightClient *IEthereumLightClientCaller) FinalizedExecutionStateRootAndSlot(opts *bind.CallOpts) (struct {
	Root [32]byte
	Slot uint64
}, error) {
	var out []interface{}
	err := _IEthereumLightClient.contract.Call(opts, &out, "finalizedExecutionStateRootAndSlot")

	outstruct := new(struct {
		Root [32]byte
		Slot uint64
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Root = *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)
	outstruct.Slot = *abi.ConvertType(out[1], new(uint64)).(*uint64)

	return *outstruct, err

}

// FinalizedExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x12420766.
//
// Solidity: function finalizedExecutionStateRootAndSlot() view returns(bytes32 root, uint64 slot)
func (_IEthereumLightClient *IEthereumLightClientSession) FinalizedExecutionStateRootAndSlot() (struct {
	Root [32]byte
	Slot uint64
}, error) {
	return _IEthereumLightClient.Contract.FinalizedExecutionStateRootAndSlot(&_IEthereumLightClient.CallOpts)
}

// FinalizedExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x12420766.
//
// Solidity: function finalizedExecutionStateRootAndSlot() view returns(bytes32 root, uint64 slot)
func (_IEthereumLightClient *IEthereumLightClientCallerSession) FinalizedExecutionStateRootAndSlot() (struct {
	Root [32]byte
	Slot uint64
}, error) {
	return _IEthereumLightClient.Contract.FinalizedExecutionStateRootAndSlot(&_IEthereumLightClient.CallOpts)
}

// OptimisticExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x43a6c5a6.
//
// Solidity: function optimisticExecutionStateRootAndSlot() view returns(bytes32 root, uint64 slot)
func (_IEthereumLightClient *IEthereumLightClientCaller) OptimisticExecutionStateRootAndSlot(opts *bind.CallOpts) (struct {
	Root [32]byte
	Slot uint64
}, error) {
	var out []interface{}
	err := _IEthereumLightClient.contract.Call(opts, &out, "optimisticExecutionStateRootAndSlot")

	outstruct := new(struct {
		Root [32]byte
		Slot uint64
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Root = *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)
	outstruct.Slot = *abi.ConvertType(out[1], new(uint64)).(*uint64)

	return *outstruct, err

}

// OptimisticExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x43a6c5a6.
//
// Solidity: function optimisticExecutionStateRootAndSlot() view returns(bytes32 root, uint64 slot)
func (_IEthereumLightClient *IEthereumLightClientSession) OptimisticExecutionStateRootAndSlot() (struct {
	Root [32]byte
	Slot uint64
}, error) {
	return _IEthereumLightClient.Contract.OptimisticExecutionStateRootAndSlot(&_IEthereumLightClient.CallOpts)
}

// OptimisticExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x43a6c5a6.
//
// Solidity: function optimisticExecutionStateRootAndSlot() view returns(bytes32 root, uint64 slot)
func (_IEthereumLightClient *IEthereumLightClientCallerSession) OptimisticExecutionStateRootAndSlot() (struct {
	Root [32]byte
	Slot uint64
}, error) {
	return _IEthereumLightClient.Contract.OptimisticExecutionStateRootAndSlot(&_IEthereumLightClient.CallOpts)
}

// IFeesMetaData contains all meta data concerning the IFees contract.
var IFeesMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"FeeTooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProtocolFeeCannotBeFetched\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"protocolFeeController\",\"type\":\"address\"}],\"name\":\"ProtocolFeeControllerUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MIN_PROTOCOL_FEE_DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hookFeesAccrued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Currency\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"protocolFeesAccrued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// IFeesABI is the input ABI used to generate the binding from.
// Deprecated: Use IFeesMetaData.ABI instead.
var IFeesABI = IFeesMetaData.ABI

// IFees is an auto generated Go binding around an Ethereum contract.
type IFees struct {
	IFeesCaller     // Read-only binding to the contract
	IFeesTransactor // Write-only binding to the contract
	IFeesFilterer   // Log filterer for contract events
}

// IFeesCaller is an auto generated read-only Go binding around an Ethereum contract.
type IFeesCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IFeesTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IFeesTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IFeesFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IFeesFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IFeesSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IFeesSession struct {
	Contract     *IFees            // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IFeesCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IFeesCallerSession struct {
	Contract *IFeesCaller  // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// IFeesTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IFeesTransactorSession struct {
	Contract     *IFeesTransactor  // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IFeesRaw is an auto generated low-level Go binding around an Ethereum contract.
type IFeesRaw struct {
	Contract *IFees // Generic contract binding to access the raw methods on
}

// IFeesCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IFeesCallerRaw struct {
	Contract *IFeesCaller // Generic read-only contract binding to access the raw methods on
}

// IFeesTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IFeesTransactorRaw struct {
	Contract *IFeesTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIFees creates a new instance of IFees, bound to a specific deployed contract.
func NewIFees(address common.Address, backend bind.ContractBackend) (*IFees, error) {
	contract, err := bindIFees(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IFees{IFeesCaller: IFeesCaller{contract: contract}, IFeesTransactor: IFeesTransactor{contract: contract}, IFeesFilterer: IFeesFilterer{contract: contract}}, nil
}

// NewIFeesCaller creates a new read-only instance of IFees, bound to a specific deployed contract.
func NewIFeesCaller(address common.Address, caller bind.ContractCaller) (*IFeesCaller, error) {
	contract, err := bindIFees(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IFeesCaller{contract: contract}, nil
}

// NewIFeesTransactor creates a new write-only instance of IFees, bound to a specific deployed contract.
func NewIFeesTransactor(address common.Address, transactor bind.ContractTransactor) (*IFeesTransactor, error) {
	contract, err := bindIFees(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IFeesTransactor{contract: contract}, nil
}

// NewIFeesFilterer creates a new log filterer instance of IFees, bound to a specific deployed contract.
func NewIFeesFilterer(address common.Address, filterer bind.ContractFilterer) (*IFeesFilterer, error) {
	contract, err := bindIFees(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IFeesFilterer{contract: contract}, nil
}

// bindIFees binds a generic wrapper to an already deployed contract.
func bindIFees(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IFeesMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IFees *IFeesRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IFees.Contract.IFeesCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IFees *IFeesRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IFees.Contract.IFeesTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IFees *IFeesRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IFees.Contract.IFeesTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IFees *IFeesCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IFees.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IFees *IFeesTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IFees.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IFees *IFeesTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IFees.Contract.contract.Transact(opts, method, params...)
}

// MINPROTOCOLFEEDENOMINATOR is a free data retrieval call binding the contract method 0x84e41c5e.
//
// Solidity: function MIN_PROTOCOL_FEE_DENOMINATOR() view returns(uint8)
func (_IFees *IFeesCaller) MINPROTOCOLFEEDENOMINATOR(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _IFees.contract.Call(opts, &out, "MIN_PROTOCOL_FEE_DENOMINATOR")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// MINPROTOCOLFEEDENOMINATOR is a free data retrieval call binding the contract method 0x84e41c5e.
//
// Solidity: function MIN_PROTOCOL_FEE_DENOMINATOR() view returns(uint8)
func (_IFees *IFeesSession) MINPROTOCOLFEEDENOMINATOR() (uint8, error) {
	return _IFees.Contract.MINPROTOCOLFEEDENOMINATOR(&_IFees.CallOpts)
}

// MINPROTOCOLFEEDENOMINATOR is a free data retrieval call binding the contract method 0x84e41c5e.
//
// Solidity: function MIN_PROTOCOL_FEE_DENOMINATOR() view returns(uint8)
func (_IFees *IFeesCallerSession) MINPROTOCOLFEEDENOMINATOR() (uint8, error) {
	return _IFees.Contract.MINPROTOCOLFEEDENOMINATOR(&_IFees.CallOpts)
}

// HookFeesAccrued is a free data retrieval call binding the contract method 0xb4c41939.
//
// Solidity: function hookFeesAccrued(address , address ) view returns(uint256)
func (_IFees *IFeesCaller) HookFeesAccrued(opts *bind.CallOpts, arg0 common.Address, arg1 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IFees.contract.Call(opts, &out, "hookFeesAccrued", arg0, arg1)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// HookFeesAccrued is a free data retrieval call binding the contract method 0xb4c41939.
//
// Solidity: function hookFeesAccrued(address , address ) view returns(uint256)
func (_IFees *IFeesSession) HookFeesAccrued(arg0 common.Address, arg1 common.Address) (*big.Int, error) {
	return _IFees.Contract.HookFeesAccrued(&_IFees.CallOpts, arg0, arg1)
}

// HookFeesAccrued is a free data retrieval call binding the contract method 0xb4c41939.
//
// Solidity: function hookFeesAccrued(address , address ) view returns(uint256)
func (_IFees *IFeesCallerSession) HookFeesAccrued(arg0 common.Address, arg1 common.Address) (*big.Int, error) {
	return _IFees.Contract.HookFeesAccrued(&_IFees.CallOpts, arg0, arg1)
}

// ProtocolFeesAccrued is a free data retrieval call binding the contract method 0x97e8cd4e.
//
// Solidity: function protocolFeesAccrued(address ) view returns(uint256)
func (_IFees *IFeesCaller) ProtocolFeesAccrued(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IFees.contract.Call(opts, &out, "protocolFeesAccrued", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// ProtocolFeesAccrued is a free data retrieval call binding the contract method 0x97e8cd4e.
//
// Solidity: function protocolFeesAccrued(address ) view returns(uint256)
func (_IFees *IFeesSession) ProtocolFeesAccrued(arg0 common.Address) (*big.Int, error) {
	return _IFees.Contract.ProtocolFeesAccrued(&_IFees.CallOpts, arg0)
}

// ProtocolFeesAccrued is a free data retrieval call binding the contract method 0x97e8cd4e.
//
// Solidity: function protocolFeesAccrued(address ) view returns(uint256)
func (_IFees *IFeesCallerSession) ProtocolFeesAccrued(arg0 common.Address) (*big.Int, error) {
	return _IFees.Contract.ProtocolFeesAccrued(&_IFees.CallOpts, arg0)
}

// IFeesProtocolFeeControllerUpdatedIterator is returned from FilterProtocolFeeControllerUpdated and is used to iterate over the raw logs and unpacked data for ProtocolFeeControllerUpdated events raised by the IFees contract.
type IFeesProtocolFeeControllerUpdatedIterator struct {
	Event *IFeesProtocolFeeControllerUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IFeesProtocolFeeControllerUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IFeesProtocolFeeControllerUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IFeesProtocolFeeControllerUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IFeesProtocolFeeControllerUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IFeesProtocolFeeControllerUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IFeesProtocolFeeControllerUpdated represents a ProtocolFeeControllerUpdated event raised by the IFees contract.
type IFeesProtocolFeeControllerUpdated struct {
	ProtocolFeeController common.Address
	Raw                   types.Log // Blockchain specific contextual infos
}

// FilterProtocolFeeControllerUpdated is a free log retrieval operation binding the contract event 0xb4bd8ef53df690b9943d3318996006dbb82a25f54719d8c8035b516a2a5b8acc.
//
// Solidity: event ProtocolFeeControllerUpdated(address protocolFeeController)
func (_IFees *IFeesFilterer) FilterProtocolFeeControllerUpdated(opts *bind.FilterOpts) (*IFeesProtocolFeeControllerUpdatedIterator, error) {

	logs, sub, err := _IFees.contract.FilterLogs(opts, "ProtocolFeeControllerUpdated")
	if err != nil {
		return nil, err
	}
	return &IFeesProtocolFeeControllerUpdatedIterator{contract: _IFees.contract, event: "ProtocolFeeControllerUpdated", logs: logs, sub: sub}, nil
}

// WatchProtocolFeeControllerUpdated is a free log subscription operation binding the contract event 0xb4bd8ef53df690b9943d3318996006dbb82a25f54719d8c8035b516a2a5b8acc.
//
// Solidity: event ProtocolFeeControllerUpdated(address protocolFeeController)
func (_IFees *IFeesFilterer) WatchProtocolFeeControllerUpdated(opts *bind.WatchOpts, sink chan<- *IFeesProtocolFeeControllerUpdated) (event.Subscription, error) {

	logs, sub, err := _IFees.contract.WatchLogs(opts, "ProtocolFeeControllerUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IFeesProtocolFeeControllerUpdated)
				if err := _IFees.contract.UnpackLog(event, "ProtocolFeeControllerUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProtocolFeeControllerUpdated is a log parse operation binding the contract event 0xb4bd8ef53df690b9943d3318996006dbb82a25f54719d8c8035b516a2a5b8acc.
//
// Solidity: event ProtocolFeeControllerUpdated(address protocolFeeController)
func (_IFees *IFeesFilterer) ParseProtocolFeeControllerUpdated(log types.Log) (*IFeesProtocolFeeControllerUpdated, error) {
	event := new(IFeesProtocolFeeControllerUpdated)
	if err := _IFees.contract.UnpackLog(event, "ProtocolFeeControllerUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IHookFeeManagerMetaData contains all meta data concerning the IHookFeeManager contract.
var IHookFeeManagerMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"}],\"name\":\"getHookFees\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// IHookFeeManagerABI is the input ABI used to generate the binding from.
// Deprecated: Use IHookFeeManagerMetaData.ABI instead.
var IHookFeeManagerABI = IHookFeeManagerMetaData.ABI

// IHookFeeManager is an auto generated Go binding around an Ethereum contract.
type IHookFeeManager struct {
	IHookFeeManagerCaller     // Read-only binding to the contract
	IHookFeeManagerTransactor // Write-only binding to the contract
	IHookFeeManagerFilterer   // Log filterer for contract events
}

// IHookFeeManagerCaller is an auto generated read-only Go binding around an Ethereum contract.
type IHookFeeManagerCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IHookFeeManagerTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IHookFeeManagerTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IHookFeeManagerFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IHookFeeManagerFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IHookFeeManagerSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IHookFeeManagerSession struct {
	Contract     *IHookFeeManager  // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IHookFeeManagerCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IHookFeeManagerCallerSession struct {
	Contract *IHookFeeManagerCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts          // Call options to use throughout this session
}

// IHookFeeManagerTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IHookFeeManagerTransactorSession struct {
	Contract     *IHookFeeManagerTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts          // Transaction auth options to use throughout this session
}

// IHookFeeManagerRaw is an auto generated low-level Go binding around an Ethereum contract.
type IHookFeeManagerRaw struct {
	Contract *IHookFeeManager // Generic contract binding to access the raw methods on
}

// IHookFeeManagerCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IHookFeeManagerCallerRaw struct {
	Contract *IHookFeeManagerCaller // Generic read-only contract binding to access the raw methods on
}

// IHookFeeManagerTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IHookFeeManagerTransactorRaw struct {
	Contract *IHookFeeManagerTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIHookFeeManager creates a new instance of IHookFeeManager, bound to a specific deployed contract.
func NewIHookFeeManager(address common.Address, backend bind.ContractBackend) (*IHookFeeManager, error) {
	contract, err := bindIHookFeeManager(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IHookFeeManager{IHookFeeManagerCaller: IHookFeeManagerCaller{contract: contract}, IHookFeeManagerTransactor: IHookFeeManagerTransactor{contract: contract}, IHookFeeManagerFilterer: IHookFeeManagerFilterer{contract: contract}}, nil
}

// NewIHookFeeManagerCaller creates a new read-only instance of IHookFeeManager, bound to a specific deployed contract.
func NewIHookFeeManagerCaller(address common.Address, caller bind.ContractCaller) (*IHookFeeManagerCaller, error) {
	contract, err := bindIHookFeeManager(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IHookFeeManagerCaller{contract: contract}, nil
}

// NewIHookFeeManagerTransactor creates a new write-only instance of IHookFeeManager, bound to a specific deployed contract.
func NewIHookFeeManagerTransactor(address common.Address, transactor bind.ContractTransactor) (*IHookFeeManagerTransactor, error) {
	contract, err := bindIHookFeeManager(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IHookFeeManagerTransactor{contract: contract}, nil
}

// NewIHookFeeManagerFilterer creates a new log filterer instance of IHookFeeManager, bound to a specific deployed contract.
func NewIHookFeeManagerFilterer(address common.Address, filterer bind.ContractFilterer) (*IHookFeeManagerFilterer, error) {
	contract, err := bindIHookFeeManager(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IHookFeeManagerFilterer{contract: contract}, nil
}

// bindIHookFeeManager binds a generic wrapper to an already deployed contract.
func bindIHookFeeManager(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IHookFeeManagerMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IHookFeeManager *IHookFeeManagerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IHookFeeManager.Contract.IHookFeeManagerCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IHookFeeManager *IHookFeeManagerRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IHookFeeManager.Contract.IHookFeeManagerTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IHookFeeManager *IHookFeeManagerRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IHookFeeManager.Contract.IHookFeeManagerTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IHookFeeManager *IHookFeeManagerCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IHookFeeManager.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IHookFeeManager *IHookFeeManagerTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IHookFeeManager.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IHookFeeManager *IHookFeeManagerTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IHookFeeManager.Contract.contract.Transact(opts, method, params...)
}

// GetHookFees is a free data retrieval call binding the contract method 0x5ae4ce58.
//
// Solidity: function getHookFees((address,address,uint24,int24,address) key) view returns(uint24)
func (_IHookFeeManager *IHookFeeManagerCaller) GetHookFees(opts *bind.CallOpts, key PoolKey) (*big.Int, error) {
	var out []interface{}
	err := _IHookFeeManager.contract.Call(opts, &out, "getHookFees", key)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetHookFees is a free data retrieval call binding the contract method 0x5ae4ce58.
//
// Solidity: function getHookFees((address,address,uint24,int24,address) key) view returns(uint24)
func (_IHookFeeManager *IHookFeeManagerSession) GetHookFees(key PoolKey) (*big.Int, error) {
	return _IHookFeeManager.Contract.GetHookFees(&_IHookFeeManager.CallOpts, key)
}

// GetHookFees is a free data retrieval call binding the contract method 0x5ae4ce58.
//
// Solidity: function getHookFees((address,address,uint24,int24,address) key) view returns(uint24)
func (_IHookFeeManager *IHookFeeManagerCallerSession) GetHookFees(key PoolKey) (*big.Int, error) {
	return _IHookFeeManager.Contract.GetHookFees(&_IHookFeeManager.CallOpts, key)
}

// IHooksMetaData contains all meta data concerning the IHooks contract.
var IHooksMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"hookData\",\"type\":\"bytes\"}],\"name\":\"afterDonate\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceX96\",\"type\":\"uint160\"},{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"},{\"internalType\":\"bytes\",\"name\":\"hookData\",\"type\":\"bytes\"}],\"name\":\"afterInitialize\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"int256\",\"name\":\"liquidityDelta\",\"type\":\"int256\"}],\"internalType\":\"structIPoolManager.ModifyPositionParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"BalanceDelta\",\"name\":\"delta\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"hookData\",\"type\":\"bytes\"}],\"name\":\"afterModifyPosition\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"zeroForOne\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"amountSpecified\",\"type\":\"int256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"structIPoolManager.SwapParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"BalanceDelta\",\"name\":\"delta\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"hookData\",\"type\":\"bytes\"}],\"name\":\"afterSwap\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"hookData\",\"type\":\"bytes\"}],\"name\":\"beforeDonate\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceX96\",\"type\":\"uint160\"},{\"internalType\":\"bytes\",\"name\":\"hookData\",\"type\":\"bytes\"}],\"name\":\"beforeInitialize\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"int256\",\"name\":\"liquidityDelta\",\"type\":\"int256\"}],\"internalType\":\"structIPoolManager.ModifyPositionParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"hookData\",\"type\":\"bytes\"}],\"name\":\"beforeModifyPosition\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"zeroForOne\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"amountSpecified\",\"type\":\"int256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"structIPoolManager.SwapParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"hookData\",\"type\":\"bytes\"}],\"name\":\"beforeSwap\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IHooksABI is the input ABI used to generate the binding from.
// Deprecated: Use IHooksMetaData.ABI instead.
var IHooksABI = IHooksMetaData.ABI

// IHooks is an auto generated Go binding around an Ethereum contract.
type IHooks struct {
	IHooksCaller     // Read-only binding to the contract
	IHooksTransactor // Write-only binding to the contract
	IHooksFilterer   // Log filterer for contract events
}

// IHooksCaller is an auto generated read-only Go binding around an Ethereum contract.
type IHooksCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IHooksTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IHooksTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IHooksFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IHooksFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IHooksSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IHooksSession struct {
	Contract     *IHooks           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IHooksCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IHooksCallerSession struct {
	Contract *IHooksCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// IHooksTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IHooksTransactorSession struct {
	Contract     *IHooksTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IHooksRaw is an auto generated low-level Go binding around an Ethereum contract.
type IHooksRaw struct {
	Contract *IHooks // Generic contract binding to access the raw methods on
}

// IHooksCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IHooksCallerRaw struct {
	Contract *IHooksCaller // Generic read-only contract binding to access the raw methods on
}

// IHooksTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IHooksTransactorRaw struct {
	Contract *IHooksTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIHooks creates a new instance of IHooks, bound to a specific deployed contract.
func NewIHooks(address common.Address, backend bind.ContractBackend) (*IHooks, error) {
	contract, err := bindIHooks(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IHooks{IHooksCaller: IHooksCaller{contract: contract}, IHooksTransactor: IHooksTransactor{contract: contract}, IHooksFilterer: IHooksFilterer{contract: contract}}, nil
}

// NewIHooksCaller creates a new read-only instance of IHooks, bound to a specific deployed contract.
func NewIHooksCaller(address common.Address, caller bind.ContractCaller) (*IHooksCaller, error) {
	contract, err := bindIHooks(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IHooksCaller{contract: contract}, nil
}

// NewIHooksTransactor creates a new write-only instance of IHooks, bound to a specific deployed contract.
func NewIHooksTransactor(address common.Address, transactor bind.ContractTransactor) (*IHooksTransactor, error) {
	contract, err := bindIHooks(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IHooksTransactor{contract: contract}, nil
}

// NewIHooksFilterer creates a new log filterer instance of IHooks, bound to a specific deployed contract.
func NewIHooksFilterer(address common.Address, filterer bind.ContractFilterer) (*IHooksFilterer, error) {
	contract, err := bindIHooks(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IHooksFilterer{contract: contract}, nil
}

// bindIHooks binds a generic wrapper to an already deployed contract.
func bindIHooks(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IHooksMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IHooks *IHooksRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IHooks.Contract.IHooksCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IHooks *IHooksRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IHooks.Contract.IHooksTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IHooks *IHooksRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IHooks.Contract.IHooksTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IHooks *IHooksCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IHooks.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IHooks *IHooksTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IHooks.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IHooks *IHooksTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IHooks.Contract.contract.Transact(opts, method, params...)
}

// AfterDonate is a paid mutator transaction binding the contract method 0xe1b4af69.
//
// Solidity: function afterDonate(address sender, (address,address,uint24,int24,address) key, uint256 amount0, uint256 amount1, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactor) AfterDonate(opts *bind.TransactOpts, sender common.Address, key PoolKey, amount0 *big.Int, amount1 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.contract.Transact(opts, "afterDonate", sender, key, amount0, amount1, hookData)
}

// AfterDonate is a paid mutator transaction binding the contract method 0xe1b4af69.
//
// Solidity: function afterDonate(address sender, (address,address,uint24,int24,address) key, uint256 amount0, uint256 amount1, bytes hookData) returns(bytes4)
func (_IHooks *IHooksSession) AfterDonate(sender common.Address, key PoolKey, amount0 *big.Int, amount1 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.AfterDonate(&_IHooks.TransactOpts, sender, key, amount0, amount1, hookData)
}

// AfterDonate is a paid mutator transaction binding the contract method 0xe1b4af69.
//
// Solidity: function afterDonate(address sender, (address,address,uint24,int24,address) key, uint256 amount0, uint256 amount1, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactorSession) AfterDonate(sender common.Address, key PoolKey, amount0 *big.Int, amount1 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.AfterDonate(&_IHooks.TransactOpts, sender, key, amount0, amount1, hookData)
}

// AfterInitialize is a paid mutator transaction binding the contract method 0xa910f80f.
//
// Solidity: function afterInitialize(address sender, (address,address,uint24,int24,address) key, uint160 sqrtPriceX96, int24 tick, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactor) AfterInitialize(opts *bind.TransactOpts, sender common.Address, key PoolKey, sqrtPriceX96 *big.Int, tick *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.contract.Transact(opts, "afterInitialize", sender, key, sqrtPriceX96, tick, hookData)
}

// AfterInitialize is a paid mutator transaction binding the contract method 0xa910f80f.
//
// Solidity: function afterInitialize(address sender, (address,address,uint24,int24,address) key, uint160 sqrtPriceX96, int24 tick, bytes hookData) returns(bytes4)
func (_IHooks *IHooksSession) AfterInitialize(sender common.Address, key PoolKey, sqrtPriceX96 *big.Int, tick *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.AfterInitialize(&_IHooks.TransactOpts, sender, key, sqrtPriceX96, tick, hookData)
}

// AfterInitialize is a paid mutator transaction binding the contract method 0xa910f80f.
//
// Solidity: function afterInitialize(address sender, (address,address,uint24,int24,address) key, uint160 sqrtPriceX96, int24 tick, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactorSession) AfterInitialize(sender common.Address, key PoolKey, sqrtPriceX96 *big.Int, tick *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.AfterInitialize(&_IHooks.TransactOpts, sender, key, sqrtPriceX96, tick, hookData)
}

// AfterModifyPosition is a paid mutator transaction binding the contract method 0x30b7cdef.
//
// Solidity: function afterModifyPosition(address sender, (address,address,uint24,int24,address) key, (int24,int24,int256) params, int256 delta, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactor) AfterModifyPosition(opts *bind.TransactOpts, sender common.Address, key PoolKey, params IPoolManagerModifyPositionParams, delta *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.contract.Transact(opts, "afterModifyPosition", sender, key, params, delta, hookData)
}

// AfterModifyPosition is a paid mutator transaction binding the contract method 0x30b7cdef.
//
// Solidity: function afterModifyPosition(address sender, (address,address,uint24,int24,address) key, (int24,int24,int256) params, int256 delta, bytes hookData) returns(bytes4)
func (_IHooks *IHooksSession) AfterModifyPosition(sender common.Address, key PoolKey, params IPoolManagerModifyPositionParams, delta *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.AfterModifyPosition(&_IHooks.TransactOpts, sender, key, params, delta, hookData)
}

// AfterModifyPosition is a paid mutator transaction binding the contract method 0x30b7cdef.
//
// Solidity: function afterModifyPosition(address sender, (address,address,uint24,int24,address) key, (int24,int24,int256) params, int256 delta, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactorSession) AfterModifyPosition(sender common.Address, key PoolKey, params IPoolManagerModifyPositionParams, delta *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.AfterModifyPosition(&_IHooks.TransactOpts, sender, key, params, delta, hookData)
}

// AfterSwap is a paid mutator transaction binding the contract method 0xb47b2fb1.
//
// Solidity: function afterSwap(address sender, (address,address,uint24,int24,address) key, (bool,int256,uint160) params, int256 delta, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactor) AfterSwap(opts *bind.TransactOpts, sender common.Address, key PoolKey, params IPoolManagerSwapParams, delta *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.contract.Transact(opts, "afterSwap", sender, key, params, delta, hookData)
}

// AfterSwap is a paid mutator transaction binding the contract method 0xb47b2fb1.
//
// Solidity: function afterSwap(address sender, (address,address,uint24,int24,address) key, (bool,int256,uint160) params, int256 delta, bytes hookData) returns(bytes4)
func (_IHooks *IHooksSession) AfterSwap(sender common.Address, key PoolKey, params IPoolManagerSwapParams, delta *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.AfterSwap(&_IHooks.TransactOpts, sender, key, params, delta, hookData)
}

// AfterSwap is a paid mutator transaction binding the contract method 0xb47b2fb1.
//
// Solidity: function afterSwap(address sender, (address,address,uint24,int24,address) key, (bool,int256,uint160) params, int256 delta, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactorSession) AfterSwap(sender common.Address, key PoolKey, params IPoolManagerSwapParams, delta *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.AfterSwap(&_IHooks.TransactOpts, sender, key, params, delta, hookData)
}

// BeforeDonate is a paid mutator transaction binding the contract method 0xb6a8b0fa.
//
// Solidity: function beforeDonate(address sender, (address,address,uint24,int24,address) key, uint256 amount0, uint256 amount1, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactor) BeforeDonate(opts *bind.TransactOpts, sender common.Address, key PoolKey, amount0 *big.Int, amount1 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.contract.Transact(opts, "beforeDonate", sender, key, amount0, amount1, hookData)
}

// BeforeDonate is a paid mutator transaction binding the contract method 0xb6a8b0fa.
//
// Solidity: function beforeDonate(address sender, (address,address,uint24,int24,address) key, uint256 amount0, uint256 amount1, bytes hookData) returns(bytes4)
func (_IHooks *IHooksSession) BeforeDonate(sender common.Address, key PoolKey, amount0 *big.Int, amount1 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.BeforeDonate(&_IHooks.TransactOpts, sender, key, amount0, amount1, hookData)
}

// BeforeDonate is a paid mutator transaction binding the contract method 0xb6a8b0fa.
//
// Solidity: function beforeDonate(address sender, (address,address,uint24,int24,address) key, uint256 amount0, uint256 amount1, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactorSession) BeforeDonate(sender common.Address, key PoolKey, amount0 *big.Int, amount1 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.BeforeDonate(&_IHooks.TransactOpts, sender, key, amount0, amount1, hookData)
}

// BeforeInitialize is a paid mutator transaction binding the contract method 0x3440d820.
//
// Solidity: function beforeInitialize(address sender, (address,address,uint24,int24,address) key, uint160 sqrtPriceX96, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactor) BeforeInitialize(opts *bind.TransactOpts, sender common.Address, key PoolKey, sqrtPriceX96 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.contract.Transact(opts, "beforeInitialize", sender, key, sqrtPriceX96, hookData)
}

// BeforeInitialize is a paid mutator transaction binding the contract method 0x3440d820.
//
// Solidity: function beforeInitialize(address sender, (address,address,uint24,int24,address) key, uint160 sqrtPriceX96, bytes hookData) returns(bytes4)
func (_IHooks *IHooksSession) BeforeInitialize(sender common.Address, key PoolKey, sqrtPriceX96 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.BeforeInitialize(&_IHooks.TransactOpts, sender, key, sqrtPriceX96, hookData)
}

// BeforeInitialize is a paid mutator transaction binding the contract method 0x3440d820.
//
// Solidity: function beforeInitialize(address sender, (address,address,uint24,int24,address) key, uint160 sqrtPriceX96, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactorSession) BeforeInitialize(sender common.Address, key PoolKey, sqrtPriceX96 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.BeforeInitialize(&_IHooks.TransactOpts, sender, key, sqrtPriceX96, hookData)
}

// BeforeModifyPosition is a paid mutator transaction binding the contract method 0xfe9a6f45.
//
// Solidity: function beforeModifyPosition(address sender, (address,address,uint24,int24,address) key, (int24,int24,int256) params, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactor) BeforeModifyPosition(opts *bind.TransactOpts, sender common.Address, key PoolKey, params IPoolManagerModifyPositionParams, hookData []byte) (*types.Transaction, error) {
	return _IHooks.contract.Transact(opts, "beforeModifyPosition", sender, key, params, hookData)
}

// BeforeModifyPosition is a paid mutator transaction binding the contract method 0xfe9a6f45.
//
// Solidity: function beforeModifyPosition(address sender, (address,address,uint24,int24,address) key, (int24,int24,int256) params, bytes hookData) returns(bytes4)
func (_IHooks *IHooksSession) BeforeModifyPosition(sender common.Address, key PoolKey, params IPoolManagerModifyPositionParams, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.BeforeModifyPosition(&_IHooks.TransactOpts, sender, key, params, hookData)
}

// BeforeModifyPosition is a paid mutator transaction binding the contract method 0xfe9a6f45.
//
// Solidity: function beforeModifyPosition(address sender, (address,address,uint24,int24,address) key, (int24,int24,int256) params, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactorSession) BeforeModifyPosition(sender common.Address, key PoolKey, params IPoolManagerModifyPositionParams, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.BeforeModifyPosition(&_IHooks.TransactOpts, sender, key, params, hookData)
}

// BeforeSwap is a paid mutator transaction binding the contract method 0x575e24b4.
//
// Solidity: function beforeSwap(address sender, (address,address,uint24,int24,address) key, (bool,int256,uint160) params, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactor) BeforeSwap(opts *bind.TransactOpts, sender common.Address, key PoolKey, params IPoolManagerSwapParams, hookData []byte) (*types.Transaction, error) {
	return _IHooks.contract.Transact(opts, "beforeSwap", sender, key, params, hookData)
}

// BeforeSwap is a paid mutator transaction binding the contract method 0x575e24b4.
//
// Solidity: function beforeSwap(address sender, (address,address,uint24,int24,address) key, (bool,int256,uint160) params, bytes hookData) returns(bytes4)
func (_IHooks *IHooksSession) BeforeSwap(sender common.Address, key PoolKey, params IPoolManagerSwapParams, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.BeforeSwap(&_IHooks.TransactOpts, sender, key, params, hookData)
}

// BeforeSwap is a paid mutator transaction binding the contract method 0x575e24b4.
//
// Solidity: function beforeSwap(address sender, (address,address,uint24,int24,address) key, (bool,int256,uint160) params, bytes hookData) returns(bytes4)
func (_IHooks *IHooksTransactorSession) BeforeSwap(sender common.Address, key PoolKey, params IPoolManagerSwapParams, hookData []byte) (*types.Transaction, error) {
	return _IHooks.Contract.BeforeSwap(&_IHooks.TransactOpts, sender, key, params, hookData)
}

// IMessageBridgeMetaData contains all meta data concerning the IMessageBridge contract.
var IMessageBridgeMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"MessageCallReverted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"name\":\"MessageExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"MessageSent\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"accountProof\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes[]\",\"name\":\"storageProof\",\"type\":\"bytes[]\"}],\"name\":\"executeMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"getExecutionStateRootAndSlot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"lightClients\",\"outputs\":[{\"internalType\":\"contractIEthereumLightClient\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"sendMessage\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IMessageBridgeABI is the input ABI used to generate the binding from.
// Deprecated: Use IMessageBridgeMetaData.ABI instead.
var IMessageBridgeABI = IMessageBridgeMetaData.ABI

// IMessageBridge is an auto generated Go binding around an Ethereum contract.
type IMessageBridge struct {
	IMessageBridgeCaller     // Read-only binding to the contract
	IMessageBridgeTransactor // Write-only binding to the contract
	IMessageBridgeFilterer   // Log filterer for contract events
}

// IMessageBridgeCaller is an auto generated read-only Go binding around an Ethereum contract.
type IMessageBridgeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IMessageBridgeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IMessageBridgeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IMessageBridgeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IMessageBridgeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IMessageBridgeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IMessageBridgeSession struct {
	Contract     *IMessageBridge   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IMessageBridgeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IMessageBridgeCallerSession struct {
	Contract *IMessageBridgeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// IMessageBridgeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IMessageBridgeTransactorSession struct {
	Contract     *IMessageBridgeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// IMessageBridgeRaw is an auto generated low-level Go binding around an Ethereum contract.
type IMessageBridgeRaw struct {
	Contract *IMessageBridge // Generic contract binding to access the raw methods on
}

// IMessageBridgeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IMessageBridgeCallerRaw struct {
	Contract *IMessageBridgeCaller // Generic read-only contract binding to access the raw methods on
}

// IMessageBridgeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IMessageBridgeTransactorRaw struct {
	Contract *IMessageBridgeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIMessageBridge creates a new instance of IMessageBridge, bound to a specific deployed contract.
func NewIMessageBridge(address common.Address, backend bind.ContractBackend) (*IMessageBridge, error) {
	contract, err := bindIMessageBridge(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IMessageBridge{IMessageBridgeCaller: IMessageBridgeCaller{contract: contract}, IMessageBridgeTransactor: IMessageBridgeTransactor{contract: contract}, IMessageBridgeFilterer: IMessageBridgeFilterer{contract: contract}}, nil
}

// NewIMessageBridgeCaller creates a new read-only instance of IMessageBridge, bound to a specific deployed contract.
func NewIMessageBridgeCaller(address common.Address, caller bind.ContractCaller) (*IMessageBridgeCaller, error) {
	contract, err := bindIMessageBridge(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IMessageBridgeCaller{contract: contract}, nil
}

// NewIMessageBridgeTransactor creates a new write-only instance of IMessageBridge, bound to a specific deployed contract.
func NewIMessageBridgeTransactor(address common.Address, transactor bind.ContractTransactor) (*IMessageBridgeTransactor, error) {
	contract, err := bindIMessageBridge(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IMessageBridgeTransactor{contract: contract}, nil
}

// NewIMessageBridgeFilterer creates a new log filterer instance of IMessageBridge, bound to a specific deployed contract.
func NewIMessageBridgeFilterer(address common.Address, filterer bind.ContractFilterer) (*IMessageBridgeFilterer, error) {
	contract, err := bindIMessageBridge(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IMessageBridgeFilterer{contract: contract}, nil
}

// bindIMessageBridge binds a generic wrapper to an already deployed contract.
func bindIMessageBridge(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IMessageBridgeMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IMessageBridge *IMessageBridgeRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IMessageBridge.Contract.IMessageBridgeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IMessageBridge *IMessageBridgeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IMessageBridge.Contract.IMessageBridgeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IMessageBridge *IMessageBridgeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IMessageBridge.Contract.IMessageBridgeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IMessageBridge *IMessageBridgeCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IMessageBridge.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IMessageBridge *IMessageBridgeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IMessageBridge.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IMessageBridge *IMessageBridgeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IMessageBridge.Contract.contract.Transact(opts, method, params...)
}

// GetExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x6e98da7d.
//
// Solidity: function getExecutionStateRootAndSlot(uint64 chainId) view returns(bytes32 root, uint64 slot)
func (_IMessageBridge *IMessageBridgeCaller) GetExecutionStateRootAndSlot(opts *bind.CallOpts, chainId uint64) (struct {
	Root [32]byte
	Slot uint64
}, error) {
	var out []interface{}
	err := _IMessageBridge.contract.Call(opts, &out, "getExecutionStateRootAndSlot", chainId)

	outstruct := new(struct {
		Root [32]byte
		Slot uint64
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Root = *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)
	outstruct.Slot = *abi.ConvertType(out[1], new(uint64)).(*uint64)

	return *outstruct, err

}

// GetExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x6e98da7d.
//
// Solidity: function getExecutionStateRootAndSlot(uint64 chainId) view returns(bytes32 root, uint64 slot)
func (_IMessageBridge *IMessageBridgeSession) GetExecutionStateRootAndSlot(chainId uint64) (struct {
	Root [32]byte
	Slot uint64
}, error) {
	return _IMessageBridge.Contract.GetExecutionStateRootAndSlot(&_IMessageBridge.CallOpts, chainId)
}

// GetExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x6e98da7d.
//
// Solidity: function getExecutionStateRootAndSlot(uint64 chainId) view returns(bytes32 root, uint64 slot)
func (_IMessageBridge *IMessageBridgeCallerSession) GetExecutionStateRootAndSlot(chainId uint64) (struct {
	Root [32]byte
	Slot uint64
}, error) {
	return _IMessageBridge.Contract.GetExecutionStateRootAndSlot(&_IMessageBridge.CallOpts, chainId)
}

// LightClients is a free data retrieval call binding the contract method 0x970b3240.
//
// Solidity: function lightClients(uint256 chainId) view returns(address)
func (_IMessageBridge *IMessageBridgeCaller) LightClients(opts *bind.CallOpts, chainId *big.Int) (common.Address, error) {
	var out []interface{}
	err := _IMessageBridge.contract.Call(opts, &out, "lightClients", chainId)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// LightClients is a free data retrieval call binding the contract method 0x970b3240.
//
// Solidity: function lightClients(uint256 chainId) view returns(address)
func (_IMessageBridge *IMessageBridgeSession) LightClients(chainId *big.Int) (common.Address, error) {
	return _IMessageBridge.Contract.LightClients(&_IMessageBridge.CallOpts, chainId)
}

// LightClients is a free data retrieval call binding the contract method 0x970b3240.
//
// Solidity: function lightClients(uint256 chainId) view returns(address)
func (_IMessageBridge *IMessageBridgeCallerSession) LightClients(chainId *big.Int) (common.Address, error) {
	return _IMessageBridge.Contract.LightClients(&_IMessageBridge.CallOpts, chainId)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0x4f256d81.
//
// Solidity: function executeMessage(uint64 srcChainId, uint64 nonce, address sender, address receiver, bytes message, bytes[] accountProof, bytes[] storageProof) returns(bool)
func (_IMessageBridge *IMessageBridgeTransactor) ExecuteMessage(opts *bind.TransactOpts, srcChainId uint64, nonce uint64, sender common.Address, receiver common.Address, message []byte, accountProof [][]byte, storageProof [][]byte) (*types.Transaction, error) {
	return _IMessageBridge.contract.Transact(opts, "executeMessage", srcChainId, nonce, sender, receiver, message, accountProof, storageProof)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0x4f256d81.
//
// Solidity: function executeMessage(uint64 srcChainId, uint64 nonce, address sender, address receiver, bytes message, bytes[] accountProof, bytes[] storageProof) returns(bool)
func (_IMessageBridge *IMessageBridgeSession) ExecuteMessage(srcChainId uint64, nonce uint64, sender common.Address, receiver common.Address, message []byte, accountProof [][]byte, storageProof [][]byte) (*types.Transaction, error) {
	return _IMessageBridge.Contract.ExecuteMessage(&_IMessageBridge.TransactOpts, srcChainId, nonce, sender, receiver, message, accountProof, storageProof)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0x4f256d81.
//
// Solidity: function executeMessage(uint64 srcChainId, uint64 nonce, address sender, address receiver, bytes message, bytes[] accountProof, bytes[] storageProof) returns(bool)
func (_IMessageBridge *IMessageBridgeTransactorSession) ExecuteMessage(srcChainId uint64, nonce uint64, sender common.Address, receiver common.Address, message []byte, accountProof [][]byte, storageProof [][]byte) (*types.Transaction, error) {
	return _IMessageBridge.Contract.ExecuteMessage(&_IMessageBridge.TransactOpts, srcChainId, nonce, sender, receiver, message, accountProof, storageProof)
}

// SendMessage is a paid mutator transaction binding the contract method 0xb90b8352.
//
// Solidity: function sendMessage(uint64 dstChainId, address receiver, bytes message) returns(bytes32)
func (_IMessageBridge *IMessageBridgeTransactor) SendMessage(opts *bind.TransactOpts, dstChainId uint64, receiver common.Address, message []byte) (*types.Transaction, error) {
	return _IMessageBridge.contract.Transact(opts, "sendMessage", dstChainId, receiver, message)
}

// SendMessage is a paid mutator transaction binding the contract method 0xb90b8352.
//
// Solidity: function sendMessage(uint64 dstChainId, address receiver, bytes message) returns(bytes32)
func (_IMessageBridge *IMessageBridgeSession) SendMessage(dstChainId uint64, receiver common.Address, message []byte) (*types.Transaction, error) {
	return _IMessageBridge.Contract.SendMessage(&_IMessageBridge.TransactOpts, dstChainId, receiver, message)
}

// SendMessage is a paid mutator transaction binding the contract method 0xb90b8352.
//
// Solidity: function sendMessage(uint64 dstChainId, address receiver, bytes message) returns(bytes32)
func (_IMessageBridge *IMessageBridgeTransactorSession) SendMessage(dstChainId uint64, receiver common.Address, message []byte) (*types.Transaction, error) {
	return _IMessageBridge.Contract.SendMessage(&_IMessageBridge.TransactOpts, dstChainId, receiver, message)
}

// IMessageBridgeMessageCallRevertedIterator is returned from FilterMessageCallReverted and is used to iterate over the raw logs and unpacked data for MessageCallReverted events raised by the IMessageBridge contract.
type IMessageBridgeMessageCallRevertedIterator struct {
	Event *IMessageBridgeMessageCallReverted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IMessageBridgeMessageCallRevertedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IMessageBridgeMessageCallReverted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IMessageBridgeMessageCallReverted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IMessageBridgeMessageCallRevertedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IMessageBridgeMessageCallRevertedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IMessageBridgeMessageCallReverted represents a MessageCallReverted event raised by the IMessageBridge contract.
type IMessageBridgeMessageCallReverted struct {
	MessageId [32]byte
	Reason    string
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterMessageCallReverted is a free log retrieval operation binding the contract event 0xc666137142d7507d306f3aee4e2e08927034d27fc7c790316e8860c69782c94e.
//
// Solidity: event MessageCallReverted(bytes32 messageId, string reason)
func (_IMessageBridge *IMessageBridgeFilterer) FilterMessageCallReverted(opts *bind.FilterOpts) (*IMessageBridgeMessageCallRevertedIterator, error) {

	logs, sub, err := _IMessageBridge.contract.FilterLogs(opts, "MessageCallReverted")
	if err != nil {
		return nil, err
	}
	return &IMessageBridgeMessageCallRevertedIterator{contract: _IMessageBridge.contract, event: "MessageCallReverted", logs: logs, sub: sub}, nil
}

// WatchMessageCallReverted is a free log subscription operation binding the contract event 0xc666137142d7507d306f3aee4e2e08927034d27fc7c790316e8860c69782c94e.
//
// Solidity: event MessageCallReverted(bytes32 messageId, string reason)
func (_IMessageBridge *IMessageBridgeFilterer) WatchMessageCallReverted(opts *bind.WatchOpts, sink chan<- *IMessageBridgeMessageCallReverted) (event.Subscription, error) {

	logs, sub, err := _IMessageBridge.contract.WatchLogs(opts, "MessageCallReverted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IMessageBridgeMessageCallReverted)
				if err := _IMessageBridge.contract.UnpackLog(event, "MessageCallReverted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMessageCallReverted is a log parse operation binding the contract event 0xc666137142d7507d306f3aee4e2e08927034d27fc7c790316e8860c69782c94e.
//
// Solidity: event MessageCallReverted(bytes32 messageId, string reason)
func (_IMessageBridge *IMessageBridgeFilterer) ParseMessageCallReverted(log types.Log) (*IMessageBridgeMessageCallReverted, error) {
	event := new(IMessageBridgeMessageCallReverted)
	if err := _IMessageBridge.contract.UnpackLog(event, "MessageCallReverted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IMessageBridgeMessageExecutedIterator is returned from FilterMessageExecuted and is used to iterate over the raw logs and unpacked data for MessageExecuted events raised by the IMessageBridge contract.
type IMessageBridgeMessageExecutedIterator struct {
	Event *IMessageBridgeMessageExecuted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IMessageBridgeMessageExecutedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IMessageBridgeMessageExecuted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IMessageBridgeMessageExecuted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IMessageBridgeMessageExecutedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IMessageBridgeMessageExecutedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IMessageBridgeMessageExecuted represents a MessageExecuted event raised by the IMessageBridge contract.
type IMessageBridgeMessageExecuted struct {
	MessageId  [32]byte
	Nonce      *big.Int
	SrcChainId uint64
	Sender     common.Address
	Receiver   common.Address
	Message    []byte
	Success    bool
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterMessageExecuted is a free log retrieval operation binding the contract event 0xbf79e9ebbcf1fdc699f3a386de83f09cb080ab7e07f7b872118a93aef293102d.
//
// Solidity: event MessageExecuted(bytes32 indexed messageId, uint256 indexed nonce, uint64 srcChainId, address sender, address receiver, bytes message, bool success)
func (_IMessageBridge *IMessageBridgeFilterer) FilterMessageExecuted(opts *bind.FilterOpts, messageId [][32]byte, nonce []*big.Int) (*IMessageBridgeMessageExecutedIterator, error) {

	var messageIdRule []interface{}
	for _, messageIdItem := range messageId {
		messageIdRule = append(messageIdRule, messageIdItem)
	}
	var nonceRule []interface{}
	for _, nonceItem := range nonce {
		nonceRule = append(nonceRule, nonceItem)
	}

	logs, sub, err := _IMessageBridge.contract.FilterLogs(opts, "MessageExecuted", messageIdRule, nonceRule)
	if err != nil {
		return nil, err
	}
	return &IMessageBridgeMessageExecutedIterator{contract: _IMessageBridge.contract, event: "MessageExecuted", logs: logs, sub: sub}, nil
}

// WatchMessageExecuted is a free log subscription operation binding the contract event 0xbf79e9ebbcf1fdc699f3a386de83f09cb080ab7e07f7b872118a93aef293102d.
//
// Solidity: event MessageExecuted(bytes32 indexed messageId, uint256 indexed nonce, uint64 srcChainId, address sender, address receiver, bytes message, bool success)
func (_IMessageBridge *IMessageBridgeFilterer) WatchMessageExecuted(opts *bind.WatchOpts, sink chan<- *IMessageBridgeMessageExecuted, messageId [][32]byte, nonce []*big.Int) (event.Subscription, error) {

	var messageIdRule []interface{}
	for _, messageIdItem := range messageId {
		messageIdRule = append(messageIdRule, messageIdItem)
	}
	var nonceRule []interface{}
	for _, nonceItem := range nonce {
		nonceRule = append(nonceRule, nonceItem)
	}

	logs, sub, err := _IMessageBridge.contract.WatchLogs(opts, "MessageExecuted", messageIdRule, nonceRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IMessageBridgeMessageExecuted)
				if err := _IMessageBridge.contract.UnpackLog(event, "MessageExecuted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMessageExecuted is a log parse operation binding the contract event 0xbf79e9ebbcf1fdc699f3a386de83f09cb080ab7e07f7b872118a93aef293102d.
//
// Solidity: event MessageExecuted(bytes32 indexed messageId, uint256 indexed nonce, uint64 srcChainId, address sender, address receiver, bytes message, bool success)
func (_IMessageBridge *IMessageBridgeFilterer) ParseMessageExecuted(log types.Log) (*IMessageBridgeMessageExecuted, error) {
	event := new(IMessageBridgeMessageExecuted)
	if err := _IMessageBridge.contract.UnpackLog(event, "MessageExecuted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IMessageBridgeMessageSentIterator is returned from FilterMessageSent and is used to iterate over the raw logs and unpacked data for MessageSent events raised by the IMessageBridge contract.
type IMessageBridgeMessageSentIterator struct {
	Event *IMessageBridgeMessageSent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IMessageBridgeMessageSentIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IMessageBridgeMessageSent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IMessageBridgeMessageSent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IMessageBridgeMessageSentIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IMessageBridgeMessageSentIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IMessageBridgeMessageSent represents a MessageSent event raised by the IMessageBridge contract.
type IMessageBridgeMessageSent struct {
	MessageId  [32]byte
	Nonce      *big.Int
	DstChainId uint64
	Sender     common.Address
	Receiver   common.Address
	Message    []byte
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterMessageSent is a free log retrieval operation binding the contract event 0xd4c077d3ac449bc1b439559b537c6550f793c2432e3d74082b023162296dc566.
//
// Solidity: event MessageSent(bytes32 indexed messageId, uint256 indexed nonce, uint64 dstChainId, address sender, address receiver, bytes message)
func (_IMessageBridge *IMessageBridgeFilterer) FilterMessageSent(opts *bind.FilterOpts, messageId [][32]byte, nonce []*big.Int) (*IMessageBridgeMessageSentIterator, error) {

	var messageIdRule []interface{}
	for _, messageIdItem := range messageId {
		messageIdRule = append(messageIdRule, messageIdItem)
	}
	var nonceRule []interface{}
	for _, nonceItem := range nonce {
		nonceRule = append(nonceRule, nonceItem)
	}

	logs, sub, err := _IMessageBridge.contract.FilterLogs(opts, "MessageSent", messageIdRule, nonceRule)
	if err != nil {
		return nil, err
	}
	return &IMessageBridgeMessageSentIterator{contract: _IMessageBridge.contract, event: "MessageSent", logs: logs, sub: sub}, nil
}

// WatchMessageSent is a free log subscription operation binding the contract event 0xd4c077d3ac449bc1b439559b537c6550f793c2432e3d74082b023162296dc566.
//
// Solidity: event MessageSent(bytes32 indexed messageId, uint256 indexed nonce, uint64 dstChainId, address sender, address receiver, bytes message)
func (_IMessageBridge *IMessageBridgeFilterer) WatchMessageSent(opts *bind.WatchOpts, sink chan<- *IMessageBridgeMessageSent, messageId [][32]byte, nonce []*big.Int) (event.Subscription, error) {

	var messageIdRule []interface{}
	for _, messageIdItem := range messageId {
		messageIdRule = append(messageIdRule, messageIdItem)
	}
	var nonceRule []interface{}
	for _, nonceItem := range nonce {
		nonceRule = append(nonceRule, nonceItem)
	}

	logs, sub, err := _IMessageBridge.contract.WatchLogs(opts, "MessageSent", messageIdRule, nonceRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IMessageBridgeMessageSent)
				if err := _IMessageBridge.contract.UnpackLog(event, "MessageSent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMessageSent is a log parse operation binding the contract event 0xd4c077d3ac449bc1b439559b537c6550f793c2432e3d74082b023162296dc566.
//
// Solidity: event MessageSent(bytes32 indexed messageId, uint256 indexed nonce, uint64 dstChainId, address sender, address receiver, bytes message)
func (_IMessageBridge *IMessageBridgeFilterer) ParseMessageSent(log types.Log) (*IMessageBridgeMessageSent, error) {
	event := new(IMessageBridgeMessageSent)
	if err := _IMessageBridge.contract.UnpackLog(event, "MessageSent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IMessageReceiverAppMetaData contains all meta data concerning the IMessageReceiverApp contract.
var IMessageReceiverAppMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_executor\",\"type\":\"address\"}],\"name\":\"executeMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IMessageReceiverAppABI is the input ABI used to generate the binding from.
// Deprecated: Use IMessageReceiverAppMetaData.ABI instead.
var IMessageReceiverAppABI = IMessageReceiverAppMetaData.ABI

// IMessageReceiverApp is an auto generated Go binding around an Ethereum contract.
type IMessageReceiverApp struct {
	IMessageReceiverAppCaller     // Read-only binding to the contract
	IMessageReceiverAppTransactor // Write-only binding to the contract
	IMessageReceiverAppFilterer   // Log filterer for contract events
}

// IMessageReceiverAppCaller is an auto generated read-only Go binding around an Ethereum contract.
type IMessageReceiverAppCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IMessageReceiverAppTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IMessageReceiverAppTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IMessageReceiverAppFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IMessageReceiverAppFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IMessageReceiverAppSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IMessageReceiverAppSession struct {
	Contract     *IMessageReceiverApp // Generic contract binding to set the session for
	CallOpts     bind.CallOpts        // Call options to use throughout this session
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// IMessageReceiverAppCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IMessageReceiverAppCallerSession struct {
	Contract *IMessageReceiverAppCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts              // Call options to use throughout this session
}

// IMessageReceiverAppTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IMessageReceiverAppTransactorSession struct {
	Contract     *IMessageReceiverAppTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts              // Transaction auth options to use throughout this session
}

// IMessageReceiverAppRaw is an auto generated low-level Go binding around an Ethereum contract.
type IMessageReceiverAppRaw struct {
	Contract *IMessageReceiverApp // Generic contract binding to access the raw methods on
}

// IMessageReceiverAppCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IMessageReceiverAppCallerRaw struct {
	Contract *IMessageReceiverAppCaller // Generic read-only contract binding to access the raw methods on
}

// IMessageReceiverAppTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IMessageReceiverAppTransactorRaw struct {
	Contract *IMessageReceiverAppTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIMessageReceiverApp creates a new instance of IMessageReceiverApp, bound to a specific deployed contract.
func NewIMessageReceiverApp(address common.Address, backend bind.ContractBackend) (*IMessageReceiverApp, error) {
	contract, err := bindIMessageReceiverApp(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IMessageReceiverApp{IMessageReceiverAppCaller: IMessageReceiverAppCaller{contract: contract}, IMessageReceiverAppTransactor: IMessageReceiverAppTransactor{contract: contract}, IMessageReceiverAppFilterer: IMessageReceiverAppFilterer{contract: contract}}, nil
}

// NewIMessageReceiverAppCaller creates a new read-only instance of IMessageReceiverApp, bound to a specific deployed contract.
func NewIMessageReceiverAppCaller(address common.Address, caller bind.ContractCaller) (*IMessageReceiverAppCaller, error) {
	contract, err := bindIMessageReceiverApp(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IMessageReceiverAppCaller{contract: contract}, nil
}

// NewIMessageReceiverAppTransactor creates a new write-only instance of IMessageReceiverApp, bound to a specific deployed contract.
func NewIMessageReceiverAppTransactor(address common.Address, transactor bind.ContractTransactor) (*IMessageReceiverAppTransactor, error) {
	contract, err := bindIMessageReceiverApp(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IMessageReceiverAppTransactor{contract: contract}, nil
}

// NewIMessageReceiverAppFilterer creates a new log filterer instance of IMessageReceiverApp, bound to a specific deployed contract.
func NewIMessageReceiverAppFilterer(address common.Address, filterer bind.ContractFilterer) (*IMessageReceiverAppFilterer, error) {
	contract, err := bindIMessageReceiverApp(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IMessageReceiverAppFilterer{contract: contract}, nil
}

// bindIMessageReceiverApp binds a generic wrapper to an already deployed contract.
func bindIMessageReceiverApp(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IMessageReceiverAppMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IMessageReceiverApp *IMessageReceiverAppRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IMessageReceiverApp.Contract.IMessageReceiverAppCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IMessageReceiverApp *IMessageReceiverAppRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IMessageReceiverApp.Contract.IMessageReceiverAppTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IMessageReceiverApp *IMessageReceiverAppRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IMessageReceiverApp.Contract.IMessageReceiverAppTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IMessageReceiverApp *IMessageReceiverAppCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IMessageReceiverApp.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IMessageReceiverApp *IMessageReceiverAppTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IMessageReceiverApp.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IMessageReceiverApp *IMessageReceiverAppTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IMessageReceiverApp.Contract.contract.Transact(opts, method, params...)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 _srcChainId, address _sender, bytes _message, address _executor) returns(bool)
func (_IMessageReceiverApp *IMessageReceiverAppTransactor) ExecuteMessage(opts *bind.TransactOpts, _srcChainId uint64, _sender common.Address, _message []byte, _executor common.Address) (*types.Transaction, error) {
	return _IMessageReceiverApp.contract.Transact(opts, "executeMessage", _srcChainId, _sender, _message, _executor)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 _srcChainId, address _sender, bytes _message, address _executor) returns(bool)
func (_IMessageReceiverApp *IMessageReceiverAppSession) ExecuteMessage(_srcChainId uint64, _sender common.Address, _message []byte, _executor common.Address) (*types.Transaction, error) {
	return _IMessageReceiverApp.Contract.ExecuteMessage(&_IMessageReceiverApp.TransactOpts, _srcChainId, _sender, _message, _executor)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 _srcChainId, address _sender, bytes _message, address _executor) returns(bool)
func (_IMessageReceiverApp *IMessageReceiverAppTransactorSession) ExecuteMessage(_srcChainId uint64, _sender common.Address, _message []byte, _executor common.Address) (*types.Transaction, error) {
	return _IMessageReceiverApp.Contract.ExecuteMessage(&_IMessageReceiverApp.TransactOpts, _srcChainId, _sender, _message, _executor)
}

// IPeggedTokenMetaData contains all meta data concerning the IPeggedToken contract.
var IPeggedTokenMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IPeggedTokenABI is the input ABI used to generate the binding from.
// Deprecated: Use IPeggedTokenMetaData.ABI instead.
var IPeggedTokenABI = IPeggedTokenMetaData.ABI

// IPeggedToken is an auto generated Go binding around an Ethereum contract.
type IPeggedToken struct {
	IPeggedTokenCaller     // Read-only binding to the contract
	IPeggedTokenTransactor // Write-only binding to the contract
	IPeggedTokenFilterer   // Log filterer for contract events
}

// IPeggedTokenCaller is an auto generated read-only Go binding around an Ethereum contract.
type IPeggedTokenCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IPeggedTokenTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IPeggedTokenTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IPeggedTokenFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IPeggedTokenFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IPeggedTokenSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IPeggedTokenSession struct {
	Contract     *IPeggedToken     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IPeggedTokenCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IPeggedTokenCallerSession struct {
	Contract *IPeggedTokenCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// IPeggedTokenTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IPeggedTokenTransactorSession struct {
	Contract     *IPeggedTokenTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// IPeggedTokenRaw is an auto generated low-level Go binding around an Ethereum contract.
type IPeggedTokenRaw struct {
	Contract *IPeggedToken // Generic contract binding to access the raw methods on
}

// IPeggedTokenCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IPeggedTokenCallerRaw struct {
	Contract *IPeggedTokenCaller // Generic read-only contract binding to access the raw methods on
}

// IPeggedTokenTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IPeggedTokenTransactorRaw struct {
	Contract *IPeggedTokenTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIPeggedToken creates a new instance of IPeggedToken, bound to a specific deployed contract.
func NewIPeggedToken(address common.Address, backend bind.ContractBackend) (*IPeggedToken, error) {
	contract, err := bindIPeggedToken(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IPeggedToken{IPeggedTokenCaller: IPeggedTokenCaller{contract: contract}, IPeggedTokenTransactor: IPeggedTokenTransactor{contract: contract}, IPeggedTokenFilterer: IPeggedTokenFilterer{contract: contract}}, nil
}

// NewIPeggedTokenCaller creates a new read-only instance of IPeggedToken, bound to a specific deployed contract.
func NewIPeggedTokenCaller(address common.Address, caller bind.ContractCaller) (*IPeggedTokenCaller, error) {
	contract, err := bindIPeggedToken(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IPeggedTokenCaller{contract: contract}, nil
}

// NewIPeggedTokenTransactor creates a new write-only instance of IPeggedToken, bound to a specific deployed contract.
func NewIPeggedTokenTransactor(address common.Address, transactor bind.ContractTransactor) (*IPeggedTokenTransactor, error) {
	contract, err := bindIPeggedToken(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IPeggedTokenTransactor{contract: contract}, nil
}

// NewIPeggedTokenFilterer creates a new log filterer instance of IPeggedToken, bound to a specific deployed contract.
func NewIPeggedTokenFilterer(address common.Address, filterer bind.ContractFilterer) (*IPeggedTokenFilterer, error) {
	contract, err := bindIPeggedToken(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IPeggedTokenFilterer{contract: contract}, nil
}

// bindIPeggedToken binds a generic wrapper to an already deployed contract.
func bindIPeggedToken(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IPeggedTokenMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IPeggedToken *IPeggedTokenRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IPeggedToken.Contract.IPeggedTokenCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IPeggedToken *IPeggedTokenRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IPeggedToken.Contract.IPeggedTokenTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IPeggedToken *IPeggedTokenRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IPeggedToken.Contract.IPeggedTokenTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IPeggedToken *IPeggedTokenCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IPeggedToken.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IPeggedToken *IPeggedTokenTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IPeggedToken.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IPeggedToken *IPeggedTokenTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IPeggedToken.Contract.contract.Transact(opts, method, params...)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x79cc6790.
//
// Solidity: function burnFrom(address _from, uint256 _amount) returns()
func (_IPeggedToken *IPeggedTokenTransactor) BurnFrom(opts *bind.TransactOpts, _from common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _IPeggedToken.contract.Transact(opts, "burnFrom", _from, _amount)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x79cc6790.
//
// Solidity: function burnFrom(address _from, uint256 _amount) returns()
func (_IPeggedToken *IPeggedTokenSession) BurnFrom(_from common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _IPeggedToken.Contract.BurnFrom(&_IPeggedToken.TransactOpts, _from, _amount)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x79cc6790.
//
// Solidity: function burnFrom(address _from, uint256 _amount) returns()
func (_IPeggedToken *IPeggedTokenTransactorSession) BurnFrom(_from common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _IPeggedToken.Contract.BurnFrom(&_IPeggedToken.TransactOpts, _from, _amount)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address _to, uint256 _amount) returns()
func (_IPeggedToken *IPeggedTokenTransactor) Mint(opts *bind.TransactOpts, _to common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _IPeggedToken.contract.Transact(opts, "mint", _to, _amount)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address _to, uint256 _amount) returns()
func (_IPeggedToken *IPeggedTokenSession) Mint(_to common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _IPeggedToken.Contract.Mint(&_IPeggedToken.TransactOpts, _to, _amount)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address _to, uint256 _amount) returns()
func (_IPeggedToken *IPeggedTokenTransactorSession) Mint(_to common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _IPeggedToken.Contract.Mint(&_IPeggedToken.TransactOpts, _to, _amount)
}

// IPoolManagerMetaData contains all meta data concerning the IPoolManager contract.
var IPoolManagerMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"CurrenciesInitializedOutOfOrder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CurrencyNotSettled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FeeTooLarge\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"locker\",\"type\":\"address\"}],\"name\":\"LockedBy\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxCurrenciesTouched\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotPoolManagerToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProtocolFeeCannotBeFetched\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TickSpacingTooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TickSpacingTooSmall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"PoolId\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"hookFees\",\"type\":\"uint24\"}],\"name\":\"HookFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"PoolId\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"indexed\":false,\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"name\":\"Initialize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"PoolId\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"indexed\":false,\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"liquidityDelta\",\"type\":\"int256\"}],\"name\":\"ModifyPosition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"protocolFeeController\",\"type\":\"address\"}],\"name\":\"ProtocolFeeControllerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"PoolId\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"protocolFees\",\"type\":\"uint24\"}],\"name\":\"ProtocolFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"PoolId\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int128\",\"name\":\"amount0\",\"type\":\"int128\"},{\"indexed\":false,\"internalType\":\"int128\",\"name\":\"amount1\",\"type\":\"int128\"},{\"indexed\":false,\"internalType\":\"uint160\",\"name\":\"sqrtPriceX96\",\"type\":\"uint160\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_TICK_SPACING\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_PROTOCOL_FEE_DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_TICK_SPACING\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"locker\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency\",\"type\":\"address\"}],\"name\":\"currencyDelta\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"hookData\",\"type\":\"bytes\"}],\"name\":\"donate\",\"outputs\":[{\"internalType\":\"BalanceDelta\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"slot\",\"type\":\"bytes32\"}],\"name\":\"extsload\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"value\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"slot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nSlots\",\"type\":\"uint256\"}],\"name\":\"extsload\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"value\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"PoolId\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"}],\"name\":\"getLiquidity\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"PoolId\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"getLiquidity\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getLock\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"locker\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"PoolId\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"}],\"name\":\"getPosition\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"feeGrowthInside0LastX128\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeGrowthInside1LastX128\",\"type\":\"uint256\"}],\"internalType\":\"structPosition.Info\",\"name\":\"position\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"PoolId\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"getSlot0\",\"outputs\":[{\"internalType\":\"uint160\",\"name\":\"sqrtPriceX96\",\"type\":\"uint160\"},{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"},{\"internalType\":\"uint24\",\"name\":\"protocolFees\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"hookFees\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hookFeesAccrued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceX96\",\"type\":\"uint160\"},{\"internalType\":\"bytes\",\"name\":\"hookData\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"lock\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockData\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"length\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"nonzeroDeltaCount\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Currency\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"int256\",\"name\":\"liquidityDelta\",\"type\":\"int256\"}],\"internalType\":\"structIPoolManager.ModifyPositionParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"hookData\",\"type\":\"bytes\"}],\"name\":\"modifyPosition\",\"outputs\":[{\"internalType\":\"BalanceDelta\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Currency\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"protocolFeesAccrued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Currency\",\"name\":\"currency\",\"type\":\"address\"}],\"name\":\"reservesOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"}],\"name\":\"setHookFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"}],\"name\":\"setProtocolFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Currency\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"settle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"paid\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"zeroForOne\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"amountSpecified\",\"type\":\"int256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"structIPoolManager.SwapParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"hookData\",\"type\":\"bytes\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"BalanceDelta\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Currency\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"take\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IPoolManagerABI is the input ABI used to generate the binding from.
// Deprecated: Use IPoolManagerMetaData.ABI instead.
var IPoolManagerABI = IPoolManagerMetaData.ABI

// IPoolManager is an auto generated Go binding around an Ethereum contract.
type IPoolManager struct {
	IPoolManagerCaller     // Read-only binding to the contract
	IPoolManagerTransactor // Write-only binding to the contract
	IPoolManagerFilterer   // Log filterer for contract events
}

// IPoolManagerCaller is an auto generated read-only Go binding around an Ethereum contract.
type IPoolManagerCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IPoolManagerTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IPoolManagerTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IPoolManagerFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IPoolManagerFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IPoolManagerSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IPoolManagerSession struct {
	Contract     *IPoolManager     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IPoolManagerCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IPoolManagerCallerSession struct {
	Contract *IPoolManagerCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// IPoolManagerTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IPoolManagerTransactorSession struct {
	Contract     *IPoolManagerTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// IPoolManagerRaw is an auto generated low-level Go binding around an Ethereum contract.
type IPoolManagerRaw struct {
	Contract *IPoolManager // Generic contract binding to access the raw methods on
}

// IPoolManagerCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IPoolManagerCallerRaw struct {
	Contract *IPoolManagerCaller // Generic read-only contract binding to access the raw methods on
}

// IPoolManagerTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IPoolManagerTransactorRaw struct {
	Contract *IPoolManagerTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIPoolManager creates a new instance of IPoolManager, bound to a specific deployed contract.
func NewIPoolManager(address common.Address, backend bind.ContractBackend) (*IPoolManager, error) {
	contract, err := bindIPoolManager(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IPoolManager{IPoolManagerCaller: IPoolManagerCaller{contract: contract}, IPoolManagerTransactor: IPoolManagerTransactor{contract: contract}, IPoolManagerFilterer: IPoolManagerFilterer{contract: contract}}, nil
}

// NewIPoolManagerCaller creates a new read-only instance of IPoolManager, bound to a specific deployed contract.
func NewIPoolManagerCaller(address common.Address, caller bind.ContractCaller) (*IPoolManagerCaller, error) {
	contract, err := bindIPoolManager(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IPoolManagerCaller{contract: contract}, nil
}

// NewIPoolManagerTransactor creates a new write-only instance of IPoolManager, bound to a specific deployed contract.
func NewIPoolManagerTransactor(address common.Address, transactor bind.ContractTransactor) (*IPoolManagerTransactor, error) {
	contract, err := bindIPoolManager(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IPoolManagerTransactor{contract: contract}, nil
}

// NewIPoolManagerFilterer creates a new log filterer instance of IPoolManager, bound to a specific deployed contract.
func NewIPoolManagerFilterer(address common.Address, filterer bind.ContractFilterer) (*IPoolManagerFilterer, error) {
	contract, err := bindIPoolManager(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IPoolManagerFilterer{contract: contract}, nil
}

// bindIPoolManager binds a generic wrapper to an already deployed contract.
func bindIPoolManager(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IPoolManagerMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IPoolManager *IPoolManagerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IPoolManager.Contract.IPoolManagerCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IPoolManager *IPoolManagerRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IPoolManager.Contract.IPoolManagerTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IPoolManager *IPoolManagerRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IPoolManager.Contract.IPoolManagerTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IPoolManager *IPoolManagerCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IPoolManager.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IPoolManager *IPoolManagerTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IPoolManager.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IPoolManager *IPoolManagerTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IPoolManager.Contract.contract.Transact(opts, method, params...)
}

// MAXTICKSPACING is a free data retrieval call binding the contract method 0x60460f06.
//
// Solidity: function MAX_TICK_SPACING() view returns(int24)
func (_IPoolManager *IPoolManagerCaller) MAXTICKSPACING(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "MAX_TICK_SPACING")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MAXTICKSPACING is a free data retrieval call binding the contract method 0x60460f06.
//
// Solidity: function MAX_TICK_SPACING() view returns(int24)
func (_IPoolManager *IPoolManagerSession) MAXTICKSPACING() (*big.Int, error) {
	return _IPoolManager.Contract.MAXTICKSPACING(&_IPoolManager.CallOpts)
}

// MAXTICKSPACING is a free data retrieval call binding the contract method 0x60460f06.
//
// Solidity: function MAX_TICK_SPACING() view returns(int24)
func (_IPoolManager *IPoolManagerCallerSession) MAXTICKSPACING() (*big.Int, error) {
	return _IPoolManager.Contract.MAXTICKSPACING(&_IPoolManager.CallOpts)
}

// MINPROTOCOLFEEDENOMINATOR is a free data retrieval call binding the contract method 0x84e41c5e.
//
// Solidity: function MIN_PROTOCOL_FEE_DENOMINATOR() view returns(uint8)
func (_IPoolManager *IPoolManagerCaller) MINPROTOCOLFEEDENOMINATOR(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "MIN_PROTOCOL_FEE_DENOMINATOR")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// MINPROTOCOLFEEDENOMINATOR is a free data retrieval call binding the contract method 0x84e41c5e.
//
// Solidity: function MIN_PROTOCOL_FEE_DENOMINATOR() view returns(uint8)
func (_IPoolManager *IPoolManagerSession) MINPROTOCOLFEEDENOMINATOR() (uint8, error) {
	return _IPoolManager.Contract.MINPROTOCOLFEEDENOMINATOR(&_IPoolManager.CallOpts)
}

// MINPROTOCOLFEEDENOMINATOR is a free data retrieval call binding the contract method 0x84e41c5e.
//
// Solidity: function MIN_PROTOCOL_FEE_DENOMINATOR() view returns(uint8)
func (_IPoolManager *IPoolManagerCallerSession) MINPROTOCOLFEEDENOMINATOR() (uint8, error) {
	return _IPoolManager.Contract.MINPROTOCOLFEEDENOMINATOR(&_IPoolManager.CallOpts)
}

// MINTICKSPACING is a free data retrieval call binding the contract method 0x07eff0dd.
//
// Solidity: function MIN_TICK_SPACING() view returns(int24)
func (_IPoolManager *IPoolManagerCaller) MINTICKSPACING(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "MIN_TICK_SPACING")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MINTICKSPACING is a free data retrieval call binding the contract method 0x07eff0dd.
//
// Solidity: function MIN_TICK_SPACING() view returns(int24)
func (_IPoolManager *IPoolManagerSession) MINTICKSPACING() (*big.Int, error) {
	return _IPoolManager.Contract.MINTICKSPACING(&_IPoolManager.CallOpts)
}

// MINTICKSPACING is a free data retrieval call binding the contract method 0x07eff0dd.
//
// Solidity: function MIN_TICK_SPACING() view returns(int24)
func (_IPoolManager *IPoolManagerCallerSession) MINTICKSPACING() (*big.Int, error) {
	return _IPoolManager.Contract.MINTICKSPACING(&_IPoolManager.CallOpts)
}

// BalanceOf is a free data retrieval call binding the contract method 0x00fdd58e.
//
// Solidity: function balanceOf(address account, uint256 id) view returns(uint256)
func (_IPoolManager *IPoolManagerCaller) BalanceOf(opts *bind.CallOpts, account common.Address, id *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "balanceOf", account, id)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x00fdd58e.
//
// Solidity: function balanceOf(address account, uint256 id) view returns(uint256)
func (_IPoolManager *IPoolManagerSession) BalanceOf(account common.Address, id *big.Int) (*big.Int, error) {
	return _IPoolManager.Contract.BalanceOf(&_IPoolManager.CallOpts, account, id)
}

// BalanceOf is a free data retrieval call binding the contract method 0x00fdd58e.
//
// Solidity: function balanceOf(address account, uint256 id) view returns(uint256)
func (_IPoolManager *IPoolManagerCallerSession) BalanceOf(account common.Address, id *big.Int) (*big.Int, error) {
	return _IPoolManager.Contract.BalanceOf(&_IPoolManager.CallOpts, account, id)
}

// BalanceOfBatch is a free data retrieval call binding the contract method 0x4e1273f4.
//
// Solidity: function balanceOfBatch(address[] accounts, uint256[] ids) view returns(uint256[])
func (_IPoolManager *IPoolManagerCaller) BalanceOfBatch(opts *bind.CallOpts, accounts []common.Address, ids []*big.Int) ([]*big.Int, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "balanceOfBatch", accounts, ids)

	if err != nil {
		return *new([]*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new([]*big.Int)).(*[]*big.Int)

	return out0, err

}

// BalanceOfBatch is a free data retrieval call binding the contract method 0x4e1273f4.
//
// Solidity: function balanceOfBatch(address[] accounts, uint256[] ids) view returns(uint256[])
func (_IPoolManager *IPoolManagerSession) BalanceOfBatch(accounts []common.Address, ids []*big.Int) ([]*big.Int, error) {
	return _IPoolManager.Contract.BalanceOfBatch(&_IPoolManager.CallOpts, accounts, ids)
}

// BalanceOfBatch is a free data retrieval call binding the contract method 0x4e1273f4.
//
// Solidity: function balanceOfBatch(address[] accounts, uint256[] ids) view returns(uint256[])
func (_IPoolManager *IPoolManagerCallerSession) BalanceOfBatch(accounts []common.Address, ids []*big.Int) ([]*big.Int, error) {
	return _IPoolManager.Contract.BalanceOfBatch(&_IPoolManager.CallOpts, accounts, ids)
}

// CurrencyDelta is a free data retrieval call binding the contract method 0xa54b2831.
//
// Solidity: function currencyDelta(address locker, address currency) view returns(int256)
func (_IPoolManager *IPoolManagerCaller) CurrencyDelta(opts *bind.CallOpts, locker common.Address, currency common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "currencyDelta", locker, currency)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// CurrencyDelta is a free data retrieval call binding the contract method 0xa54b2831.
//
// Solidity: function currencyDelta(address locker, address currency) view returns(int256)
func (_IPoolManager *IPoolManagerSession) CurrencyDelta(locker common.Address, currency common.Address) (*big.Int, error) {
	return _IPoolManager.Contract.CurrencyDelta(&_IPoolManager.CallOpts, locker, currency)
}

// CurrencyDelta is a free data retrieval call binding the contract method 0xa54b2831.
//
// Solidity: function currencyDelta(address locker, address currency) view returns(int256)
func (_IPoolManager *IPoolManagerCallerSession) CurrencyDelta(locker common.Address, currency common.Address) (*big.Int, error) {
	return _IPoolManager.Contract.CurrencyDelta(&_IPoolManager.CallOpts, locker, currency)
}

// Extsload is a free data retrieval call binding the contract method 0x1e2eaeaf.
//
// Solidity: function extsload(bytes32 slot) view returns(bytes32 value)
func (_IPoolManager *IPoolManagerCaller) Extsload(opts *bind.CallOpts, slot [32]byte) ([32]byte, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "extsload", slot)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// Extsload is a free data retrieval call binding the contract method 0x1e2eaeaf.
//
// Solidity: function extsload(bytes32 slot) view returns(bytes32 value)
func (_IPoolManager *IPoolManagerSession) Extsload(slot [32]byte) ([32]byte, error) {
	return _IPoolManager.Contract.Extsload(&_IPoolManager.CallOpts, slot)
}

// Extsload is a free data retrieval call binding the contract method 0x1e2eaeaf.
//
// Solidity: function extsload(bytes32 slot) view returns(bytes32 value)
func (_IPoolManager *IPoolManagerCallerSession) Extsload(slot [32]byte) ([32]byte, error) {
	return _IPoolManager.Contract.Extsload(&_IPoolManager.CallOpts, slot)
}

// Extsload0 is a free data retrieval call binding the contract method 0x35fd631a.
//
// Solidity: function extsload(bytes32 slot, uint256 nSlots) view returns(bytes value)
func (_IPoolManager *IPoolManagerCaller) Extsload0(opts *bind.CallOpts, slot [32]byte, nSlots *big.Int) ([]byte, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "extsload0", slot, nSlots)

	if err != nil {
		return *new([]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([]byte)).(*[]byte)

	return out0, err

}

// Extsload0 is a free data retrieval call binding the contract method 0x35fd631a.
//
// Solidity: function extsload(bytes32 slot, uint256 nSlots) view returns(bytes value)
func (_IPoolManager *IPoolManagerSession) Extsload0(slot [32]byte, nSlots *big.Int) ([]byte, error) {
	return _IPoolManager.Contract.Extsload0(&_IPoolManager.CallOpts, slot, nSlots)
}

// Extsload0 is a free data retrieval call binding the contract method 0x35fd631a.
//
// Solidity: function extsload(bytes32 slot, uint256 nSlots) view returns(bytes value)
func (_IPoolManager *IPoolManagerCallerSession) Extsload0(slot [32]byte, nSlots *big.Int) ([]byte, error) {
	return _IPoolManager.Contract.Extsload0(&_IPoolManager.CallOpts, slot, nSlots)
}

// GetLiquidity is a free data retrieval call binding the contract method 0x33aa955b.
//
// Solidity: function getLiquidity(bytes32 id, address owner, int24 tickLower, int24 tickUpper) view returns(uint128 liquidity)
func (_IPoolManager *IPoolManagerCaller) GetLiquidity(opts *bind.CallOpts, id [32]byte, owner common.Address, tickLower *big.Int, tickUpper *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "getLiquidity", id, owner, tickLower, tickUpper)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetLiquidity is a free data retrieval call binding the contract method 0x33aa955b.
//
// Solidity: function getLiquidity(bytes32 id, address owner, int24 tickLower, int24 tickUpper) view returns(uint128 liquidity)
func (_IPoolManager *IPoolManagerSession) GetLiquidity(id [32]byte, owner common.Address, tickLower *big.Int, tickUpper *big.Int) (*big.Int, error) {
	return _IPoolManager.Contract.GetLiquidity(&_IPoolManager.CallOpts, id, owner, tickLower, tickUpper)
}

// GetLiquidity is a free data retrieval call binding the contract method 0x33aa955b.
//
// Solidity: function getLiquidity(bytes32 id, address owner, int24 tickLower, int24 tickUpper) view returns(uint128 liquidity)
func (_IPoolManager *IPoolManagerCallerSession) GetLiquidity(id [32]byte, owner common.Address, tickLower *big.Int, tickUpper *big.Int) (*big.Int, error) {
	return _IPoolManager.Contract.GetLiquidity(&_IPoolManager.CallOpts, id, owner, tickLower, tickUpper)
}

// GetLiquidity0 is a free data retrieval call binding the contract method 0xfa6793d5.
//
// Solidity: function getLiquidity(bytes32 id) view returns(uint128 liquidity)
func (_IPoolManager *IPoolManagerCaller) GetLiquidity0(opts *bind.CallOpts, id [32]byte) (*big.Int, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "getLiquidity0", id)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetLiquidity0 is a free data retrieval call binding the contract method 0xfa6793d5.
//
// Solidity: function getLiquidity(bytes32 id) view returns(uint128 liquidity)
func (_IPoolManager *IPoolManagerSession) GetLiquidity0(id [32]byte) (*big.Int, error) {
	return _IPoolManager.Contract.GetLiquidity0(&_IPoolManager.CallOpts, id)
}

// GetLiquidity0 is a free data retrieval call binding the contract method 0xfa6793d5.
//
// Solidity: function getLiquidity(bytes32 id) view returns(uint128 liquidity)
func (_IPoolManager *IPoolManagerCallerSession) GetLiquidity0(id [32]byte) (*big.Int, error) {
	return _IPoolManager.Contract.GetLiquidity0(&_IPoolManager.CallOpts, id)
}

// GetLock is a free data retrieval call binding the contract method 0xd68f4dd1.
//
// Solidity: function getLock(uint256 i) view returns(address locker)
func (_IPoolManager *IPoolManagerCaller) GetLock(opts *bind.CallOpts, i *big.Int) (common.Address, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "getLock", i)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetLock is a free data retrieval call binding the contract method 0xd68f4dd1.
//
// Solidity: function getLock(uint256 i) view returns(address locker)
func (_IPoolManager *IPoolManagerSession) GetLock(i *big.Int) (common.Address, error) {
	return _IPoolManager.Contract.GetLock(&_IPoolManager.CallOpts, i)
}

// GetLock is a free data retrieval call binding the contract method 0xd68f4dd1.
//
// Solidity: function getLock(uint256 i) view returns(address locker)
func (_IPoolManager *IPoolManagerCallerSession) GetLock(i *big.Int) (common.Address, error) {
	return _IPoolManager.Contract.GetLock(&_IPoolManager.CallOpts, i)
}

// GetPosition is a free data retrieval call binding the contract method 0x048d9c70.
//
// Solidity: function getPosition(bytes32 id, address owner, int24 tickLower, int24 tickUpper) view returns((uint128,uint256,uint256) position)
func (_IPoolManager *IPoolManagerCaller) GetPosition(opts *bind.CallOpts, id [32]byte, owner common.Address, tickLower *big.Int, tickUpper *big.Int) (PositionInfo, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "getPosition", id, owner, tickLower, tickUpper)

	if err != nil {
		return *new(PositionInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(PositionInfo)).(*PositionInfo)

	return out0, err

}

// GetPosition is a free data retrieval call binding the contract method 0x048d9c70.
//
// Solidity: function getPosition(bytes32 id, address owner, int24 tickLower, int24 tickUpper) view returns((uint128,uint256,uint256) position)
func (_IPoolManager *IPoolManagerSession) GetPosition(id [32]byte, owner common.Address, tickLower *big.Int, tickUpper *big.Int) (PositionInfo, error) {
	return _IPoolManager.Contract.GetPosition(&_IPoolManager.CallOpts, id, owner, tickLower, tickUpper)
}

// GetPosition is a free data retrieval call binding the contract method 0x048d9c70.
//
// Solidity: function getPosition(bytes32 id, address owner, int24 tickLower, int24 tickUpper) view returns((uint128,uint256,uint256) position)
func (_IPoolManager *IPoolManagerCallerSession) GetPosition(id [32]byte, owner common.Address, tickLower *big.Int, tickUpper *big.Int) (PositionInfo, error) {
	return _IPoolManager.Contract.GetPosition(&_IPoolManager.CallOpts, id, owner, tickLower, tickUpper)
}

// GetSlot0 is a free data retrieval call binding the contract method 0xc815641c.
//
// Solidity: function getSlot0(bytes32 id) view returns(uint160 sqrtPriceX96, int24 tick, uint24 protocolFees, uint24 hookFees)
func (_IPoolManager *IPoolManagerCaller) GetSlot0(opts *bind.CallOpts, id [32]byte) (struct {
	SqrtPriceX96 *big.Int
	Tick         *big.Int
	ProtocolFees *big.Int
	HookFees     *big.Int
}, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "getSlot0", id)

	outstruct := new(struct {
		SqrtPriceX96 *big.Int
		Tick         *big.Int
		ProtocolFees *big.Int
		HookFees     *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.SqrtPriceX96 = *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)
	outstruct.Tick = *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)
	outstruct.ProtocolFees = *abi.ConvertType(out[2], new(*big.Int)).(**big.Int)
	outstruct.HookFees = *abi.ConvertType(out[3], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// GetSlot0 is a free data retrieval call binding the contract method 0xc815641c.
//
// Solidity: function getSlot0(bytes32 id) view returns(uint160 sqrtPriceX96, int24 tick, uint24 protocolFees, uint24 hookFees)
func (_IPoolManager *IPoolManagerSession) GetSlot0(id [32]byte) (struct {
	SqrtPriceX96 *big.Int
	Tick         *big.Int
	ProtocolFees *big.Int
	HookFees     *big.Int
}, error) {
	return _IPoolManager.Contract.GetSlot0(&_IPoolManager.CallOpts, id)
}

// GetSlot0 is a free data retrieval call binding the contract method 0xc815641c.
//
// Solidity: function getSlot0(bytes32 id) view returns(uint160 sqrtPriceX96, int24 tick, uint24 protocolFees, uint24 hookFees)
func (_IPoolManager *IPoolManagerCallerSession) GetSlot0(id [32]byte) (struct {
	SqrtPriceX96 *big.Int
	Tick         *big.Int
	ProtocolFees *big.Int
	HookFees     *big.Int
}, error) {
	return _IPoolManager.Contract.GetSlot0(&_IPoolManager.CallOpts, id)
}

// HookFeesAccrued is a free data retrieval call binding the contract method 0xb4c41939.
//
// Solidity: function hookFeesAccrued(address , address ) view returns(uint256)
func (_IPoolManager *IPoolManagerCaller) HookFeesAccrued(opts *bind.CallOpts, arg0 common.Address, arg1 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "hookFeesAccrued", arg0, arg1)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// HookFeesAccrued is a free data retrieval call binding the contract method 0xb4c41939.
//
// Solidity: function hookFeesAccrued(address , address ) view returns(uint256)
func (_IPoolManager *IPoolManagerSession) HookFeesAccrued(arg0 common.Address, arg1 common.Address) (*big.Int, error) {
	return _IPoolManager.Contract.HookFeesAccrued(&_IPoolManager.CallOpts, arg0, arg1)
}

// HookFeesAccrued is a free data retrieval call binding the contract method 0xb4c41939.
//
// Solidity: function hookFeesAccrued(address , address ) view returns(uint256)
func (_IPoolManager *IPoolManagerCallerSession) HookFeesAccrued(arg0 common.Address, arg1 common.Address) (*big.Int, error) {
	return _IPoolManager.Contract.HookFeesAccrued(&_IPoolManager.CallOpts, arg0, arg1)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address account, address operator) view returns(bool)
func (_IPoolManager *IPoolManagerCaller) IsApprovedForAll(opts *bind.CallOpts, account common.Address, operator common.Address) (bool, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "isApprovedForAll", account, operator)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address account, address operator) view returns(bool)
func (_IPoolManager *IPoolManagerSession) IsApprovedForAll(account common.Address, operator common.Address) (bool, error) {
	return _IPoolManager.Contract.IsApprovedForAll(&_IPoolManager.CallOpts, account, operator)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address account, address operator) view returns(bool)
func (_IPoolManager *IPoolManagerCallerSession) IsApprovedForAll(account common.Address, operator common.Address) (bool, error) {
	return _IPoolManager.Contract.IsApprovedForAll(&_IPoolManager.CallOpts, account, operator)
}

// LockData is a free data retrieval call binding the contract method 0xf8fcd156.
//
// Solidity: function lockData() view returns(uint128 length, uint128 nonzeroDeltaCount)
func (_IPoolManager *IPoolManagerCaller) LockData(opts *bind.CallOpts) (struct {
	Length            *big.Int
	NonzeroDeltaCount *big.Int
}, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "lockData")

	outstruct := new(struct {
		Length            *big.Int
		NonzeroDeltaCount *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Length = *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)
	outstruct.NonzeroDeltaCount = *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// LockData is a free data retrieval call binding the contract method 0xf8fcd156.
//
// Solidity: function lockData() view returns(uint128 length, uint128 nonzeroDeltaCount)
func (_IPoolManager *IPoolManagerSession) LockData() (struct {
	Length            *big.Int
	NonzeroDeltaCount *big.Int
}, error) {
	return _IPoolManager.Contract.LockData(&_IPoolManager.CallOpts)
}

// LockData is a free data retrieval call binding the contract method 0xf8fcd156.
//
// Solidity: function lockData() view returns(uint128 length, uint128 nonzeroDeltaCount)
func (_IPoolManager *IPoolManagerCallerSession) LockData() (struct {
	Length            *big.Int
	NonzeroDeltaCount *big.Int
}, error) {
	return _IPoolManager.Contract.LockData(&_IPoolManager.CallOpts)
}

// ProtocolFeesAccrued is a free data retrieval call binding the contract method 0x97e8cd4e.
//
// Solidity: function protocolFeesAccrued(address ) view returns(uint256)
func (_IPoolManager *IPoolManagerCaller) ProtocolFeesAccrued(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "protocolFeesAccrued", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// ProtocolFeesAccrued is a free data retrieval call binding the contract method 0x97e8cd4e.
//
// Solidity: function protocolFeesAccrued(address ) view returns(uint256)
func (_IPoolManager *IPoolManagerSession) ProtocolFeesAccrued(arg0 common.Address) (*big.Int, error) {
	return _IPoolManager.Contract.ProtocolFeesAccrued(&_IPoolManager.CallOpts, arg0)
}

// ProtocolFeesAccrued is a free data retrieval call binding the contract method 0x97e8cd4e.
//
// Solidity: function protocolFeesAccrued(address ) view returns(uint256)
func (_IPoolManager *IPoolManagerCallerSession) ProtocolFeesAccrued(arg0 common.Address) (*big.Int, error) {
	return _IPoolManager.Contract.ProtocolFeesAccrued(&_IPoolManager.CallOpts, arg0)
}

// ReservesOf is a free data retrieval call binding the contract method 0x93c85a21.
//
// Solidity: function reservesOf(address currency) view returns(uint256)
func (_IPoolManager *IPoolManagerCaller) ReservesOf(opts *bind.CallOpts, currency common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "reservesOf", currency)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// ReservesOf is a free data retrieval call binding the contract method 0x93c85a21.
//
// Solidity: function reservesOf(address currency) view returns(uint256)
func (_IPoolManager *IPoolManagerSession) ReservesOf(currency common.Address) (*big.Int, error) {
	return _IPoolManager.Contract.ReservesOf(&_IPoolManager.CallOpts, currency)
}

// ReservesOf is a free data retrieval call binding the contract method 0x93c85a21.
//
// Solidity: function reservesOf(address currency) view returns(uint256)
func (_IPoolManager *IPoolManagerCallerSession) ReservesOf(currency common.Address) (*big.Int, error) {
	return _IPoolManager.Contract.ReservesOf(&_IPoolManager.CallOpts, currency)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IPoolManager *IPoolManagerCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _IPoolManager.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IPoolManager *IPoolManagerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _IPoolManager.Contract.SupportsInterface(&_IPoolManager.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IPoolManager *IPoolManagerCallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _IPoolManager.Contract.SupportsInterface(&_IPoolManager.CallOpts, interfaceId)
}

// Donate is a paid mutator transaction binding the contract method 0x234266d7.
//
// Solidity: function donate((address,address,uint24,int24,address) key, uint256 amount0, uint256 amount1, bytes hookData) returns(int256)
func (_IPoolManager *IPoolManagerTransactor) Donate(opts *bind.TransactOpts, key PoolKey, amount0 *big.Int, amount1 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IPoolManager.contract.Transact(opts, "donate", key, amount0, amount1, hookData)
}

// Donate is a paid mutator transaction binding the contract method 0x234266d7.
//
// Solidity: function donate((address,address,uint24,int24,address) key, uint256 amount0, uint256 amount1, bytes hookData) returns(int256)
func (_IPoolManager *IPoolManagerSession) Donate(key PoolKey, amount0 *big.Int, amount1 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IPoolManager.Contract.Donate(&_IPoolManager.TransactOpts, key, amount0, amount1, hookData)
}

// Donate is a paid mutator transaction binding the contract method 0x234266d7.
//
// Solidity: function donate((address,address,uint24,int24,address) key, uint256 amount0, uint256 amount1, bytes hookData) returns(int256)
func (_IPoolManager *IPoolManagerTransactorSession) Donate(key PoolKey, amount0 *big.Int, amount1 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IPoolManager.Contract.Donate(&_IPoolManager.TransactOpts, key, amount0, amount1, hookData)
}

// Initialize is a paid mutator transaction binding the contract method 0x695c5bf5.
//
// Solidity: function initialize((address,address,uint24,int24,address) key, uint160 sqrtPriceX96, bytes hookData) returns(int24 tick)
func (_IPoolManager *IPoolManagerTransactor) Initialize(opts *bind.TransactOpts, key PoolKey, sqrtPriceX96 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IPoolManager.contract.Transact(opts, "initialize", key, sqrtPriceX96, hookData)
}

// Initialize is a paid mutator transaction binding the contract method 0x695c5bf5.
//
// Solidity: function initialize((address,address,uint24,int24,address) key, uint160 sqrtPriceX96, bytes hookData) returns(int24 tick)
func (_IPoolManager *IPoolManagerSession) Initialize(key PoolKey, sqrtPriceX96 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IPoolManager.Contract.Initialize(&_IPoolManager.TransactOpts, key, sqrtPriceX96, hookData)
}

// Initialize is a paid mutator transaction binding the contract method 0x695c5bf5.
//
// Solidity: function initialize((address,address,uint24,int24,address) key, uint160 sqrtPriceX96, bytes hookData) returns(int24 tick)
func (_IPoolManager *IPoolManagerTransactorSession) Initialize(key PoolKey, sqrtPriceX96 *big.Int, hookData []byte) (*types.Transaction, error) {
	return _IPoolManager.Contract.Initialize(&_IPoolManager.TransactOpts, key, sqrtPriceX96, hookData)
}

// Lock is a paid mutator transaction binding the contract method 0x81548319.
//
// Solidity: function lock(bytes data) returns(bytes)
func (_IPoolManager *IPoolManagerTransactor) Lock(opts *bind.TransactOpts, data []byte) (*types.Transaction, error) {
	return _IPoolManager.contract.Transact(opts, "lock", data)
}

// Lock is a paid mutator transaction binding the contract method 0x81548319.
//
// Solidity: function lock(bytes data) returns(bytes)
func (_IPoolManager *IPoolManagerSession) Lock(data []byte) (*types.Transaction, error) {
	return _IPoolManager.Contract.Lock(&_IPoolManager.TransactOpts, data)
}

// Lock is a paid mutator transaction binding the contract method 0x81548319.
//
// Solidity: function lock(bytes data) returns(bytes)
func (_IPoolManager *IPoolManagerTransactorSession) Lock(data []byte) (*types.Transaction, error) {
	return _IPoolManager.Contract.Lock(&_IPoolManager.TransactOpts, data)
}

// Mint is a paid mutator transaction binding the contract method 0xc6c3bbe6.
//
// Solidity: function mint(address token, address to, uint256 amount) returns()
func (_IPoolManager *IPoolManagerTransactor) Mint(opts *bind.TransactOpts, token common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IPoolManager.contract.Transact(opts, "mint", token, to, amount)
}

// Mint is a paid mutator transaction binding the contract method 0xc6c3bbe6.
//
// Solidity: function mint(address token, address to, uint256 amount) returns()
func (_IPoolManager *IPoolManagerSession) Mint(token common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IPoolManager.Contract.Mint(&_IPoolManager.TransactOpts, token, to, amount)
}

// Mint is a paid mutator transaction binding the contract method 0xc6c3bbe6.
//
// Solidity: function mint(address token, address to, uint256 amount) returns()
func (_IPoolManager *IPoolManagerTransactorSession) Mint(token common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IPoolManager.Contract.Mint(&_IPoolManager.TransactOpts, token, to, amount)
}

// ModifyPosition is a paid mutator transaction binding the contract method 0x61ae449a.
//
// Solidity: function modifyPosition((address,address,uint24,int24,address) key, (int24,int24,int256) params, bytes hookData) returns(int256)
func (_IPoolManager *IPoolManagerTransactor) ModifyPosition(opts *bind.TransactOpts, key PoolKey, params IPoolManagerModifyPositionParams, hookData []byte) (*types.Transaction, error) {
	return _IPoolManager.contract.Transact(opts, "modifyPosition", key, params, hookData)
}

// ModifyPosition is a paid mutator transaction binding the contract method 0x61ae449a.
//
// Solidity: function modifyPosition((address,address,uint24,int24,address) key, (int24,int24,int256) params, bytes hookData) returns(int256)
func (_IPoolManager *IPoolManagerSession) ModifyPosition(key PoolKey, params IPoolManagerModifyPositionParams, hookData []byte) (*types.Transaction, error) {
	return _IPoolManager.Contract.ModifyPosition(&_IPoolManager.TransactOpts, key, params, hookData)
}

// ModifyPosition is a paid mutator transaction binding the contract method 0x61ae449a.
//
// Solidity: function modifyPosition((address,address,uint24,int24,address) key, (int24,int24,int256) params, bytes hookData) returns(int256)
func (_IPoolManager *IPoolManagerTransactorSession) ModifyPosition(key PoolKey, params IPoolManagerModifyPositionParams, hookData []byte) (*types.Transaction, error) {
	return _IPoolManager.Contract.ModifyPosition(&_IPoolManager.TransactOpts, key, params, hookData)
}

// SafeBatchTransferFrom is a paid mutator transaction binding the contract method 0x2eb2c2d6.
//
// Solidity: function safeBatchTransferFrom(address from, address to, uint256[] ids, uint256[] amounts, bytes data) returns()
func (_IPoolManager *IPoolManagerTransactor) SafeBatchTransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, ids []*big.Int, amounts []*big.Int, data []byte) (*types.Transaction, error) {
	return _IPoolManager.contract.Transact(opts, "safeBatchTransferFrom", from, to, ids, amounts, data)
}

// SafeBatchTransferFrom is a paid mutator transaction binding the contract method 0x2eb2c2d6.
//
// Solidity: function safeBatchTransferFrom(address from, address to, uint256[] ids, uint256[] amounts, bytes data) returns()
func (_IPoolManager *IPoolManagerSession) SafeBatchTransferFrom(from common.Address, to common.Address, ids []*big.Int, amounts []*big.Int, data []byte) (*types.Transaction, error) {
	return _IPoolManager.Contract.SafeBatchTransferFrom(&_IPoolManager.TransactOpts, from, to, ids, amounts, data)
}

// SafeBatchTransferFrom is a paid mutator transaction binding the contract method 0x2eb2c2d6.
//
// Solidity: function safeBatchTransferFrom(address from, address to, uint256[] ids, uint256[] amounts, bytes data) returns()
func (_IPoolManager *IPoolManagerTransactorSession) SafeBatchTransferFrom(from common.Address, to common.Address, ids []*big.Int, amounts []*big.Int, data []byte) (*types.Transaction, error) {
	return _IPoolManager.Contract.SafeBatchTransferFrom(&_IPoolManager.TransactOpts, from, to, ids, amounts, data)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0xf242432a.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes data) returns()
func (_IPoolManager *IPoolManagerTransactor) SafeTransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, id *big.Int, amount *big.Int, data []byte) (*types.Transaction, error) {
	return _IPoolManager.contract.Transact(opts, "safeTransferFrom", from, to, id, amount, data)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0xf242432a.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes data) returns()
func (_IPoolManager *IPoolManagerSession) SafeTransferFrom(from common.Address, to common.Address, id *big.Int, amount *big.Int, data []byte) (*types.Transaction, error) {
	return _IPoolManager.Contract.SafeTransferFrom(&_IPoolManager.TransactOpts, from, to, id, amount, data)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0xf242432a.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes data) returns()
func (_IPoolManager *IPoolManagerTransactorSession) SafeTransferFrom(from common.Address, to common.Address, id *big.Int, amount *big.Int, data []byte) (*types.Transaction, error) {
	return _IPoolManager.Contract.SafeTransferFrom(&_IPoolManager.TransactOpts, from, to, id, amount, data)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_IPoolManager *IPoolManagerTransactor) SetApprovalForAll(opts *bind.TransactOpts, operator common.Address, approved bool) (*types.Transaction, error) {
	return _IPoolManager.contract.Transact(opts, "setApprovalForAll", operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_IPoolManager *IPoolManagerSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _IPoolManager.Contract.SetApprovalForAll(&_IPoolManager.TransactOpts, operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_IPoolManager *IPoolManagerTransactorSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _IPoolManager.Contract.SetApprovalForAll(&_IPoolManager.TransactOpts, operator, approved)
}

// SetHookFees is a paid mutator transaction binding the contract method 0xaf440f82.
//
// Solidity: function setHookFees((address,address,uint24,int24,address) key) returns()
func (_IPoolManager *IPoolManagerTransactor) SetHookFees(opts *bind.TransactOpts, key PoolKey) (*types.Transaction, error) {
	return _IPoolManager.contract.Transact(opts, "setHookFees", key)
}

// SetHookFees is a paid mutator transaction binding the contract method 0xaf440f82.
//
// Solidity: function setHookFees((address,address,uint24,int24,address) key) returns()
func (_IPoolManager *IPoolManagerSession) SetHookFees(key PoolKey) (*types.Transaction, error) {
	return _IPoolManager.Contract.SetHookFees(&_IPoolManager.TransactOpts, key)
}

// SetHookFees is a paid mutator transaction binding the contract method 0xaf440f82.
//
// Solidity: function setHookFees((address,address,uint24,int24,address) key) returns()
func (_IPoolManager *IPoolManagerTransactorSession) SetHookFees(key PoolKey) (*types.Transaction, error) {
	return _IPoolManager.Contract.SetHookFees(&_IPoolManager.TransactOpts, key)
}

// SetProtocolFees is a paid mutator transaction binding the contract method 0x282076cc.
//
// Solidity: function setProtocolFees((address,address,uint24,int24,address) key) returns()
func (_IPoolManager *IPoolManagerTransactor) SetProtocolFees(opts *bind.TransactOpts, key PoolKey) (*types.Transaction, error) {
	return _IPoolManager.contract.Transact(opts, "setProtocolFees", key)
}

// SetProtocolFees is a paid mutator transaction binding the contract method 0x282076cc.
//
// Solidity: function setProtocolFees((address,address,uint24,int24,address) key) returns()
func (_IPoolManager *IPoolManagerSession) SetProtocolFees(key PoolKey) (*types.Transaction, error) {
	return _IPoolManager.Contract.SetProtocolFees(&_IPoolManager.TransactOpts, key)
}

// SetProtocolFees is a paid mutator transaction binding the contract method 0x282076cc.
//
// Solidity: function setProtocolFees((address,address,uint24,int24,address) key) returns()
func (_IPoolManager *IPoolManagerTransactorSession) SetProtocolFees(key PoolKey) (*types.Transaction, error) {
	return _IPoolManager.Contract.SetProtocolFees(&_IPoolManager.TransactOpts, key)
}

// Settle is a paid mutator transaction binding the contract method 0x6a256b29.
//
// Solidity: function settle(address token) payable returns(uint256 paid)
func (_IPoolManager *IPoolManagerTransactor) Settle(opts *bind.TransactOpts, token common.Address) (*types.Transaction, error) {
	return _IPoolManager.contract.Transact(opts, "settle", token)
}

// Settle is a paid mutator transaction binding the contract method 0x6a256b29.
//
// Solidity: function settle(address token) payable returns(uint256 paid)
func (_IPoolManager *IPoolManagerSession) Settle(token common.Address) (*types.Transaction, error) {
	return _IPoolManager.Contract.Settle(&_IPoolManager.TransactOpts, token)
}

// Settle is a paid mutator transaction binding the contract method 0x6a256b29.
//
// Solidity: function settle(address token) payable returns(uint256 paid)
func (_IPoolManager *IPoolManagerTransactorSession) Settle(token common.Address) (*types.Transaction, error) {
	return _IPoolManager.Contract.Settle(&_IPoolManager.TransactOpts, token)
}

// Swap is a paid mutator transaction binding the contract method 0xf3cd914c.
//
// Solidity: function swap((address,address,uint24,int24,address) key, (bool,int256,uint160) params, bytes hookData) returns(int256)
func (_IPoolManager *IPoolManagerTransactor) Swap(opts *bind.TransactOpts, key PoolKey, params IPoolManagerSwapParams, hookData []byte) (*types.Transaction, error) {
	return _IPoolManager.contract.Transact(opts, "swap", key, params, hookData)
}

// Swap is a paid mutator transaction binding the contract method 0xf3cd914c.
//
// Solidity: function swap((address,address,uint24,int24,address) key, (bool,int256,uint160) params, bytes hookData) returns(int256)
func (_IPoolManager *IPoolManagerSession) Swap(key PoolKey, params IPoolManagerSwapParams, hookData []byte) (*types.Transaction, error) {
	return _IPoolManager.Contract.Swap(&_IPoolManager.TransactOpts, key, params, hookData)
}

// Swap is a paid mutator transaction binding the contract method 0xf3cd914c.
//
// Solidity: function swap((address,address,uint24,int24,address) key, (bool,int256,uint160) params, bytes hookData) returns(int256)
func (_IPoolManager *IPoolManagerTransactorSession) Swap(key PoolKey, params IPoolManagerSwapParams, hookData []byte) (*types.Transaction, error) {
	return _IPoolManager.Contract.Swap(&_IPoolManager.TransactOpts, key, params, hookData)
}

// Take is a paid mutator transaction binding the contract method 0x0b0d9c09.
//
// Solidity: function take(address currency, address to, uint256 amount) returns()
func (_IPoolManager *IPoolManagerTransactor) Take(opts *bind.TransactOpts, currency common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IPoolManager.contract.Transact(opts, "take", currency, to, amount)
}

// Take is a paid mutator transaction binding the contract method 0x0b0d9c09.
//
// Solidity: function take(address currency, address to, uint256 amount) returns()
func (_IPoolManager *IPoolManagerSession) Take(currency common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IPoolManager.Contract.Take(&_IPoolManager.TransactOpts, currency, to, amount)
}

// Take is a paid mutator transaction binding the contract method 0x0b0d9c09.
//
// Solidity: function take(address currency, address to, uint256 amount) returns()
func (_IPoolManager *IPoolManagerTransactorSession) Take(currency common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IPoolManager.Contract.Take(&_IPoolManager.TransactOpts, currency, to, amount)
}

// IPoolManagerApprovalForAllIterator is returned from FilterApprovalForAll and is used to iterate over the raw logs and unpacked data for ApprovalForAll events raised by the IPoolManager contract.
type IPoolManagerApprovalForAllIterator struct {
	Event *IPoolManagerApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPoolManagerApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPoolManagerApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPoolManagerApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPoolManagerApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPoolManagerApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPoolManagerApprovalForAll represents a ApprovalForAll event raised by the IPoolManager contract.
type IPoolManagerApprovalForAll struct {
	Account  common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApprovalForAll is a free log retrieval operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed account, address indexed operator, bool approved)
func (_IPoolManager *IPoolManagerFilterer) FilterApprovalForAll(opts *bind.FilterOpts, account []common.Address, operator []common.Address) (*IPoolManagerApprovalForAllIterator, error) {

	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _IPoolManager.contract.FilterLogs(opts, "ApprovalForAll", accountRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return &IPoolManagerApprovalForAllIterator{contract: _IPoolManager.contract, event: "ApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchApprovalForAll is a free log subscription operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed account, address indexed operator, bool approved)
func (_IPoolManager *IPoolManagerFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *IPoolManagerApprovalForAll, account []common.Address, operator []common.Address) (event.Subscription, error) {

	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _IPoolManager.contract.WatchLogs(opts, "ApprovalForAll", accountRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPoolManagerApprovalForAll)
				if err := _IPoolManager.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApprovalForAll is a log parse operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed account, address indexed operator, bool approved)
func (_IPoolManager *IPoolManagerFilterer) ParseApprovalForAll(log types.Log) (*IPoolManagerApprovalForAll, error) {
	event := new(IPoolManagerApprovalForAll)
	if err := _IPoolManager.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPoolManagerHookFeeUpdatedIterator is returned from FilterHookFeeUpdated and is used to iterate over the raw logs and unpacked data for HookFeeUpdated events raised by the IPoolManager contract.
type IPoolManagerHookFeeUpdatedIterator struct {
	Event *IPoolManagerHookFeeUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPoolManagerHookFeeUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPoolManagerHookFeeUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPoolManagerHookFeeUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPoolManagerHookFeeUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPoolManagerHookFeeUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPoolManagerHookFeeUpdated represents a HookFeeUpdated event raised by the IPoolManager contract.
type IPoolManagerHookFeeUpdated struct {
	Id       [32]byte
	HookFees *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterHookFeeUpdated is a free log retrieval operation binding the contract event 0xc939c5b4f4e3398eb275de825cd913cca3ade8d1f42daa0ffe1d88accd407158.
//
// Solidity: event HookFeeUpdated(bytes32 indexed id, uint24 hookFees)
func (_IPoolManager *IPoolManagerFilterer) FilterHookFeeUpdated(opts *bind.FilterOpts, id [][32]byte) (*IPoolManagerHookFeeUpdatedIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _IPoolManager.contract.FilterLogs(opts, "HookFeeUpdated", idRule)
	if err != nil {
		return nil, err
	}
	return &IPoolManagerHookFeeUpdatedIterator{contract: _IPoolManager.contract, event: "HookFeeUpdated", logs: logs, sub: sub}, nil
}

// WatchHookFeeUpdated is a free log subscription operation binding the contract event 0xc939c5b4f4e3398eb275de825cd913cca3ade8d1f42daa0ffe1d88accd407158.
//
// Solidity: event HookFeeUpdated(bytes32 indexed id, uint24 hookFees)
func (_IPoolManager *IPoolManagerFilterer) WatchHookFeeUpdated(opts *bind.WatchOpts, sink chan<- *IPoolManagerHookFeeUpdated, id [][32]byte) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _IPoolManager.contract.WatchLogs(opts, "HookFeeUpdated", idRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPoolManagerHookFeeUpdated)
				if err := _IPoolManager.contract.UnpackLog(event, "HookFeeUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseHookFeeUpdated is a log parse operation binding the contract event 0xc939c5b4f4e3398eb275de825cd913cca3ade8d1f42daa0ffe1d88accd407158.
//
// Solidity: event HookFeeUpdated(bytes32 indexed id, uint24 hookFees)
func (_IPoolManager *IPoolManagerFilterer) ParseHookFeeUpdated(log types.Log) (*IPoolManagerHookFeeUpdated, error) {
	event := new(IPoolManagerHookFeeUpdated)
	if err := _IPoolManager.contract.UnpackLog(event, "HookFeeUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPoolManagerInitializeIterator is returned from FilterInitialize and is used to iterate over the raw logs and unpacked data for Initialize events raised by the IPoolManager contract.
type IPoolManagerInitializeIterator struct {
	Event *IPoolManagerInitialize // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPoolManagerInitializeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPoolManagerInitialize)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPoolManagerInitialize)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPoolManagerInitializeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPoolManagerInitializeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPoolManagerInitialize represents a Initialize event raised by the IPoolManager contract.
type IPoolManagerInitialize struct {
	Id          [32]byte
	Currency0   common.Address
	Currency1   common.Address
	Fee         *big.Int
	TickSpacing *big.Int
	Hooks       common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterInitialize is a free log retrieval operation binding the contract event 0x3fd553db44f207b1f41348cfc4d251860814af9eadc470e8e7895e4d120511f4.
//
// Solidity: event Initialize(bytes32 indexed id, address indexed currency0, address indexed currency1, uint24 fee, int24 tickSpacing, address hooks)
func (_IPoolManager *IPoolManagerFilterer) FilterInitialize(opts *bind.FilterOpts, id [][32]byte, currency0 []common.Address, currency1 []common.Address) (*IPoolManagerInitializeIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}
	var currency0Rule []interface{}
	for _, currency0Item := range currency0 {
		currency0Rule = append(currency0Rule, currency0Item)
	}
	var currency1Rule []interface{}
	for _, currency1Item := range currency1 {
		currency1Rule = append(currency1Rule, currency1Item)
	}

	logs, sub, err := _IPoolManager.contract.FilterLogs(opts, "Initialize", idRule, currency0Rule, currency1Rule)
	if err != nil {
		return nil, err
	}
	return &IPoolManagerInitializeIterator{contract: _IPoolManager.contract, event: "Initialize", logs: logs, sub: sub}, nil
}

// WatchInitialize is a free log subscription operation binding the contract event 0x3fd553db44f207b1f41348cfc4d251860814af9eadc470e8e7895e4d120511f4.
//
// Solidity: event Initialize(bytes32 indexed id, address indexed currency0, address indexed currency1, uint24 fee, int24 tickSpacing, address hooks)
func (_IPoolManager *IPoolManagerFilterer) WatchInitialize(opts *bind.WatchOpts, sink chan<- *IPoolManagerInitialize, id [][32]byte, currency0 []common.Address, currency1 []common.Address) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}
	var currency0Rule []interface{}
	for _, currency0Item := range currency0 {
		currency0Rule = append(currency0Rule, currency0Item)
	}
	var currency1Rule []interface{}
	for _, currency1Item := range currency1 {
		currency1Rule = append(currency1Rule, currency1Item)
	}

	logs, sub, err := _IPoolManager.contract.WatchLogs(opts, "Initialize", idRule, currency0Rule, currency1Rule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPoolManagerInitialize)
				if err := _IPoolManager.contract.UnpackLog(event, "Initialize", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInitialize is a log parse operation binding the contract event 0x3fd553db44f207b1f41348cfc4d251860814af9eadc470e8e7895e4d120511f4.
//
// Solidity: event Initialize(bytes32 indexed id, address indexed currency0, address indexed currency1, uint24 fee, int24 tickSpacing, address hooks)
func (_IPoolManager *IPoolManagerFilterer) ParseInitialize(log types.Log) (*IPoolManagerInitialize, error) {
	event := new(IPoolManagerInitialize)
	if err := _IPoolManager.contract.UnpackLog(event, "Initialize", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPoolManagerModifyPositionIterator is returned from FilterModifyPosition and is used to iterate over the raw logs and unpacked data for ModifyPosition events raised by the IPoolManager contract.
type IPoolManagerModifyPositionIterator struct {
	Event *IPoolManagerModifyPosition // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPoolManagerModifyPositionIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPoolManagerModifyPosition)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPoolManagerModifyPosition)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPoolManagerModifyPositionIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPoolManagerModifyPositionIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPoolManagerModifyPosition represents a ModifyPosition event raised by the IPoolManager contract.
type IPoolManagerModifyPosition struct {
	Id             [32]byte
	Sender         common.Address
	TickLower      *big.Int
	TickUpper      *big.Int
	LiquidityDelta *big.Int
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterModifyPosition is a free log retrieval operation binding the contract event 0xc54f65a0367b92850ef8e90f7e302da8b0a137ab343132a9b8d0e63e684bf53c.
//
// Solidity: event ModifyPosition(bytes32 indexed id, address indexed sender, int24 tickLower, int24 tickUpper, int256 liquidityDelta)
func (_IPoolManager *IPoolManagerFilterer) FilterModifyPosition(opts *bind.FilterOpts, id [][32]byte, sender []common.Address) (*IPoolManagerModifyPositionIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IPoolManager.contract.FilterLogs(opts, "ModifyPosition", idRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &IPoolManagerModifyPositionIterator{contract: _IPoolManager.contract, event: "ModifyPosition", logs: logs, sub: sub}, nil
}

// WatchModifyPosition is a free log subscription operation binding the contract event 0xc54f65a0367b92850ef8e90f7e302da8b0a137ab343132a9b8d0e63e684bf53c.
//
// Solidity: event ModifyPosition(bytes32 indexed id, address indexed sender, int24 tickLower, int24 tickUpper, int256 liquidityDelta)
func (_IPoolManager *IPoolManagerFilterer) WatchModifyPosition(opts *bind.WatchOpts, sink chan<- *IPoolManagerModifyPosition, id [][32]byte, sender []common.Address) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IPoolManager.contract.WatchLogs(opts, "ModifyPosition", idRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPoolManagerModifyPosition)
				if err := _IPoolManager.contract.UnpackLog(event, "ModifyPosition", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseModifyPosition is a log parse operation binding the contract event 0xc54f65a0367b92850ef8e90f7e302da8b0a137ab343132a9b8d0e63e684bf53c.
//
// Solidity: event ModifyPosition(bytes32 indexed id, address indexed sender, int24 tickLower, int24 tickUpper, int256 liquidityDelta)
func (_IPoolManager *IPoolManagerFilterer) ParseModifyPosition(log types.Log) (*IPoolManagerModifyPosition, error) {
	event := new(IPoolManagerModifyPosition)
	if err := _IPoolManager.contract.UnpackLog(event, "ModifyPosition", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPoolManagerProtocolFeeControllerUpdatedIterator is returned from FilterProtocolFeeControllerUpdated and is used to iterate over the raw logs and unpacked data for ProtocolFeeControllerUpdated events raised by the IPoolManager contract.
type IPoolManagerProtocolFeeControllerUpdatedIterator struct {
	Event *IPoolManagerProtocolFeeControllerUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPoolManagerProtocolFeeControllerUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPoolManagerProtocolFeeControllerUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPoolManagerProtocolFeeControllerUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPoolManagerProtocolFeeControllerUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPoolManagerProtocolFeeControllerUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPoolManagerProtocolFeeControllerUpdated represents a ProtocolFeeControllerUpdated event raised by the IPoolManager contract.
type IPoolManagerProtocolFeeControllerUpdated struct {
	ProtocolFeeController common.Address
	Raw                   types.Log // Blockchain specific contextual infos
}

// FilterProtocolFeeControllerUpdated is a free log retrieval operation binding the contract event 0xb4bd8ef53df690b9943d3318996006dbb82a25f54719d8c8035b516a2a5b8acc.
//
// Solidity: event ProtocolFeeControllerUpdated(address protocolFeeController)
func (_IPoolManager *IPoolManagerFilterer) FilterProtocolFeeControllerUpdated(opts *bind.FilterOpts) (*IPoolManagerProtocolFeeControllerUpdatedIterator, error) {

	logs, sub, err := _IPoolManager.contract.FilterLogs(opts, "ProtocolFeeControllerUpdated")
	if err != nil {
		return nil, err
	}
	return &IPoolManagerProtocolFeeControllerUpdatedIterator{contract: _IPoolManager.contract, event: "ProtocolFeeControllerUpdated", logs: logs, sub: sub}, nil
}

// WatchProtocolFeeControllerUpdated is a free log subscription operation binding the contract event 0xb4bd8ef53df690b9943d3318996006dbb82a25f54719d8c8035b516a2a5b8acc.
//
// Solidity: event ProtocolFeeControllerUpdated(address protocolFeeController)
func (_IPoolManager *IPoolManagerFilterer) WatchProtocolFeeControllerUpdated(opts *bind.WatchOpts, sink chan<- *IPoolManagerProtocolFeeControllerUpdated) (event.Subscription, error) {

	logs, sub, err := _IPoolManager.contract.WatchLogs(opts, "ProtocolFeeControllerUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPoolManagerProtocolFeeControllerUpdated)
				if err := _IPoolManager.contract.UnpackLog(event, "ProtocolFeeControllerUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProtocolFeeControllerUpdated is a log parse operation binding the contract event 0xb4bd8ef53df690b9943d3318996006dbb82a25f54719d8c8035b516a2a5b8acc.
//
// Solidity: event ProtocolFeeControllerUpdated(address protocolFeeController)
func (_IPoolManager *IPoolManagerFilterer) ParseProtocolFeeControllerUpdated(log types.Log) (*IPoolManagerProtocolFeeControllerUpdated, error) {
	event := new(IPoolManagerProtocolFeeControllerUpdated)
	if err := _IPoolManager.contract.UnpackLog(event, "ProtocolFeeControllerUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPoolManagerProtocolFeeUpdatedIterator is returned from FilterProtocolFeeUpdated and is used to iterate over the raw logs and unpacked data for ProtocolFeeUpdated events raised by the IPoolManager contract.
type IPoolManagerProtocolFeeUpdatedIterator struct {
	Event *IPoolManagerProtocolFeeUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPoolManagerProtocolFeeUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPoolManagerProtocolFeeUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPoolManagerProtocolFeeUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPoolManagerProtocolFeeUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPoolManagerProtocolFeeUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPoolManagerProtocolFeeUpdated represents a ProtocolFeeUpdated event raised by the IPoolManager contract.
type IPoolManagerProtocolFeeUpdated struct {
	Id           [32]byte
	ProtocolFees *big.Int
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterProtocolFeeUpdated is a free log retrieval operation binding the contract event 0xe9c42593e71f84403b84352cd168d693e2c9fcd1fdbcc3feb21d92b43e6696f9.
//
// Solidity: event ProtocolFeeUpdated(bytes32 indexed id, uint24 protocolFees)
func (_IPoolManager *IPoolManagerFilterer) FilterProtocolFeeUpdated(opts *bind.FilterOpts, id [][32]byte) (*IPoolManagerProtocolFeeUpdatedIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _IPoolManager.contract.FilterLogs(opts, "ProtocolFeeUpdated", idRule)
	if err != nil {
		return nil, err
	}
	return &IPoolManagerProtocolFeeUpdatedIterator{contract: _IPoolManager.contract, event: "ProtocolFeeUpdated", logs: logs, sub: sub}, nil
}

// WatchProtocolFeeUpdated is a free log subscription operation binding the contract event 0xe9c42593e71f84403b84352cd168d693e2c9fcd1fdbcc3feb21d92b43e6696f9.
//
// Solidity: event ProtocolFeeUpdated(bytes32 indexed id, uint24 protocolFees)
func (_IPoolManager *IPoolManagerFilterer) WatchProtocolFeeUpdated(opts *bind.WatchOpts, sink chan<- *IPoolManagerProtocolFeeUpdated, id [][32]byte) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _IPoolManager.contract.WatchLogs(opts, "ProtocolFeeUpdated", idRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPoolManagerProtocolFeeUpdated)
				if err := _IPoolManager.contract.UnpackLog(event, "ProtocolFeeUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProtocolFeeUpdated is a log parse operation binding the contract event 0xe9c42593e71f84403b84352cd168d693e2c9fcd1fdbcc3feb21d92b43e6696f9.
//
// Solidity: event ProtocolFeeUpdated(bytes32 indexed id, uint24 protocolFees)
func (_IPoolManager *IPoolManagerFilterer) ParseProtocolFeeUpdated(log types.Log) (*IPoolManagerProtocolFeeUpdated, error) {
	event := new(IPoolManagerProtocolFeeUpdated)
	if err := _IPoolManager.contract.UnpackLog(event, "ProtocolFeeUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPoolManagerSwapIterator is returned from FilterSwap and is used to iterate over the raw logs and unpacked data for Swap events raised by the IPoolManager contract.
type IPoolManagerSwapIterator struct {
	Event *IPoolManagerSwap // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPoolManagerSwapIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPoolManagerSwap)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPoolManagerSwap)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPoolManagerSwapIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPoolManagerSwapIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPoolManagerSwap represents a Swap event raised by the IPoolManager contract.
type IPoolManagerSwap struct {
	Id           [32]byte
	Sender       common.Address
	Amount0      *big.Int
	Amount1      *big.Int
	SqrtPriceX96 *big.Int
	Liquidity    *big.Int
	Tick         *big.Int
	Fee          *big.Int
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterSwap is a free log retrieval operation binding the contract event 0x40e9cecb9f5f1f1c5b9c97dec2917b7ee92e57ba5563708daca94dd84ad7112f.
//
// Solidity: event Swap(bytes32 indexed id, address indexed sender, int128 amount0, int128 amount1, uint160 sqrtPriceX96, uint128 liquidity, int24 tick, uint24 fee)
func (_IPoolManager *IPoolManagerFilterer) FilterSwap(opts *bind.FilterOpts, id [][32]byte, sender []common.Address) (*IPoolManagerSwapIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IPoolManager.contract.FilterLogs(opts, "Swap", idRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &IPoolManagerSwapIterator{contract: _IPoolManager.contract, event: "Swap", logs: logs, sub: sub}, nil
}

// WatchSwap is a free log subscription operation binding the contract event 0x40e9cecb9f5f1f1c5b9c97dec2917b7ee92e57ba5563708daca94dd84ad7112f.
//
// Solidity: event Swap(bytes32 indexed id, address indexed sender, int128 amount0, int128 amount1, uint160 sqrtPriceX96, uint128 liquidity, int24 tick, uint24 fee)
func (_IPoolManager *IPoolManagerFilterer) WatchSwap(opts *bind.WatchOpts, sink chan<- *IPoolManagerSwap, id [][32]byte, sender []common.Address) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IPoolManager.contract.WatchLogs(opts, "Swap", idRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPoolManagerSwap)
				if err := _IPoolManager.contract.UnpackLog(event, "Swap", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSwap is a log parse operation binding the contract event 0x40e9cecb9f5f1f1c5b9c97dec2917b7ee92e57ba5563708daca94dd84ad7112f.
//
// Solidity: event Swap(bytes32 indexed id, address indexed sender, int128 amount0, int128 amount1, uint160 sqrtPriceX96, uint128 liquidity, int24 tick, uint24 fee)
func (_IPoolManager *IPoolManagerFilterer) ParseSwap(log types.Log) (*IPoolManagerSwap, error) {
	event := new(IPoolManagerSwap)
	if err := _IPoolManager.contract.UnpackLog(event, "Swap", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPoolManagerTransferBatchIterator is returned from FilterTransferBatch and is used to iterate over the raw logs and unpacked data for TransferBatch events raised by the IPoolManager contract.
type IPoolManagerTransferBatchIterator struct {
	Event *IPoolManagerTransferBatch // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPoolManagerTransferBatchIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPoolManagerTransferBatch)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPoolManagerTransferBatch)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPoolManagerTransferBatchIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPoolManagerTransferBatchIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPoolManagerTransferBatch represents a TransferBatch event raised by the IPoolManager contract.
type IPoolManagerTransferBatch struct {
	Operator common.Address
	From     common.Address
	To       common.Address
	Ids      []*big.Int
	Values   []*big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterTransferBatch is a free log retrieval operation binding the contract event 0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb.
//
// Solidity: event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values)
func (_IPoolManager *IPoolManagerFilterer) FilterTransferBatch(opts *bind.FilterOpts, operator []common.Address, from []common.Address, to []common.Address) (*IPoolManagerTransferBatchIterator, error) {

	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IPoolManager.contract.FilterLogs(opts, "TransferBatch", operatorRule, fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &IPoolManagerTransferBatchIterator{contract: _IPoolManager.contract, event: "TransferBatch", logs: logs, sub: sub}, nil
}

// WatchTransferBatch is a free log subscription operation binding the contract event 0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb.
//
// Solidity: event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values)
func (_IPoolManager *IPoolManagerFilterer) WatchTransferBatch(opts *bind.WatchOpts, sink chan<- *IPoolManagerTransferBatch, operator []common.Address, from []common.Address, to []common.Address) (event.Subscription, error) {

	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IPoolManager.contract.WatchLogs(opts, "TransferBatch", operatorRule, fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPoolManagerTransferBatch)
				if err := _IPoolManager.contract.UnpackLog(event, "TransferBatch", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransferBatch is a log parse operation binding the contract event 0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb.
//
// Solidity: event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values)
func (_IPoolManager *IPoolManagerFilterer) ParseTransferBatch(log types.Log) (*IPoolManagerTransferBatch, error) {
	event := new(IPoolManagerTransferBatch)
	if err := _IPoolManager.contract.UnpackLog(event, "TransferBatch", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPoolManagerTransferSingleIterator is returned from FilterTransferSingle and is used to iterate over the raw logs and unpacked data for TransferSingle events raised by the IPoolManager contract.
type IPoolManagerTransferSingleIterator struct {
	Event *IPoolManagerTransferSingle // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPoolManagerTransferSingleIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPoolManagerTransferSingle)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPoolManagerTransferSingle)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPoolManagerTransferSingleIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPoolManagerTransferSingleIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPoolManagerTransferSingle represents a TransferSingle event raised by the IPoolManager contract.
type IPoolManagerTransferSingle struct {
	Operator common.Address
	From     common.Address
	To       common.Address
	Id       *big.Int
	Value    *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterTransferSingle is a free log retrieval operation binding the contract event 0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62.
//
// Solidity: event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value)
func (_IPoolManager *IPoolManagerFilterer) FilterTransferSingle(opts *bind.FilterOpts, operator []common.Address, from []common.Address, to []common.Address) (*IPoolManagerTransferSingleIterator, error) {

	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IPoolManager.contract.FilterLogs(opts, "TransferSingle", operatorRule, fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &IPoolManagerTransferSingleIterator{contract: _IPoolManager.contract, event: "TransferSingle", logs: logs, sub: sub}, nil
}

// WatchTransferSingle is a free log subscription operation binding the contract event 0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62.
//
// Solidity: event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value)
func (_IPoolManager *IPoolManagerFilterer) WatchTransferSingle(opts *bind.WatchOpts, sink chan<- *IPoolManagerTransferSingle, operator []common.Address, from []common.Address, to []common.Address) (event.Subscription, error) {

	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IPoolManager.contract.WatchLogs(opts, "TransferSingle", operatorRule, fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPoolManagerTransferSingle)
				if err := _IPoolManager.contract.UnpackLog(event, "TransferSingle", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransferSingle is a log parse operation binding the contract event 0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62.
//
// Solidity: event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value)
func (_IPoolManager *IPoolManagerFilterer) ParseTransferSingle(log types.Log) (*IPoolManagerTransferSingle, error) {
	event := new(IPoolManagerTransferSingle)
	if err := _IPoolManager.contract.UnpackLog(event, "TransferSingle", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IPoolManagerURIIterator is returned from FilterURI and is used to iterate over the raw logs and unpacked data for URI events raised by the IPoolManager contract.
type IPoolManagerURIIterator struct {
	Event *IPoolManagerURI // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IPoolManagerURIIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IPoolManagerURI)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IPoolManagerURI)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IPoolManagerURIIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IPoolManagerURIIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IPoolManagerURI represents a URI event raised by the IPoolManager contract.
type IPoolManagerURI struct {
	Value string
	Id    *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterURI is a free log retrieval operation binding the contract event 0x6bb7ff708619ba0610cba295a58592e0451dee2622938c8755667688daf3529b.
//
// Solidity: event URI(string value, uint256 indexed id)
func (_IPoolManager *IPoolManagerFilterer) FilterURI(opts *bind.FilterOpts, id []*big.Int) (*IPoolManagerURIIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _IPoolManager.contract.FilterLogs(opts, "URI", idRule)
	if err != nil {
		return nil, err
	}
	return &IPoolManagerURIIterator{contract: _IPoolManager.contract, event: "URI", logs: logs, sub: sub}, nil
}

// WatchURI is a free log subscription operation binding the contract event 0x6bb7ff708619ba0610cba295a58592e0451dee2622938c8755667688daf3529b.
//
// Solidity: event URI(string value, uint256 indexed id)
func (_IPoolManager *IPoolManagerFilterer) WatchURI(opts *bind.WatchOpts, sink chan<- *IPoolManagerURI, id []*big.Int) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _IPoolManager.contract.WatchLogs(opts, "URI", idRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IPoolManagerURI)
				if err := _IPoolManager.contract.UnpackLog(event, "URI", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseURI is a log parse operation binding the contract event 0x6bb7ff708619ba0610cba295a58592e0451dee2622938c8755667688daf3529b.
//
// Solidity: event URI(string value, uint256 indexed id)
func (_IPoolManager *IPoolManagerFilterer) ParseURI(log types.Log) (*IPoolManagerURI, error) {
	event := new(IPoolManagerURI)
	if err := _IPoolManager.contract.UnpackLog(event, "URI", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IReceiptVerifierMetaData contains all meta data concerning the IReceiptVerifier contract.
var IReceiptVerifierMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"receiptRaw\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"auxiBlkVerifyInfo\",\"type\":\"bytes\"}],\"name\":\"verifyReceipt\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"blkHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"blkTime\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"topics\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"structIReceiptVerifier.LogInfo[]\",\"name\":\"logs\",\"type\":\"tuple[]\"}],\"internalType\":\"structIReceiptVerifier.ReceiptInfo\",\"name\":\"receiptInfo\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"receiptRaw\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"auxiBlkVerifyInfo\",\"type\":\"bytes\"}],\"name\":\"verifyReceiptAndLog\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"blkHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"blkTime\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"topics\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"structIReceiptVerifier.LogInfo[]\",\"name\":\"logs\",\"type\":\"tuple[]\"}],\"internalType\":\"structIReceiptVerifier.ReceiptInfo\",\"name\":\"receiptInfo\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IReceiptVerifierABI is the input ABI used to generate the binding from.
// Deprecated: Use IReceiptVerifierMetaData.ABI instead.
var IReceiptVerifierABI = IReceiptVerifierMetaData.ABI

// IReceiptVerifier is an auto generated Go binding around an Ethereum contract.
type IReceiptVerifier struct {
	IReceiptVerifierCaller     // Read-only binding to the contract
	IReceiptVerifierTransactor // Write-only binding to the contract
	IReceiptVerifierFilterer   // Log filterer for contract events
}

// IReceiptVerifierCaller is an auto generated read-only Go binding around an Ethereum contract.
type IReceiptVerifierCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IReceiptVerifierTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IReceiptVerifierTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IReceiptVerifierFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IReceiptVerifierFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IReceiptVerifierSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IReceiptVerifierSession struct {
	Contract     *IReceiptVerifier // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IReceiptVerifierCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IReceiptVerifierCallerSession struct {
	Contract *IReceiptVerifierCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts           // Call options to use throughout this session
}

// IReceiptVerifierTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IReceiptVerifierTransactorSession struct {
	Contract     *IReceiptVerifierTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts           // Transaction auth options to use throughout this session
}

// IReceiptVerifierRaw is an auto generated low-level Go binding around an Ethereum contract.
type IReceiptVerifierRaw struct {
	Contract *IReceiptVerifier // Generic contract binding to access the raw methods on
}

// IReceiptVerifierCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IReceiptVerifierCallerRaw struct {
	Contract *IReceiptVerifierCaller // Generic read-only contract binding to access the raw methods on
}

// IReceiptVerifierTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IReceiptVerifierTransactorRaw struct {
	Contract *IReceiptVerifierTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIReceiptVerifier creates a new instance of IReceiptVerifier, bound to a specific deployed contract.
func NewIReceiptVerifier(address common.Address, backend bind.ContractBackend) (*IReceiptVerifier, error) {
	contract, err := bindIReceiptVerifier(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IReceiptVerifier{IReceiptVerifierCaller: IReceiptVerifierCaller{contract: contract}, IReceiptVerifierTransactor: IReceiptVerifierTransactor{contract: contract}, IReceiptVerifierFilterer: IReceiptVerifierFilterer{contract: contract}}, nil
}

// NewIReceiptVerifierCaller creates a new read-only instance of IReceiptVerifier, bound to a specific deployed contract.
func NewIReceiptVerifierCaller(address common.Address, caller bind.ContractCaller) (*IReceiptVerifierCaller, error) {
	contract, err := bindIReceiptVerifier(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IReceiptVerifierCaller{contract: contract}, nil
}

// NewIReceiptVerifierTransactor creates a new write-only instance of IReceiptVerifier, bound to a specific deployed contract.
func NewIReceiptVerifierTransactor(address common.Address, transactor bind.ContractTransactor) (*IReceiptVerifierTransactor, error) {
	contract, err := bindIReceiptVerifier(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IReceiptVerifierTransactor{contract: contract}, nil
}

// NewIReceiptVerifierFilterer creates a new log filterer instance of IReceiptVerifier, bound to a specific deployed contract.
func NewIReceiptVerifierFilterer(address common.Address, filterer bind.ContractFilterer) (*IReceiptVerifierFilterer, error) {
	contract, err := bindIReceiptVerifier(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IReceiptVerifierFilterer{contract: contract}, nil
}

// bindIReceiptVerifier binds a generic wrapper to an already deployed contract.
func bindIReceiptVerifier(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IReceiptVerifierMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IReceiptVerifier *IReceiptVerifierRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IReceiptVerifier.Contract.IReceiptVerifierCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IReceiptVerifier *IReceiptVerifierRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IReceiptVerifier.Contract.IReceiptVerifierTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IReceiptVerifier *IReceiptVerifierRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IReceiptVerifier.Contract.IReceiptVerifierTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IReceiptVerifier *IReceiptVerifierCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IReceiptVerifier.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IReceiptVerifier *IReceiptVerifierTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IReceiptVerifier.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IReceiptVerifier *IReceiptVerifierTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IReceiptVerifier.Contract.contract.Transact(opts, method, params...)
}

// VerifyReceipt is a free data retrieval call binding the contract method 0x68ac2f78.
//
// Solidity: function verifyReceipt(bytes receiptRaw, bytes proofData, bytes auxiBlkVerifyInfo) view returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) receiptInfo)
func (_IReceiptVerifier *IReceiptVerifierCaller) VerifyReceipt(opts *bind.CallOpts, receiptRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (IReceiptVerifierReceiptInfo, error) {
	var out []interface{}
	err := _IReceiptVerifier.contract.Call(opts, &out, "verifyReceipt", receiptRaw, proofData, auxiBlkVerifyInfo)

	if err != nil {
		return *new(IReceiptVerifierReceiptInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(IReceiptVerifierReceiptInfo)).(*IReceiptVerifierReceiptInfo)

	return out0, err

}

// VerifyReceipt is a free data retrieval call binding the contract method 0x68ac2f78.
//
// Solidity: function verifyReceipt(bytes receiptRaw, bytes proofData, bytes auxiBlkVerifyInfo) view returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) receiptInfo)
func (_IReceiptVerifier *IReceiptVerifierSession) VerifyReceipt(receiptRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (IReceiptVerifierReceiptInfo, error) {
	return _IReceiptVerifier.Contract.VerifyReceipt(&_IReceiptVerifier.CallOpts, receiptRaw, proofData, auxiBlkVerifyInfo)
}

// VerifyReceipt is a free data retrieval call binding the contract method 0x68ac2f78.
//
// Solidity: function verifyReceipt(bytes receiptRaw, bytes proofData, bytes auxiBlkVerifyInfo) view returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) receiptInfo)
func (_IReceiptVerifier *IReceiptVerifierCallerSession) VerifyReceipt(receiptRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (IReceiptVerifierReceiptInfo, error) {
	return _IReceiptVerifier.Contract.VerifyReceipt(&_IReceiptVerifier.CallOpts, receiptRaw, proofData, auxiBlkVerifyInfo)
}

// VerifyReceiptAndLog is a paid mutator transaction binding the contract method 0x3996da7a.
//
// Solidity: function verifyReceiptAndLog(bytes receiptRaw, bytes proofData, bytes auxiBlkVerifyInfo) returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) receiptInfo)
func (_IReceiptVerifier *IReceiptVerifierTransactor) VerifyReceiptAndLog(opts *bind.TransactOpts, receiptRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (*types.Transaction, error) {
	return _IReceiptVerifier.contract.Transact(opts, "verifyReceiptAndLog", receiptRaw, proofData, auxiBlkVerifyInfo)
}

// VerifyReceiptAndLog is a paid mutator transaction binding the contract method 0x3996da7a.
//
// Solidity: function verifyReceiptAndLog(bytes receiptRaw, bytes proofData, bytes auxiBlkVerifyInfo) returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) receiptInfo)
func (_IReceiptVerifier *IReceiptVerifierSession) VerifyReceiptAndLog(receiptRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (*types.Transaction, error) {
	return _IReceiptVerifier.Contract.VerifyReceiptAndLog(&_IReceiptVerifier.TransactOpts, receiptRaw, proofData, auxiBlkVerifyInfo)
}

// VerifyReceiptAndLog is a paid mutator transaction binding the contract method 0x3996da7a.
//
// Solidity: function verifyReceiptAndLog(bytes receiptRaw, bytes proofData, bytes auxiBlkVerifyInfo) returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) receiptInfo)
func (_IReceiptVerifier *IReceiptVerifierTransactorSession) VerifyReceiptAndLog(receiptRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (*types.Transaction, error) {
	return _IReceiptVerifier.Contract.VerifyReceiptAndLog(&_IReceiptVerifier.TransactOpts, receiptRaw, proofData, auxiBlkVerifyInfo)
}

// ISMTMetaData contains all meta data concerning the ISMT contract.
var ISMTMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"smtRoot\",\"type\":\"bytes32\"}],\"name\":\"isSmtRootValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"newSmtRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"endBlockNum\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"endBlockHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"nextChunkMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[8]\",\"name\":\"proof\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commit\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"knowledgeProof\",\"type\":\"uint256[2]\"}],\"internalType\":\"structISMT.SmtUpdate\",\"name\":\"u\",\"type\":\"tuple\"}],\"name\":\"updateRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// ISMTABI is the input ABI used to generate the binding from.
// Deprecated: Use ISMTMetaData.ABI instead.
var ISMTABI = ISMTMetaData.ABI

// ISMT is an auto generated Go binding around an Ethereum contract.
type ISMT struct {
	ISMTCaller     // Read-only binding to the contract
	ISMTTransactor // Write-only binding to the contract
	ISMTFilterer   // Log filterer for contract events
}

// ISMTCaller is an auto generated read-only Go binding around an Ethereum contract.
type ISMTCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ISMTTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ISMTTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ISMTFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ISMTFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ISMTSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ISMTSession struct {
	Contract     *ISMT             // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ISMTCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ISMTCallerSession struct {
	Contract *ISMTCaller   // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// ISMTTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ISMTTransactorSession struct {
	Contract     *ISMTTransactor   // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ISMTRaw is an auto generated low-level Go binding around an Ethereum contract.
type ISMTRaw struct {
	Contract *ISMT // Generic contract binding to access the raw methods on
}

// ISMTCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ISMTCallerRaw struct {
	Contract *ISMTCaller // Generic read-only contract binding to access the raw methods on
}

// ISMTTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ISMTTransactorRaw struct {
	Contract *ISMTTransactor // Generic write-only contract binding to access the raw methods on
}

// NewISMT creates a new instance of ISMT, bound to a specific deployed contract.
func NewISMT(address common.Address, backend bind.ContractBackend) (*ISMT, error) {
	contract, err := bindISMT(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ISMT{ISMTCaller: ISMTCaller{contract: contract}, ISMTTransactor: ISMTTransactor{contract: contract}, ISMTFilterer: ISMTFilterer{contract: contract}}, nil
}

// NewISMTCaller creates a new read-only instance of ISMT, bound to a specific deployed contract.
func NewISMTCaller(address common.Address, caller bind.ContractCaller) (*ISMTCaller, error) {
	contract, err := bindISMT(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ISMTCaller{contract: contract}, nil
}

// NewISMTTransactor creates a new write-only instance of ISMT, bound to a specific deployed contract.
func NewISMTTransactor(address common.Address, transactor bind.ContractTransactor) (*ISMTTransactor, error) {
	contract, err := bindISMT(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ISMTTransactor{contract: contract}, nil
}

// NewISMTFilterer creates a new log filterer instance of ISMT, bound to a specific deployed contract.
func NewISMTFilterer(address common.Address, filterer bind.ContractFilterer) (*ISMTFilterer, error) {
	contract, err := bindISMT(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ISMTFilterer{contract: contract}, nil
}

// bindISMT binds a generic wrapper to an already deployed contract.
func bindISMT(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ISMTMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ISMT *ISMTRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ISMT.Contract.ISMTCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ISMT *ISMTRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ISMT.Contract.ISMTTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ISMT *ISMTRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ISMT.Contract.ISMTTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ISMT *ISMTCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ISMT.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ISMT *ISMTTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ISMT.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ISMT *ISMTTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ISMT.Contract.contract.Transact(opts, method, params...)
}

// IsSmtRootValid is a free data retrieval call binding the contract method 0x1019b616.
//
// Solidity: function isSmtRootValid(uint64 chainId, bytes32 smtRoot) view returns(bool)
func (_ISMT *ISMTCaller) IsSmtRootValid(opts *bind.CallOpts, chainId uint64, smtRoot [32]byte) (bool, error) {
	var out []interface{}
	err := _ISMT.contract.Call(opts, &out, "isSmtRootValid", chainId, smtRoot)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsSmtRootValid is a free data retrieval call binding the contract method 0x1019b616.
//
// Solidity: function isSmtRootValid(uint64 chainId, bytes32 smtRoot) view returns(bool)
func (_ISMT *ISMTSession) IsSmtRootValid(chainId uint64, smtRoot [32]byte) (bool, error) {
	return _ISMT.Contract.IsSmtRootValid(&_ISMT.CallOpts, chainId, smtRoot)
}

// IsSmtRootValid is a free data retrieval call binding the contract method 0x1019b616.
//
// Solidity: function isSmtRootValid(uint64 chainId, bytes32 smtRoot) view returns(bool)
func (_ISMT *ISMTCallerSession) IsSmtRootValid(chainId uint64, smtRoot [32]byte) (bool, error) {
	return _ISMT.Contract.IsSmtRootValid(&_ISMT.CallOpts, chainId, smtRoot)
}

// UpdateRoot is a paid mutator transaction binding the contract method 0x97c7c309.
//
// Solidity: function updateRoot(uint64 chainId, (bytes32,uint64,bytes32,bytes32,uint256[8],uint256[2],uint256[2]) u) returns()
func (_ISMT *ISMTTransactor) UpdateRoot(opts *bind.TransactOpts, chainId uint64, u ISMTSmtUpdate) (*types.Transaction, error) {
	return _ISMT.contract.Transact(opts, "updateRoot", chainId, u)
}

// UpdateRoot is a paid mutator transaction binding the contract method 0x97c7c309.
//
// Solidity: function updateRoot(uint64 chainId, (bytes32,uint64,bytes32,bytes32,uint256[8],uint256[2],uint256[2]) u) returns()
func (_ISMT *ISMTSession) UpdateRoot(chainId uint64, u ISMTSmtUpdate) (*types.Transaction, error) {
	return _ISMT.Contract.UpdateRoot(&_ISMT.TransactOpts, chainId, u)
}

// UpdateRoot is a paid mutator transaction binding the contract method 0x97c7c309.
//
// Solidity: function updateRoot(uint64 chainId, (bytes32,uint64,bytes32,bytes32,uint256[8],uint256[2],uint256[2]) u) returns()
func (_ISMT *ISMTTransactorSession) UpdateRoot(chainId uint64, u ISMTSmtUpdate) (*types.Transaction, error) {
	return _ISMT.Contract.UpdateRoot(&_ISMT.TransactOpts, chainId, u)
}

// ISlotValueVerifierMetaData contains all meta data concerning the ISlotValueVerifier contract.
var ISlotValueVerifierMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"blkVerifyInfo\",\"type\":\"bytes\"}],\"name\":\"verifySlotValue\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"addrHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"blkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"slotKeyHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"slotValue\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"}],\"internalType\":\"structISlotValueVerifier.SlotInfo\",\"name\":\"slotInfo\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// ISlotValueVerifierABI is the input ABI used to generate the binding from.
// Deprecated: Use ISlotValueVerifierMetaData.ABI instead.
var ISlotValueVerifierABI = ISlotValueVerifierMetaData.ABI

// ISlotValueVerifier is an auto generated Go binding around an Ethereum contract.
type ISlotValueVerifier struct {
	ISlotValueVerifierCaller     // Read-only binding to the contract
	ISlotValueVerifierTransactor // Write-only binding to the contract
	ISlotValueVerifierFilterer   // Log filterer for contract events
}

// ISlotValueVerifierCaller is an auto generated read-only Go binding around an Ethereum contract.
type ISlotValueVerifierCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ISlotValueVerifierTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ISlotValueVerifierTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ISlotValueVerifierFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ISlotValueVerifierFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ISlotValueVerifierSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ISlotValueVerifierSession struct {
	Contract     *ISlotValueVerifier // Generic contract binding to set the session for
	CallOpts     bind.CallOpts       // Call options to use throughout this session
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// ISlotValueVerifierCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ISlotValueVerifierCallerSession struct {
	Contract *ISlotValueVerifierCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts             // Call options to use throughout this session
}

// ISlotValueVerifierTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ISlotValueVerifierTransactorSession struct {
	Contract     *ISlotValueVerifierTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts             // Transaction auth options to use throughout this session
}

// ISlotValueVerifierRaw is an auto generated low-level Go binding around an Ethereum contract.
type ISlotValueVerifierRaw struct {
	Contract *ISlotValueVerifier // Generic contract binding to access the raw methods on
}

// ISlotValueVerifierCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ISlotValueVerifierCallerRaw struct {
	Contract *ISlotValueVerifierCaller // Generic read-only contract binding to access the raw methods on
}

// ISlotValueVerifierTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ISlotValueVerifierTransactorRaw struct {
	Contract *ISlotValueVerifierTransactor // Generic write-only contract binding to access the raw methods on
}

// NewISlotValueVerifier creates a new instance of ISlotValueVerifier, bound to a specific deployed contract.
func NewISlotValueVerifier(address common.Address, backend bind.ContractBackend) (*ISlotValueVerifier, error) {
	contract, err := bindISlotValueVerifier(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ISlotValueVerifier{ISlotValueVerifierCaller: ISlotValueVerifierCaller{contract: contract}, ISlotValueVerifierTransactor: ISlotValueVerifierTransactor{contract: contract}, ISlotValueVerifierFilterer: ISlotValueVerifierFilterer{contract: contract}}, nil
}

// NewISlotValueVerifierCaller creates a new read-only instance of ISlotValueVerifier, bound to a specific deployed contract.
func NewISlotValueVerifierCaller(address common.Address, caller bind.ContractCaller) (*ISlotValueVerifierCaller, error) {
	contract, err := bindISlotValueVerifier(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ISlotValueVerifierCaller{contract: contract}, nil
}

// NewISlotValueVerifierTransactor creates a new write-only instance of ISlotValueVerifier, bound to a specific deployed contract.
func NewISlotValueVerifierTransactor(address common.Address, transactor bind.ContractTransactor) (*ISlotValueVerifierTransactor, error) {
	contract, err := bindISlotValueVerifier(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ISlotValueVerifierTransactor{contract: contract}, nil
}

// NewISlotValueVerifierFilterer creates a new log filterer instance of ISlotValueVerifier, bound to a specific deployed contract.
func NewISlotValueVerifierFilterer(address common.Address, filterer bind.ContractFilterer) (*ISlotValueVerifierFilterer, error) {
	contract, err := bindISlotValueVerifier(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ISlotValueVerifierFilterer{contract: contract}, nil
}

// bindISlotValueVerifier binds a generic wrapper to an already deployed contract.
func bindISlotValueVerifier(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ISlotValueVerifierMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ISlotValueVerifier *ISlotValueVerifierRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ISlotValueVerifier.Contract.ISlotValueVerifierCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ISlotValueVerifier *ISlotValueVerifierRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ISlotValueVerifier.Contract.ISlotValueVerifierTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ISlotValueVerifier *ISlotValueVerifierRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ISlotValueVerifier.Contract.ISlotValueVerifierTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ISlotValueVerifier *ISlotValueVerifierCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ISlotValueVerifier.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ISlotValueVerifier *ISlotValueVerifierTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ISlotValueVerifier.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ISlotValueVerifier *ISlotValueVerifierTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ISlotValueVerifier.Contract.contract.Transact(opts, method, params...)
}

// VerifySlotValue is a free data retrieval call binding the contract method 0x0b885e53.
//
// Solidity: function verifySlotValue(uint64 chainId, bytes proofData, bytes blkVerifyInfo) view returns((uint64,bytes32,bytes32,bytes32,bytes32,uint32) slotInfo)
func (_ISlotValueVerifier *ISlotValueVerifierCaller) VerifySlotValue(opts *bind.CallOpts, chainId uint64, proofData []byte, blkVerifyInfo []byte) (ISlotValueVerifierSlotInfo, error) {
	var out []interface{}
	err := _ISlotValueVerifier.contract.Call(opts, &out, "verifySlotValue", chainId, proofData, blkVerifyInfo)

	if err != nil {
		return *new(ISlotValueVerifierSlotInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(ISlotValueVerifierSlotInfo)).(*ISlotValueVerifierSlotInfo)

	return out0, err

}

// VerifySlotValue is a free data retrieval call binding the contract method 0x0b885e53.
//
// Solidity: function verifySlotValue(uint64 chainId, bytes proofData, bytes blkVerifyInfo) view returns((uint64,bytes32,bytes32,bytes32,bytes32,uint32) slotInfo)
func (_ISlotValueVerifier *ISlotValueVerifierSession) VerifySlotValue(chainId uint64, proofData []byte, blkVerifyInfo []byte) (ISlotValueVerifierSlotInfo, error) {
	return _ISlotValueVerifier.Contract.VerifySlotValue(&_ISlotValueVerifier.CallOpts, chainId, proofData, blkVerifyInfo)
}

// VerifySlotValue is a free data retrieval call binding the contract method 0x0b885e53.
//
// Solidity: function verifySlotValue(uint64 chainId, bytes proofData, bytes blkVerifyInfo) view returns((uint64,bytes32,bytes32,bytes32,bytes32,uint32) slotInfo)
func (_ISlotValueVerifier *ISlotValueVerifierCallerSession) VerifySlotValue(chainId uint64, proofData []byte, blkVerifyInfo []byte) (ISlotValueVerifierSlotInfo, error) {
	return _ISlotValueVerifier.Contract.VerifySlotValue(&_ISlotValueVerifier.CallOpts, chainId, proofData, blkVerifyInfo)
}

// ITxVerifierMetaData contains all meta data concerning the ITxVerifier contract.
var ITxVerifierMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"txRaw\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"auxiBlkVerifyInfo\",\"type\":\"bytes\"}],\"name\":\"verifyTx\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"gasTipCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasFeeCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"blkHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"blkTime\",\"type\":\"uint64\"}],\"internalType\":\"structITxVerifier.TxInfo\",\"name\":\"txInfo\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"txRaw\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"auxiBlkVerifyInfo\",\"type\":\"bytes\"}],\"name\":\"verifyTxAndLog\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"gasTipCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasFeeCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"blkHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"blkTime\",\"type\":\"uint64\"}],\"internalType\":\"structITxVerifier.TxInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// ITxVerifierABI is the input ABI used to generate the binding from.
// Deprecated: Use ITxVerifierMetaData.ABI instead.
var ITxVerifierABI = ITxVerifierMetaData.ABI

// ITxVerifier is an auto generated Go binding around an Ethereum contract.
type ITxVerifier struct {
	ITxVerifierCaller     // Read-only binding to the contract
	ITxVerifierTransactor // Write-only binding to the contract
	ITxVerifierFilterer   // Log filterer for contract events
}

// ITxVerifierCaller is an auto generated read-only Go binding around an Ethereum contract.
type ITxVerifierCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ITxVerifierTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ITxVerifierTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ITxVerifierFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ITxVerifierFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ITxVerifierSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ITxVerifierSession struct {
	Contract     *ITxVerifier      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ITxVerifierCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ITxVerifierCallerSession struct {
	Contract *ITxVerifierCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// ITxVerifierTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ITxVerifierTransactorSession struct {
	Contract     *ITxVerifierTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// ITxVerifierRaw is an auto generated low-level Go binding around an Ethereum contract.
type ITxVerifierRaw struct {
	Contract *ITxVerifier // Generic contract binding to access the raw methods on
}

// ITxVerifierCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ITxVerifierCallerRaw struct {
	Contract *ITxVerifierCaller // Generic read-only contract binding to access the raw methods on
}

// ITxVerifierTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ITxVerifierTransactorRaw struct {
	Contract *ITxVerifierTransactor // Generic write-only contract binding to access the raw methods on
}

// NewITxVerifier creates a new instance of ITxVerifier, bound to a specific deployed contract.
func NewITxVerifier(address common.Address, backend bind.ContractBackend) (*ITxVerifier, error) {
	contract, err := bindITxVerifier(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ITxVerifier{ITxVerifierCaller: ITxVerifierCaller{contract: contract}, ITxVerifierTransactor: ITxVerifierTransactor{contract: contract}, ITxVerifierFilterer: ITxVerifierFilterer{contract: contract}}, nil
}

// NewITxVerifierCaller creates a new read-only instance of ITxVerifier, bound to a specific deployed contract.
func NewITxVerifierCaller(address common.Address, caller bind.ContractCaller) (*ITxVerifierCaller, error) {
	contract, err := bindITxVerifier(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ITxVerifierCaller{contract: contract}, nil
}

// NewITxVerifierTransactor creates a new write-only instance of ITxVerifier, bound to a specific deployed contract.
func NewITxVerifierTransactor(address common.Address, transactor bind.ContractTransactor) (*ITxVerifierTransactor, error) {
	contract, err := bindITxVerifier(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ITxVerifierTransactor{contract: contract}, nil
}

// NewITxVerifierFilterer creates a new log filterer instance of ITxVerifier, bound to a specific deployed contract.
func NewITxVerifierFilterer(address common.Address, filterer bind.ContractFilterer) (*ITxVerifierFilterer, error) {
	contract, err := bindITxVerifier(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ITxVerifierFilterer{contract: contract}, nil
}

// bindITxVerifier binds a generic wrapper to an already deployed contract.
func bindITxVerifier(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ITxVerifierMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ITxVerifier *ITxVerifierRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ITxVerifier.Contract.ITxVerifierCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ITxVerifier *ITxVerifierRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ITxVerifier.Contract.ITxVerifierTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ITxVerifier *ITxVerifierRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ITxVerifier.Contract.ITxVerifierTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ITxVerifier *ITxVerifierCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ITxVerifier.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ITxVerifier *ITxVerifierTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ITxVerifier.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ITxVerifier *ITxVerifierTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ITxVerifier.Contract.contract.Transact(opts, method, params...)
}

// VerifyTx is a free data retrieval call binding the contract method 0xa8da8d69.
//
// Solidity: function verifyTx(bytes txRaw, bytes proofData, bytes auxiBlkVerifyInfo) view returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) txInfo)
func (_ITxVerifier *ITxVerifierCaller) VerifyTx(opts *bind.CallOpts, txRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (ITxVerifierTxInfo, error) {
	var out []interface{}
	err := _ITxVerifier.contract.Call(opts, &out, "verifyTx", txRaw, proofData, auxiBlkVerifyInfo)

	if err != nil {
		return *new(ITxVerifierTxInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(ITxVerifierTxInfo)).(*ITxVerifierTxInfo)

	return out0, err

}

// VerifyTx is a free data retrieval call binding the contract method 0xa8da8d69.
//
// Solidity: function verifyTx(bytes txRaw, bytes proofData, bytes auxiBlkVerifyInfo) view returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) txInfo)
func (_ITxVerifier *ITxVerifierSession) VerifyTx(txRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (ITxVerifierTxInfo, error) {
	return _ITxVerifier.Contract.VerifyTx(&_ITxVerifier.CallOpts, txRaw, proofData, auxiBlkVerifyInfo)
}

// VerifyTx is a free data retrieval call binding the contract method 0xa8da8d69.
//
// Solidity: function verifyTx(bytes txRaw, bytes proofData, bytes auxiBlkVerifyInfo) view returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) txInfo)
func (_ITxVerifier *ITxVerifierCallerSession) VerifyTx(txRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (ITxVerifierTxInfo, error) {
	return _ITxVerifier.Contract.VerifyTx(&_ITxVerifier.CallOpts, txRaw, proofData, auxiBlkVerifyInfo)
}

// VerifyTxAndLog is a paid mutator transaction binding the contract method 0x361108de.
//
// Solidity: function verifyTxAndLog(bytes txRaw, bytes proofData, bytes auxiBlkVerifyInfo) returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) info)
func (_ITxVerifier *ITxVerifierTransactor) VerifyTxAndLog(opts *bind.TransactOpts, txRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (*types.Transaction, error) {
	return _ITxVerifier.contract.Transact(opts, "verifyTxAndLog", txRaw, proofData, auxiBlkVerifyInfo)
}

// VerifyTxAndLog is a paid mutator transaction binding the contract method 0x361108de.
//
// Solidity: function verifyTxAndLog(bytes txRaw, bytes proofData, bytes auxiBlkVerifyInfo) returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) info)
func (_ITxVerifier *ITxVerifierSession) VerifyTxAndLog(txRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (*types.Transaction, error) {
	return _ITxVerifier.Contract.VerifyTxAndLog(&_ITxVerifier.TransactOpts, txRaw, proofData, auxiBlkVerifyInfo)
}

// VerifyTxAndLog is a paid mutator transaction binding the contract method 0x361108de.
//
// Solidity: function verifyTxAndLog(bytes txRaw, bytes proofData, bytes auxiBlkVerifyInfo) returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) info)
func (_ITxVerifier *ITxVerifierTransactorSession) VerifyTxAndLog(txRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (*types.Transaction, error) {
	return _ITxVerifier.Contract.VerifyTxAndLog(&_ITxVerifier.TransactOpts, txRaw, proofData, auxiBlkVerifyInfo)
}

// IUniswapSumVolumeMetaData contains all meta data concerning the IUniswapSumVolume contract.
var IUniswapSumVolumeMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"swapper\",\"type\":\"address\"}],\"name\":\"getAttestedSwapSumVolume\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"volume\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// IUniswapSumVolumeABI is the input ABI used to generate the binding from.
// Deprecated: Use IUniswapSumVolumeMetaData.ABI instead.
var IUniswapSumVolumeABI = IUniswapSumVolumeMetaData.ABI

// IUniswapSumVolume is an auto generated Go binding around an Ethereum contract.
type IUniswapSumVolume struct {
	IUniswapSumVolumeCaller     // Read-only binding to the contract
	IUniswapSumVolumeTransactor // Write-only binding to the contract
	IUniswapSumVolumeFilterer   // Log filterer for contract events
}

// IUniswapSumVolumeCaller is an auto generated read-only Go binding around an Ethereum contract.
type IUniswapSumVolumeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IUniswapSumVolumeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IUniswapSumVolumeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IUniswapSumVolumeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IUniswapSumVolumeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IUniswapSumVolumeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IUniswapSumVolumeSession struct {
	Contract     *IUniswapSumVolume // Generic contract binding to set the session for
	CallOpts     bind.CallOpts      // Call options to use throughout this session
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// IUniswapSumVolumeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IUniswapSumVolumeCallerSession struct {
	Contract *IUniswapSumVolumeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts            // Call options to use throughout this session
}

// IUniswapSumVolumeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IUniswapSumVolumeTransactorSession struct {
	Contract     *IUniswapSumVolumeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts            // Transaction auth options to use throughout this session
}

// IUniswapSumVolumeRaw is an auto generated low-level Go binding around an Ethereum contract.
type IUniswapSumVolumeRaw struct {
	Contract *IUniswapSumVolume // Generic contract binding to access the raw methods on
}

// IUniswapSumVolumeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IUniswapSumVolumeCallerRaw struct {
	Contract *IUniswapSumVolumeCaller // Generic read-only contract binding to access the raw methods on
}

// IUniswapSumVolumeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IUniswapSumVolumeTransactorRaw struct {
	Contract *IUniswapSumVolumeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIUniswapSumVolume creates a new instance of IUniswapSumVolume, bound to a specific deployed contract.
func NewIUniswapSumVolume(address common.Address, backend bind.ContractBackend) (*IUniswapSumVolume, error) {
	contract, err := bindIUniswapSumVolume(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IUniswapSumVolume{IUniswapSumVolumeCaller: IUniswapSumVolumeCaller{contract: contract}, IUniswapSumVolumeTransactor: IUniswapSumVolumeTransactor{contract: contract}, IUniswapSumVolumeFilterer: IUniswapSumVolumeFilterer{contract: contract}}, nil
}

// NewIUniswapSumVolumeCaller creates a new read-only instance of IUniswapSumVolume, bound to a specific deployed contract.
func NewIUniswapSumVolumeCaller(address common.Address, caller bind.ContractCaller) (*IUniswapSumVolumeCaller, error) {
	contract, err := bindIUniswapSumVolume(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IUniswapSumVolumeCaller{contract: contract}, nil
}

// NewIUniswapSumVolumeTransactor creates a new write-only instance of IUniswapSumVolume, bound to a specific deployed contract.
func NewIUniswapSumVolumeTransactor(address common.Address, transactor bind.ContractTransactor) (*IUniswapSumVolumeTransactor, error) {
	contract, err := bindIUniswapSumVolume(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IUniswapSumVolumeTransactor{contract: contract}, nil
}

// NewIUniswapSumVolumeFilterer creates a new log filterer instance of IUniswapSumVolume, bound to a specific deployed contract.
func NewIUniswapSumVolumeFilterer(address common.Address, filterer bind.ContractFilterer) (*IUniswapSumVolumeFilterer, error) {
	contract, err := bindIUniswapSumVolume(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IUniswapSumVolumeFilterer{contract: contract}, nil
}

// bindIUniswapSumVolume binds a generic wrapper to an already deployed contract.
func bindIUniswapSumVolume(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IUniswapSumVolumeMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IUniswapSumVolume *IUniswapSumVolumeRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IUniswapSumVolume.Contract.IUniswapSumVolumeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IUniswapSumVolume *IUniswapSumVolumeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IUniswapSumVolume.Contract.IUniswapSumVolumeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IUniswapSumVolume *IUniswapSumVolumeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IUniswapSumVolume.Contract.IUniswapSumVolumeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IUniswapSumVolume *IUniswapSumVolumeCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IUniswapSumVolume.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IUniswapSumVolume *IUniswapSumVolumeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IUniswapSumVolume.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IUniswapSumVolume *IUniswapSumVolumeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IUniswapSumVolume.Contract.contract.Transact(opts, method, params...)
}

// GetAttestedSwapSumVolume is a free data retrieval call binding the contract method 0x950650c1.
//
// Solidity: function getAttestedSwapSumVolume(address swapper) view returns(uint256 volume)
func (_IUniswapSumVolume *IUniswapSumVolumeCaller) GetAttestedSwapSumVolume(opts *bind.CallOpts, swapper common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IUniswapSumVolume.contract.Call(opts, &out, "getAttestedSwapSumVolume", swapper)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetAttestedSwapSumVolume is a free data retrieval call binding the contract method 0x950650c1.
//
// Solidity: function getAttestedSwapSumVolume(address swapper) view returns(uint256 volume)
func (_IUniswapSumVolume *IUniswapSumVolumeSession) GetAttestedSwapSumVolume(swapper common.Address) (*big.Int, error) {
	return _IUniswapSumVolume.Contract.GetAttestedSwapSumVolume(&_IUniswapSumVolume.CallOpts, swapper)
}

// GetAttestedSwapSumVolume is a free data retrieval call binding the contract method 0x950650c1.
//
// Solidity: function getAttestedSwapSumVolume(address swapper) view returns(uint256 volume)
func (_IUniswapSumVolume *IUniswapSumVolumeCallerSession) GetAttestedSwapSumVolume(swapper common.Address) (*big.Int, error) {
	return _IUniswapSumVolume.Contract.GetAttestedSwapSumVolume(&_IUniswapSumVolume.CallOpts, swapper)
}

// IVerifierMetaData contains all meta data concerning the IVerifier contract.
var IVerifierMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint256[8]\",\"name\":\"proof\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commit\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"knowledgeProof\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[9]\",\"name\":\"input\",\"type\":\"uint256[9]\"}],\"name\":\"verifyProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"r\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// IVerifierABI is the input ABI used to generate the binding from.
// Deprecated: Use IVerifierMetaData.ABI instead.
var IVerifierABI = IVerifierMetaData.ABI

// IVerifier is an auto generated Go binding around an Ethereum contract.
type IVerifier struct {
	IVerifierCaller     // Read-only binding to the contract
	IVerifierTransactor // Write-only binding to the contract
	IVerifierFilterer   // Log filterer for contract events
}

// IVerifierCaller is an auto generated read-only Go binding around an Ethereum contract.
type IVerifierCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IVerifierTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IVerifierTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IVerifierFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IVerifierFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IVerifierSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IVerifierSession struct {
	Contract     *IVerifier        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IVerifierCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IVerifierCallerSession struct {
	Contract *IVerifierCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// IVerifierTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IVerifierTransactorSession struct {
	Contract     *IVerifierTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// IVerifierRaw is an auto generated low-level Go binding around an Ethereum contract.
type IVerifierRaw struct {
	Contract *IVerifier // Generic contract binding to access the raw methods on
}

// IVerifierCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IVerifierCallerRaw struct {
	Contract *IVerifierCaller // Generic read-only contract binding to access the raw methods on
}

// IVerifierTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IVerifierTransactorRaw struct {
	Contract *IVerifierTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIVerifier creates a new instance of IVerifier, bound to a specific deployed contract.
func NewIVerifier(address common.Address, backend bind.ContractBackend) (*IVerifier, error) {
	contract, err := bindIVerifier(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IVerifier{IVerifierCaller: IVerifierCaller{contract: contract}, IVerifierTransactor: IVerifierTransactor{contract: contract}, IVerifierFilterer: IVerifierFilterer{contract: contract}}, nil
}

// NewIVerifierCaller creates a new read-only instance of IVerifier, bound to a specific deployed contract.
func NewIVerifierCaller(address common.Address, caller bind.ContractCaller) (*IVerifierCaller, error) {
	contract, err := bindIVerifier(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IVerifierCaller{contract: contract}, nil
}

// NewIVerifierTransactor creates a new write-only instance of IVerifier, bound to a specific deployed contract.
func NewIVerifierTransactor(address common.Address, transactor bind.ContractTransactor) (*IVerifierTransactor, error) {
	contract, err := bindIVerifier(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IVerifierTransactor{contract: contract}, nil
}

// NewIVerifierFilterer creates a new log filterer instance of IVerifier, bound to a specific deployed contract.
func NewIVerifierFilterer(address common.Address, filterer bind.ContractFilterer) (*IVerifierFilterer, error) {
	contract, err := bindIVerifier(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IVerifierFilterer{contract: contract}, nil
}

// bindIVerifier binds a generic wrapper to an already deployed contract.
func bindIVerifier(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IVerifierMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IVerifier *IVerifierRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IVerifier.Contract.IVerifierCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IVerifier *IVerifierRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IVerifier.Contract.IVerifierTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IVerifier *IVerifierRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IVerifier.Contract.IVerifierTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IVerifier *IVerifierCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IVerifier.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IVerifier *IVerifierTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IVerifier.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IVerifier *IVerifierTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IVerifier.Contract.contract.Transact(opts, method, params...)
}

// VerifyProof is a free data retrieval call binding the contract method 0x60e58346.
//
// Solidity: function verifyProof(uint256[8] proof, uint256[2] commit, uint256[2] knowledgeProof, uint256[9] input) view returns(bool r)
func (_IVerifier *IVerifierCaller) VerifyProof(opts *bind.CallOpts, proof [8]*big.Int, commit [2]*big.Int, knowledgeProof [2]*big.Int, input [9]*big.Int) (bool, error) {
	var out []interface{}
	err := _IVerifier.contract.Call(opts, &out, "verifyProof", proof, commit, knowledgeProof, input)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// VerifyProof is a free data retrieval call binding the contract method 0x60e58346.
//
// Solidity: function verifyProof(uint256[8] proof, uint256[2] commit, uint256[2] knowledgeProof, uint256[9] input) view returns(bool r)
func (_IVerifier *IVerifierSession) VerifyProof(proof [8]*big.Int, commit [2]*big.Int, knowledgeProof [2]*big.Int, input [9]*big.Int) (bool, error) {
	return _IVerifier.Contract.VerifyProof(&_IVerifier.CallOpts, proof, commit, knowledgeProof, input)
}

// VerifyProof is a free data retrieval call binding the contract method 0x60e58346.
//
// Solidity: function verifyProof(uint256[8] proof, uint256[2] commit, uint256[2] knowledgeProof, uint256[9] input) view returns(bool r)
func (_IVerifier *IVerifierCallerSession) VerifyProof(proof [8]*big.Int, commit [2]*big.Int, knowledgeProof [2]*big.Int, input [9]*big.Int) (bool, error) {
	return _IVerifier.Contract.VerifyProof(&_IVerifier.CallOpts, proof, commit, knowledgeProof, input)
}

// IZkpVerifierMetaData contains all meta data concerning the IZkpVerifier contract.
var IZkpVerifierMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"}],\"name\":\"verifyRaw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"r\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// IZkpVerifierABI is the input ABI used to generate the binding from.
// Deprecated: Use IZkpVerifierMetaData.ABI instead.
var IZkpVerifierABI = IZkpVerifierMetaData.ABI

// IZkpVerifier is an auto generated Go binding around an Ethereum contract.
type IZkpVerifier struct {
	IZkpVerifierCaller     // Read-only binding to the contract
	IZkpVerifierTransactor // Write-only binding to the contract
	IZkpVerifierFilterer   // Log filterer for contract events
}

// IZkpVerifierCaller is an auto generated read-only Go binding around an Ethereum contract.
type IZkpVerifierCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IZkpVerifierTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IZkpVerifierTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IZkpVerifierFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IZkpVerifierFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IZkpVerifierSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IZkpVerifierSession struct {
	Contract     *IZkpVerifier     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IZkpVerifierCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IZkpVerifierCallerSession struct {
	Contract *IZkpVerifierCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// IZkpVerifierTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IZkpVerifierTransactorSession struct {
	Contract     *IZkpVerifierTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// IZkpVerifierRaw is an auto generated low-level Go binding around an Ethereum contract.
type IZkpVerifierRaw struct {
	Contract *IZkpVerifier // Generic contract binding to access the raw methods on
}

// IZkpVerifierCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IZkpVerifierCallerRaw struct {
	Contract *IZkpVerifierCaller // Generic read-only contract binding to access the raw methods on
}

// IZkpVerifierTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IZkpVerifierTransactorRaw struct {
	Contract *IZkpVerifierTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIZkpVerifier creates a new instance of IZkpVerifier, bound to a specific deployed contract.
func NewIZkpVerifier(address common.Address, backend bind.ContractBackend) (*IZkpVerifier, error) {
	contract, err := bindIZkpVerifier(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IZkpVerifier{IZkpVerifierCaller: IZkpVerifierCaller{contract: contract}, IZkpVerifierTransactor: IZkpVerifierTransactor{contract: contract}, IZkpVerifierFilterer: IZkpVerifierFilterer{contract: contract}}, nil
}

// NewIZkpVerifierCaller creates a new read-only instance of IZkpVerifier, bound to a specific deployed contract.
func NewIZkpVerifierCaller(address common.Address, caller bind.ContractCaller) (*IZkpVerifierCaller, error) {
	contract, err := bindIZkpVerifier(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IZkpVerifierCaller{contract: contract}, nil
}

// NewIZkpVerifierTransactor creates a new write-only instance of IZkpVerifier, bound to a specific deployed contract.
func NewIZkpVerifierTransactor(address common.Address, transactor bind.ContractTransactor) (*IZkpVerifierTransactor, error) {
	contract, err := bindIZkpVerifier(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IZkpVerifierTransactor{contract: contract}, nil
}

// NewIZkpVerifierFilterer creates a new log filterer instance of IZkpVerifier, bound to a specific deployed contract.
func NewIZkpVerifierFilterer(address common.Address, filterer bind.ContractFilterer) (*IZkpVerifierFilterer, error) {
	contract, err := bindIZkpVerifier(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IZkpVerifierFilterer{contract: contract}, nil
}

// bindIZkpVerifier binds a generic wrapper to an already deployed contract.
func bindIZkpVerifier(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IZkpVerifierMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IZkpVerifier *IZkpVerifierRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IZkpVerifier.Contract.IZkpVerifierCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IZkpVerifier *IZkpVerifierRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IZkpVerifier.Contract.IZkpVerifierTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IZkpVerifier *IZkpVerifierRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IZkpVerifier.Contract.IZkpVerifierTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IZkpVerifier *IZkpVerifierCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IZkpVerifier.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IZkpVerifier *IZkpVerifierTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IZkpVerifier.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IZkpVerifier *IZkpVerifierTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IZkpVerifier.Contract.contract.Transact(opts, method, params...)
}

// VerifyRaw is a free data retrieval call binding the contract method 0x457726e6.
//
// Solidity: function verifyRaw(bytes proofData) view returns(bool r)
func (_IZkpVerifier *IZkpVerifierCaller) VerifyRaw(opts *bind.CallOpts, proofData []byte) (bool, error) {
	var out []interface{}
	err := _IZkpVerifier.contract.Call(opts, &out, "verifyRaw", proofData)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// VerifyRaw is a free data retrieval call binding the contract method 0x457726e6.
//
// Solidity: function verifyRaw(bytes proofData) view returns(bool r)
func (_IZkpVerifier *IZkpVerifierSession) VerifyRaw(proofData []byte) (bool, error) {
	return _IZkpVerifier.Contract.VerifyRaw(&_IZkpVerifier.CallOpts, proofData)
}

// VerifyRaw is a free data retrieval call binding the contract method 0x457726e6.
//
// Solidity: function verifyRaw(bytes proofData) view returns(bool r)
func (_IZkpVerifier *IZkpVerifierCallerSession) VerifyRaw(proofData []byte) (bool, error) {
	return _IZkpVerifier.Contract.VerifyRaw(&_IZkpVerifier.CallOpts, proofData)
}

// LightClientStoreMetaData contains all meta data concerning the LightClientStore contract.
var LightClientStoreMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"bestValidUpdate\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"proposerIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"parentRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"bodyRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBeaconBlockHeader\",\"name\":\"beacon\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"stateRoot\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockHash\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockNumber\",\"type\":\"tuple\"}],\"internalType\":\"structExecutionPayload\",\"name\":\"execution\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"executionRoot\",\"type\":\"tuple\"}],\"internalType\":\"structHeaderWithExecution\",\"name\":\"attestedHeader\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"proposerIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"parentRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"bodyRoot\",\"type\":\"bytes32\"}],\"internalType\":\"structBeaconBlockHeader\",\"name\":\"beacon\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"stateRoot\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockHash\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"blockNumber\",\"type\":\"tuple\"}],\"internalType\":\"structExecutionPayload\",\"name\":\"execution\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"branch\",\"type\":\"bytes32[]\"}],\"internalType\":\"structLeafWithBranch\",\"name\":\"executionRoot\",\"type\":\"tuple\"}],\"internalType\":\"structHeaderWithExecution\",\"name\":\"finalizedHeader\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"nextSyncCommitteeRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"nextSyncCommitteePoseidonRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commitment\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIBeaconVerifier.Proof\",\"name\":\"nextSyncCommitteeRootMappingProof\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"participation\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"poseidonRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"commitment\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commitment\",\"type\":\"uint256[2]\"}],\"internalType\":\"structIBeaconVerifier.Proof\",\"name\":\"proof\",\"type\":\"tuple\"}],\"internalType\":\"structSyncAggregate\",\"name\":\"syncAggregate\",\"type\":\"tuple\"},{\"internalType\":\"uint64\",\"name\":\"signatureSlot\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentSyncCommitteePoseidonRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentSyncCommitteeRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalizedExecutionStateRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalizedSlot\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"forkEpochs\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"forkVersions\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextSyncCommitteePoseidonRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextSyncCommitteeRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optimisticExecutionStateRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optimisticSlot\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zkVerifier\",\"outputs\":[{\"internalType\":\"contractIBeaconVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// LightClientStoreABI is the input ABI used to generate the binding from.
// Deprecated: Use LightClientStoreMetaData.ABI instead.
var LightClientStoreABI = LightClientStoreMetaData.ABI

// LightClientStore is an auto generated Go binding around an Ethereum contract.
type LightClientStore struct {
	LightClientStoreCaller     // Read-only binding to the contract
	LightClientStoreTransactor // Write-only binding to the contract
	LightClientStoreFilterer   // Log filterer for contract events
}

// LightClientStoreCaller is an auto generated read-only Go binding around an Ethereum contract.
type LightClientStoreCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// LightClientStoreTransactor is an auto generated write-only Go binding around an Ethereum contract.
type LightClientStoreTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// LightClientStoreFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type LightClientStoreFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// LightClientStoreSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type LightClientStoreSession struct {
	Contract     *LightClientStore // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// LightClientStoreCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type LightClientStoreCallerSession struct {
	Contract *LightClientStoreCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts           // Call options to use throughout this session
}

// LightClientStoreTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type LightClientStoreTransactorSession struct {
	Contract     *LightClientStoreTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts           // Transaction auth options to use throughout this session
}

// LightClientStoreRaw is an auto generated low-level Go binding around an Ethereum contract.
type LightClientStoreRaw struct {
	Contract *LightClientStore // Generic contract binding to access the raw methods on
}

// LightClientStoreCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type LightClientStoreCallerRaw struct {
	Contract *LightClientStoreCaller // Generic read-only contract binding to access the raw methods on
}

// LightClientStoreTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type LightClientStoreTransactorRaw struct {
	Contract *LightClientStoreTransactor // Generic write-only contract binding to access the raw methods on
}

// NewLightClientStore creates a new instance of LightClientStore, bound to a specific deployed contract.
func NewLightClientStore(address common.Address, backend bind.ContractBackend) (*LightClientStore, error) {
	contract, err := bindLightClientStore(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &LightClientStore{LightClientStoreCaller: LightClientStoreCaller{contract: contract}, LightClientStoreTransactor: LightClientStoreTransactor{contract: contract}, LightClientStoreFilterer: LightClientStoreFilterer{contract: contract}}, nil
}

// NewLightClientStoreCaller creates a new read-only instance of LightClientStore, bound to a specific deployed contract.
func NewLightClientStoreCaller(address common.Address, caller bind.ContractCaller) (*LightClientStoreCaller, error) {
	contract, err := bindLightClientStore(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &LightClientStoreCaller{contract: contract}, nil
}

// NewLightClientStoreTransactor creates a new write-only instance of LightClientStore, bound to a specific deployed contract.
func NewLightClientStoreTransactor(address common.Address, transactor bind.ContractTransactor) (*LightClientStoreTransactor, error) {
	contract, err := bindLightClientStore(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &LightClientStoreTransactor{contract: contract}, nil
}

// NewLightClientStoreFilterer creates a new log filterer instance of LightClientStore, bound to a specific deployed contract.
func NewLightClientStoreFilterer(address common.Address, filterer bind.ContractFilterer) (*LightClientStoreFilterer, error) {
	contract, err := bindLightClientStore(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &LightClientStoreFilterer{contract: contract}, nil
}

// bindLightClientStore binds a generic wrapper to an already deployed contract.
func bindLightClientStore(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := LightClientStoreMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_LightClientStore *LightClientStoreRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _LightClientStore.Contract.LightClientStoreCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_LightClientStore *LightClientStoreRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _LightClientStore.Contract.LightClientStoreTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_LightClientStore *LightClientStoreRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _LightClientStore.Contract.LightClientStoreTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_LightClientStore *LightClientStoreCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _LightClientStore.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_LightClientStore *LightClientStoreTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _LightClientStore.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_LightClientStore *LightClientStoreTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _LightClientStore.Contract.contract.Transact(opts, method, params...)
}

// BestValidUpdate is a free data retrieval call binding the contract method 0xba67ee48.
//
// Solidity: function bestValidUpdate() view returns(((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])) attestedHeader, ((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])) finalizedHeader, bytes32 nextSyncCommitteeRoot, bytes32 nextSyncCommitteePoseidonRoot, (uint256[2],uint256[2][2],uint256[2],uint256[2]) nextSyncCommitteeRootMappingProof, (uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])) syncAggregate, uint64 signatureSlot)
func (_LightClientStore *LightClientStoreCaller) BestValidUpdate(opts *bind.CallOpts) (struct {
	AttestedHeader                    HeaderWithExecution
	FinalizedHeader                   HeaderWithExecution
	NextSyncCommitteeRoot             [32]byte
	NextSyncCommitteePoseidonRoot     [32]byte
	NextSyncCommitteeRootMappingProof IBeaconVerifierProof
	SyncAggregate                     SyncAggregate
	SignatureSlot                     uint64
}, error) {
	var out []interface{}
	err := _LightClientStore.contract.Call(opts, &out, "bestValidUpdate")

	outstruct := new(struct {
		AttestedHeader                    HeaderWithExecution
		FinalizedHeader                   HeaderWithExecution
		NextSyncCommitteeRoot             [32]byte
		NextSyncCommitteePoseidonRoot     [32]byte
		NextSyncCommitteeRootMappingProof IBeaconVerifierProof
		SyncAggregate                     SyncAggregate
		SignatureSlot                     uint64
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.AttestedHeader = *abi.ConvertType(out[0], new(HeaderWithExecution)).(*HeaderWithExecution)
	outstruct.FinalizedHeader = *abi.ConvertType(out[1], new(HeaderWithExecution)).(*HeaderWithExecution)
	outstruct.NextSyncCommitteeRoot = *abi.ConvertType(out[2], new([32]byte)).(*[32]byte)
	outstruct.NextSyncCommitteePoseidonRoot = *abi.ConvertType(out[3], new([32]byte)).(*[32]byte)
	outstruct.NextSyncCommitteeRootMappingProof = *abi.ConvertType(out[4], new(IBeaconVerifierProof)).(*IBeaconVerifierProof)
	outstruct.SyncAggregate = *abi.ConvertType(out[5], new(SyncAggregate)).(*SyncAggregate)
	outstruct.SignatureSlot = *abi.ConvertType(out[6], new(uint64)).(*uint64)

	return *outstruct, err

}

// BestValidUpdate is a free data retrieval call binding the contract method 0xba67ee48.
//
// Solidity: function bestValidUpdate() view returns(((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])) attestedHeader, ((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])) finalizedHeader, bytes32 nextSyncCommitteeRoot, bytes32 nextSyncCommitteePoseidonRoot, (uint256[2],uint256[2][2],uint256[2],uint256[2]) nextSyncCommitteeRootMappingProof, (uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])) syncAggregate, uint64 signatureSlot)
func (_LightClientStore *LightClientStoreSession) BestValidUpdate() (struct {
	AttestedHeader                    HeaderWithExecution
	FinalizedHeader                   HeaderWithExecution
	NextSyncCommitteeRoot             [32]byte
	NextSyncCommitteePoseidonRoot     [32]byte
	NextSyncCommitteeRootMappingProof IBeaconVerifierProof
	SyncAggregate                     SyncAggregate
	SignatureSlot                     uint64
}, error) {
	return _LightClientStore.Contract.BestValidUpdate(&_LightClientStore.CallOpts)
}

// BestValidUpdate is a free data retrieval call binding the contract method 0xba67ee48.
//
// Solidity: function bestValidUpdate() view returns(((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])) attestedHeader, ((uint64,uint64,bytes32,bytes32,bytes32),((bytes32,bytes32[]),(bytes32,bytes32[]),(bytes32,bytes32[])),(bytes32,bytes32[])) finalizedHeader, bytes32 nextSyncCommitteeRoot, bytes32 nextSyncCommitteePoseidonRoot, (uint256[2],uint256[2][2],uint256[2],uint256[2]) nextSyncCommitteeRootMappingProof, (uint64,bytes32,uint256,(uint256[2],uint256[2][2],uint256[2],uint256[2])) syncAggregate, uint64 signatureSlot)
func (_LightClientStore *LightClientStoreCallerSession) BestValidUpdate() (struct {
	AttestedHeader                    HeaderWithExecution
	FinalizedHeader                   HeaderWithExecution
	NextSyncCommitteeRoot             [32]byte
	NextSyncCommitteePoseidonRoot     [32]byte
	NextSyncCommitteeRootMappingProof IBeaconVerifierProof
	SyncAggregate                     SyncAggregate
	SignatureSlot                     uint64
}, error) {
	return _LightClientStore.Contract.BestValidUpdate(&_LightClientStore.CallOpts)
}

// CurrentSyncCommitteePoseidonRoot is a free data retrieval call binding the contract method 0x65e700de.
//
// Solidity: function currentSyncCommitteePoseidonRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreCaller) CurrentSyncCommitteePoseidonRoot(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _LightClientStore.contract.Call(opts, &out, "currentSyncCommitteePoseidonRoot")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// CurrentSyncCommitteePoseidonRoot is a free data retrieval call binding the contract method 0x65e700de.
//
// Solidity: function currentSyncCommitteePoseidonRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreSession) CurrentSyncCommitteePoseidonRoot() ([32]byte, error) {
	return _LightClientStore.Contract.CurrentSyncCommitteePoseidonRoot(&_LightClientStore.CallOpts)
}

// CurrentSyncCommitteePoseidonRoot is a free data retrieval call binding the contract method 0x65e700de.
//
// Solidity: function currentSyncCommitteePoseidonRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreCallerSession) CurrentSyncCommitteePoseidonRoot() ([32]byte, error) {
	return _LightClientStore.Contract.CurrentSyncCommitteePoseidonRoot(&_LightClientStore.CallOpts)
}

// CurrentSyncCommitteeRoot is a free data retrieval call binding the contract method 0xa4059e07.
//
// Solidity: function currentSyncCommitteeRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreCaller) CurrentSyncCommitteeRoot(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _LightClientStore.contract.Call(opts, &out, "currentSyncCommitteeRoot")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// CurrentSyncCommitteeRoot is a free data retrieval call binding the contract method 0xa4059e07.
//
// Solidity: function currentSyncCommitteeRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreSession) CurrentSyncCommitteeRoot() ([32]byte, error) {
	return _LightClientStore.Contract.CurrentSyncCommitteeRoot(&_LightClientStore.CallOpts)
}

// CurrentSyncCommitteeRoot is a free data retrieval call binding the contract method 0xa4059e07.
//
// Solidity: function currentSyncCommitteeRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreCallerSession) CurrentSyncCommitteeRoot() ([32]byte, error) {
	return _LightClientStore.Contract.CurrentSyncCommitteeRoot(&_LightClientStore.CallOpts)
}

// FinalizedExecutionStateRoot is a free data retrieval call binding the contract method 0xc5190436.
//
// Solidity: function finalizedExecutionStateRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreCaller) FinalizedExecutionStateRoot(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _LightClientStore.contract.Call(opts, &out, "finalizedExecutionStateRoot")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// FinalizedExecutionStateRoot is a free data retrieval call binding the contract method 0xc5190436.
//
// Solidity: function finalizedExecutionStateRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreSession) FinalizedExecutionStateRoot() ([32]byte, error) {
	return _LightClientStore.Contract.FinalizedExecutionStateRoot(&_LightClientStore.CallOpts)
}

// FinalizedExecutionStateRoot is a free data retrieval call binding the contract method 0xc5190436.
//
// Solidity: function finalizedExecutionStateRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreCallerSession) FinalizedExecutionStateRoot() ([32]byte, error) {
	return _LightClientStore.Contract.FinalizedExecutionStateRoot(&_LightClientStore.CallOpts)
}

// FinalizedSlot is a free data retrieval call binding the contract method 0xd1802369.
//
// Solidity: function finalizedSlot() view returns(uint64)
func (_LightClientStore *LightClientStoreCaller) FinalizedSlot(opts *bind.CallOpts) (uint64, error) {
	var out []interface{}
	err := _LightClientStore.contract.Call(opts, &out, "finalizedSlot")

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// FinalizedSlot is a free data retrieval call binding the contract method 0xd1802369.
//
// Solidity: function finalizedSlot() view returns(uint64)
func (_LightClientStore *LightClientStoreSession) FinalizedSlot() (uint64, error) {
	return _LightClientStore.Contract.FinalizedSlot(&_LightClientStore.CallOpts)
}

// FinalizedSlot is a free data retrieval call binding the contract method 0xd1802369.
//
// Solidity: function finalizedSlot() view returns(uint64)
func (_LightClientStore *LightClientStoreCallerSession) FinalizedSlot() (uint64, error) {
	return _LightClientStore.Contract.FinalizedSlot(&_LightClientStore.CallOpts)
}

// ForkEpochs is a free data retrieval call binding the contract method 0xbcbaf770.
//
// Solidity: function forkEpochs(uint256 ) view returns(uint64)
func (_LightClientStore *LightClientStoreCaller) ForkEpochs(opts *bind.CallOpts, arg0 *big.Int) (uint64, error) {
	var out []interface{}
	err := _LightClientStore.contract.Call(opts, &out, "forkEpochs", arg0)

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// ForkEpochs is a free data retrieval call binding the contract method 0xbcbaf770.
//
// Solidity: function forkEpochs(uint256 ) view returns(uint64)
func (_LightClientStore *LightClientStoreSession) ForkEpochs(arg0 *big.Int) (uint64, error) {
	return _LightClientStore.Contract.ForkEpochs(&_LightClientStore.CallOpts, arg0)
}

// ForkEpochs is a free data retrieval call binding the contract method 0xbcbaf770.
//
// Solidity: function forkEpochs(uint256 ) view returns(uint64)
func (_LightClientStore *LightClientStoreCallerSession) ForkEpochs(arg0 *big.Int) (uint64, error) {
	return _LightClientStore.Contract.ForkEpochs(&_LightClientStore.CallOpts, arg0)
}

// ForkVersions is a free data retrieval call binding the contract method 0xbaa94ea2.
//
// Solidity: function forkVersions(uint256 ) view returns(bytes4)
func (_LightClientStore *LightClientStoreCaller) ForkVersions(opts *bind.CallOpts, arg0 *big.Int) ([4]byte, error) {
	var out []interface{}
	err := _LightClientStore.contract.Call(opts, &out, "forkVersions", arg0)

	if err != nil {
		return *new([4]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([4]byte)).(*[4]byte)

	return out0, err

}

// ForkVersions is a free data retrieval call binding the contract method 0xbaa94ea2.
//
// Solidity: function forkVersions(uint256 ) view returns(bytes4)
func (_LightClientStore *LightClientStoreSession) ForkVersions(arg0 *big.Int) ([4]byte, error) {
	return _LightClientStore.Contract.ForkVersions(&_LightClientStore.CallOpts, arg0)
}

// ForkVersions is a free data retrieval call binding the contract method 0xbaa94ea2.
//
// Solidity: function forkVersions(uint256 ) view returns(bytes4)
func (_LightClientStore *LightClientStoreCallerSession) ForkVersions(arg0 *big.Int) ([4]byte, error) {
	return _LightClientStore.Contract.ForkVersions(&_LightClientStore.CallOpts, arg0)
}

// NextSyncCommitteePoseidonRoot is a free data retrieval call binding the contract method 0xe1861b08.
//
// Solidity: function nextSyncCommitteePoseidonRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreCaller) NextSyncCommitteePoseidonRoot(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _LightClientStore.contract.Call(opts, &out, "nextSyncCommitteePoseidonRoot")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// NextSyncCommitteePoseidonRoot is a free data retrieval call binding the contract method 0xe1861b08.
//
// Solidity: function nextSyncCommitteePoseidonRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreSession) NextSyncCommitteePoseidonRoot() ([32]byte, error) {
	return _LightClientStore.Contract.NextSyncCommitteePoseidonRoot(&_LightClientStore.CallOpts)
}

// NextSyncCommitteePoseidonRoot is a free data retrieval call binding the contract method 0xe1861b08.
//
// Solidity: function nextSyncCommitteePoseidonRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreCallerSession) NextSyncCommitteePoseidonRoot() ([32]byte, error) {
	return _LightClientStore.Contract.NextSyncCommitteePoseidonRoot(&_LightClientStore.CallOpts)
}

// NextSyncCommitteeRoot is a free data retrieval call binding the contract method 0x67b49cc7.
//
// Solidity: function nextSyncCommitteeRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreCaller) NextSyncCommitteeRoot(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _LightClientStore.contract.Call(opts, &out, "nextSyncCommitteeRoot")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// NextSyncCommitteeRoot is a free data retrieval call binding the contract method 0x67b49cc7.
//
// Solidity: function nextSyncCommitteeRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreSession) NextSyncCommitteeRoot() ([32]byte, error) {
	return _LightClientStore.Contract.NextSyncCommitteeRoot(&_LightClientStore.CallOpts)
}

// NextSyncCommitteeRoot is a free data retrieval call binding the contract method 0x67b49cc7.
//
// Solidity: function nextSyncCommitteeRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreCallerSession) NextSyncCommitteeRoot() ([32]byte, error) {
	return _LightClientStore.Contract.NextSyncCommitteeRoot(&_LightClientStore.CallOpts)
}

// OptimisticExecutionStateRoot is a free data retrieval call binding the contract method 0x39536c8f.
//
// Solidity: function optimisticExecutionStateRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreCaller) OptimisticExecutionStateRoot(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _LightClientStore.contract.Call(opts, &out, "optimisticExecutionStateRoot")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// OptimisticExecutionStateRoot is a free data retrieval call binding the contract method 0x39536c8f.
//
// Solidity: function optimisticExecutionStateRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreSession) OptimisticExecutionStateRoot() ([32]byte, error) {
	return _LightClientStore.Contract.OptimisticExecutionStateRoot(&_LightClientStore.CallOpts)
}

// OptimisticExecutionStateRoot is a free data retrieval call binding the contract method 0x39536c8f.
//
// Solidity: function optimisticExecutionStateRoot() view returns(bytes32)
func (_LightClientStore *LightClientStoreCallerSession) OptimisticExecutionStateRoot() ([32]byte, error) {
	return _LightClientStore.Contract.OptimisticExecutionStateRoot(&_LightClientStore.CallOpts)
}

// OptimisticSlot is a free data retrieval call binding the contract method 0x3cf5ea9e.
//
// Solidity: function optimisticSlot() view returns(uint64)
func (_LightClientStore *LightClientStoreCaller) OptimisticSlot(opts *bind.CallOpts) (uint64, error) {
	var out []interface{}
	err := _LightClientStore.contract.Call(opts, &out, "optimisticSlot")

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// OptimisticSlot is a free data retrieval call binding the contract method 0x3cf5ea9e.
//
// Solidity: function optimisticSlot() view returns(uint64)
func (_LightClientStore *LightClientStoreSession) OptimisticSlot() (uint64, error) {
	return _LightClientStore.Contract.OptimisticSlot(&_LightClientStore.CallOpts)
}

// OptimisticSlot is a free data retrieval call binding the contract method 0x3cf5ea9e.
//
// Solidity: function optimisticSlot() view returns(uint64)
func (_LightClientStore *LightClientStoreCallerSession) OptimisticSlot() (uint64, error) {
	return _LightClientStore.Contract.OptimisticSlot(&_LightClientStore.CallOpts)
}

// ZkVerifier is a free data retrieval call binding the contract method 0xd6df096d.
//
// Solidity: function zkVerifier() view returns(address)
func (_LightClientStore *LightClientStoreCaller) ZkVerifier(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _LightClientStore.contract.Call(opts, &out, "zkVerifier")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// ZkVerifier is a free data retrieval call binding the contract method 0xd6df096d.
//
// Solidity: function zkVerifier() view returns(address)
func (_LightClientStore *LightClientStoreSession) ZkVerifier() (common.Address, error) {
	return _LightClientStore.Contract.ZkVerifier(&_LightClientStore.CallOpts)
}

// ZkVerifier is a free data retrieval call binding the contract method 0xd6df096d.
//
// Solidity: function zkVerifier() view returns(address)
func (_LightClientStore *LightClientStoreCallerSession) ZkVerifier() (common.Address, error) {
	return _LightClientStore.Contract.ZkVerifier(&_LightClientStore.CallOpts)
}

// MerkleProofTreeMetaData contains all meta data concerning the MerkleProofTree contract.
var MerkleProofTreeMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212209b7c71a1f5c58712f919595af724b4f341c4079f1bdfcf25619fecbde1c3cf6964736f6c63430008140033",
}

// MerkleProofTreeABI is the input ABI used to generate the binding from.
// Deprecated: Use MerkleProofTreeMetaData.ABI instead.
var MerkleProofTreeABI = MerkleProofTreeMetaData.ABI

// MerkleProofTreeBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use MerkleProofTreeMetaData.Bin instead.
var MerkleProofTreeBin = MerkleProofTreeMetaData.Bin

// DeployMerkleProofTree deploys a new Ethereum contract, binding an instance of MerkleProofTree to it.
func DeployMerkleProofTree(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *MerkleProofTree, error) {
	parsed, err := MerkleProofTreeMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(MerkleProofTreeBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &MerkleProofTree{MerkleProofTreeCaller: MerkleProofTreeCaller{contract: contract}, MerkleProofTreeTransactor: MerkleProofTreeTransactor{contract: contract}, MerkleProofTreeFilterer: MerkleProofTreeFilterer{contract: contract}}, nil
}

// MerkleProofTree is an auto generated Go binding around an Ethereum contract.
type MerkleProofTree struct {
	MerkleProofTreeCaller     // Read-only binding to the contract
	MerkleProofTreeTransactor // Write-only binding to the contract
	MerkleProofTreeFilterer   // Log filterer for contract events
}

// MerkleProofTreeCaller is an auto generated read-only Go binding around an Ethereum contract.
type MerkleProofTreeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MerkleProofTreeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MerkleProofTreeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MerkleProofTreeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MerkleProofTreeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MerkleProofTreeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MerkleProofTreeSession struct {
	Contract     *MerkleProofTree  // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MerkleProofTreeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MerkleProofTreeCallerSession struct {
	Contract *MerkleProofTreeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts          // Call options to use throughout this session
}

// MerkleProofTreeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MerkleProofTreeTransactorSession struct {
	Contract     *MerkleProofTreeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts          // Transaction auth options to use throughout this session
}

// MerkleProofTreeRaw is an auto generated low-level Go binding around an Ethereum contract.
type MerkleProofTreeRaw struct {
	Contract *MerkleProofTree // Generic contract binding to access the raw methods on
}

// MerkleProofTreeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MerkleProofTreeCallerRaw struct {
	Contract *MerkleProofTreeCaller // Generic read-only contract binding to access the raw methods on
}

// MerkleProofTreeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MerkleProofTreeTransactorRaw struct {
	Contract *MerkleProofTreeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMerkleProofTree creates a new instance of MerkleProofTree, bound to a specific deployed contract.
func NewMerkleProofTree(address common.Address, backend bind.ContractBackend) (*MerkleProofTree, error) {
	contract, err := bindMerkleProofTree(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &MerkleProofTree{MerkleProofTreeCaller: MerkleProofTreeCaller{contract: contract}, MerkleProofTreeTransactor: MerkleProofTreeTransactor{contract: contract}, MerkleProofTreeFilterer: MerkleProofTreeFilterer{contract: contract}}, nil
}

// NewMerkleProofTreeCaller creates a new read-only instance of MerkleProofTree, bound to a specific deployed contract.
func NewMerkleProofTreeCaller(address common.Address, caller bind.ContractCaller) (*MerkleProofTreeCaller, error) {
	contract, err := bindMerkleProofTree(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MerkleProofTreeCaller{contract: contract}, nil
}

// NewMerkleProofTreeTransactor creates a new write-only instance of MerkleProofTree, bound to a specific deployed contract.
func NewMerkleProofTreeTransactor(address common.Address, transactor bind.ContractTransactor) (*MerkleProofTreeTransactor, error) {
	contract, err := bindMerkleProofTree(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MerkleProofTreeTransactor{contract: contract}, nil
}

// NewMerkleProofTreeFilterer creates a new log filterer instance of MerkleProofTree, bound to a specific deployed contract.
func NewMerkleProofTreeFilterer(address common.Address, filterer bind.ContractFilterer) (*MerkleProofTreeFilterer, error) {
	contract, err := bindMerkleProofTree(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MerkleProofTreeFilterer{contract: contract}, nil
}

// bindMerkleProofTree binds a generic wrapper to an already deployed contract.
func bindMerkleProofTree(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := MerkleProofTreeMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MerkleProofTree *MerkleProofTreeRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MerkleProofTree.Contract.MerkleProofTreeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MerkleProofTree *MerkleProofTreeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MerkleProofTree.Contract.MerkleProofTreeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MerkleProofTree *MerkleProofTreeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MerkleProofTree.Contract.MerkleProofTreeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MerkleProofTree *MerkleProofTreeCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MerkleProofTree.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MerkleProofTree *MerkleProofTreeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MerkleProofTree.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MerkleProofTree *MerkleProofTreeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MerkleProofTree.Contract.contract.Transact(opts, method, params...)
}

// MessageAppMetaData contains all meta data concerning the MessageApp contract.
var MessageAppMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"executeMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"messageBridge\",\"outputs\":[{\"internalType\":\"contractIMessageBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// MessageAppABI is the input ABI used to generate the binding from.
// Deprecated: Use MessageAppMetaData.ABI instead.
var MessageAppABI = MessageAppMetaData.ABI

// MessageApp is an auto generated Go binding around an Ethereum contract.
type MessageApp struct {
	MessageAppCaller     // Read-only binding to the contract
	MessageAppTransactor // Write-only binding to the contract
	MessageAppFilterer   // Log filterer for contract events
}

// MessageAppCaller is an auto generated read-only Go binding around an Ethereum contract.
type MessageAppCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageAppTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MessageAppTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageAppFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MessageAppFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageAppSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MessageAppSession struct {
	Contract     *MessageApp       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MessageAppCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MessageAppCallerSession struct {
	Contract *MessageAppCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// MessageAppTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MessageAppTransactorSession struct {
	Contract     *MessageAppTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// MessageAppRaw is an auto generated low-level Go binding around an Ethereum contract.
type MessageAppRaw struct {
	Contract *MessageApp // Generic contract binding to access the raw methods on
}

// MessageAppCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MessageAppCallerRaw struct {
	Contract *MessageAppCaller // Generic read-only contract binding to access the raw methods on
}

// MessageAppTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MessageAppTransactorRaw struct {
	Contract *MessageAppTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMessageApp creates a new instance of MessageApp, bound to a specific deployed contract.
func NewMessageApp(address common.Address, backend bind.ContractBackend) (*MessageApp, error) {
	contract, err := bindMessageApp(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &MessageApp{MessageAppCaller: MessageAppCaller{contract: contract}, MessageAppTransactor: MessageAppTransactor{contract: contract}, MessageAppFilterer: MessageAppFilterer{contract: contract}}, nil
}

// NewMessageAppCaller creates a new read-only instance of MessageApp, bound to a specific deployed contract.
func NewMessageAppCaller(address common.Address, caller bind.ContractCaller) (*MessageAppCaller, error) {
	contract, err := bindMessageApp(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MessageAppCaller{contract: contract}, nil
}

// NewMessageAppTransactor creates a new write-only instance of MessageApp, bound to a specific deployed contract.
func NewMessageAppTransactor(address common.Address, transactor bind.ContractTransactor) (*MessageAppTransactor, error) {
	contract, err := bindMessageApp(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MessageAppTransactor{contract: contract}, nil
}

// NewMessageAppFilterer creates a new log filterer instance of MessageApp, bound to a specific deployed contract.
func NewMessageAppFilterer(address common.Address, filterer bind.ContractFilterer) (*MessageAppFilterer, error) {
	contract, err := bindMessageApp(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MessageAppFilterer{contract: contract}, nil
}

// bindMessageApp binds a generic wrapper to an already deployed contract.
func bindMessageApp(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := MessageAppMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MessageApp *MessageAppRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MessageApp.Contract.MessageAppCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MessageApp *MessageAppRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MessageApp.Contract.MessageAppTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MessageApp *MessageAppRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MessageApp.Contract.MessageAppTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MessageApp *MessageAppCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MessageApp.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MessageApp *MessageAppTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MessageApp.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MessageApp *MessageAppTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MessageApp.Contract.contract.Transact(opts, method, params...)
}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_MessageApp *MessageAppCaller) MessageBridge(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _MessageApp.contract.Call(opts, &out, "messageBridge")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_MessageApp *MessageAppSession) MessageBridge() (common.Address, error) {
	return _MessageApp.Contract.MessageBridge(&_MessageApp.CallOpts)
}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_MessageApp *MessageAppCallerSession) MessageBridge() (common.Address, error) {
	return _MessageApp.Contract.MessageBridge(&_MessageApp.CallOpts)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 srcChainId, address sender, bytes message, address executor) returns(bool)
func (_MessageApp *MessageAppTransactor) ExecuteMessage(opts *bind.TransactOpts, srcChainId uint64, sender common.Address, message []byte, executor common.Address) (*types.Transaction, error) {
	return _MessageApp.contract.Transact(opts, "executeMessage", srcChainId, sender, message, executor)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 srcChainId, address sender, bytes message, address executor) returns(bool)
func (_MessageApp *MessageAppSession) ExecuteMessage(srcChainId uint64, sender common.Address, message []byte, executor common.Address) (*types.Transaction, error) {
	return _MessageApp.Contract.ExecuteMessage(&_MessageApp.TransactOpts, srcChainId, sender, message, executor)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 srcChainId, address sender, bytes message, address executor) returns(bool)
func (_MessageApp *MessageAppTransactorSession) ExecuteMessage(srcChainId uint64, sender common.Address, message []byte, executor common.Address) (*types.Transaction, error) {
	return _MessageApp.Contract.ExecuteMessage(&_MessageApp.TransactOpts, srcChainId, sender, message, executor)
}

// MessageBridgeMetaData contains all meta data concerning the MessageBridge contract.
var MessageBridgeMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"MessageCallReverted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"name\":\"MessageExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"dstChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"MessageSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"_accountProof\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_storageProof\",\"type\":\"bytes[]\"}],\"name\":\"executeMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_zkProofData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_blkVerifyInfo\",\"type\":\"bytes\"}],\"name\":\"executeMessageWithZkProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"}],\"name\":\"getExecutionStateRootAndSlot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"slot\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lightClients\",\"outputs\":[{\"internalType\":\"contractIEthereumLightClient\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"preExecuteMessageGasUsage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"receivedMessages\",\"outputs\":[{\"internalType\":\"enumIMessageBridge.MessageStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"remoteMessageBridgeHashes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"remoteMessageBridges\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_dstChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"sendMessage\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"sentMessages\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_lightClient\",\"type\":\"address\"}],\"name\":\"setLightClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_usage\",\"type\":\"uint256\"}],\"name\":\"setPreExecuteMessageGasUsage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_remoteMessageBridge\",\"type\":\"address\"}],\"name\":\"setRemoteMessageBridge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_slotValueVerifier\",\"type\":\"address\"}],\"name\":\"setSlotValueVerifier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slotValueVerifier\",\"outputs\":[{\"internalType\":\"contractISlotValueVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x6080806040523461005d5760015f8181558154336001600160a01b0319821681179093556001600160a01b0316907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09080a3611f1c90816100628239f35b5f80fdfe60806040526004361015610011575f80fd5b5f3560e01c80630bbd09ab14610144578063127387081461013f578063456cb9f61461013a5780634586f331146101355780634f256d8114610130578063584e45e11461012b57806363c6ccb2146101265780636b217c0d146101215780636e98da7d1461011c578063715018a614610117578063735267cf146101125780638da5cb5b1461010d578063903e4d1e14610108578063970b324014610103578063975f5e1f146100fe578063affed0e0146100f9578063b90b8352146100f4578063f2fde38b146100ef5763f69f8151146100ea575f80fd5b61089c565b6107f1565b610704565b6106dd565b61066a565b61063d565b610600565b6105da565b610593565b610531565b6104f2565b6104c5565b61049f565b610482565b6103e3565b610389565b610365565b61029e565b6101c6565b67ffffffffffffffff81160361015b57565b5f80fd5b6024359061016c82610149565b565b602435906001600160a01b038216820361015b57565b604435906001600160a01b038216820361015b57565b606435906001600160a01b038216820361015b57565b600435906001600160a01b038216820361015b57565b3461015b57604036600319011261015b576004356101e381610149565b67ffffffffffffffff6101f461016e565b9161020b6001600160a01b03600154163314610c32565b165f81815260066020526040812080546001600160a01b0319166001600160a01b0385161790559160405160208101916bffffffffffffffffffffffff199060601b1682526014815261025d81610c91565b5190209082526007602052604082205580f35b9181601f8401121561015b5782359167ffffffffffffffff831161015b576020838186019501011161015b57565b3461015b5760e036600319011261015b576004356102bb81610149565b6102c361015f565b906102cc610184565b916102d561019a565b67ffffffffffffffff929060843584811161015b576102f8903690600401610270565b60a49291923586811161015b57610313903690600401610270565b93909260c43597881161015b5761034f9861033561033d993690600401610270565b989097610b27565b60405190151581529081906020820190565b0390f35b602090600319011261015b5760043590565b3461015b5761037336610353565b5f526007602052602060405f2054604051908152f35b3461015b5761039736610353565b6103ad6001600160a01b03600154163314610c32565b600955005b9181601f8401121561015b5782359167ffffffffffffffff831161015b576020808501948460051b01011161015b57565b3461015b5760e036600319011261015b5760043561040081610149565b61040861015f565b90610411610184565b9161041a61019a565b67ffffffffffffffff929060843584811161015b5761043d903690600401610270565b60a49291923586811161015b576104589036906004016103b2565b93909260c43597881161015b5761034f9861047a61033d9936906004016103b2565b9890976109a2565b3461015b575f36600319011261015b576020600954604051908152f35b3461015b575f36600319011261015b5760206001600160a01b0360085416604051908152f35b3461015b576104d336610353565b5f52600660205260206001600160a01b0360405f205416604051908152f35b3461015b57602036600319011261015b57604067ffffffffffffffff61052260043561051d81610149565b610cdf565b83519182529091166020820152f35b3461015b575f8060031936011261059057806001546001600160a01b03196001600160a01b03821691610565338414610c32565b166001557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b80fd5b3461015b57602036600319011261015b576105ac6101b0565b6001600160a01b03906105c482600154163314610c32565b166001600160a01b031960085416176008555f80f35b3461015b575f36600319011261015b5760206001600160a01b0360015416604051908152f35b3461015b57602036600319011261015b5767ffffffffffffffff60043561062681610149565b165f526002602052602060405f2054604051908152f35b3461015b5761064b36610353565b5f52600560205260206001600160a01b0360405f205416604051908152f35b3461015b57604036600319011261015b576106db60043561068a81610149565b61069261016e565b67ffffffffffffffff6001600160a01b03926106b384600154163314610c32565b165f5260056020521660405f20906001600160a01b03166001600160a01b0319825416179055565b005b3461015b575f36600319011261015b57602067ffffffffffffffff60035416604051908152f35b3461015b57606036600319011261015b5760043561072181610149565b61072961016e565b67ffffffffffffffff60443581811161015b5761074a903690600401610270565b82600354169361076182848887461685338b6118c2565b945f5260026020528460405f205583600354169384146107ec5761034f956107d97fd4c077d3ac449bc1b439559b537c6550f793c2432e3d74082b023162296dc5669387956107cb6001890167ffffffffffffffff1667ffffffffffffffff196003541617600355565b60405194859433908661091a565b0390a36040519081529081906020820190565b6108e6565b3461015b57602036600319011261015b5761080a6101b0565b6001600160a01b0361082181600154163314610c32565b811615610831576106db90611e9f565b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608490fd5b3461015b57602036600319011261015b576004355f52600460205260ff60405f20541660405160038210156108d2576020918152f35b634e487b7160e01b5f52602160045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b908060209392818452848401375f828201840152601f01601f1916010190565b9091610953959367ffffffffffffffff6080941683526001600160a01b03809216602084015216604082015281606082015201916108fa565b90565b1561095d57565b60405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606490fd5b92959093969194976109b860025f541415610956565b60025f556109ca898989898989610d70565b9a90936109d686610cdf565b50938415610abc57610ab29c610a598795610aa795610a9b610a81610a7b610a69610a648f8b610aad9f8c610a50610aa29f94610a5f9f610a5994610a2b610a24610a5f99610a3894610e8d565b3691610ef6565b6020815191012014611074565b67ffffffffffffffff165f52600760205260405f2090565b54923691610f9c565b90611789565b611af9565b611b1f565b610a7660048251146110e6565b611158565b51611c14565b610a8e610a248486610e8d565b6020815191012014610f2c565b3691610f9c565b611c14565b1461101c565b611450565b9061016c60015f55565b60405162461bcd60e51b815260206004820152602d60248201527f4d6573736167654272696467653a20657865637574696f6e207374617465207260448201527f6f6f74206e6f7420666f756e64000000000000000000000000000000000000006064820152608490fd5b929590939691949760c090610b4060025f541415610956565b60025f55610b528a8a8a8a8a8a610d70565b939094610b76610b6a6008546001600160a01b031690565b6001600160a01b031690565b91610b986040519e8f9586948594630b885e5360e01b86528c60048701611212565b03915afa988915610c2d57610ab299610aad926020925f92610bf9575b50610bc590606083015114611248565b610bd48460808301511461129e565b0151610bf28467ffffffffffffffff165f52600760205260405f2090565b54146112f6565b610bc5919250610c1f9060c03d8111610c26575b610c178183610cb2565b810190611199565b9190610bb5565b503d610c0d565b610cd4565b15610c3957565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b634e487b7160e01b5f52604160045260245ffd5b6040810190811067ffffffffffffffff821117610cad57604052565b610c7d565b90601f8019910116810190811067ffffffffffffffff821117610cad57604052565b6040513d5f823e3d90fd5b9067ffffffffffffffff5f92168252600560205260406004816001600160a01b0381862054168151928380926321d362d360e11b82525afa938415610c2d5780928195610d2e575b5050509190565b919450915083813d8111610d69575b610d478183610cb2565b8101031261059057506020825192015191610d6183610149565b5f8080610d27565b503d610d3d565b610d8b94929196959367ffffffffffffffff461692886118c2565b91825f52600460205260ff60405f20541660038110156108d257610e0e576040519081610dd4602082019283602060029193929367ffffffffffffffff60408201951681520152565b0391610de8601f1993848101835282610cb2565b51902060408051602081019283529281018352909190610e089082610cb2565b51902090565b60405162461bcd60e51b815260206004820152602760248201527f4d6573736167654272696467653a206d65737361676520616c7265616479206560448201527f78656375746564000000000000000000000000000000000000000000000000006064820152608490fd5b634e487b7160e01b5f52603260045260245ffd5b9015610ec857803590601e198136030182121561015b57019081359167ffffffffffffffff831161015b57602001823603811361015b579190565b610e79565b6040519061016c82610c91565b67ffffffffffffffff8111610cad57601f01601f191660200190565b929192610f0282610eda565b91610f106040519384610cb2565b82948184528183011161015b578281602093845f960137010152565b15610f3357565b60405162461bcd60e51b815260206004820152602360248201527f4d6573736167654272696467653a20696e76616c69642073746f7261676520726044820152621bdbdd60ea1b6064820152608490fd5b67ffffffffffffffff8111610cad5760051b60200190565b92919092610fa984610f84565b91610fb76040519384610cb2565b829480845260208094019060051b83019282841161015b5780915b848310610fe157505050505050565b823567ffffffffffffffff811161015b57820184601f8201121561015b5786916110118683858095359101610ef6565b815201920191610fd2565b1561102357565b60405162461bcd60e51b815260206004820152602360248201527f4d6573736167654272696467653a20696e76616c6964206d65737361676520686044820152620c2e6d60eb1b6064820152608490fd5b1561107b57565b60405162461bcd60e51b815260206004820152602960248201527f4d6573736167654272696467653a20696e76616c6964206163636f756e74207060448201527f726f6f6620726f6f7400000000000000000000000000000000000000000000006064820152608490fd5b156110ed57565b60405162461bcd60e51b815260206004820152602f60248201527f4d6573736167654272696467653a20696e76616c6964206163636f756e74206460448201527f65636f6465642066726f6d20524c5000000000000000000000000000000000006064820152608490fd5b805160021015610ec85760600190565b805115610ec85760200190565b805160011015610ec85760400190565b8051821015610ec85760209160051b010190565b908160c091031261015b576040519060c082019082821067ffffffffffffffff831117610cad5760a09160405280516111d181610149565b835260208101516020840152604081015160408401526060810151606084015260808101516080840152015163ffffffff8116810361015b5760a082015290565b9391610953959367ffffffffffffffff61123a931686526060602087015260608601916108fa565b9260408185039101526108fa565b1561124f57565b60405162461bcd60e51b815260206004820152602160248201527f4d6573736167654272696467653a20736c6f74206b6579206e6f74206d6174636044820152600d60fb1b6064820152608490fd5b156112a557565b60405162461bcd60e51b815260206004820152602360248201527f4d6573736167654272696467653a20736c6f742076616c7565206e6f74206d616044820152620e8c6d60eb1b6064820152608490fd5b156112fd57565b60405162461bcd60e51b815260206004820152602560248201527f4d6573736167654272696467653a2073726320636f6e7472616374206e6f742060448201527f6d617463680000000000000000000000000000000000000000000000000000006064820152608490fd5b939260609367ffffffffffffffff6113a1939897981686526001600160a01b0380941660208701526080604087015260808601916108fa565b9416910152565b3d156113d2573d906113b982610eda565b916113c76040519384610cb2565b82523d5f602084013e565b606090565b9081602091031261015b5751801515810361015b5790565b9060038110156108d25760ff80198354169116179055565b9490916114489367ffffffffffffffff608096949998991687526001600160a01b03809216602088015216604086015260a0606086015260a08501916108fa565b931515910152565b939590949291925f604051905f8060208401632bb2568560e21b8152611490856114828d8a8a8d339360248701611368565b03601f198101875286610cb2565b5a945190828d5af1916114a16113a8565b9215611532575050927fbf79e9ebbcf1fdc699f3a386de83f09cb080ab7e07f7b872118a93aef293102d9492611522926114ed8660208067ffffffffffffffff995183010191016113d7565b998a935b84156115285761151460015b61150f8c5f52600460205260405f2090565b6113ef565b604051978897169a87611407565b0390a390565b61151460026114fd565b92819967ffffffffffffffff966115717fbf79e9ebbcf1fdc699f3a386de83f09cb080ab7e07f7b872118a93aef293102d99979495611522978c611614565b6114f1565b60bf198101919082116107ec57565b607f198101919082116107ec57565b60200390602082116107ec57565b5f198101919082116107ec57565b60f6198101919082116107ec57565b60b6198101919082116107ec57565b5f5b8381106115df5750505f910152565b81810151838201526020016115d0565b90602091611608815180928185528580860191016115ce565b601f01601f1916010190565b905a60095445034581116107ec5782109182611688575b50506116865761165b7fc666137142d7507d306f3aee4e2e08927034d27fc7c790316e8860c69782c94e92611952565b9061166582611a18565b61168160405192839283526040602084015260408301906115ef565b0390a1565bfe5b60061c101590505f8061162b565b1561169d57565b60405162461bcd60e51b815260206004820152602760248201527f4d6573736167654272696467653a2049696e76616c696420524c50206c69737460448201527f206c656e677468000000000000000000000000000000000000000000000000006064820152608490fd5b90600182018092116107ec57565b919082018092116107ec57565b5f1981146107ec5760010190565b1561173857565b60405162461bcd60e51b815260206004820152602360248201527f4d6573736167654272696467653a206e6f64652068617368206d69736d6174636044820152621a195960ea1b6064820152608490fd5b905f9061179581611168565b51926117a4610a648495611af9565b938451601181145f1461180e575090919293610a646117e76117e1610a7b6117a494600f886117d289611723565b98603f0360021b1c1690611185565b96611723565b956118046117f58888611185565b51918251602084012014611731565b9594939295611af9565b600261181a9114611696565b61183d61183761183261182c88611168565b51611c82565b61187d565b92611716565b9015611853575050505061182c61095391611175565b90919293610a646117e76117e1610a7b6117a494611175565b908151811015610ec8570160200190565b90815115610ec857602082015160fc1c91515f1981019081116107ec578060011b90808204600214901517156107ec576001831681018091116107ec57600190921190565b949580919660609493610e0896604051988996602088019b8c947fffffffffffffffff0000000000000000000000000000000000000000000000009586809560c01b1690526bffffffffffffffffffffffff1980928c1b1660288b01528a1b16603c89015260c01b16605087015260c01b1660588501528484013781015f83820152036040810184520182610cb2565b60448151106119cd5760048101518101906020816024840193031261015b5760248101519067ffffffffffffffff821161015b57018160438201121561015b5760248101516119a081610eda565b926119ae6040519485610cb2565b8184526044828401011161015b576109539160446020850191016115ce565b506040516119da81610c91565b601d81527f5472616e73616374696f6e2072657665727465642073696c656e746c79000000602082015290565b9060206109539281815201906115ef565b604051611a2481610c91565b600b81527f4d53473a3a41424f52543a0000000000000000000000000000000000000000006020820152600b82511015611a5c575050565b5f5b8151811015611ac357611a82611a74828561186c565b516001600160f81b03191690565b611a9f611a92611a74848661186c565b6001600160f81b03191690565b6001600160f81b031990911603611abe57611ab990611723565b611a5e565b505050565b60405162461bcd60e51b815280611add8560048301611a07565b0390fd5b60405190611aee82610c91565b5f6020838281520152565b611b01611ae1565b50602081519160405192611b1484610c91565b835201602082015290565b611b2881611bf0565b1561015b57611b3681611ccf565b611b3f81610f84565b91611b4d6040519384610cb2565b818352601f19611b5c83610f84565b015f5b818110611bd9575050611b80602080920151611b7a81611db5565b90611716565b5f905b838210611b91575050505090565b611bcd81611ba1611bd393611d30565b90611baa610ecd565b8281528187820152611bbc868a611185565b52611bc78589611185565b50611716565b91611723565b90611b83565b602090611be4611ae1565b82828801015201611b5f565b805115611c0f57602060c0910151515f1a10611c0b57600190565b5f90565b505f90565b80518015159081611c4a575b501561015b57611c2f90611c56565b90519060208110611c3e575090565b6020036101000a900490565b6021915011155f611c20565b906020820191611c668351611db5565b9251908382018092116107ec57519283039283116107ec579190565b80511561015b57611c9561095391611c56565b611ca181939293610eda565b92611caf6040519485610cb2565b818452601f19611cbe83610eda565b013660208601378360200190611e22565b805115611c0f575f9060208101908151611ce881611db5565b81018091116107ec579151905181018091116107ec5791905b828110611d0e5750905090565b611d1781611d30565b81018091116107ec57611d2a9091611723565b90611d01565b80515f1a906080821015611d45575050600190565b60b8821015611d605750611d5b61095391611585565b611708565b9060c0811015611d845760b51991600160b783602003016101000a91015104010190565b9060f8821015611d9b5750611d5b61095391611576565b60010151602082900360f7016101000a90040160f5190190565b515f1a6080811015611dc657505f90565b60b881108015611dfd575b15611ddc5750600190565b60c0811015611df157611d5b610953916115bf565b611d5b610953916115b0565b5060c08110158015611dd1575060f88110611dd1565b601f81116107ec576101000a90565b929091928315611e995792915b602093848410611e6457805182528481018091116107ec579381018091116107ec5791601f1981019081116107ec5791611e2f565b9193509180611e7257505050565b611e86611e81611e8b92611594565b611e13565b6115a2565b905182518216911916179052565b50915050565b600154906001600160a01b0380911691826001600160a01b0319821617600155167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a356fea2646970667358221220c1c17d6aed0b3e87c102e99468c362280aa40753d64407692b6f5fa86d7dfbd764736f6c63430008140033",
}

// MessageBridgeABI is the input ABI used to generate the binding from.
// Deprecated: Use MessageBridgeMetaData.ABI instead.
var MessageBridgeABI = MessageBridgeMetaData.ABI

// MessageBridgeBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use MessageBridgeMetaData.Bin instead.
var MessageBridgeBin = MessageBridgeMetaData.Bin

// DeployMessageBridge deploys a new Ethereum contract, binding an instance of MessageBridge to it.
func DeployMessageBridge(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *MessageBridge, error) {
	parsed, err := MessageBridgeMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(MessageBridgeBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &MessageBridge{MessageBridgeCaller: MessageBridgeCaller{contract: contract}, MessageBridgeTransactor: MessageBridgeTransactor{contract: contract}, MessageBridgeFilterer: MessageBridgeFilterer{contract: contract}}, nil
}

// MessageBridge is an auto generated Go binding around an Ethereum contract.
type MessageBridge struct {
	MessageBridgeCaller     // Read-only binding to the contract
	MessageBridgeTransactor // Write-only binding to the contract
	MessageBridgeFilterer   // Log filterer for contract events
}

// MessageBridgeCaller is an auto generated read-only Go binding around an Ethereum contract.
type MessageBridgeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageBridgeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MessageBridgeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageBridgeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MessageBridgeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageBridgeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MessageBridgeSession struct {
	Contract     *MessageBridge    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MessageBridgeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MessageBridgeCallerSession struct {
	Contract *MessageBridgeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// MessageBridgeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MessageBridgeTransactorSession struct {
	Contract     *MessageBridgeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// MessageBridgeRaw is an auto generated low-level Go binding around an Ethereum contract.
type MessageBridgeRaw struct {
	Contract *MessageBridge // Generic contract binding to access the raw methods on
}

// MessageBridgeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MessageBridgeCallerRaw struct {
	Contract *MessageBridgeCaller // Generic read-only contract binding to access the raw methods on
}

// MessageBridgeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MessageBridgeTransactorRaw struct {
	Contract *MessageBridgeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMessageBridge creates a new instance of MessageBridge, bound to a specific deployed contract.
func NewMessageBridge(address common.Address, backend bind.ContractBackend) (*MessageBridge, error) {
	contract, err := bindMessageBridge(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &MessageBridge{MessageBridgeCaller: MessageBridgeCaller{contract: contract}, MessageBridgeTransactor: MessageBridgeTransactor{contract: contract}, MessageBridgeFilterer: MessageBridgeFilterer{contract: contract}}, nil
}

// NewMessageBridgeCaller creates a new read-only instance of MessageBridge, bound to a specific deployed contract.
func NewMessageBridgeCaller(address common.Address, caller bind.ContractCaller) (*MessageBridgeCaller, error) {
	contract, err := bindMessageBridge(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MessageBridgeCaller{contract: contract}, nil
}

// NewMessageBridgeTransactor creates a new write-only instance of MessageBridge, bound to a specific deployed contract.
func NewMessageBridgeTransactor(address common.Address, transactor bind.ContractTransactor) (*MessageBridgeTransactor, error) {
	contract, err := bindMessageBridge(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MessageBridgeTransactor{contract: contract}, nil
}

// NewMessageBridgeFilterer creates a new log filterer instance of MessageBridge, bound to a specific deployed contract.
func NewMessageBridgeFilterer(address common.Address, filterer bind.ContractFilterer) (*MessageBridgeFilterer, error) {
	contract, err := bindMessageBridge(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MessageBridgeFilterer{contract: contract}, nil
}

// bindMessageBridge binds a generic wrapper to an already deployed contract.
func bindMessageBridge(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := MessageBridgeMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MessageBridge *MessageBridgeRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MessageBridge.Contract.MessageBridgeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MessageBridge *MessageBridgeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MessageBridge.Contract.MessageBridgeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MessageBridge *MessageBridgeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MessageBridge.Contract.MessageBridgeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MessageBridge *MessageBridgeCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MessageBridge.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MessageBridge *MessageBridgeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MessageBridge.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MessageBridge *MessageBridgeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MessageBridge.Contract.contract.Transact(opts, method, params...)
}

// GetExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x6e98da7d.
//
// Solidity: function getExecutionStateRootAndSlot(uint64 _chainId) view returns(bytes32 root, uint64 slot)
func (_MessageBridge *MessageBridgeCaller) GetExecutionStateRootAndSlot(opts *bind.CallOpts, _chainId uint64) (struct {
	Root [32]byte
	Slot uint64
}, error) {
	var out []interface{}
	err := _MessageBridge.contract.Call(opts, &out, "getExecutionStateRootAndSlot", _chainId)

	outstruct := new(struct {
		Root [32]byte
		Slot uint64
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Root = *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)
	outstruct.Slot = *abi.ConvertType(out[1], new(uint64)).(*uint64)

	return *outstruct, err

}

// GetExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x6e98da7d.
//
// Solidity: function getExecutionStateRootAndSlot(uint64 _chainId) view returns(bytes32 root, uint64 slot)
func (_MessageBridge *MessageBridgeSession) GetExecutionStateRootAndSlot(_chainId uint64) (struct {
	Root [32]byte
	Slot uint64
}, error) {
	return _MessageBridge.Contract.GetExecutionStateRootAndSlot(&_MessageBridge.CallOpts, _chainId)
}

// GetExecutionStateRootAndSlot is a free data retrieval call binding the contract method 0x6e98da7d.
//
// Solidity: function getExecutionStateRootAndSlot(uint64 _chainId) view returns(bytes32 root, uint64 slot)
func (_MessageBridge *MessageBridgeCallerSession) GetExecutionStateRootAndSlot(_chainId uint64) (struct {
	Root [32]byte
	Slot uint64
}, error) {
	return _MessageBridge.Contract.GetExecutionStateRootAndSlot(&_MessageBridge.CallOpts, _chainId)
}

// LightClients is a free data retrieval call binding the contract method 0x970b3240.
//
// Solidity: function lightClients(uint256 ) view returns(address)
func (_MessageBridge *MessageBridgeCaller) LightClients(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _MessageBridge.contract.Call(opts, &out, "lightClients", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// LightClients is a free data retrieval call binding the contract method 0x970b3240.
//
// Solidity: function lightClients(uint256 ) view returns(address)
func (_MessageBridge *MessageBridgeSession) LightClients(arg0 *big.Int) (common.Address, error) {
	return _MessageBridge.Contract.LightClients(&_MessageBridge.CallOpts, arg0)
}

// LightClients is a free data retrieval call binding the contract method 0x970b3240.
//
// Solidity: function lightClients(uint256 ) view returns(address)
func (_MessageBridge *MessageBridgeCallerSession) LightClients(arg0 *big.Int) (common.Address, error) {
	return _MessageBridge.Contract.LightClients(&_MessageBridge.CallOpts, arg0)
}

// Nonce is a free data retrieval call binding the contract method 0xaffed0e0.
//
// Solidity: function nonce() view returns(uint64)
func (_MessageBridge *MessageBridgeCaller) Nonce(opts *bind.CallOpts) (uint64, error) {
	var out []interface{}
	err := _MessageBridge.contract.Call(opts, &out, "nonce")

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// Nonce is a free data retrieval call binding the contract method 0xaffed0e0.
//
// Solidity: function nonce() view returns(uint64)
func (_MessageBridge *MessageBridgeSession) Nonce() (uint64, error) {
	return _MessageBridge.Contract.Nonce(&_MessageBridge.CallOpts)
}

// Nonce is a free data retrieval call binding the contract method 0xaffed0e0.
//
// Solidity: function nonce() view returns(uint64)
func (_MessageBridge *MessageBridgeCallerSession) Nonce() (uint64, error) {
	return _MessageBridge.Contract.Nonce(&_MessageBridge.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_MessageBridge *MessageBridgeCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _MessageBridge.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_MessageBridge *MessageBridgeSession) Owner() (common.Address, error) {
	return _MessageBridge.Contract.Owner(&_MessageBridge.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_MessageBridge *MessageBridgeCallerSession) Owner() (common.Address, error) {
	return _MessageBridge.Contract.Owner(&_MessageBridge.CallOpts)
}

// PreExecuteMessageGasUsage is a free data retrieval call binding the contract method 0x584e45e1.
//
// Solidity: function preExecuteMessageGasUsage() view returns(uint256)
func (_MessageBridge *MessageBridgeCaller) PreExecuteMessageGasUsage(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _MessageBridge.contract.Call(opts, &out, "preExecuteMessageGasUsage")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// PreExecuteMessageGasUsage is a free data retrieval call binding the contract method 0x584e45e1.
//
// Solidity: function preExecuteMessageGasUsage() view returns(uint256)
func (_MessageBridge *MessageBridgeSession) PreExecuteMessageGasUsage() (*big.Int, error) {
	return _MessageBridge.Contract.PreExecuteMessageGasUsage(&_MessageBridge.CallOpts)
}

// PreExecuteMessageGasUsage is a free data retrieval call binding the contract method 0x584e45e1.
//
// Solidity: function preExecuteMessageGasUsage() view returns(uint256)
func (_MessageBridge *MessageBridgeCallerSession) PreExecuteMessageGasUsage() (*big.Int, error) {
	return _MessageBridge.Contract.PreExecuteMessageGasUsage(&_MessageBridge.CallOpts)
}

// ReceivedMessages is a free data retrieval call binding the contract method 0xf69f8151.
//
// Solidity: function receivedMessages(bytes32 ) view returns(uint8)
func (_MessageBridge *MessageBridgeCaller) ReceivedMessages(opts *bind.CallOpts, arg0 [32]byte) (uint8, error) {
	var out []interface{}
	err := _MessageBridge.contract.Call(opts, &out, "receivedMessages", arg0)

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// ReceivedMessages is a free data retrieval call binding the contract method 0xf69f8151.
//
// Solidity: function receivedMessages(bytes32 ) view returns(uint8)
func (_MessageBridge *MessageBridgeSession) ReceivedMessages(arg0 [32]byte) (uint8, error) {
	return _MessageBridge.Contract.ReceivedMessages(&_MessageBridge.CallOpts, arg0)
}

// ReceivedMessages is a free data retrieval call binding the contract method 0xf69f8151.
//
// Solidity: function receivedMessages(bytes32 ) view returns(uint8)
func (_MessageBridge *MessageBridgeCallerSession) ReceivedMessages(arg0 [32]byte) (uint8, error) {
	return _MessageBridge.Contract.ReceivedMessages(&_MessageBridge.CallOpts, arg0)
}

// RemoteMessageBridgeHashes is a free data retrieval call binding the contract method 0x456cb9f6.
//
// Solidity: function remoteMessageBridgeHashes(uint256 ) view returns(bytes32)
func (_MessageBridge *MessageBridgeCaller) RemoteMessageBridgeHashes(opts *bind.CallOpts, arg0 *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _MessageBridge.contract.Call(opts, &out, "remoteMessageBridgeHashes", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// RemoteMessageBridgeHashes is a free data retrieval call binding the contract method 0x456cb9f6.
//
// Solidity: function remoteMessageBridgeHashes(uint256 ) view returns(bytes32)
func (_MessageBridge *MessageBridgeSession) RemoteMessageBridgeHashes(arg0 *big.Int) ([32]byte, error) {
	return _MessageBridge.Contract.RemoteMessageBridgeHashes(&_MessageBridge.CallOpts, arg0)
}

// RemoteMessageBridgeHashes is a free data retrieval call binding the contract method 0x456cb9f6.
//
// Solidity: function remoteMessageBridgeHashes(uint256 ) view returns(bytes32)
func (_MessageBridge *MessageBridgeCallerSession) RemoteMessageBridgeHashes(arg0 *big.Int) ([32]byte, error) {
	return _MessageBridge.Contract.RemoteMessageBridgeHashes(&_MessageBridge.CallOpts, arg0)
}

// RemoteMessageBridges is a free data retrieval call binding the contract method 0x6b217c0d.
//
// Solidity: function remoteMessageBridges(uint256 ) view returns(address)
func (_MessageBridge *MessageBridgeCaller) RemoteMessageBridges(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _MessageBridge.contract.Call(opts, &out, "remoteMessageBridges", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// RemoteMessageBridges is a free data retrieval call binding the contract method 0x6b217c0d.
//
// Solidity: function remoteMessageBridges(uint256 ) view returns(address)
func (_MessageBridge *MessageBridgeSession) RemoteMessageBridges(arg0 *big.Int) (common.Address, error) {
	return _MessageBridge.Contract.RemoteMessageBridges(&_MessageBridge.CallOpts, arg0)
}

// RemoteMessageBridges is a free data retrieval call binding the contract method 0x6b217c0d.
//
// Solidity: function remoteMessageBridges(uint256 ) view returns(address)
func (_MessageBridge *MessageBridgeCallerSession) RemoteMessageBridges(arg0 *big.Int) (common.Address, error) {
	return _MessageBridge.Contract.RemoteMessageBridges(&_MessageBridge.CallOpts, arg0)
}

// SentMessages is a free data retrieval call binding the contract method 0x903e4d1e.
//
// Solidity: function sentMessages(uint64 ) view returns(bytes32)
func (_MessageBridge *MessageBridgeCaller) SentMessages(opts *bind.CallOpts, arg0 uint64) ([32]byte, error) {
	var out []interface{}
	err := _MessageBridge.contract.Call(opts, &out, "sentMessages", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// SentMessages is a free data retrieval call binding the contract method 0x903e4d1e.
//
// Solidity: function sentMessages(uint64 ) view returns(bytes32)
func (_MessageBridge *MessageBridgeSession) SentMessages(arg0 uint64) ([32]byte, error) {
	return _MessageBridge.Contract.SentMessages(&_MessageBridge.CallOpts, arg0)
}

// SentMessages is a free data retrieval call binding the contract method 0x903e4d1e.
//
// Solidity: function sentMessages(uint64 ) view returns(bytes32)
func (_MessageBridge *MessageBridgeCallerSession) SentMessages(arg0 uint64) ([32]byte, error) {
	return _MessageBridge.Contract.SentMessages(&_MessageBridge.CallOpts, arg0)
}

// SlotValueVerifier is a free data retrieval call binding the contract method 0x63c6ccb2.
//
// Solidity: function slotValueVerifier() view returns(address)
func (_MessageBridge *MessageBridgeCaller) SlotValueVerifier(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _MessageBridge.contract.Call(opts, &out, "slotValueVerifier")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SlotValueVerifier is a free data retrieval call binding the contract method 0x63c6ccb2.
//
// Solidity: function slotValueVerifier() view returns(address)
func (_MessageBridge *MessageBridgeSession) SlotValueVerifier() (common.Address, error) {
	return _MessageBridge.Contract.SlotValueVerifier(&_MessageBridge.CallOpts)
}

// SlotValueVerifier is a free data retrieval call binding the contract method 0x63c6ccb2.
//
// Solidity: function slotValueVerifier() view returns(address)
func (_MessageBridge *MessageBridgeCallerSession) SlotValueVerifier() (common.Address, error) {
	return _MessageBridge.Contract.SlotValueVerifier(&_MessageBridge.CallOpts)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0x4f256d81.
//
// Solidity: function executeMessage(uint64 _srcChainId, uint64 _nonce, address _sender, address _receiver, bytes _message, bytes[] _accountProof, bytes[] _storageProof) returns(bool success)
func (_MessageBridge *MessageBridgeTransactor) ExecuteMessage(opts *bind.TransactOpts, _srcChainId uint64, _nonce uint64, _sender common.Address, _receiver common.Address, _message []byte, _accountProof [][]byte, _storageProof [][]byte) (*types.Transaction, error) {
	return _MessageBridge.contract.Transact(opts, "executeMessage", _srcChainId, _nonce, _sender, _receiver, _message, _accountProof, _storageProof)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0x4f256d81.
//
// Solidity: function executeMessage(uint64 _srcChainId, uint64 _nonce, address _sender, address _receiver, bytes _message, bytes[] _accountProof, bytes[] _storageProof) returns(bool success)
func (_MessageBridge *MessageBridgeSession) ExecuteMessage(_srcChainId uint64, _nonce uint64, _sender common.Address, _receiver common.Address, _message []byte, _accountProof [][]byte, _storageProof [][]byte) (*types.Transaction, error) {
	return _MessageBridge.Contract.ExecuteMessage(&_MessageBridge.TransactOpts, _srcChainId, _nonce, _sender, _receiver, _message, _accountProof, _storageProof)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0x4f256d81.
//
// Solidity: function executeMessage(uint64 _srcChainId, uint64 _nonce, address _sender, address _receiver, bytes _message, bytes[] _accountProof, bytes[] _storageProof) returns(bool success)
func (_MessageBridge *MessageBridgeTransactorSession) ExecuteMessage(_srcChainId uint64, _nonce uint64, _sender common.Address, _receiver common.Address, _message []byte, _accountProof [][]byte, _storageProof [][]byte) (*types.Transaction, error) {
	return _MessageBridge.Contract.ExecuteMessage(&_MessageBridge.TransactOpts, _srcChainId, _nonce, _sender, _receiver, _message, _accountProof, _storageProof)
}

// ExecuteMessageWithZkProof is a paid mutator transaction binding the contract method 0x12738708.
//
// Solidity: function executeMessageWithZkProof(uint64 _srcChainId, uint64 _nonce, address _sender, address _receiver, bytes _message, bytes _zkProofData, bytes _blkVerifyInfo) returns(bool success)
func (_MessageBridge *MessageBridgeTransactor) ExecuteMessageWithZkProof(opts *bind.TransactOpts, _srcChainId uint64, _nonce uint64, _sender common.Address, _receiver common.Address, _message []byte, _zkProofData []byte, _blkVerifyInfo []byte) (*types.Transaction, error) {
	return _MessageBridge.contract.Transact(opts, "executeMessageWithZkProof", _srcChainId, _nonce, _sender, _receiver, _message, _zkProofData, _blkVerifyInfo)
}

// ExecuteMessageWithZkProof is a paid mutator transaction binding the contract method 0x12738708.
//
// Solidity: function executeMessageWithZkProof(uint64 _srcChainId, uint64 _nonce, address _sender, address _receiver, bytes _message, bytes _zkProofData, bytes _blkVerifyInfo) returns(bool success)
func (_MessageBridge *MessageBridgeSession) ExecuteMessageWithZkProof(_srcChainId uint64, _nonce uint64, _sender common.Address, _receiver common.Address, _message []byte, _zkProofData []byte, _blkVerifyInfo []byte) (*types.Transaction, error) {
	return _MessageBridge.Contract.ExecuteMessageWithZkProof(&_MessageBridge.TransactOpts, _srcChainId, _nonce, _sender, _receiver, _message, _zkProofData, _blkVerifyInfo)
}

// ExecuteMessageWithZkProof is a paid mutator transaction binding the contract method 0x12738708.
//
// Solidity: function executeMessageWithZkProof(uint64 _srcChainId, uint64 _nonce, address _sender, address _receiver, bytes _message, bytes _zkProofData, bytes _blkVerifyInfo) returns(bool success)
func (_MessageBridge *MessageBridgeTransactorSession) ExecuteMessageWithZkProof(_srcChainId uint64, _nonce uint64, _sender common.Address, _receiver common.Address, _message []byte, _zkProofData []byte, _blkVerifyInfo []byte) (*types.Transaction, error) {
	return _MessageBridge.Contract.ExecuteMessageWithZkProof(&_MessageBridge.TransactOpts, _srcChainId, _nonce, _sender, _receiver, _message, _zkProofData, _blkVerifyInfo)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_MessageBridge *MessageBridgeTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MessageBridge.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_MessageBridge *MessageBridgeSession) RenounceOwnership() (*types.Transaction, error) {
	return _MessageBridge.Contract.RenounceOwnership(&_MessageBridge.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_MessageBridge *MessageBridgeTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _MessageBridge.Contract.RenounceOwnership(&_MessageBridge.TransactOpts)
}

// SendMessage is a paid mutator transaction binding the contract method 0xb90b8352.
//
// Solidity: function sendMessage(uint64 _dstChainId, address _receiver, bytes _message) returns(bytes32)
func (_MessageBridge *MessageBridgeTransactor) SendMessage(opts *bind.TransactOpts, _dstChainId uint64, _receiver common.Address, _message []byte) (*types.Transaction, error) {
	return _MessageBridge.contract.Transact(opts, "sendMessage", _dstChainId, _receiver, _message)
}

// SendMessage is a paid mutator transaction binding the contract method 0xb90b8352.
//
// Solidity: function sendMessage(uint64 _dstChainId, address _receiver, bytes _message) returns(bytes32)
func (_MessageBridge *MessageBridgeSession) SendMessage(_dstChainId uint64, _receiver common.Address, _message []byte) (*types.Transaction, error) {
	return _MessageBridge.Contract.SendMessage(&_MessageBridge.TransactOpts, _dstChainId, _receiver, _message)
}

// SendMessage is a paid mutator transaction binding the contract method 0xb90b8352.
//
// Solidity: function sendMessage(uint64 _dstChainId, address _receiver, bytes _message) returns(bytes32)
func (_MessageBridge *MessageBridgeTransactorSession) SendMessage(_dstChainId uint64, _receiver common.Address, _message []byte) (*types.Transaction, error) {
	return _MessageBridge.Contract.SendMessage(&_MessageBridge.TransactOpts, _dstChainId, _receiver, _message)
}

// SetLightClient is a paid mutator transaction binding the contract method 0x975f5e1f.
//
// Solidity: function setLightClient(uint64 _chainId, address _lightClient) returns()
func (_MessageBridge *MessageBridgeTransactor) SetLightClient(opts *bind.TransactOpts, _chainId uint64, _lightClient common.Address) (*types.Transaction, error) {
	return _MessageBridge.contract.Transact(opts, "setLightClient", _chainId, _lightClient)
}

// SetLightClient is a paid mutator transaction binding the contract method 0x975f5e1f.
//
// Solidity: function setLightClient(uint64 _chainId, address _lightClient) returns()
func (_MessageBridge *MessageBridgeSession) SetLightClient(_chainId uint64, _lightClient common.Address) (*types.Transaction, error) {
	return _MessageBridge.Contract.SetLightClient(&_MessageBridge.TransactOpts, _chainId, _lightClient)
}

// SetLightClient is a paid mutator transaction binding the contract method 0x975f5e1f.
//
// Solidity: function setLightClient(uint64 _chainId, address _lightClient) returns()
func (_MessageBridge *MessageBridgeTransactorSession) SetLightClient(_chainId uint64, _lightClient common.Address) (*types.Transaction, error) {
	return _MessageBridge.Contract.SetLightClient(&_MessageBridge.TransactOpts, _chainId, _lightClient)
}

// SetPreExecuteMessageGasUsage is a paid mutator transaction binding the contract method 0x4586f331.
//
// Solidity: function setPreExecuteMessageGasUsage(uint256 _usage) returns()
func (_MessageBridge *MessageBridgeTransactor) SetPreExecuteMessageGasUsage(opts *bind.TransactOpts, _usage *big.Int) (*types.Transaction, error) {
	return _MessageBridge.contract.Transact(opts, "setPreExecuteMessageGasUsage", _usage)
}

// SetPreExecuteMessageGasUsage is a paid mutator transaction binding the contract method 0x4586f331.
//
// Solidity: function setPreExecuteMessageGasUsage(uint256 _usage) returns()
func (_MessageBridge *MessageBridgeSession) SetPreExecuteMessageGasUsage(_usage *big.Int) (*types.Transaction, error) {
	return _MessageBridge.Contract.SetPreExecuteMessageGasUsage(&_MessageBridge.TransactOpts, _usage)
}

// SetPreExecuteMessageGasUsage is a paid mutator transaction binding the contract method 0x4586f331.
//
// Solidity: function setPreExecuteMessageGasUsage(uint256 _usage) returns()
func (_MessageBridge *MessageBridgeTransactorSession) SetPreExecuteMessageGasUsage(_usage *big.Int) (*types.Transaction, error) {
	return _MessageBridge.Contract.SetPreExecuteMessageGasUsage(&_MessageBridge.TransactOpts, _usage)
}

// SetRemoteMessageBridge is a paid mutator transaction binding the contract method 0x0bbd09ab.
//
// Solidity: function setRemoteMessageBridge(uint64 _chainId, address _remoteMessageBridge) returns()
func (_MessageBridge *MessageBridgeTransactor) SetRemoteMessageBridge(opts *bind.TransactOpts, _chainId uint64, _remoteMessageBridge common.Address) (*types.Transaction, error) {
	return _MessageBridge.contract.Transact(opts, "setRemoteMessageBridge", _chainId, _remoteMessageBridge)
}

// SetRemoteMessageBridge is a paid mutator transaction binding the contract method 0x0bbd09ab.
//
// Solidity: function setRemoteMessageBridge(uint64 _chainId, address _remoteMessageBridge) returns()
func (_MessageBridge *MessageBridgeSession) SetRemoteMessageBridge(_chainId uint64, _remoteMessageBridge common.Address) (*types.Transaction, error) {
	return _MessageBridge.Contract.SetRemoteMessageBridge(&_MessageBridge.TransactOpts, _chainId, _remoteMessageBridge)
}

// SetRemoteMessageBridge is a paid mutator transaction binding the contract method 0x0bbd09ab.
//
// Solidity: function setRemoteMessageBridge(uint64 _chainId, address _remoteMessageBridge) returns()
func (_MessageBridge *MessageBridgeTransactorSession) SetRemoteMessageBridge(_chainId uint64, _remoteMessageBridge common.Address) (*types.Transaction, error) {
	return _MessageBridge.Contract.SetRemoteMessageBridge(&_MessageBridge.TransactOpts, _chainId, _remoteMessageBridge)
}

// SetSlotValueVerifier is a paid mutator transaction binding the contract method 0x735267cf.
//
// Solidity: function setSlotValueVerifier(address _slotValueVerifier) returns()
func (_MessageBridge *MessageBridgeTransactor) SetSlotValueVerifier(opts *bind.TransactOpts, _slotValueVerifier common.Address) (*types.Transaction, error) {
	return _MessageBridge.contract.Transact(opts, "setSlotValueVerifier", _slotValueVerifier)
}

// SetSlotValueVerifier is a paid mutator transaction binding the contract method 0x735267cf.
//
// Solidity: function setSlotValueVerifier(address _slotValueVerifier) returns()
func (_MessageBridge *MessageBridgeSession) SetSlotValueVerifier(_slotValueVerifier common.Address) (*types.Transaction, error) {
	return _MessageBridge.Contract.SetSlotValueVerifier(&_MessageBridge.TransactOpts, _slotValueVerifier)
}

// SetSlotValueVerifier is a paid mutator transaction binding the contract method 0x735267cf.
//
// Solidity: function setSlotValueVerifier(address _slotValueVerifier) returns()
func (_MessageBridge *MessageBridgeTransactorSession) SetSlotValueVerifier(_slotValueVerifier common.Address) (*types.Transaction, error) {
	return _MessageBridge.Contract.SetSlotValueVerifier(&_MessageBridge.TransactOpts, _slotValueVerifier)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_MessageBridge *MessageBridgeTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _MessageBridge.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_MessageBridge *MessageBridgeSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _MessageBridge.Contract.TransferOwnership(&_MessageBridge.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_MessageBridge *MessageBridgeTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _MessageBridge.Contract.TransferOwnership(&_MessageBridge.TransactOpts, newOwner)
}

// MessageBridgeMessageCallRevertedIterator is returned from FilterMessageCallReverted and is used to iterate over the raw logs and unpacked data for MessageCallReverted events raised by the MessageBridge contract.
type MessageBridgeMessageCallRevertedIterator struct {
	Event *MessageBridgeMessageCallReverted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MessageBridgeMessageCallRevertedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MessageBridgeMessageCallReverted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MessageBridgeMessageCallReverted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MessageBridgeMessageCallRevertedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MessageBridgeMessageCallRevertedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MessageBridgeMessageCallReverted represents a MessageCallReverted event raised by the MessageBridge contract.
type MessageBridgeMessageCallReverted struct {
	MessageId [32]byte
	Reason    string
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterMessageCallReverted is a free log retrieval operation binding the contract event 0xc666137142d7507d306f3aee4e2e08927034d27fc7c790316e8860c69782c94e.
//
// Solidity: event MessageCallReverted(bytes32 messageId, string reason)
func (_MessageBridge *MessageBridgeFilterer) FilterMessageCallReverted(opts *bind.FilterOpts) (*MessageBridgeMessageCallRevertedIterator, error) {

	logs, sub, err := _MessageBridge.contract.FilterLogs(opts, "MessageCallReverted")
	if err != nil {
		return nil, err
	}
	return &MessageBridgeMessageCallRevertedIterator{contract: _MessageBridge.contract, event: "MessageCallReverted", logs: logs, sub: sub}, nil
}

// WatchMessageCallReverted is a free log subscription operation binding the contract event 0xc666137142d7507d306f3aee4e2e08927034d27fc7c790316e8860c69782c94e.
//
// Solidity: event MessageCallReverted(bytes32 messageId, string reason)
func (_MessageBridge *MessageBridgeFilterer) WatchMessageCallReverted(opts *bind.WatchOpts, sink chan<- *MessageBridgeMessageCallReverted) (event.Subscription, error) {

	logs, sub, err := _MessageBridge.contract.WatchLogs(opts, "MessageCallReverted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MessageBridgeMessageCallReverted)
				if err := _MessageBridge.contract.UnpackLog(event, "MessageCallReverted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMessageCallReverted is a log parse operation binding the contract event 0xc666137142d7507d306f3aee4e2e08927034d27fc7c790316e8860c69782c94e.
//
// Solidity: event MessageCallReverted(bytes32 messageId, string reason)
func (_MessageBridge *MessageBridgeFilterer) ParseMessageCallReverted(log types.Log) (*MessageBridgeMessageCallReverted, error) {
	event := new(MessageBridgeMessageCallReverted)
	if err := _MessageBridge.contract.UnpackLog(event, "MessageCallReverted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// MessageBridgeMessageExecutedIterator is returned from FilterMessageExecuted and is used to iterate over the raw logs and unpacked data for MessageExecuted events raised by the MessageBridge contract.
type MessageBridgeMessageExecutedIterator struct {
	Event *MessageBridgeMessageExecuted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MessageBridgeMessageExecutedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MessageBridgeMessageExecuted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MessageBridgeMessageExecuted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MessageBridgeMessageExecutedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MessageBridgeMessageExecutedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MessageBridgeMessageExecuted represents a MessageExecuted event raised by the MessageBridge contract.
type MessageBridgeMessageExecuted struct {
	MessageId  [32]byte
	Nonce      *big.Int
	SrcChainId uint64
	Sender     common.Address
	Receiver   common.Address
	Message    []byte
	Success    bool
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterMessageExecuted is a free log retrieval operation binding the contract event 0xbf79e9ebbcf1fdc699f3a386de83f09cb080ab7e07f7b872118a93aef293102d.
//
// Solidity: event MessageExecuted(bytes32 indexed messageId, uint256 indexed nonce, uint64 srcChainId, address sender, address receiver, bytes message, bool success)
func (_MessageBridge *MessageBridgeFilterer) FilterMessageExecuted(opts *bind.FilterOpts, messageId [][32]byte, nonce []*big.Int) (*MessageBridgeMessageExecutedIterator, error) {

	var messageIdRule []interface{}
	for _, messageIdItem := range messageId {
		messageIdRule = append(messageIdRule, messageIdItem)
	}
	var nonceRule []interface{}
	for _, nonceItem := range nonce {
		nonceRule = append(nonceRule, nonceItem)
	}

	logs, sub, err := _MessageBridge.contract.FilterLogs(opts, "MessageExecuted", messageIdRule, nonceRule)
	if err != nil {
		return nil, err
	}
	return &MessageBridgeMessageExecutedIterator{contract: _MessageBridge.contract, event: "MessageExecuted", logs: logs, sub: sub}, nil
}

// WatchMessageExecuted is a free log subscription operation binding the contract event 0xbf79e9ebbcf1fdc699f3a386de83f09cb080ab7e07f7b872118a93aef293102d.
//
// Solidity: event MessageExecuted(bytes32 indexed messageId, uint256 indexed nonce, uint64 srcChainId, address sender, address receiver, bytes message, bool success)
func (_MessageBridge *MessageBridgeFilterer) WatchMessageExecuted(opts *bind.WatchOpts, sink chan<- *MessageBridgeMessageExecuted, messageId [][32]byte, nonce []*big.Int) (event.Subscription, error) {

	var messageIdRule []interface{}
	for _, messageIdItem := range messageId {
		messageIdRule = append(messageIdRule, messageIdItem)
	}
	var nonceRule []interface{}
	for _, nonceItem := range nonce {
		nonceRule = append(nonceRule, nonceItem)
	}

	logs, sub, err := _MessageBridge.contract.WatchLogs(opts, "MessageExecuted", messageIdRule, nonceRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MessageBridgeMessageExecuted)
				if err := _MessageBridge.contract.UnpackLog(event, "MessageExecuted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMessageExecuted is a log parse operation binding the contract event 0xbf79e9ebbcf1fdc699f3a386de83f09cb080ab7e07f7b872118a93aef293102d.
//
// Solidity: event MessageExecuted(bytes32 indexed messageId, uint256 indexed nonce, uint64 srcChainId, address sender, address receiver, bytes message, bool success)
func (_MessageBridge *MessageBridgeFilterer) ParseMessageExecuted(log types.Log) (*MessageBridgeMessageExecuted, error) {
	event := new(MessageBridgeMessageExecuted)
	if err := _MessageBridge.contract.UnpackLog(event, "MessageExecuted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// MessageBridgeMessageSentIterator is returned from FilterMessageSent and is used to iterate over the raw logs and unpacked data for MessageSent events raised by the MessageBridge contract.
type MessageBridgeMessageSentIterator struct {
	Event *MessageBridgeMessageSent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MessageBridgeMessageSentIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MessageBridgeMessageSent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MessageBridgeMessageSent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MessageBridgeMessageSentIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MessageBridgeMessageSentIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MessageBridgeMessageSent represents a MessageSent event raised by the MessageBridge contract.
type MessageBridgeMessageSent struct {
	MessageId  [32]byte
	Nonce      *big.Int
	DstChainId uint64
	Sender     common.Address
	Receiver   common.Address
	Message    []byte
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterMessageSent is a free log retrieval operation binding the contract event 0xd4c077d3ac449bc1b439559b537c6550f793c2432e3d74082b023162296dc566.
//
// Solidity: event MessageSent(bytes32 indexed messageId, uint256 indexed nonce, uint64 dstChainId, address sender, address receiver, bytes message)
func (_MessageBridge *MessageBridgeFilterer) FilterMessageSent(opts *bind.FilterOpts, messageId [][32]byte, nonce []*big.Int) (*MessageBridgeMessageSentIterator, error) {

	var messageIdRule []interface{}
	for _, messageIdItem := range messageId {
		messageIdRule = append(messageIdRule, messageIdItem)
	}
	var nonceRule []interface{}
	for _, nonceItem := range nonce {
		nonceRule = append(nonceRule, nonceItem)
	}

	logs, sub, err := _MessageBridge.contract.FilterLogs(opts, "MessageSent", messageIdRule, nonceRule)
	if err != nil {
		return nil, err
	}
	return &MessageBridgeMessageSentIterator{contract: _MessageBridge.contract, event: "MessageSent", logs: logs, sub: sub}, nil
}

// WatchMessageSent is a free log subscription operation binding the contract event 0xd4c077d3ac449bc1b439559b537c6550f793c2432e3d74082b023162296dc566.
//
// Solidity: event MessageSent(bytes32 indexed messageId, uint256 indexed nonce, uint64 dstChainId, address sender, address receiver, bytes message)
func (_MessageBridge *MessageBridgeFilterer) WatchMessageSent(opts *bind.WatchOpts, sink chan<- *MessageBridgeMessageSent, messageId [][32]byte, nonce []*big.Int) (event.Subscription, error) {

	var messageIdRule []interface{}
	for _, messageIdItem := range messageId {
		messageIdRule = append(messageIdRule, messageIdItem)
	}
	var nonceRule []interface{}
	for _, nonceItem := range nonce {
		nonceRule = append(nonceRule, nonceItem)
	}

	logs, sub, err := _MessageBridge.contract.WatchLogs(opts, "MessageSent", messageIdRule, nonceRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MessageBridgeMessageSent)
				if err := _MessageBridge.contract.UnpackLog(event, "MessageSent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMessageSent is a log parse operation binding the contract event 0xd4c077d3ac449bc1b439559b537c6550f793c2432e3d74082b023162296dc566.
//
// Solidity: event MessageSent(bytes32 indexed messageId, uint256 indexed nonce, uint64 dstChainId, address sender, address receiver, bytes message)
func (_MessageBridge *MessageBridgeFilterer) ParseMessageSent(log types.Log) (*MessageBridgeMessageSent, error) {
	event := new(MessageBridgeMessageSent)
	if err := _MessageBridge.contract.UnpackLog(event, "MessageSent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// MessageBridgeOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the MessageBridge contract.
type MessageBridgeOwnershipTransferredIterator struct {
	Event *MessageBridgeOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MessageBridgeOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MessageBridgeOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MessageBridgeOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MessageBridgeOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MessageBridgeOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MessageBridgeOwnershipTransferred represents a OwnershipTransferred event raised by the MessageBridge contract.
type MessageBridgeOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_MessageBridge *MessageBridgeFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*MessageBridgeOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _MessageBridge.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &MessageBridgeOwnershipTransferredIterator{contract: _MessageBridge.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_MessageBridge *MessageBridgeFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *MessageBridgeOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _MessageBridge.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MessageBridgeOwnershipTransferred)
				if err := _MessageBridge.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_MessageBridge *MessageBridgeFilterer) ParseOwnershipTransferred(log types.Log) (*MessageBridgeOwnershipTransferred, error) {
	event := new(MessageBridgeOwnershipTransferred)
	if err := _MessageBridge.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// MessageBridgeAddressMetaData contains all meta data concerning the MessageBridgeAddress contract.
var MessageBridgeAddressMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"messageBridge\",\"outputs\":[{\"internalType\":\"contractIMessageBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// MessageBridgeAddressABI is the input ABI used to generate the binding from.
// Deprecated: Use MessageBridgeAddressMetaData.ABI instead.
var MessageBridgeAddressABI = MessageBridgeAddressMetaData.ABI

// MessageBridgeAddress is an auto generated Go binding around an Ethereum contract.
type MessageBridgeAddress struct {
	MessageBridgeAddressCaller     // Read-only binding to the contract
	MessageBridgeAddressTransactor // Write-only binding to the contract
	MessageBridgeAddressFilterer   // Log filterer for contract events
}

// MessageBridgeAddressCaller is an auto generated read-only Go binding around an Ethereum contract.
type MessageBridgeAddressCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageBridgeAddressTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MessageBridgeAddressTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageBridgeAddressFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MessageBridgeAddressFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageBridgeAddressSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MessageBridgeAddressSession struct {
	Contract     *MessageBridgeAddress // Generic contract binding to set the session for
	CallOpts     bind.CallOpts         // Call options to use throughout this session
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// MessageBridgeAddressCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MessageBridgeAddressCallerSession struct {
	Contract *MessageBridgeAddressCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts               // Call options to use throughout this session
}

// MessageBridgeAddressTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MessageBridgeAddressTransactorSession struct {
	Contract     *MessageBridgeAddressTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts               // Transaction auth options to use throughout this session
}

// MessageBridgeAddressRaw is an auto generated low-level Go binding around an Ethereum contract.
type MessageBridgeAddressRaw struct {
	Contract *MessageBridgeAddress // Generic contract binding to access the raw methods on
}

// MessageBridgeAddressCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MessageBridgeAddressCallerRaw struct {
	Contract *MessageBridgeAddressCaller // Generic read-only contract binding to access the raw methods on
}

// MessageBridgeAddressTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MessageBridgeAddressTransactorRaw struct {
	Contract *MessageBridgeAddressTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMessageBridgeAddress creates a new instance of MessageBridgeAddress, bound to a specific deployed contract.
func NewMessageBridgeAddress(address common.Address, backend bind.ContractBackend) (*MessageBridgeAddress, error) {
	contract, err := bindMessageBridgeAddress(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &MessageBridgeAddress{MessageBridgeAddressCaller: MessageBridgeAddressCaller{contract: contract}, MessageBridgeAddressTransactor: MessageBridgeAddressTransactor{contract: contract}, MessageBridgeAddressFilterer: MessageBridgeAddressFilterer{contract: contract}}, nil
}

// NewMessageBridgeAddressCaller creates a new read-only instance of MessageBridgeAddress, bound to a specific deployed contract.
func NewMessageBridgeAddressCaller(address common.Address, caller bind.ContractCaller) (*MessageBridgeAddressCaller, error) {
	contract, err := bindMessageBridgeAddress(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MessageBridgeAddressCaller{contract: contract}, nil
}

// NewMessageBridgeAddressTransactor creates a new write-only instance of MessageBridgeAddress, bound to a specific deployed contract.
func NewMessageBridgeAddressTransactor(address common.Address, transactor bind.ContractTransactor) (*MessageBridgeAddressTransactor, error) {
	contract, err := bindMessageBridgeAddress(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MessageBridgeAddressTransactor{contract: contract}, nil
}

// NewMessageBridgeAddressFilterer creates a new log filterer instance of MessageBridgeAddress, bound to a specific deployed contract.
func NewMessageBridgeAddressFilterer(address common.Address, filterer bind.ContractFilterer) (*MessageBridgeAddressFilterer, error) {
	contract, err := bindMessageBridgeAddress(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MessageBridgeAddressFilterer{contract: contract}, nil
}

// bindMessageBridgeAddress binds a generic wrapper to an already deployed contract.
func bindMessageBridgeAddress(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := MessageBridgeAddressMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MessageBridgeAddress *MessageBridgeAddressRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MessageBridgeAddress.Contract.MessageBridgeAddressCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MessageBridgeAddress *MessageBridgeAddressRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MessageBridgeAddress.Contract.MessageBridgeAddressTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MessageBridgeAddress *MessageBridgeAddressRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MessageBridgeAddress.Contract.MessageBridgeAddressTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MessageBridgeAddress *MessageBridgeAddressCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MessageBridgeAddress.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MessageBridgeAddress *MessageBridgeAddressTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MessageBridgeAddress.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MessageBridgeAddress *MessageBridgeAddressTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MessageBridgeAddress.Contract.contract.Transact(opts, method, params...)
}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_MessageBridgeAddress *MessageBridgeAddressCaller) MessageBridge(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _MessageBridgeAddress.contract.Call(opts, &out, "messageBridge")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_MessageBridgeAddress *MessageBridgeAddressSession) MessageBridge() (common.Address, error) {
	return _MessageBridgeAddress.Contract.MessageBridge(&_MessageBridgeAddress.CallOpts)
}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_MessageBridgeAddress *MessageBridgeAddressCallerSession) MessageBridge() (common.Address, error) {
	return _MessageBridgeAddress.Contract.MessageBridge(&_MessageBridgeAddress.CallOpts)
}

// MessageReceiverAppMetaData contains all meta data concerning the MessageReceiverApp contract.
var MessageReceiverAppMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"executeMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"messageBridge\",\"outputs\":[{\"internalType\":\"contractIMessageBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// MessageReceiverAppABI is the input ABI used to generate the binding from.
// Deprecated: Use MessageReceiverAppMetaData.ABI instead.
var MessageReceiverAppABI = MessageReceiverAppMetaData.ABI

// MessageReceiverApp is an auto generated Go binding around an Ethereum contract.
type MessageReceiverApp struct {
	MessageReceiverAppCaller     // Read-only binding to the contract
	MessageReceiverAppTransactor // Write-only binding to the contract
	MessageReceiverAppFilterer   // Log filterer for contract events
}

// MessageReceiverAppCaller is an auto generated read-only Go binding around an Ethereum contract.
type MessageReceiverAppCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageReceiverAppTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MessageReceiverAppTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageReceiverAppFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MessageReceiverAppFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageReceiverAppSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MessageReceiverAppSession struct {
	Contract     *MessageReceiverApp // Generic contract binding to set the session for
	CallOpts     bind.CallOpts       // Call options to use throughout this session
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// MessageReceiverAppCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MessageReceiverAppCallerSession struct {
	Contract *MessageReceiverAppCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts             // Call options to use throughout this session
}

// MessageReceiverAppTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MessageReceiverAppTransactorSession struct {
	Contract     *MessageReceiverAppTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts             // Transaction auth options to use throughout this session
}

// MessageReceiverAppRaw is an auto generated low-level Go binding around an Ethereum contract.
type MessageReceiverAppRaw struct {
	Contract *MessageReceiverApp // Generic contract binding to access the raw methods on
}

// MessageReceiverAppCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MessageReceiverAppCallerRaw struct {
	Contract *MessageReceiverAppCaller // Generic read-only contract binding to access the raw methods on
}

// MessageReceiverAppTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MessageReceiverAppTransactorRaw struct {
	Contract *MessageReceiverAppTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMessageReceiverApp creates a new instance of MessageReceiverApp, bound to a specific deployed contract.
func NewMessageReceiverApp(address common.Address, backend bind.ContractBackend) (*MessageReceiverApp, error) {
	contract, err := bindMessageReceiverApp(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &MessageReceiverApp{MessageReceiverAppCaller: MessageReceiverAppCaller{contract: contract}, MessageReceiverAppTransactor: MessageReceiverAppTransactor{contract: contract}, MessageReceiverAppFilterer: MessageReceiverAppFilterer{contract: contract}}, nil
}

// NewMessageReceiverAppCaller creates a new read-only instance of MessageReceiverApp, bound to a specific deployed contract.
func NewMessageReceiverAppCaller(address common.Address, caller bind.ContractCaller) (*MessageReceiverAppCaller, error) {
	contract, err := bindMessageReceiverApp(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MessageReceiverAppCaller{contract: contract}, nil
}

// NewMessageReceiverAppTransactor creates a new write-only instance of MessageReceiverApp, bound to a specific deployed contract.
func NewMessageReceiverAppTransactor(address common.Address, transactor bind.ContractTransactor) (*MessageReceiverAppTransactor, error) {
	contract, err := bindMessageReceiverApp(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MessageReceiverAppTransactor{contract: contract}, nil
}

// NewMessageReceiverAppFilterer creates a new log filterer instance of MessageReceiverApp, bound to a specific deployed contract.
func NewMessageReceiverAppFilterer(address common.Address, filterer bind.ContractFilterer) (*MessageReceiverAppFilterer, error) {
	contract, err := bindMessageReceiverApp(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MessageReceiverAppFilterer{contract: contract}, nil
}

// bindMessageReceiverApp binds a generic wrapper to an already deployed contract.
func bindMessageReceiverApp(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := MessageReceiverAppMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MessageReceiverApp *MessageReceiverAppRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MessageReceiverApp.Contract.MessageReceiverAppCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MessageReceiverApp *MessageReceiverAppRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MessageReceiverApp.Contract.MessageReceiverAppTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MessageReceiverApp *MessageReceiverAppRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MessageReceiverApp.Contract.MessageReceiverAppTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MessageReceiverApp *MessageReceiverAppCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MessageReceiverApp.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MessageReceiverApp *MessageReceiverAppTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MessageReceiverApp.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MessageReceiverApp *MessageReceiverAppTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MessageReceiverApp.Contract.contract.Transact(opts, method, params...)
}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_MessageReceiverApp *MessageReceiverAppCaller) MessageBridge(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _MessageReceiverApp.contract.Call(opts, &out, "messageBridge")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_MessageReceiverApp *MessageReceiverAppSession) MessageBridge() (common.Address, error) {
	return _MessageReceiverApp.Contract.MessageBridge(&_MessageReceiverApp.CallOpts)
}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_MessageReceiverApp *MessageReceiverAppCallerSession) MessageBridge() (common.Address, error) {
	return _MessageReceiverApp.Contract.MessageBridge(&_MessageReceiverApp.CallOpts)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 srcChainId, address sender, bytes message, address executor) returns(bool)
func (_MessageReceiverApp *MessageReceiverAppTransactor) ExecuteMessage(opts *bind.TransactOpts, srcChainId uint64, sender common.Address, message []byte, executor common.Address) (*types.Transaction, error) {
	return _MessageReceiverApp.contract.Transact(opts, "executeMessage", srcChainId, sender, message, executor)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 srcChainId, address sender, bytes message, address executor) returns(bool)
func (_MessageReceiverApp *MessageReceiverAppSession) ExecuteMessage(srcChainId uint64, sender common.Address, message []byte, executor common.Address) (*types.Transaction, error) {
	return _MessageReceiverApp.Contract.ExecuteMessage(&_MessageReceiverApp.TransactOpts, srcChainId, sender, message, executor)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 srcChainId, address sender, bytes message, address executor) returns(bool)
func (_MessageReceiverApp *MessageReceiverAppTransactorSession) ExecuteMessage(srcChainId uint64, sender common.Address, message []byte, executor common.Address) (*types.Transaction, error) {
	return _MessageReceiverApp.Contract.ExecuteMessage(&_MessageReceiverApp.TransactOpts, srcChainId, sender, message, executor)
}

// MessageSenderAppMetaData contains all meta data concerning the MessageSenderApp contract.
var MessageSenderAppMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"messageBridge\",\"outputs\":[{\"internalType\":\"contractIMessageBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// MessageSenderAppABI is the input ABI used to generate the binding from.
// Deprecated: Use MessageSenderAppMetaData.ABI instead.
var MessageSenderAppABI = MessageSenderAppMetaData.ABI

// MessageSenderApp is an auto generated Go binding around an Ethereum contract.
type MessageSenderApp struct {
	MessageSenderAppCaller     // Read-only binding to the contract
	MessageSenderAppTransactor // Write-only binding to the contract
	MessageSenderAppFilterer   // Log filterer for contract events
}

// MessageSenderAppCaller is an auto generated read-only Go binding around an Ethereum contract.
type MessageSenderAppCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageSenderAppTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MessageSenderAppTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageSenderAppFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MessageSenderAppFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessageSenderAppSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MessageSenderAppSession struct {
	Contract     *MessageSenderApp // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MessageSenderAppCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MessageSenderAppCallerSession struct {
	Contract *MessageSenderAppCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts           // Call options to use throughout this session
}

// MessageSenderAppTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MessageSenderAppTransactorSession struct {
	Contract     *MessageSenderAppTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts           // Transaction auth options to use throughout this session
}

// MessageSenderAppRaw is an auto generated low-level Go binding around an Ethereum contract.
type MessageSenderAppRaw struct {
	Contract *MessageSenderApp // Generic contract binding to access the raw methods on
}

// MessageSenderAppCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MessageSenderAppCallerRaw struct {
	Contract *MessageSenderAppCaller // Generic read-only contract binding to access the raw methods on
}

// MessageSenderAppTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MessageSenderAppTransactorRaw struct {
	Contract *MessageSenderAppTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMessageSenderApp creates a new instance of MessageSenderApp, bound to a specific deployed contract.
func NewMessageSenderApp(address common.Address, backend bind.ContractBackend) (*MessageSenderApp, error) {
	contract, err := bindMessageSenderApp(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &MessageSenderApp{MessageSenderAppCaller: MessageSenderAppCaller{contract: contract}, MessageSenderAppTransactor: MessageSenderAppTransactor{contract: contract}, MessageSenderAppFilterer: MessageSenderAppFilterer{contract: contract}}, nil
}

// NewMessageSenderAppCaller creates a new read-only instance of MessageSenderApp, bound to a specific deployed contract.
func NewMessageSenderAppCaller(address common.Address, caller bind.ContractCaller) (*MessageSenderAppCaller, error) {
	contract, err := bindMessageSenderApp(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MessageSenderAppCaller{contract: contract}, nil
}

// NewMessageSenderAppTransactor creates a new write-only instance of MessageSenderApp, bound to a specific deployed contract.
func NewMessageSenderAppTransactor(address common.Address, transactor bind.ContractTransactor) (*MessageSenderAppTransactor, error) {
	contract, err := bindMessageSenderApp(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MessageSenderAppTransactor{contract: contract}, nil
}

// NewMessageSenderAppFilterer creates a new log filterer instance of MessageSenderApp, bound to a specific deployed contract.
func NewMessageSenderAppFilterer(address common.Address, filterer bind.ContractFilterer) (*MessageSenderAppFilterer, error) {
	contract, err := bindMessageSenderApp(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MessageSenderAppFilterer{contract: contract}, nil
}

// bindMessageSenderApp binds a generic wrapper to an already deployed contract.
func bindMessageSenderApp(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := MessageSenderAppMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MessageSenderApp *MessageSenderAppRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MessageSenderApp.Contract.MessageSenderAppCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MessageSenderApp *MessageSenderAppRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MessageSenderApp.Contract.MessageSenderAppTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MessageSenderApp *MessageSenderAppRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MessageSenderApp.Contract.MessageSenderAppTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MessageSenderApp *MessageSenderAppCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MessageSenderApp.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MessageSenderApp *MessageSenderAppTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MessageSenderApp.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MessageSenderApp *MessageSenderAppTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MessageSenderApp.Contract.contract.Transact(opts, method, params...)
}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_MessageSenderApp *MessageSenderAppCaller) MessageBridge(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _MessageSenderApp.contract.Call(opts, &out, "messageBridge")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_MessageSenderApp *MessageSenderAppSession) MessageBridge() (common.Address, error) {
	return _MessageSenderApp.Contract.MessageBridge(&_MessageSenderApp.CallOpts)
}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_MessageSenderApp *MessageSenderAppCallerSession) MessageBridge() (common.Address, error) {
	return _MessageSenderApp.Contract.MessageBridge(&_MessageSenderApp.CallOpts)
}

// MintableERC20MetaData contains all meta data concerning the MintableERC20 contract.
var MintableERC20MetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals_\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"initialSupply_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter_\",\"type\":\"address\"}],\"name\":\"setMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x6040608081523462000424576200131d803803806200001e8162000428565b9283398101608082820312620004245781516001600160401b039290838111620004245782620000509183016200044e565b92602092838301519082821162000424576200006e9184016200044e565b858301519260ff84168403620004245760600151948051928084116200032f5760038054946001938487811c9716801562000419575b8988101462000405578190601f97888111620003b2575b5089908883116001146200034f575f9262000343575b50505f1982841b1c191690841b1781555b83519182116200032f5760049384548481811c9116801562000324575b898210146200031157868111620002c9575b50879086841160011462000262579383949184925f9562000256575b50501b925f19911b1c19161781555b600554865193336001600160a01b0383167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a360ff60a01b60a09190911b1660ff60a01b19339081166001600160a81b0319939093169290921717600555600680546001600160a01b031916821790551562000219575050507fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef5f91620001e884600254620004be565b60025533835282815284832062000201858254620004be565b905584519384523393a351610e3c9081620004e18239f35b9260649362461bcd60e51b845283015260248201527f45524332303a206d696e7420746f20746865207a65726f2061646472657373006044820152fd5b015193505f806200012d565b9190601f19841692865f52848a5f20945f5b8c89838310620002b1575050501062000297575b50505050811b0181556200013c565b01519060f8845f19921b161c191690555f80808062000288565b86860151895590970196948501948893500162000274565b855f52885f208780860160051c8201928b871062000307575b0160051c019085905b828110620002fb57505062000111565b5f8155018590620002eb565b92508192620002e2565b602286634e487b7160e01b5f525260245ffd5b90607f1690620000ff565b634e487b7160e01b5f52604160045260245ffd5b015190505f80620000d1565b90869350601f19831691855f528b5f20925f5b8d8282106200039b575050841162000383575b505050811b018155620000e2565b01515f1983861b60f8161c191690555f808062000375565b8385015186558a9790950194938401930162000362565b909150835f52895f208880850160051c8201928c8610620003fb575b918891869594930160051c01915b828110620003ec575050620000bb565b5f8155859450889101620003dc565b92508192620003ce565b634e487b7160e01b5f52602260045260245ffd5b96607f1696620000a4565b5f80fd5b6040519190601f01601f191682016001600160401b038111838210176200032f57604052565b919080601f84011215620004245782516001600160401b0381116200032f5760209062000484601f8201601f1916830162000428565b9281845282828701011162000424575f5b818110620004aa5750825f9394955001015290565b858101830151848201840152820162000495565b91908201809211620004cc57565b634e487b7160e01b5f52601160045260245ffdfe608060409080825260049182361015610016575f80fd5b5f92833560e01c92836306fdde03146107f25750826307546172146107ca578263095ea7b3146107a057826318160ddd1461078157826323b872dd14610744578263313ce5671461071f57826339509351146106d057826340c10f19146105b157826342966c681461059357826370a082311461055d578263715018a6146104f157826379cc6790146104be5782638da5cb5b1461049657826395d89b4114610377578263a457c2d7146102bb578263a9059cbb1461028a578263dd62ed3e1461023d578263f2fde38b1461014b57505063fca3b5aa146100f5575f80fd5b346101485760203660031901126101485761010e610911565b6001600160a01b039061012682600554163314610941565b1673ffffffffffffffffffffffffffffffffffffffff19600654161760065580f35b80fd5b9091503461023957602036600319011261023957610167610911565b90600554906001600160a01b0380831693610183338614610941565b169384156101d057505073ffffffffffffffffffffffffffffffffffffffff191682176005557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b906020608492519162461bcd60e51b8352820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152fd5b8280fd5b8382346102865780600319360112610286578060209261025b610911565b61026361092b565b6001600160a01b0391821683526001865283832091168252845220549051908152f35b5080fd5b8382346102865780600319360112610286576020906102b46102aa610911565b60243590336109ad565b5160018152f35b83346101485782600319360112610148576102d4610911565b91836024359233815260016020528181206001600160a01b038616825260205220549082821061030e576020856102b48585038733610b50565b608490602086519162461bcd60e51b8352820152602560248201527f45524332303a2064656372656173656420616c6c6f77616e63652062656c6f7760448201527f207a65726f0000000000000000000000000000000000000000000000000000006064820152fd5b838234610286578160031936011261028657805190828454600181811c9080831692831561048c575b60209384841081146104795783885290811561045d5750600114610408575b505050829003601f01601f191682019267ffffffffffffffff8411838510176103f557508291826103f19252826108ca565b0390f35b634e487b7160e01b815260418552602490fd5b8787529192508591837f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b5b83851061044957505050508301018580806103bf565b805488860183015293019284908201610433565b60ff1916878501525050151560051b84010190508580806103bf565b634e487b7160e01b895260228a52602489fd5b91607f16916103a0565b8382346102865781600319360112610286576020906001600160a01b03600554169051908152f35b83823461028657366003190112610148576104ee6104da610911565b602435906104e9823383610c4e565b610ce2565b80f35b83346101485780600319360112610148578060055473ffffffffffffffffffffffffffffffffffffffff196001600160a01b03821691610532338414610941565b166005557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b83823461028657602036600319011261028657806020926001600160a01b03610584610911565b16815280845220549051908152f35b839034610286576020366003190112610286576104ee903533610ce2565b9150346102395780600319360112610239576105cb610911565b90602435916001600160a01b039081600654163303610682571692831561064057506020827fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9261061f879560025461098c565b60025585855284835280852061063683825461098c565b905551908152a380f35b6020606492519162461bcd60e51b8352820152601f60248201527f45524332303a206d696e7420746f20746865207a65726f2061646472657373006044820152fd5b825162461bcd60e51b8152602081870152602260248201527f4d696e7461626c653a2063616c6c6572206973206e6f7420746865206d696e7460448201526132b960f11b6064820152608490fd5b8382346102865780600319360112610286576102b46020926107186106f3610911565b91338152600186528481206001600160a01b038416825286528460243591205461098c565b9033610b50565b83823461028657816003193601126102865760209060ff60055460a01c169051908152f35b838234610286576060366003190112610286576020906102b4610765610911565b61076d61092b565b6044359161077c833383610c4e565b6109ad565b8382346102865781600319360112610286576020906002549051908152f35b8382346102865780600319360112610286576020906102b46107c0610911565b6024359033610b50565b8382346102865781600319360112610286576020906001600160a01b03600654169051908152f35b8491923461023957826003193601126102395782600354600181811c908083169283156108c0575b60209384841081146104795783885290811561045d575060011461086a57505050829003601f01601f191682019267ffffffffffffffff8411838510176103f557508291826103f19252826108ca565b600387529192508591837fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b5b8385106108ac57505050508301018580806103bf565b805488860183015293019284908201610896565b91607f169161081a565b602080825282518183018190529093925f5b8281106108fd57505060409293505f838284010152601f8019910116010190565b8181018601518482016040015285016108dc565b600435906001600160a01b038216820361092757565b5f80fd5b602435906001600160a01b038216820361092757565b1561094857565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b9190820180921161099957565b634e487b7160e01b5f52601160045260245ffd5b6001600160a01b03809116918215610ae55716918215610a94575f82815280602052604081205491808310610a2957604082827fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef958760209652828652038282205586815220610a1e82825461098c565b9055604051908152a3565b60405162461bcd60e51b815260206004820152602660248201527f45524332303a207472616e7366657220616d6f756e742065786365656473206260448201527f616c616e636500000000000000000000000000000000000000000000000000006064820152608490fd5b60405162461bcd60e51b815260206004820152602360248201527f45524332303a207472616e7366657220746f20746865207a65726f206164647260448201526265737360e81b6064820152608490fd5b60405162461bcd60e51b815260206004820152602560248201527f45524332303a207472616e736665722066726f6d20746865207a65726f20616460448201527f64726573730000000000000000000000000000000000000000000000000000006064820152608490fd5b6001600160a01b03809116918215610bfd5716918215610bad5760207f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92591835f526001825260405f20855f5282528060405f2055604051908152a3565b60405162461bcd60e51b815260206004820152602260248201527f45524332303a20617070726f766520746f20746865207a65726f206164647265604482015261737360f01b6064820152608490fd5b60405162461bcd60e51b8152602060048201526024808201527f45524332303a20617070726f76652066726f6d20746865207a65726f206164646044820152637265737360e01b6064820152608490fd5b906001600160a01b038083165f52600160205260405f209082165f5260205260405f2054925f198403610c82575b50505050565b808410610c9d57610c94930391610b50565b5f808080610c7c565b60405162461bcd60e51b815260206004820152601d60248201527f45524332303a20696e73756666696369656e7420616c6c6f77616e63650000006044820152606490fd5b6001600160a01b03168015610db7575f91818352826020526040832054818110610d6757819083855284602052036040842055600254818103908111610d53577fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91602091600255604051908152a3565b634e487b7160e01b84526011600452602484fd5b60405162461bcd60e51b815260206004820152602260248201527f45524332303a206275726e20616d6f756e7420657863656564732062616c616e604482015261636560f01b6064820152608490fd5b60405162461bcd60e51b815260206004820152602160248201527f45524332303a206275726e2066726f6d20746865207a65726f206164647265736044820152607360f81b6064820152608490fdfea2646970667358221220983a8fb28f08fc947d7b469640fa09935042e34240614ac4744a9c6c80580e4064736f6c63430008140033",
}

// MintableERC20ABI is the input ABI used to generate the binding from.
// Deprecated: Use MintableERC20MetaData.ABI instead.
var MintableERC20ABI = MintableERC20MetaData.ABI

// MintableERC20Bin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use MintableERC20MetaData.Bin instead.
var MintableERC20Bin = MintableERC20MetaData.Bin

// DeployMintableERC20 deploys a new Ethereum contract, binding an instance of MintableERC20 to it.
func DeployMintableERC20(auth *bind.TransactOpts, backend bind.ContractBackend, name_ string, symbol_ string, decimals_ uint8, initialSupply_ *big.Int) (common.Address, *types.Transaction, *MintableERC20, error) {
	parsed, err := MintableERC20MetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(MintableERC20Bin), backend, name_, symbol_, decimals_, initialSupply_)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &MintableERC20{MintableERC20Caller: MintableERC20Caller{contract: contract}, MintableERC20Transactor: MintableERC20Transactor{contract: contract}, MintableERC20Filterer: MintableERC20Filterer{contract: contract}}, nil
}

// MintableERC20 is an auto generated Go binding around an Ethereum contract.
type MintableERC20 struct {
	MintableERC20Caller     // Read-only binding to the contract
	MintableERC20Transactor // Write-only binding to the contract
	MintableERC20Filterer   // Log filterer for contract events
}

// MintableERC20Caller is an auto generated read-only Go binding around an Ethereum contract.
type MintableERC20Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MintableERC20Transactor is an auto generated write-only Go binding around an Ethereum contract.
type MintableERC20Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MintableERC20Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MintableERC20Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MintableERC20Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MintableERC20Session struct {
	Contract     *MintableERC20    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MintableERC20CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MintableERC20CallerSession struct {
	Contract *MintableERC20Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// MintableERC20TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MintableERC20TransactorSession struct {
	Contract     *MintableERC20Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// MintableERC20Raw is an auto generated low-level Go binding around an Ethereum contract.
type MintableERC20Raw struct {
	Contract *MintableERC20 // Generic contract binding to access the raw methods on
}

// MintableERC20CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MintableERC20CallerRaw struct {
	Contract *MintableERC20Caller // Generic read-only contract binding to access the raw methods on
}

// MintableERC20TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MintableERC20TransactorRaw struct {
	Contract *MintableERC20Transactor // Generic write-only contract binding to access the raw methods on
}

// NewMintableERC20 creates a new instance of MintableERC20, bound to a specific deployed contract.
func NewMintableERC20(address common.Address, backend bind.ContractBackend) (*MintableERC20, error) {
	contract, err := bindMintableERC20(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &MintableERC20{MintableERC20Caller: MintableERC20Caller{contract: contract}, MintableERC20Transactor: MintableERC20Transactor{contract: contract}, MintableERC20Filterer: MintableERC20Filterer{contract: contract}}, nil
}

// NewMintableERC20Caller creates a new read-only instance of MintableERC20, bound to a specific deployed contract.
func NewMintableERC20Caller(address common.Address, caller bind.ContractCaller) (*MintableERC20Caller, error) {
	contract, err := bindMintableERC20(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MintableERC20Caller{contract: contract}, nil
}

// NewMintableERC20Transactor creates a new write-only instance of MintableERC20, bound to a specific deployed contract.
func NewMintableERC20Transactor(address common.Address, transactor bind.ContractTransactor) (*MintableERC20Transactor, error) {
	contract, err := bindMintableERC20(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MintableERC20Transactor{contract: contract}, nil
}

// NewMintableERC20Filterer creates a new log filterer instance of MintableERC20, bound to a specific deployed contract.
func NewMintableERC20Filterer(address common.Address, filterer bind.ContractFilterer) (*MintableERC20Filterer, error) {
	contract, err := bindMintableERC20(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MintableERC20Filterer{contract: contract}, nil
}

// bindMintableERC20 binds a generic wrapper to an already deployed contract.
func bindMintableERC20(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := MintableERC20MetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MintableERC20 *MintableERC20Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MintableERC20.Contract.MintableERC20Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MintableERC20 *MintableERC20Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MintableERC20.Contract.MintableERC20Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MintableERC20 *MintableERC20Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MintableERC20.Contract.MintableERC20Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MintableERC20 *MintableERC20CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MintableERC20.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MintableERC20 *MintableERC20TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MintableERC20.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MintableERC20 *MintableERC20TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MintableERC20.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_MintableERC20 *MintableERC20Caller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var out []interface{}
	err := _MintableERC20.contract.Call(opts, &out, "allowance", owner, spender)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_MintableERC20 *MintableERC20Session) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _MintableERC20.Contract.Allowance(&_MintableERC20.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_MintableERC20 *MintableERC20CallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _MintableERC20.Contract.Allowance(&_MintableERC20.CallOpts, owner, spender)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_MintableERC20 *MintableERC20Caller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _MintableERC20.contract.Call(opts, &out, "balanceOf", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_MintableERC20 *MintableERC20Session) BalanceOf(account common.Address) (*big.Int, error) {
	return _MintableERC20.Contract.BalanceOf(&_MintableERC20.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_MintableERC20 *MintableERC20CallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _MintableERC20.Contract.BalanceOf(&_MintableERC20.CallOpts, account)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_MintableERC20 *MintableERC20Caller) Decimals(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _MintableERC20.contract.Call(opts, &out, "decimals")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_MintableERC20 *MintableERC20Session) Decimals() (uint8, error) {
	return _MintableERC20.Contract.Decimals(&_MintableERC20.CallOpts)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_MintableERC20 *MintableERC20CallerSession) Decimals() (uint8, error) {
	return _MintableERC20.Contract.Decimals(&_MintableERC20.CallOpts)
}

// Minter is a free data retrieval call binding the contract method 0x07546172.
//
// Solidity: function minter() view returns(address)
func (_MintableERC20 *MintableERC20Caller) Minter(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _MintableERC20.contract.Call(opts, &out, "minter")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Minter is a free data retrieval call binding the contract method 0x07546172.
//
// Solidity: function minter() view returns(address)
func (_MintableERC20 *MintableERC20Session) Minter() (common.Address, error) {
	return _MintableERC20.Contract.Minter(&_MintableERC20.CallOpts)
}

// Minter is a free data retrieval call binding the contract method 0x07546172.
//
// Solidity: function minter() view returns(address)
func (_MintableERC20 *MintableERC20CallerSession) Minter() (common.Address, error) {
	return _MintableERC20.Contract.Minter(&_MintableERC20.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_MintableERC20 *MintableERC20Caller) Name(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _MintableERC20.contract.Call(opts, &out, "name")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_MintableERC20 *MintableERC20Session) Name() (string, error) {
	return _MintableERC20.Contract.Name(&_MintableERC20.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_MintableERC20 *MintableERC20CallerSession) Name() (string, error) {
	return _MintableERC20.Contract.Name(&_MintableERC20.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_MintableERC20 *MintableERC20Caller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _MintableERC20.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_MintableERC20 *MintableERC20Session) Owner() (common.Address, error) {
	return _MintableERC20.Contract.Owner(&_MintableERC20.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_MintableERC20 *MintableERC20CallerSession) Owner() (common.Address, error) {
	return _MintableERC20.Contract.Owner(&_MintableERC20.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_MintableERC20 *MintableERC20Caller) Symbol(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _MintableERC20.contract.Call(opts, &out, "symbol")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_MintableERC20 *MintableERC20Session) Symbol() (string, error) {
	return _MintableERC20.Contract.Symbol(&_MintableERC20.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_MintableERC20 *MintableERC20CallerSession) Symbol() (string, error) {
	return _MintableERC20.Contract.Symbol(&_MintableERC20.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_MintableERC20 *MintableERC20Caller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _MintableERC20.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_MintableERC20 *MintableERC20Session) TotalSupply() (*big.Int, error) {
	return _MintableERC20.Contract.TotalSupply(&_MintableERC20.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_MintableERC20 *MintableERC20CallerSession) TotalSupply() (*big.Int, error) {
	return _MintableERC20.Contract.TotalSupply(&_MintableERC20.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_MintableERC20 *MintableERC20Transactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.contract.Transact(opts, "approve", spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_MintableERC20 *MintableERC20Session) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.Approve(&_MintableERC20.TransactOpts, spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_MintableERC20 *MintableERC20TransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.Approve(&_MintableERC20.TransactOpts, spender, amount)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 amount) returns()
func (_MintableERC20 *MintableERC20Transactor) Burn(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.contract.Transact(opts, "burn", amount)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 amount) returns()
func (_MintableERC20 *MintableERC20Session) Burn(amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.Burn(&_MintableERC20.TransactOpts, amount)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 amount) returns()
func (_MintableERC20 *MintableERC20TransactorSession) Burn(amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.Burn(&_MintableERC20.TransactOpts, amount)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x79cc6790.
//
// Solidity: function burnFrom(address account, uint256 amount) returns()
func (_MintableERC20 *MintableERC20Transactor) BurnFrom(opts *bind.TransactOpts, account common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.contract.Transact(opts, "burnFrom", account, amount)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x79cc6790.
//
// Solidity: function burnFrom(address account, uint256 amount) returns()
func (_MintableERC20 *MintableERC20Session) BurnFrom(account common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.BurnFrom(&_MintableERC20.TransactOpts, account, amount)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x79cc6790.
//
// Solidity: function burnFrom(address account, uint256 amount) returns()
func (_MintableERC20 *MintableERC20TransactorSession) BurnFrom(account common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.BurnFrom(&_MintableERC20.TransactOpts, account, amount)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_MintableERC20 *MintableERC20Transactor) DecreaseAllowance(opts *bind.TransactOpts, spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _MintableERC20.contract.Transact(opts, "decreaseAllowance", spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_MintableERC20 *MintableERC20Session) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.DecreaseAllowance(&_MintableERC20.TransactOpts, spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_MintableERC20 *MintableERC20TransactorSession) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.DecreaseAllowance(&_MintableERC20.TransactOpts, spender, subtractedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_MintableERC20 *MintableERC20Transactor) IncreaseAllowance(opts *bind.TransactOpts, spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _MintableERC20.contract.Transact(opts, "increaseAllowance", spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_MintableERC20 *MintableERC20Session) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.IncreaseAllowance(&_MintableERC20.TransactOpts, spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_MintableERC20 *MintableERC20TransactorSession) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.IncreaseAllowance(&_MintableERC20.TransactOpts, spender, addedValue)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address to, uint256 amount) returns()
func (_MintableERC20 *MintableERC20Transactor) Mint(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.contract.Transact(opts, "mint", to, amount)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address to, uint256 amount) returns()
func (_MintableERC20 *MintableERC20Session) Mint(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.Mint(&_MintableERC20.TransactOpts, to, amount)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address to, uint256 amount) returns()
func (_MintableERC20 *MintableERC20TransactorSession) Mint(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.Mint(&_MintableERC20.TransactOpts, to, amount)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_MintableERC20 *MintableERC20Transactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MintableERC20.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_MintableERC20 *MintableERC20Session) RenounceOwnership() (*types.Transaction, error) {
	return _MintableERC20.Contract.RenounceOwnership(&_MintableERC20.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_MintableERC20 *MintableERC20TransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _MintableERC20.Contract.RenounceOwnership(&_MintableERC20.TransactOpts)
}

// SetMinter is a paid mutator transaction binding the contract method 0xfca3b5aa.
//
// Solidity: function setMinter(address minter_) returns()
func (_MintableERC20 *MintableERC20Transactor) SetMinter(opts *bind.TransactOpts, minter_ common.Address) (*types.Transaction, error) {
	return _MintableERC20.contract.Transact(opts, "setMinter", minter_)
}

// SetMinter is a paid mutator transaction binding the contract method 0xfca3b5aa.
//
// Solidity: function setMinter(address minter_) returns()
func (_MintableERC20 *MintableERC20Session) SetMinter(minter_ common.Address) (*types.Transaction, error) {
	return _MintableERC20.Contract.SetMinter(&_MintableERC20.TransactOpts, minter_)
}

// SetMinter is a paid mutator transaction binding the contract method 0xfca3b5aa.
//
// Solidity: function setMinter(address minter_) returns()
func (_MintableERC20 *MintableERC20TransactorSession) SetMinter(minter_ common.Address) (*types.Transaction, error) {
	return _MintableERC20.Contract.SetMinter(&_MintableERC20.TransactOpts, minter_)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_MintableERC20 *MintableERC20Transactor) Transfer(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.contract.Transact(opts, "transfer", to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_MintableERC20 *MintableERC20Session) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.Transfer(&_MintableERC20.TransactOpts, to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_MintableERC20 *MintableERC20TransactorSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.Transfer(&_MintableERC20.TransactOpts, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_MintableERC20 *MintableERC20Transactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.contract.Transact(opts, "transferFrom", from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_MintableERC20 *MintableERC20Session) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.TransferFrom(&_MintableERC20.TransactOpts, from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_MintableERC20 *MintableERC20TransactorSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _MintableERC20.Contract.TransferFrom(&_MintableERC20.TransactOpts, from, to, amount)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_MintableERC20 *MintableERC20Transactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _MintableERC20.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_MintableERC20 *MintableERC20Session) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _MintableERC20.Contract.TransferOwnership(&_MintableERC20.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_MintableERC20 *MintableERC20TransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _MintableERC20.Contract.TransferOwnership(&_MintableERC20.TransactOpts, newOwner)
}

// MintableERC20ApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the MintableERC20 contract.
type MintableERC20ApprovalIterator struct {
	Event *MintableERC20Approval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MintableERC20ApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MintableERC20Approval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MintableERC20Approval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MintableERC20ApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MintableERC20ApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MintableERC20Approval represents a Approval event raised by the MintableERC20 contract.
type MintableERC20Approval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_MintableERC20 *MintableERC20Filterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*MintableERC20ApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _MintableERC20.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &MintableERC20ApprovalIterator{contract: _MintableERC20.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_MintableERC20 *MintableERC20Filterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *MintableERC20Approval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _MintableERC20.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MintableERC20Approval)
				if err := _MintableERC20.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_MintableERC20 *MintableERC20Filterer) ParseApproval(log types.Log) (*MintableERC20Approval, error) {
	event := new(MintableERC20Approval)
	if err := _MintableERC20.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// MintableERC20OwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the MintableERC20 contract.
type MintableERC20OwnershipTransferredIterator struct {
	Event *MintableERC20OwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MintableERC20OwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MintableERC20OwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MintableERC20OwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MintableERC20OwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MintableERC20OwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MintableERC20OwnershipTransferred represents a OwnershipTransferred event raised by the MintableERC20 contract.
type MintableERC20OwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_MintableERC20 *MintableERC20Filterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*MintableERC20OwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _MintableERC20.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &MintableERC20OwnershipTransferredIterator{contract: _MintableERC20.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_MintableERC20 *MintableERC20Filterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *MintableERC20OwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _MintableERC20.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MintableERC20OwnershipTransferred)
				if err := _MintableERC20.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_MintableERC20 *MintableERC20Filterer) ParseOwnershipTransferred(log types.Log) (*MintableERC20OwnershipTransferred, error) {
	event := new(MintableERC20OwnershipTransferred)
	if err := _MintableERC20.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// MintableERC20TransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the MintableERC20 contract.
type MintableERC20TransferIterator struct {
	Event *MintableERC20Transfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MintableERC20TransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MintableERC20Transfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MintableERC20Transfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MintableERC20TransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MintableERC20TransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MintableERC20Transfer represents a Transfer event raised by the MintableERC20 contract.
type MintableERC20Transfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_MintableERC20 *MintableERC20Filterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*MintableERC20TransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _MintableERC20.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &MintableERC20TransferIterator{contract: _MintableERC20.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_MintableERC20 *MintableERC20Filterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *MintableERC20Transfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _MintableERC20.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MintableERC20Transfer)
				if err := _MintableERC20.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_MintableERC20 *MintableERC20Filterer) ParseTransfer(log types.Log) (*MintableERC20Transfer, error) {
	event := new(MintableERC20Transfer)
	if err := _MintableERC20.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// MockUniswapSumVolumeMetaData contains all meta data concerning the MockUniswapSumVolume contract.
var MockUniswapSumVolumeMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getAttestedSwapSumVolume\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]",
	Bin: "0x60808060405234601457609390816100198239f35b5f80fdfe60808060405260043610156011575f80fd5b5f90813560e01c63950650c1146025575f80fd5b34605957602036600319011260595760043573ffffffffffffffffffffffffffffffffffffffff8116036059576020918152f35b5080fdfea2646970667358221220da66c5d3d84bff56e94d50ad610722623d166ec268729a86915d3273b3f5795164736f6c63430008140033",
}

// MockUniswapSumVolumeABI is the input ABI used to generate the binding from.
// Deprecated: Use MockUniswapSumVolumeMetaData.ABI instead.
var MockUniswapSumVolumeABI = MockUniswapSumVolumeMetaData.ABI

// MockUniswapSumVolumeBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use MockUniswapSumVolumeMetaData.Bin instead.
var MockUniswapSumVolumeBin = MockUniswapSumVolumeMetaData.Bin

// DeployMockUniswapSumVolume deploys a new Ethereum contract, binding an instance of MockUniswapSumVolume to it.
func DeployMockUniswapSumVolume(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *MockUniswapSumVolume, error) {
	parsed, err := MockUniswapSumVolumeMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(MockUniswapSumVolumeBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &MockUniswapSumVolume{MockUniswapSumVolumeCaller: MockUniswapSumVolumeCaller{contract: contract}, MockUniswapSumVolumeTransactor: MockUniswapSumVolumeTransactor{contract: contract}, MockUniswapSumVolumeFilterer: MockUniswapSumVolumeFilterer{contract: contract}}, nil
}

// MockUniswapSumVolume is an auto generated Go binding around an Ethereum contract.
type MockUniswapSumVolume struct {
	MockUniswapSumVolumeCaller     // Read-only binding to the contract
	MockUniswapSumVolumeTransactor // Write-only binding to the contract
	MockUniswapSumVolumeFilterer   // Log filterer for contract events
}

// MockUniswapSumVolumeCaller is an auto generated read-only Go binding around an Ethereum contract.
type MockUniswapSumVolumeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MockUniswapSumVolumeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MockUniswapSumVolumeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MockUniswapSumVolumeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MockUniswapSumVolumeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MockUniswapSumVolumeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MockUniswapSumVolumeSession struct {
	Contract     *MockUniswapSumVolume // Generic contract binding to set the session for
	CallOpts     bind.CallOpts         // Call options to use throughout this session
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// MockUniswapSumVolumeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MockUniswapSumVolumeCallerSession struct {
	Contract *MockUniswapSumVolumeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts               // Call options to use throughout this session
}

// MockUniswapSumVolumeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MockUniswapSumVolumeTransactorSession struct {
	Contract     *MockUniswapSumVolumeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts               // Transaction auth options to use throughout this session
}

// MockUniswapSumVolumeRaw is an auto generated low-level Go binding around an Ethereum contract.
type MockUniswapSumVolumeRaw struct {
	Contract *MockUniswapSumVolume // Generic contract binding to access the raw methods on
}

// MockUniswapSumVolumeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MockUniswapSumVolumeCallerRaw struct {
	Contract *MockUniswapSumVolumeCaller // Generic read-only contract binding to access the raw methods on
}

// MockUniswapSumVolumeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MockUniswapSumVolumeTransactorRaw struct {
	Contract *MockUniswapSumVolumeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMockUniswapSumVolume creates a new instance of MockUniswapSumVolume, bound to a specific deployed contract.
func NewMockUniswapSumVolume(address common.Address, backend bind.ContractBackend) (*MockUniswapSumVolume, error) {
	contract, err := bindMockUniswapSumVolume(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &MockUniswapSumVolume{MockUniswapSumVolumeCaller: MockUniswapSumVolumeCaller{contract: contract}, MockUniswapSumVolumeTransactor: MockUniswapSumVolumeTransactor{contract: contract}, MockUniswapSumVolumeFilterer: MockUniswapSumVolumeFilterer{contract: contract}}, nil
}

// NewMockUniswapSumVolumeCaller creates a new read-only instance of MockUniswapSumVolume, bound to a specific deployed contract.
func NewMockUniswapSumVolumeCaller(address common.Address, caller bind.ContractCaller) (*MockUniswapSumVolumeCaller, error) {
	contract, err := bindMockUniswapSumVolume(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MockUniswapSumVolumeCaller{contract: contract}, nil
}

// NewMockUniswapSumVolumeTransactor creates a new write-only instance of MockUniswapSumVolume, bound to a specific deployed contract.
func NewMockUniswapSumVolumeTransactor(address common.Address, transactor bind.ContractTransactor) (*MockUniswapSumVolumeTransactor, error) {
	contract, err := bindMockUniswapSumVolume(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MockUniswapSumVolumeTransactor{contract: contract}, nil
}

// NewMockUniswapSumVolumeFilterer creates a new log filterer instance of MockUniswapSumVolume, bound to a specific deployed contract.
func NewMockUniswapSumVolumeFilterer(address common.Address, filterer bind.ContractFilterer) (*MockUniswapSumVolumeFilterer, error) {
	contract, err := bindMockUniswapSumVolume(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MockUniswapSumVolumeFilterer{contract: contract}, nil
}

// bindMockUniswapSumVolume binds a generic wrapper to an already deployed contract.
func bindMockUniswapSumVolume(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := MockUniswapSumVolumeMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MockUniswapSumVolume *MockUniswapSumVolumeRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MockUniswapSumVolume.Contract.MockUniswapSumVolumeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MockUniswapSumVolume *MockUniswapSumVolumeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MockUniswapSumVolume.Contract.MockUniswapSumVolumeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MockUniswapSumVolume *MockUniswapSumVolumeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MockUniswapSumVolume.Contract.MockUniswapSumVolumeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MockUniswapSumVolume *MockUniswapSumVolumeCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MockUniswapSumVolume.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MockUniswapSumVolume *MockUniswapSumVolumeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MockUniswapSumVolume.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MockUniswapSumVolume *MockUniswapSumVolumeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MockUniswapSumVolume.Contract.contract.Transact(opts, method, params...)
}

// GetAttestedSwapSumVolume is a free data retrieval call binding the contract method 0x950650c1.
//
// Solidity: function getAttestedSwapSumVolume(address ) pure returns(uint256)
func (_MockUniswapSumVolume *MockUniswapSumVolumeCaller) GetAttestedSwapSumVolume(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _MockUniswapSumVolume.contract.Call(opts, &out, "getAttestedSwapSumVolume", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetAttestedSwapSumVolume is a free data retrieval call binding the contract method 0x950650c1.
//
// Solidity: function getAttestedSwapSumVolume(address ) pure returns(uint256)
func (_MockUniswapSumVolume *MockUniswapSumVolumeSession) GetAttestedSwapSumVolume(arg0 common.Address) (*big.Int, error) {
	return _MockUniswapSumVolume.Contract.GetAttestedSwapSumVolume(&_MockUniswapSumVolume.CallOpts, arg0)
}

// GetAttestedSwapSumVolume is a free data retrieval call binding the contract method 0x950650c1.
//
// Solidity: function getAttestedSwapSumVolume(address ) pure returns(uint256)
func (_MockUniswapSumVolume *MockUniswapSumVolumeCallerSession) GetAttestedSwapSumVolume(arg0 common.Address) (*big.Int, error) {
	return _MockUniswapSumVolume.Contract.GetAttestedSwapSumVolume(&_MockUniswapSumVolume.CallOpts, arg0)
}

// MsgLibMetaData contains all meta data concerning the MsgLib contract.
var MsgLibMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea2646970667358221220c9716a9564bad8f3c124e07035a775480e03d4d70aebff25dd082b62e8b44b0b64736f6c63430008140033",
}

// MsgLibABI is the input ABI used to generate the binding from.
// Deprecated: Use MsgLibMetaData.ABI instead.
var MsgLibABI = MsgLibMetaData.ABI

// MsgLibBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use MsgLibMetaData.Bin instead.
var MsgLibBin = MsgLibMetaData.Bin

// DeployMsgLib deploys a new Ethereum contract, binding an instance of MsgLib to it.
func DeployMsgLib(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *MsgLib, error) {
	parsed, err := MsgLibMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(MsgLibBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &MsgLib{MsgLibCaller: MsgLibCaller{contract: contract}, MsgLibTransactor: MsgLibTransactor{contract: contract}, MsgLibFilterer: MsgLibFilterer{contract: contract}}, nil
}

// MsgLib is an auto generated Go binding around an Ethereum contract.
type MsgLib struct {
	MsgLibCaller     // Read-only binding to the contract
	MsgLibTransactor // Write-only binding to the contract
	MsgLibFilterer   // Log filterer for contract events
}

// MsgLibCaller is an auto generated read-only Go binding around an Ethereum contract.
type MsgLibCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MsgLibTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MsgLibTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MsgLibFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MsgLibFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MsgLibSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MsgLibSession struct {
	Contract     *MsgLib           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MsgLibCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MsgLibCallerSession struct {
	Contract *MsgLibCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// MsgLibTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MsgLibTransactorSession struct {
	Contract     *MsgLibTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MsgLibRaw is an auto generated low-level Go binding around an Ethereum contract.
type MsgLibRaw struct {
	Contract *MsgLib // Generic contract binding to access the raw methods on
}

// MsgLibCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MsgLibCallerRaw struct {
	Contract *MsgLibCaller // Generic read-only contract binding to access the raw methods on
}

// MsgLibTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MsgLibTransactorRaw struct {
	Contract *MsgLibTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMsgLib creates a new instance of MsgLib, bound to a specific deployed contract.
func NewMsgLib(address common.Address, backend bind.ContractBackend) (*MsgLib, error) {
	contract, err := bindMsgLib(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &MsgLib{MsgLibCaller: MsgLibCaller{contract: contract}, MsgLibTransactor: MsgLibTransactor{contract: contract}, MsgLibFilterer: MsgLibFilterer{contract: contract}}, nil
}

// NewMsgLibCaller creates a new read-only instance of MsgLib, bound to a specific deployed contract.
func NewMsgLibCaller(address common.Address, caller bind.ContractCaller) (*MsgLibCaller, error) {
	contract, err := bindMsgLib(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MsgLibCaller{contract: contract}, nil
}

// NewMsgLibTransactor creates a new write-only instance of MsgLib, bound to a specific deployed contract.
func NewMsgLibTransactor(address common.Address, transactor bind.ContractTransactor) (*MsgLibTransactor, error) {
	contract, err := bindMsgLib(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MsgLibTransactor{contract: contract}, nil
}

// NewMsgLibFilterer creates a new log filterer instance of MsgLib, bound to a specific deployed contract.
func NewMsgLibFilterer(address common.Address, filterer bind.ContractFilterer) (*MsgLibFilterer, error) {
	contract, err := bindMsgLib(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MsgLibFilterer{contract: contract}, nil
}

// bindMsgLib binds a generic wrapper to an already deployed contract.
func bindMsgLib(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := MsgLibMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MsgLib *MsgLibRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MsgLib.Contract.MsgLibCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MsgLib *MsgLibRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MsgLib.Contract.MsgLibTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MsgLib *MsgLibRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MsgLib.Contract.MsgLibTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MsgLib *MsgLibCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MsgLib.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MsgLib *MsgLibTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MsgLib.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MsgLib *MsgLibTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MsgLib.Contract.contract.Transact(opts, method, params...)
}

// MsgReceiverMetaData contains all meta data concerning the MsgReceiver contract.
var MsgReceiverMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"contractISlotValueVerifier\",\"name\":\"_verifier\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_senderChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_senderContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"msg\",\"type\":\"bytes\"}],\"name\":\"MsgReceived\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_msg\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_proofData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_blkVerifyInfo\",\"type\":\"bytes\"}],\"name\":\"recvMsg\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"senderChainId\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"senderContractHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slotValueVerifier\",\"outputs\":[{\"internalType\":\"contractISlotValueVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x6080346100f5576001600160401b0390601f61063f38819003918201601f1916830191848311848410176100e1578084926060946040528339810103126100f55780516001600160a01b039190828116908190036100f5576020820151918483168093036100f5576040015192831683036100f557600280546001600160a01b0319169190911790555f80546001600160401b0319169190911790556040805160609290921b6001600160601b0319166020830190815260148352908201929091908311818410176100e1578260405251902060015561054590816100fa8239f35b634e487b7160e01b5f52604160045260245ffd5b5f80fdfe6080806040526004361015610012575f80fd5b5f3560e01c90816351a973e91461047c5750806363c6ccb21461045657806373008938146104395763faf6e9ec14610048575f80fd5b3461040e5760a036600319011261040e5760043567ffffffffffffffff8116810361040e576001600160a01b03602435166024350361040e5760443567ffffffffffffffff811161040e576100a190369060040161049f565b9160643567ffffffffffffffff811161040e576100c290369060040161049f565b60843567ffffffffffffffff811161040e576100e290369060040161049f565b9190926040519067ffffffffffffffff86166020830152600160408301526040825281606081011067ffffffffffffffff6060840111176104125760608201604052815160208301206080830152602060608301526060820160a083011067ffffffffffffffff60a084011117610412576101fd9488938860a0858160c097016040526101b1603482606081015160808201209a808b8301976bffffffffffffffffffffffff1960243560601b16895260d484013781015f60d4820152036014810185850152018383016104cd565b015190209561020f6001600160a01b03600254169367ffffffffffffffff5f5416926040519a8b9788968796630b885e5360e01b885260048801526060602488015260648701916104ef565b848103600319016044860152916104ef565b03915afa92831561042e575f93610370575b5060608301510361032b576080820151036102e65760200151600154036102a15761029c67ffffffffffffffff927f0881b56db4adae1d4876705d8794dcbeb3c199027a9995685ea2a4e29b071394946040519485941684526001600160a01b036024351660208501526060604085015260608401916104ef565b0390a1005b60405162461bcd60e51b815260206004820152601960248201527f73656e64657220636f6e7472616374206e6f74206d61746368000000000000006044820152606490fd5b60405162461bcd60e51b815260206004820152601460248201527f736c6f742076616c7565206e6f74206d617463680000000000000000000000006044820152606490fd5b60405162461bcd60e51b815260206004820152601260248201527f736c6f74206b6579206e6f74206d6174636800000000000000000000000000006044820152606490fd5b90925060c0813d60c011610426575b8161038c60c093836104cd565b8101031261040e576040519060c0820182811067ffffffffffffffff8211176104125760405280519067ffffffffffffffff8216820361040e5760a091835260208101516020840152604081015160408401526060810151606084015260808101516080840152015163ffffffff8116810361040e5760a0820152915f610221565b5f80fd5b634e487b7160e01b5f52604160045260245ffd5b3d915061037f565b6040513d5f823e3d90fd5b3461040e575f36600319011261040e576020600154604051908152f35b3461040e575f36600319011261040e5760206001600160a01b0360025416604051908152f35b3461040e575f36600319011261040e5760209067ffffffffffffffff5f54168152f35b9181601f8401121561040e5782359167ffffffffffffffff831161040e576020838186019501011161040e57565b90601f8019910116810190811067ffffffffffffffff82111761041257604052565b908060209392818452848401375f828201840152601f01601f191601019056fea2646970667358221220e1b8d054ca93193910908fa1583e7800c7548bca2d9c4785f65a8a9a900175ec64736f6c63430008140033",
}

// MsgReceiverABI is the input ABI used to generate the binding from.
// Deprecated: Use MsgReceiverMetaData.ABI instead.
var MsgReceiverABI = MsgReceiverMetaData.ABI

// MsgReceiverBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use MsgReceiverMetaData.Bin instead.
var MsgReceiverBin = MsgReceiverMetaData.Bin

// DeployMsgReceiver deploys a new Ethereum contract, binding an instance of MsgReceiver to it.
func DeployMsgReceiver(auth *bind.TransactOpts, backend bind.ContractBackend, _verifier common.Address, _senderChainId uint64, _senderContract common.Address) (common.Address, *types.Transaction, *MsgReceiver, error) {
	parsed, err := MsgReceiverMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(MsgReceiverBin), backend, _verifier, _senderChainId, _senderContract)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &MsgReceiver{MsgReceiverCaller: MsgReceiverCaller{contract: contract}, MsgReceiverTransactor: MsgReceiverTransactor{contract: contract}, MsgReceiverFilterer: MsgReceiverFilterer{contract: contract}}, nil
}

// MsgReceiver is an auto generated Go binding around an Ethereum contract.
type MsgReceiver struct {
	MsgReceiverCaller     // Read-only binding to the contract
	MsgReceiverTransactor // Write-only binding to the contract
	MsgReceiverFilterer   // Log filterer for contract events
}

// MsgReceiverCaller is an auto generated read-only Go binding around an Ethereum contract.
type MsgReceiverCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MsgReceiverTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MsgReceiverTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MsgReceiverFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MsgReceiverFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MsgReceiverSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MsgReceiverSession struct {
	Contract     *MsgReceiver      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MsgReceiverCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MsgReceiverCallerSession struct {
	Contract *MsgReceiverCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// MsgReceiverTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MsgReceiverTransactorSession struct {
	Contract     *MsgReceiverTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// MsgReceiverRaw is an auto generated low-level Go binding around an Ethereum contract.
type MsgReceiverRaw struct {
	Contract *MsgReceiver // Generic contract binding to access the raw methods on
}

// MsgReceiverCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MsgReceiverCallerRaw struct {
	Contract *MsgReceiverCaller // Generic read-only contract binding to access the raw methods on
}

// MsgReceiverTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MsgReceiverTransactorRaw struct {
	Contract *MsgReceiverTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMsgReceiver creates a new instance of MsgReceiver, bound to a specific deployed contract.
func NewMsgReceiver(address common.Address, backend bind.ContractBackend) (*MsgReceiver, error) {
	contract, err := bindMsgReceiver(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &MsgReceiver{MsgReceiverCaller: MsgReceiverCaller{contract: contract}, MsgReceiverTransactor: MsgReceiverTransactor{contract: contract}, MsgReceiverFilterer: MsgReceiverFilterer{contract: contract}}, nil
}

// NewMsgReceiverCaller creates a new read-only instance of MsgReceiver, bound to a specific deployed contract.
func NewMsgReceiverCaller(address common.Address, caller bind.ContractCaller) (*MsgReceiverCaller, error) {
	contract, err := bindMsgReceiver(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MsgReceiverCaller{contract: contract}, nil
}

// NewMsgReceiverTransactor creates a new write-only instance of MsgReceiver, bound to a specific deployed contract.
func NewMsgReceiverTransactor(address common.Address, transactor bind.ContractTransactor) (*MsgReceiverTransactor, error) {
	contract, err := bindMsgReceiver(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MsgReceiverTransactor{contract: contract}, nil
}

// NewMsgReceiverFilterer creates a new log filterer instance of MsgReceiver, bound to a specific deployed contract.
func NewMsgReceiverFilterer(address common.Address, filterer bind.ContractFilterer) (*MsgReceiverFilterer, error) {
	contract, err := bindMsgReceiver(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MsgReceiverFilterer{contract: contract}, nil
}

// bindMsgReceiver binds a generic wrapper to an already deployed contract.
func bindMsgReceiver(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := MsgReceiverMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MsgReceiver *MsgReceiverRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MsgReceiver.Contract.MsgReceiverCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MsgReceiver *MsgReceiverRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MsgReceiver.Contract.MsgReceiverTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MsgReceiver *MsgReceiverRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MsgReceiver.Contract.MsgReceiverTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MsgReceiver *MsgReceiverCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MsgReceiver.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MsgReceiver *MsgReceiverTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MsgReceiver.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MsgReceiver *MsgReceiverTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MsgReceiver.Contract.contract.Transact(opts, method, params...)
}

// SenderChainId is a free data retrieval call binding the contract method 0x51a973e9.
//
// Solidity: function senderChainId() view returns(uint64)
func (_MsgReceiver *MsgReceiverCaller) SenderChainId(opts *bind.CallOpts) (uint64, error) {
	var out []interface{}
	err := _MsgReceiver.contract.Call(opts, &out, "senderChainId")

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// SenderChainId is a free data retrieval call binding the contract method 0x51a973e9.
//
// Solidity: function senderChainId() view returns(uint64)
func (_MsgReceiver *MsgReceiverSession) SenderChainId() (uint64, error) {
	return _MsgReceiver.Contract.SenderChainId(&_MsgReceiver.CallOpts)
}

// SenderChainId is a free data retrieval call binding the contract method 0x51a973e9.
//
// Solidity: function senderChainId() view returns(uint64)
func (_MsgReceiver *MsgReceiverCallerSession) SenderChainId() (uint64, error) {
	return _MsgReceiver.Contract.SenderChainId(&_MsgReceiver.CallOpts)
}

// SenderContractHash is a free data retrieval call binding the contract method 0x73008938.
//
// Solidity: function senderContractHash() view returns(bytes32)
func (_MsgReceiver *MsgReceiverCaller) SenderContractHash(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _MsgReceiver.contract.Call(opts, &out, "senderContractHash")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// SenderContractHash is a free data retrieval call binding the contract method 0x73008938.
//
// Solidity: function senderContractHash() view returns(bytes32)
func (_MsgReceiver *MsgReceiverSession) SenderContractHash() ([32]byte, error) {
	return _MsgReceiver.Contract.SenderContractHash(&_MsgReceiver.CallOpts)
}

// SenderContractHash is a free data retrieval call binding the contract method 0x73008938.
//
// Solidity: function senderContractHash() view returns(bytes32)
func (_MsgReceiver *MsgReceiverCallerSession) SenderContractHash() ([32]byte, error) {
	return _MsgReceiver.Contract.SenderContractHash(&_MsgReceiver.CallOpts)
}

// SlotValueVerifier is a free data retrieval call binding the contract method 0x63c6ccb2.
//
// Solidity: function slotValueVerifier() view returns(address)
func (_MsgReceiver *MsgReceiverCaller) SlotValueVerifier(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _MsgReceiver.contract.Call(opts, &out, "slotValueVerifier")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SlotValueVerifier is a free data retrieval call binding the contract method 0x63c6ccb2.
//
// Solidity: function slotValueVerifier() view returns(address)
func (_MsgReceiver *MsgReceiverSession) SlotValueVerifier() (common.Address, error) {
	return _MsgReceiver.Contract.SlotValueVerifier(&_MsgReceiver.CallOpts)
}

// SlotValueVerifier is a free data retrieval call binding the contract method 0x63c6ccb2.
//
// Solidity: function slotValueVerifier() view returns(address)
func (_MsgReceiver *MsgReceiverCallerSession) SlotValueVerifier() (common.Address, error) {
	return _MsgReceiver.Contract.SlotValueVerifier(&_MsgReceiver.CallOpts)
}

// RecvMsg is a paid mutator transaction binding the contract method 0xfaf6e9ec.
//
// Solidity: function recvMsg(uint64 _nonce, address _sender, bytes _msg, bytes _proofData, bytes _blkVerifyInfo) returns()
func (_MsgReceiver *MsgReceiverTransactor) RecvMsg(opts *bind.TransactOpts, _nonce uint64, _sender common.Address, _msg []byte, _proofData []byte, _blkVerifyInfo []byte) (*types.Transaction, error) {
	return _MsgReceiver.contract.Transact(opts, "recvMsg", _nonce, _sender, _msg, _proofData, _blkVerifyInfo)
}

// RecvMsg is a paid mutator transaction binding the contract method 0xfaf6e9ec.
//
// Solidity: function recvMsg(uint64 _nonce, address _sender, bytes _msg, bytes _proofData, bytes _blkVerifyInfo) returns()
func (_MsgReceiver *MsgReceiverSession) RecvMsg(_nonce uint64, _sender common.Address, _msg []byte, _proofData []byte, _blkVerifyInfo []byte) (*types.Transaction, error) {
	return _MsgReceiver.Contract.RecvMsg(&_MsgReceiver.TransactOpts, _nonce, _sender, _msg, _proofData, _blkVerifyInfo)
}

// RecvMsg is a paid mutator transaction binding the contract method 0xfaf6e9ec.
//
// Solidity: function recvMsg(uint64 _nonce, address _sender, bytes _msg, bytes _proofData, bytes _blkVerifyInfo) returns()
func (_MsgReceiver *MsgReceiverTransactorSession) RecvMsg(_nonce uint64, _sender common.Address, _msg []byte, _proofData []byte, _blkVerifyInfo []byte) (*types.Transaction, error) {
	return _MsgReceiver.Contract.RecvMsg(&_MsgReceiver.TransactOpts, _nonce, _sender, _msg, _proofData, _blkVerifyInfo)
}

// MsgReceiverMsgReceivedIterator is returned from FilterMsgReceived and is used to iterate over the raw logs and unpacked data for MsgReceived events raised by the MsgReceiver contract.
type MsgReceiverMsgReceivedIterator struct {
	Event *MsgReceiverMsgReceived // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MsgReceiverMsgReceivedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MsgReceiverMsgReceived)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MsgReceiverMsgReceived)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MsgReceiverMsgReceivedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MsgReceiverMsgReceivedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MsgReceiverMsgReceived represents a MsgReceived event raised by the MsgReceiver contract.
type MsgReceiverMsgReceived struct {
	Nonce  uint64
	Sender common.Address
	Msg    []byte
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterMsgReceived is a free log retrieval operation binding the contract event 0x0881b56db4adae1d4876705d8794dcbeb3c199027a9995685ea2a4e29b071394.
//
// Solidity: event MsgReceived(uint64 nonce, address sender, bytes msg)
func (_MsgReceiver *MsgReceiverFilterer) FilterMsgReceived(opts *bind.FilterOpts) (*MsgReceiverMsgReceivedIterator, error) {

	logs, sub, err := _MsgReceiver.contract.FilterLogs(opts, "MsgReceived")
	if err != nil {
		return nil, err
	}
	return &MsgReceiverMsgReceivedIterator{contract: _MsgReceiver.contract, event: "MsgReceived", logs: logs, sub: sub}, nil
}

// WatchMsgReceived is a free log subscription operation binding the contract event 0x0881b56db4adae1d4876705d8794dcbeb3c199027a9995685ea2a4e29b071394.
//
// Solidity: event MsgReceived(uint64 nonce, address sender, bytes msg)
func (_MsgReceiver *MsgReceiverFilterer) WatchMsgReceived(opts *bind.WatchOpts, sink chan<- *MsgReceiverMsgReceived) (event.Subscription, error) {

	logs, sub, err := _MsgReceiver.contract.WatchLogs(opts, "MsgReceived")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MsgReceiverMsgReceived)
				if err := _MsgReceiver.contract.UnpackLog(event, "MsgReceived", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMsgReceived is a log parse operation binding the contract event 0x0881b56db4adae1d4876705d8794dcbeb3c199027a9995685ea2a4e29b071394.
//
// Solidity: event MsgReceived(uint64 nonce, address sender, bytes msg)
func (_MsgReceiver *MsgReceiverFilterer) ParseMsgReceived(log types.Log) (*MsgReceiverMsgReceived, error) {
	event := new(MsgReceiverMsgReceived)
	if err := _MsgReceiver.contract.UnpackLog(event, "MsgReceived", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// MsgSenderMetaData contains all meta data concerning the MsgSender contract.
var MsgSenderMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"msg\",\"type\":\"bytes\"}],\"name\":\"MsgSent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_msg\",\"type\":\"bytes\"}],\"name\":\"sendMsg\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"sent\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x608080604052346100165761022a908161001b8239f35b5f80fdfe6080604081815260049182361015610015575f80fd5b5f92833560e01c918263737a3ca4146100aa57508163958c3b8d1461006c575063affed0e014610043575f80fd5b3461006857816003193601126100685767ffffffffffffffff60209254169051908152f35b5080fd5b9050346100a65760203660031901126100a6573567ffffffffffffffff81168091036100a657828291602094526001845220549051908152f35b8280fd5b849084346100a65760203660031901126100a657833567ffffffffffffffff918282116101f057366023830112156101f05781860135928084116101ec57602483019260248536920101116101ec57906053939291602086013360601b8152848460348901378685810189603482015203601481018852601f199687910116870196808810838911176101d9578784525190208188541688526001602052828820558654818116918083146101c657948796939460607ff6a47eba7434fcad087203d7461e306130fba93c290c0b4a04cc1343d14e3cda999685849560809a6001601f9901169067ffffffffffffffff1916178d558852336020890152870152816060870152868601378785828601015201168101030190a180f35b634e487b7160e01b895260118a52602489fd5b634e487b7160e01b895260418a52602489fd5b8580fd5b8480fdfea264697066735822122093beededc040b8b2e2c1f9b5ffe852e2b5f0cbc708ad83231bf86c156306597964736f6c63430008140033",
}

// MsgSenderABI is the input ABI used to generate the binding from.
// Deprecated: Use MsgSenderMetaData.ABI instead.
var MsgSenderABI = MsgSenderMetaData.ABI

// MsgSenderBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use MsgSenderMetaData.Bin instead.
var MsgSenderBin = MsgSenderMetaData.Bin

// DeployMsgSender deploys a new Ethereum contract, binding an instance of MsgSender to it.
func DeployMsgSender(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *MsgSender, error) {
	parsed, err := MsgSenderMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(MsgSenderBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &MsgSender{MsgSenderCaller: MsgSenderCaller{contract: contract}, MsgSenderTransactor: MsgSenderTransactor{contract: contract}, MsgSenderFilterer: MsgSenderFilterer{contract: contract}}, nil
}

// MsgSender is an auto generated Go binding around an Ethereum contract.
type MsgSender struct {
	MsgSenderCaller     // Read-only binding to the contract
	MsgSenderTransactor // Write-only binding to the contract
	MsgSenderFilterer   // Log filterer for contract events
}

// MsgSenderCaller is an auto generated read-only Go binding around an Ethereum contract.
type MsgSenderCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MsgSenderTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MsgSenderTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MsgSenderFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MsgSenderFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MsgSenderSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MsgSenderSession struct {
	Contract     *MsgSender        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MsgSenderCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MsgSenderCallerSession struct {
	Contract *MsgSenderCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// MsgSenderTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MsgSenderTransactorSession struct {
	Contract     *MsgSenderTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// MsgSenderRaw is an auto generated low-level Go binding around an Ethereum contract.
type MsgSenderRaw struct {
	Contract *MsgSender // Generic contract binding to access the raw methods on
}

// MsgSenderCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MsgSenderCallerRaw struct {
	Contract *MsgSenderCaller // Generic read-only contract binding to access the raw methods on
}

// MsgSenderTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MsgSenderTransactorRaw struct {
	Contract *MsgSenderTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMsgSender creates a new instance of MsgSender, bound to a specific deployed contract.
func NewMsgSender(address common.Address, backend bind.ContractBackend) (*MsgSender, error) {
	contract, err := bindMsgSender(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &MsgSender{MsgSenderCaller: MsgSenderCaller{contract: contract}, MsgSenderTransactor: MsgSenderTransactor{contract: contract}, MsgSenderFilterer: MsgSenderFilterer{contract: contract}}, nil
}

// NewMsgSenderCaller creates a new read-only instance of MsgSender, bound to a specific deployed contract.
func NewMsgSenderCaller(address common.Address, caller bind.ContractCaller) (*MsgSenderCaller, error) {
	contract, err := bindMsgSender(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MsgSenderCaller{contract: contract}, nil
}

// NewMsgSenderTransactor creates a new write-only instance of MsgSender, bound to a specific deployed contract.
func NewMsgSenderTransactor(address common.Address, transactor bind.ContractTransactor) (*MsgSenderTransactor, error) {
	contract, err := bindMsgSender(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MsgSenderTransactor{contract: contract}, nil
}

// NewMsgSenderFilterer creates a new log filterer instance of MsgSender, bound to a specific deployed contract.
func NewMsgSenderFilterer(address common.Address, filterer bind.ContractFilterer) (*MsgSenderFilterer, error) {
	contract, err := bindMsgSender(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MsgSenderFilterer{contract: contract}, nil
}

// bindMsgSender binds a generic wrapper to an already deployed contract.
func bindMsgSender(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := MsgSenderMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MsgSender *MsgSenderRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MsgSender.Contract.MsgSenderCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MsgSender *MsgSenderRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MsgSender.Contract.MsgSenderTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MsgSender *MsgSenderRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MsgSender.Contract.MsgSenderTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_MsgSender *MsgSenderCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _MsgSender.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_MsgSender *MsgSenderTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _MsgSender.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_MsgSender *MsgSenderTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _MsgSender.Contract.contract.Transact(opts, method, params...)
}

// Nonce is a free data retrieval call binding the contract method 0xaffed0e0.
//
// Solidity: function nonce() view returns(uint64)
func (_MsgSender *MsgSenderCaller) Nonce(opts *bind.CallOpts) (uint64, error) {
	var out []interface{}
	err := _MsgSender.contract.Call(opts, &out, "nonce")

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// Nonce is a free data retrieval call binding the contract method 0xaffed0e0.
//
// Solidity: function nonce() view returns(uint64)
func (_MsgSender *MsgSenderSession) Nonce() (uint64, error) {
	return _MsgSender.Contract.Nonce(&_MsgSender.CallOpts)
}

// Nonce is a free data retrieval call binding the contract method 0xaffed0e0.
//
// Solidity: function nonce() view returns(uint64)
func (_MsgSender *MsgSenderCallerSession) Nonce() (uint64, error) {
	return _MsgSender.Contract.Nonce(&_MsgSender.CallOpts)
}

// Sent is a free data retrieval call binding the contract method 0x958c3b8d.
//
// Solidity: function sent(uint64 ) view returns(bytes32)
func (_MsgSender *MsgSenderCaller) Sent(opts *bind.CallOpts, arg0 uint64) ([32]byte, error) {
	var out []interface{}
	err := _MsgSender.contract.Call(opts, &out, "sent", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// Sent is a free data retrieval call binding the contract method 0x958c3b8d.
//
// Solidity: function sent(uint64 ) view returns(bytes32)
func (_MsgSender *MsgSenderSession) Sent(arg0 uint64) ([32]byte, error) {
	return _MsgSender.Contract.Sent(&_MsgSender.CallOpts, arg0)
}

// Sent is a free data retrieval call binding the contract method 0x958c3b8d.
//
// Solidity: function sent(uint64 ) view returns(bytes32)
func (_MsgSender *MsgSenderCallerSession) Sent(arg0 uint64) ([32]byte, error) {
	return _MsgSender.Contract.Sent(&_MsgSender.CallOpts, arg0)
}

// SendMsg is a paid mutator transaction binding the contract method 0x737a3ca4.
//
// Solidity: function sendMsg(bytes _msg) returns()
func (_MsgSender *MsgSenderTransactor) SendMsg(opts *bind.TransactOpts, _msg []byte) (*types.Transaction, error) {
	return _MsgSender.contract.Transact(opts, "sendMsg", _msg)
}

// SendMsg is a paid mutator transaction binding the contract method 0x737a3ca4.
//
// Solidity: function sendMsg(bytes _msg) returns()
func (_MsgSender *MsgSenderSession) SendMsg(_msg []byte) (*types.Transaction, error) {
	return _MsgSender.Contract.SendMsg(&_MsgSender.TransactOpts, _msg)
}

// SendMsg is a paid mutator transaction binding the contract method 0x737a3ca4.
//
// Solidity: function sendMsg(bytes _msg) returns()
func (_MsgSender *MsgSenderTransactorSession) SendMsg(_msg []byte) (*types.Transaction, error) {
	return _MsgSender.Contract.SendMsg(&_MsgSender.TransactOpts, _msg)
}

// MsgSenderMsgSentIterator is returned from FilterMsgSent and is used to iterate over the raw logs and unpacked data for MsgSent events raised by the MsgSender contract.
type MsgSenderMsgSentIterator struct {
	Event *MsgSenderMsgSent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MsgSenderMsgSentIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MsgSenderMsgSent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MsgSenderMsgSent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MsgSenderMsgSentIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MsgSenderMsgSentIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MsgSenderMsgSent represents a MsgSent event raised by the MsgSender contract.
type MsgSenderMsgSent struct {
	Nonce  uint64
	Sender common.Address
	Msg    []byte
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterMsgSent is a free log retrieval operation binding the contract event 0xf6a47eba7434fcad087203d7461e306130fba93c290c0b4a04cc1343d14e3cda.
//
// Solidity: event MsgSent(uint64 nonce, address sender, bytes msg)
func (_MsgSender *MsgSenderFilterer) FilterMsgSent(opts *bind.FilterOpts) (*MsgSenderMsgSentIterator, error) {

	logs, sub, err := _MsgSender.contract.FilterLogs(opts, "MsgSent")
	if err != nil {
		return nil, err
	}
	return &MsgSenderMsgSentIterator{contract: _MsgSender.contract, event: "MsgSent", logs: logs, sub: sub}, nil
}

// WatchMsgSent is a free log subscription operation binding the contract event 0xf6a47eba7434fcad087203d7461e306130fba93c290c0b4a04cc1343d14e3cda.
//
// Solidity: event MsgSent(uint64 nonce, address sender, bytes msg)
func (_MsgSender *MsgSenderFilterer) WatchMsgSent(opts *bind.WatchOpts, sink chan<- *MsgSenderMsgSent) (event.Subscription, error) {

	logs, sub, err := _MsgSender.contract.WatchLogs(opts, "MsgSent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MsgSenderMsgSent)
				if err := _MsgSender.contract.UnpackLog(event, "MsgSent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMsgSent is a log parse operation binding the contract event 0xf6a47eba7434fcad087203d7461e306130fba93c290c0b4a04cc1343d14e3cda.
//
// Solidity: event MsgSent(uint64 nonce, address sender, bytes msg)
func (_MsgSender *MsgSenderFilterer) ParseMsgSent(log types.Log) (*MsgSenderMsgSent, error) {
	event := new(MsgSenderMsgSent)
	if err := _MsgSender.contract.UnpackLog(event, "MsgSent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OwnableMetaData contains all meta data concerning the Ownable contract.
var OwnableMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// OwnableABI is the input ABI used to generate the binding from.
// Deprecated: Use OwnableMetaData.ABI instead.
var OwnableABI = OwnableMetaData.ABI

// Ownable is an auto generated Go binding around an Ethereum contract.
type Ownable struct {
	OwnableCaller     // Read-only binding to the contract
	OwnableTransactor // Write-only binding to the contract
	OwnableFilterer   // Log filterer for contract events
}

// OwnableCaller is an auto generated read-only Go binding around an Ethereum contract.
type OwnableCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnableTransactor is an auto generated write-only Go binding around an Ethereum contract.
type OwnableTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnableFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type OwnableFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnableSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type OwnableSession struct {
	Contract     *Ownable          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// OwnableCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type OwnableCallerSession struct {
	Contract *OwnableCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// OwnableTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type OwnableTransactorSession struct {
	Contract     *OwnableTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// OwnableRaw is an auto generated low-level Go binding around an Ethereum contract.
type OwnableRaw struct {
	Contract *Ownable // Generic contract binding to access the raw methods on
}

// OwnableCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type OwnableCallerRaw struct {
	Contract *OwnableCaller // Generic read-only contract binding to access the raw methods on
}

// OwnableTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type OwnableTransactorRaw struct {
	Contract *OwnableTransactor // Generic write-only contract binding to access the raw methods on
}

// NewOwnable creates a new instance of Ownable, bound to a specific deployed contract.
func NewOwnable(address common.Address, backend bind.ContractBackend) (*Ownable, error) {
	contract, err := bindOwnable(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Ownable{OwnableCaller: OwnableCaller{contract: contract}, OwnableTransactor: OwnableTransactor{contract: contract}, OwnableFilterer: OwnableFilterer{contract: contract}}, nil
}

// NewOwnableCaller creates a new read-only instance of Ownable, bound to a specific deployed contract.
func NewOwnableCaller(address common.Address, caller bind.ContractCaller) (*OwnableCaller, error) {
	contract, err := bindOwnable(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &OwnableCaller{contract: contract}, nil
}

// NewOwnableTransactor creates a new write-only instance of Ownable, bound to a specific deployed contract.
func NewOwnableTransactor(address common.Address, transactor bind.ContractTransactor) (*OwnableTransactor, error) {
	contract, err := bindOwnable(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &OwnableTransactor{contract: contract}, nil
}

// NewOwnableFilterer creates a new log filterer instance of Ownable, bound to a specific deployed contract.
func NewOwnableFilterer(address common.Address, filterer bind.ContractFilterer) (*OwnableFilterer, error) {
	contract, err := bindOwnable(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &OwnableFilterer{contract: contract}, nil
}

// bindOwnable binds a generic wrapper to an already deployed contract.
func bindOwnable(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := OwnableMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Ownable *OwnableRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Ownable.Contract.OwnableCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Ownable *OwnableRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Ownable.Contract.OwnableTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Ownable *OwnableRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Ownable.Contract.OwnableTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Ownable *OwnableCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Ownable.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Ownable *OwnableTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Ownable.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Ownable *OwnableTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Ownable.Contract.contract.Transact(opts, method, params...)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Ownable *OwnableCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Ownable.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Ownable *OwnableSession) Owner() (common.Address, error) {
	return _Ownable.Contract.Owner(&_Ownable.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Ownable *OwnableCallerSession) Owner() (common.Address, error) {
	return _Ownable.Contract.Owner(&_Ownable.CallOpts)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Ownable *OwnableTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _Ownable.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Ownable *OwnableSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _Ownable.Contract.TransferOwnership(&_Ownable.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Ownable *OwnableTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _Ownable.Contract.TransferOwnership(&_Ownable.TransactOpts, newOwner)
}

// OwnableOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the Ownable contract.
type OwnableOwnershipTransferredIterator struct {
	Event *OwnableOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OwnableOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OwnableOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OwnableOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OwnableOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OwnableOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OwnableOwnershipTransferred represents a OwnershipTransferred event raised by the Ownable contract.
type OwnableOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Ownable *OwnableFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*OwnableOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Ownable.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &OwnableOwnershipTransferredIterator{contract: _Ownable.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Ownable *OwnableFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *OwnableOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Ownable.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OwnableOwnershipTransferred)
				if err := _Ownable.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Ownable *OwnableFilterer) ParseOwnershipTransferred(log types.Log) (*OwnableOwnershipTransferred, error) {
	event := new(OwnableOwnershipTransferred)
	if err := _Ownable.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PairingMetaData contains all meta data concerning the Pairing contract.
var PairingMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212208b563705db10faa7b70648630d64eb19a0d13fc28ce4200147620a782aab00b164736f6c63430008140033",
}

// PairingABI is the input ABI used to generate the binding from.
// Deprecated: Use PairingMetaData.ABI instead.
var PairingABI = PairingMetaData.ABI

// PairingBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use PairingMetaData.Bin instead.
var PairingBin = PairingMetaData.Bin

// DeployPairing deploys a new Ethereum contract, binding an instance of Pairing to it.
func DeployPairing(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Pairing, error) {
	parsed, err := PairingMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(PairingBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Pairing{PairingCaller: PairingCaller{contract: contract}, PairingTransactor: PairingTransactor{contract: contract}, PairingFilterer: PairingFilterer{contract: contract}}, nil
}

// Pairing is an auto generated Go binding around an Ethereum contract.
type Pairing struct {
	PairingCaller     // Read-only binding to the contract
	PairingTransactor // Write-only binding to the contract
	PairingFilterer   // Log filterer for contract events
}

// PairingCaller is an auto generated read-only Go binding around an Ethereum contract.
type PairingCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PairingTransactor is an auto generated write-only Go binding around an Ethereum contract.
type PairingTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PairingFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type PairingFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PairingSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type PairingSession struct {
	Contract     *Pairing          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// PairingCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type PairingCallerSession struct {
	Contract *PairingCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// PairingTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type PairingTransactorSession struct {
	Contract     *PairingTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// PairingRaw is an auto generated low-level Go binding around an Ethereum contract.
type PairingRaw struct {
	Contract *Pairing // Generic contract binding to access the raw methods on
}

// PairingCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type PairingCallerRaw struct {
	Contract *PairingCaller // Generic read-only contract binding to access the raw methods on
}

// PairingTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type PairingTransactorRaw struct {
	Contract *PairingTransactor // Generic write-only contract binding to access the raw methods on
}

// NewPairing creates a new instance of Pairing, bound to a specific deployed contract.
func NewPairing(address common.Address, backend bind.ContractBackend) (*Pairing, error) {
	contract, err := bindPairing(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Pairing{PairingCaller: PairingCaller{contract: contract}, PairingTransactor: PairingTransactor{contract: contract}, PairingFilterer: PairingFilterer{contract: contract}}, nil
}

// NewPairingCaller creates a new read-only instance of Pairing, bound to a specific deployed contract.
func NewPairingCaller(address common.Address, caller bind.ContractCaller) (*PairingCaller, error) {
	contract, err := bindPairing(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &PairingCaller{contract: contract}, nil
}

// NewPairingTransactor creates a new write-only instance of Pairing, bound to a specific deployed contract.
func NewPairingTransactor(address common.Address, transactor bind.ContractTransactor) (*PairingTransactor, error) {
	contract, err := bindPairing(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &PairingTransactor{contract: contract}, nil
}

// NewPairingFilterer creates a new log filterer instance of Pairing, bound to a specific deployed contract.
func NewPairingFilterer(address common.Address, filterer bind.ContractFilterer) (*PairingFilterer, error) {
	contract, err := bindPairing(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &PairingFilterer{contract: contract}, nil
}

// bindPairing binds a generic wrapper to an already deployed contract.
func bindPairing(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := PairingMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Pairing *PairingRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Pairing.Contract.PairingCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Pairing *PairingRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Pairing.Contract.PairingTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Pairing *PairingRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Pairing.Contract.PairingTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Pairing *PairingCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Pairing.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Pairing *PairingTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Pairing.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Pairing *PairingTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Pairing.Contract.contract.Transact(opts, method, params...)
}

// PausableMetaData contains all meta data concerning the Pausable contract.
var PausableMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// PausableABI is the input ABI used to generate the binding from.
// Deprecated: Use PausableMetaData.ABI instead.
var PausableABI = PausableMetaData.ABI

// Pausable is an auto generated Go binding around an Ethereum contract.
type Pausable struct {
	PausableCaller     // Read-only binding to the contract
	PausableTransactor // Write-only binding to the contract
	PausableFilterer   // Log filterer for contract events
}

// PausableCaller is an auto generated read-only Go binding around an Ethereum contract.
type PausableCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PausableTransactor is an auto generated write-only Go binding around an Ethereum contract.
type PausableTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PausableFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type PausableFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PausableSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type PausableSession struct {
	Contract     *Pausable         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// PausableCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type PausableCallerSession struct {
	Contract *PausableCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// PausableTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type PausableTransactorSession struct {
	Contract     *PausableTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// PausableRaw is an auto generated low-level Go binding around an Ethereum contract.
type PausableRaw struct {
	Contract *Pausable // Generic contract binding to access the raw methods on
}

// PausableCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type PausableCallerRaw struct {
	Contract *PausableCaller // Generic read-only contract binding to access the raw methods on
}

// PausableTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type PausableTransactorRaw struct {
	Contract *PausableTransactor // Generic write-only contract binding to access the raw methods on
}

// NewPausable creates a new instance of Pausable, bound to a specific deployed contract.
func NewPausable(address common.Address, backend bind.ContractBackend) (*Pausable, error) {
	contract, err := bindPausable(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Pausable{PausableCaller: PausableCaller{contract: contract}, PausableTransactor: PausableTransactor{contract: contract}, PausableFilterer: PausableFilterer{contract: contract}}, nil
}

// NewPausableCaller creates a new read-only instance of Pausable, bound to a specific deployed contract.
func NewPausableCaller(address common.Address, caller bind.ContractCaller) (*PausableCaller, error) {
	contract, err := bindPausable(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &PausableCaller{contract: contract}, nil
}

// NewPausableTransactor creates a new write-only instance of Pausable, bound to a specific deployed contract.
func NewPausableTransactor(address common.Address, transactor bind.ContractTransactor) (*PausableTransactor, error) {
	contract, err := bindPausable(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &PausableTransactor{contract: contract}, nil
}

// NewPausableFilterer creates a new log filterer instance of Pausable, bound to a specific deployed contract.
func NewPausableFilterer(address common.Address, filterer bind.ContractFilterer) (*PausableFilterer, error) {
	contract, err := bindPausable(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &PausableFilterer{contract: contract}, nil
}

// bindPausable binds a generic wrapper to an already deployed contract.
func bindPausable(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := PausableMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Pausable *PausableRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Pausable.Contract.PausableCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Pausable *PausableRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Pausable.Contract.PausableTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Pausable *PausableRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Pausable.Contract.PausableTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Pausable *PausableCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Pausable.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Pausable *PausableTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Pausable.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Pausable *PausableTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Pausable.Contract.contract.Transact(opts, method, params...)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_Pausable *PausableCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _Pausable.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_Pausable *PausableSession) Paused() (bool, error) {
	return _Pausable.Contract.Paused(&_Pausable.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_Pausable *PausableCallerSession) Paused() (bool, error) {
	return _Pausable.Contract.Paused(&_Pausable.CallOpts)
}

// PausablePausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the Pausable contract.
type PausablePausedIterator struct {
	Event *PausablePaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PausablePausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PausablePaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PausablePaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PausablePausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PausablePausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PausablePaused represents a Paused event raised by the Pausable contract.
type PausablePaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_Pausable *PausableFilterer) FilterPaused(opts *bind.FilterOpts) (*PausablePausedIterator, error) {

	logs, sub, err := _Pausable.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &PausablePausedIterator{contract: _Pausable.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_Pausable *PausableFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *PausablePaused) (event.Subscription, error) {

	logs, sub, err := _Pausable.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PausablePaused)
				if err := _Pausable.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_Pausable *PausableFilterer) ParsePaused(log types.Log) (*PausablePaused, error) {
	event := new(PausablePaused)
	if err := _Pausable.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PausableUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the Pausable contract.
type PausableUnpausedIterator struct {
	Event *PausableUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PausableUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PausableUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PausableUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PausableUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PausableUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PausableUnpaused represents a Unpaused event raised by the Pausable contract.
type PausableUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_Pausable *PausableFilterer) FilterUnpaused(opts *bind.FilterOpts) (*PausableUnpausedIterator, error) {

	logs, sub, err := _Pausable.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &PausableUnpausedIterator{contract: _Pausable.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_Pausable *PausableFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *PausableUnpaused) (event.Subscription, error) {

	logs, sub, err := _Pausable.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PausableUnpaused)
				if err := _Pausable.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_Pausable *PausableFilterer) ParseUnpaused(log types.Log) (*PausableUnpaused, error) {
	event := new(PausableUnpaused)
	if err := _Pausable.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PauserMetaData contains all meta data concerning the Pauser contract.
var PauserMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addPausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numPausers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pauserList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removePausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// PauserABI is the input ABI used to generate the binding from.
// Deprecated: Use PauserMetaData.ABI instead.
var PauserABI = PauserMetaData.ABI

// Pauser is an auto generated Go binding around an Ethereum contract.
type Pauser struct {
	PauserCaller     // Read-only binding to the contract
	PauserTransactor // Write-only binding to the contract
	PauserFilterer   // Log filterer for contract events
}

// PauserCaller is an auto generated read-only Go binding around an Ethereum contract.
type PauserCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PauserTransactor is an auto generated write-only Go binding around an Ethereum contract.
type PauserTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PauserFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type PauserFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PauserSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type PauserSession struct {
	Contract     *Pauser           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// PauserCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type PauserCallerSession struct {
	Contract *PauserCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// PauserTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type PauserTransactorSession struct {
	Contract     *PauserTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// PauserRaw is an auto generated low-level Go binding around an Ethereum contract.
type PauserRaw struct {
	Contract *Pauser // Generic contract binding to access the raw methods on
}

// PauserCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type PauserCallerRaw struct {
	Contract *PauserCaller // Generic read-only contract binding to access the raw methods on
}

// PauserTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type PauserTransactorRaw struct {
	Contract *PauserTransactor // Generic write-only contract binding to access the raw methods on
}

// NewPauser creates a new instance of Pauser, bound to a specific deployed contract.
func NewPauser(address common.Address, backend bind.ContractBackend) (*Pauser, error) {
	contract, err := bindPauser(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Pauser{PauserCaller: PauserCaller{contract: contract}, PauserTransactor: PauserTransactor{contract: contract}, PauserFilterer: PauserFilterer{contract: contract}}, nil
}

// NewPauserCaller creates a new read-only instance of Pauser, bound to a specific deployed contract.
func NewPauserCaller(address common.Address, caller bind.ContractCaller) (*PauserCaller, error) {
	contract, err := bindPauser(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &PauserCaller{contract: contract}, nil
}

// NewPauserTransactor creates a new write-only instance of Pauser, bound to a specific deployed contract.
func NewPauserTransactor(address common.Address, transactor bind.ContractTransactor) (*PauserTransactor, error) {
	contract, err := bindPauser(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &PauserTransactor{contract: contract}, nil
}

// NewPauserFilterer creates a new log filterer instance of Pauser, bound to a specific deployed contract.
func NewPauserFilterer(address common.Address, filterer bind.ContractFilterer) (*PauserFilterer, error) {
	contract, err := bindPauser(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &PauserFilterer{contract: contract}, nil
}

// bindPauser binds a generic wrapper to an already deployed contract.
func bindPauser(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := PauserMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Pauser *PauserRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Pauser.Contract.PauserCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Pauser *PauserRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Pauser.Contract.PauserTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Pauser *PauserRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Pauser.Contract.PauserTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Pauser *PauserCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Pauser.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Pauser *PauserTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Pauser.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Pauser *PauserTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Pauser.Contract.contract.Transact(opts, method, params...)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_Pauser *PauserCaller) IsPauser(opts *bind.CallOpts, account common.Address) (bool, error) {
	var out []interface{}
	err := _Pauser.contract.Call(opts, &out, "isPauser", account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_Pauser *PauserSession) IsPauser(account common.Address) (bool, error) {
	return _Pauser.Contract.IsPauser(&_Pauser.CallOpts, account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_Pauser *PauserCallerSession) IsPauser(account common.Address) (bool, error) {
	return _Pauser.Contract.IsPauser(&_Pauser.CallOpts, account)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_Pauser *PauserCaller) NumPausers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Pauser.contract.Call(opts, &out, "numPausers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_Pauser *PauserSession) NumPausers() (*big.Int, error) {
	return _Pauser.Contract.NumPausers(&_Pauser.CallOpts)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_Pauser *PauserCallerSession) NumPausers() (*big.Int, error) {
	return _Pauser.Contract.NumPausers(&_Pauser.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Pauser *PauserCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Pauser.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Pauser *PauserSession) Owner() (common.Address, error) {
	return _Pauser.Contract.Owner(&_Pauser.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_Pauser *PauserCallerSession) Owner() (common.Address, error) {
	return _Pauser.Contract.Owner(&_Pauser.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_Pauser *PauserCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _Pauser.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_Pauser *PauserSession) Paused() (bool, error) {
	return _Pauser.Contract.Paused(&_Pauser.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_Pauser *PauserCallerSession) Paused() (bool, error) {
	return _Pauser.Contract.Paused(&_Pauser.CallOpts)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_Pauser *PauserCaller) PauserList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _Pauser.contract.Call(opts, &out, "pauserList", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_Pauser *PauserSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _Pauser.Contract.PauserList(&_Pauser.CallOpts, arg0)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_Pauser *PauserCallerSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _Pauser.Contract.PauserList(&_Pauser.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_Pauser *PauserCaller) Pausers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _Pauser.contract.Call(opts, &out, "pausers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_Pauser *PauserSession) Pausers(arg0 common.Address) (bool, error) {
	return _Pauser.Contract.Pausers(&_Pauser.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_Pauser *PauserCallerSession) Pausers(arg0 common.Address) (bool, error) {
	return _Pauser.Contract.Pausers(&_Pauser.CallOpts, arg0)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_Pauser *PauserTransactor) AddPauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _Pauser.contract.Transact(opts, "addPauser", account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_Pauser *PauserSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _Pauser.Contract.AddPauser(&_Pauser.TransactOpts, account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_Pauser *PauserTransactorSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _Pauser.Contract.AddPauser(&_Pauser.TransactOpts, account)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_Pauser *PauserTransactor) AddPausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _Pauser.contract.Transact(opts, "addPausers", accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_Pauser *PauserSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _Pauser.Contract.AddPausers(&_Pauser.TransactOpts, accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_Pauser *PauserTransactorSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _Pauser.Contract.AddPausers(&_Pauser.TransactOpts, accounts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_Pauser *PauserTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Pauser.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_Pauser *PauserSession) Pause() (*types.Transaction, error) {
	return _Pauser.Contract.Pause(&_Pauser.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_Pauser *PauserTransactorSession) Pause() (*types.Transaction, error) {
	return _Pauser.Contract.Pause(&_Pauser.TransactOpts)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_Pauser *PauserTransactor) RemovePauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _Pauser.contract.Transact(opts, "removePauser", account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_Pauser *PauserSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _Pauser.Contract.RemovePauser(&_Pauser.TransactOpts, account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_Pauser *PauserTransactorSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _Pauser.Contract.RemovePauser(&_Pauser.TransactOpts, account)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_Pauser *PauserTransactor) RemovePausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _Pauser.contract.Transact(opts, "removePausers", accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_Pauser *PauserSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _Pauser.Contract.RemovePausers(&_Pauser.TransactOpts, accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_Pauser *PauserTransactorSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _Pauser.Contract.RemovePausers(&_Pauser.TransactOpts, accounts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_Pauser *PauserTransactor) RenouncePauser(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Pauser.contract.Transact(opts, "renouncePauser")
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_Pauser *PauserSession) RenouncePauser() (*types.Transaction, error) {
	return _Pauser.Contract.RenouncePauser(&_Pauser.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_Pauser *PauserTransactorSession) RenouncePauser() (*types.Transaction, error) {
	return _Pauser.Contract.RenouncePauser(&_Pauser.TransactOpts)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Pauser *PauserTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _Pauser.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Pauser *PauserSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _Pauser.Contract.TransferOwnership(&_Pauser.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Pauser *PauserTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _Pauser.Contract.TransferOwnership(&_Pauser.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_Pauser *PauserTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Pauser.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_Pauser *PauserSession) Unpause() (*types.Transaction, error) {
	return _Pauser.Contract.Unpause(&_Pauser.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_Pauser *PauserTransactorSession) Unpause() (*types.Transaction, error) {
	return _Pauser.Contract.Unpause(&_Pauser.TransactOpts)
}

// PauserOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the Pauser contract.
type PauserOwnershipTransferredIterator struct {
	Event *PauserOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PauserOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PauserOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PauserOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PauserOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PauserOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PauserOwnershipTransferred represents a OwnershipTransferred event raised by the Pauser contract.
type PauserOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Pauser *PauserFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*PauserOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Pauser.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &PauserOwnershipTransferredIterator{contract: _Pauser.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Pauser *PauserFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *PauserOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Pauser.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PauserOwnershipTransferred)
				if err := _Pauser.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Pauser *PauserFilterer) ParseOwnershipTransferred(log types.Log) (*PauserOwnershipTransferred, error) {
	event := new(PauserOwnershipTransferred)
	if err := _Pauser.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PauserPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the Pauser contract.
type PauserPausedIterator struct {
	Event *PauserPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PauserPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PauserPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PauserPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PauserPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PauserPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PauserPaused represents a Paused event raised by the Pauser contract.
type PauserPaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_Pauser *PauserFilterer) FilterPaused(opts *bind.FilterOpts) (*PauserPausedIterator, error) {

	logs, sub, err := _Pauser.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &PauserPausedIterator{contract: _Pauser.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_Pauser *PauserFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *PauserPaused) (event.Subscription, error) {

	logs, sub, err := _Pauser.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PauserPaused)
				if err := _Pauser.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_Pauser *PauserFilterer) ParsePaused(log types.Log) (*PauserPaused, error) {
	event := new(PauserPaused)
	if err := _Pauser.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PauserPauserAddedIterator is returned from FilterPauserAdded and is used to iterate over the raw logs and unpacked data for PauserAdded events raised by the Pauser contract.
type PauserPauserAddedIterator struct {
	Event *PauserPauserAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PauserPauserAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PauserPauserAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PauserPauserAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PauserPauserAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PauserPauserAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PauserPauserAdded represents a PauserAdded event raised by the Pauser contract.
type PauserPauserAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserAdded is a free log retrieval operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_Pauser *PauserFilterer) FilterPauserAdded(opts *bind.FilterOpts) (*PauserPauserAddedIterator, error) {

	logs, sub, err := _Pauser.contract.FilterLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return &PauserPauserAddedIterator{contract: _Pauser.contract, event: "PauserAdded", logs: logs, sub: sub}, nil
}

// WatchPauserAdded is a free log subscription operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_Pauser *PauserFilterer) WatchPauserAdded(opts *bind.WatchOpts, sink chan<- *PauserPauserAdded) (event.Subscription, error) {

	logs, sub, err := _Pauser.contract.WatchLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PauserPauserAdded)
				if err := _Pauser.contract.UnpackLog(event, "PauserAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserAdded is a log parse operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_Pauser *PauserFilterer) ParsePauserAdded(log types.Log) (*PauserPauserAdded, error) {
	event := new(PauserPauserAdded)
	if err := _Pauser.contract.UnpackLog(event, "PauserAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PauserPauserRemovedIterator is returned from FilterPauserRemoved and is used to iterate over the raw logs and unpacked data for PauserRemoved events raised by the Pauser contract.
type PauserPauserRemovedIterator struct {
	Event *PauserPauserRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PauserPauserRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PauserPauserRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PauserPauserRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PauserPauserRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PauserPauserRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PauserPauserRemoved represents a PauserRemoved event raised by the Pauser contract.
type PauserPauserRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserRemoved is a free log retrieval operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_Pauser *PauserFilterer) FilterPauserRemoved(opts *bind.FilterOpts) (*PauserPauserRemovedIterator, error) {

	logs, sub, err := _Pauser.contract.FilterLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return &PauserPauserRemovedIterator{contract: _Pauser.contract, event: "PauserRemoved", logs: logs, sub: sub}, nil
}

// WatchPauserRemoved is a free log subscription operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_Pauser *PauserFilterer) WatchPauserRemoved(opts *bind.WatchOpts, sink chan<- *PauserPauserRemoved) (event.Subscription, error) {

	logs, sub, err := _Pauser.contract.WatchLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PauserPauserRemoved)
				if err := _Pauser.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserRemoved is a log parse operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_Pauser *PauserFilterer) ParsePauserRemoved(log types.Log) (*PauserPauserRemoved, error) {
	event := new(PauserPauserRemoved)
	if err := _Pauser.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PauserUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the Pauser contract.
type PauserUnpausedIterator struct {
	Event *PauserUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PauserUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PauserUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PauserUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PauserUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PauserUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PauserUnpaused represents a Unpaused event raised by the Pauser contract.
type PauserUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_Pauser *PauserFilterer) FilterUnpaused(opts *bind.FilterOpts) (*PauserUnpausedIterator, error) {

	logs, sub, err := _Pauser.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &PauserUnpausedIterator{contract: _Pauser.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_Pauser *PauserFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *PauserUnpaused) (event.Subscription, error) {

	logs, sub, err := _Pauser.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PauserUnpaused)
				if err := _Pauser.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_Pauser *PauserFilterer) ParseUnpaused(log types.Log) (*PauserUnpaused, error) {
	event := new(PauserUnpaused)
	if err := _Pauser.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PegBridgeMetaData contains all meta data concerning the PegBridge contract.
var PegBridgeMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"contractIMessageBridge\",\"name\":\"_messageBridge\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vaultToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pegToken\",\"type\":\"address\"}],\"name\":\"BridgeTokenAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vaultToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pegToken\",\"type\":\"address\"}],\"name\":\"BridgeTokenDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"burnId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"burnAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"withdrawAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MinBurnUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"mintId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"refId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_toChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_withdrawAccount\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_pegTokens\",\"type\":\"address[]\"}],\"name\":\"deletePegTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_vaultTokens\",\"type\":\"address[]\"}],\"name\":\"deleteVaultTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"executeMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"messageBridge\",\"outputs\":[{\"internalType\":\"contractIMessageBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pegToVaultTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"records\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_vaultTokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_pegTokens\",\"type\":\"address[]\"}],\"name\":\"setBridgeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMinBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_vaultChain\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_vaultAddress\",\"type\":\"address\"}],\"name\":\"setTokenVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supplies\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultChain\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vaultToPegTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x6080346100a657601f61132c38819003918201601f19168301916001600160401b038311848410176100aa578084926020946040528339810103126100a657516001600160a01b0390818116908190036100a65760018060a01b031990815f5416175f55600154903390821617600155604051913391167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a361126d90816100bf8239f35b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe6080806040526004361015610012575f80fd5b5f90813560e01c90816301e6472514610f9d5750806304a2cbd014610f235780630745fcce14610e32578063274cee3114610dfa57806332eb41f614610dd257806333a42db114610dac57806340b6cc3414610cc7578063430bf08a14610c9d578063715018a614610c3e5780637f85601314610c065780638da5cb5b14610bdf57806390fc2e2514610ba4578063a00293011461075e578063a93ce09914610644578063aec95a14146102d5578063bf4816f0146101ff578063f2fde38b146101215763fdbcd5db146100e4575f80fd5b3461011e57602036600319011261011e5760209060406001600160a01b03918261010c610ffa565b16815260048452205416604051908152f35b80fd5b503461011e57602036600319011261011e5761013b610ffa565b600154906001600160a01b0380831691610156338414611132565b16918215610194576001600160a01b03191682176001557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a380f35b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608490fd5b503461011e5761020e36611057565b90916001600160a01b039361022885600154163314611132565b61023383831461117d565b855b828110610240578680f35b8061024f6102d09286886111eb565b358761026461025f8488886111eb565b61120f565b168952600660205260408920557f3796cd0b17a8734f8da819920625598e9a18be490f686725282e5383f1d066836102a061025f8387876111eb565b6102ab83888a6111eb565b604080516001600160a01b03909316835290356020830152819081015b0390a16111c9565b610235565b503461011e57608036600319011261011e576102ef610fc9565b906102f8610fe4565b9160449283359067ffffffffffffffff90818311610640573660238401121561064057826004013582811161063c5783019060249236848401116106385761033e611010565b506001600160a01b03958688541633036105f557600754918083169116036105b25760401c85169085160361056f578260a091031261056b57610382818301611223565b94808301359061039460648501611223565b9660a46103a360848701611223565b9501359386808a169216885260209860048a526040892054908882169485156105295750604051908b8201926bffffffffffffffffffffffff199182809260601b16855288603485015260601b1660548301528860601b16606882015286607c8201523060601b609c8201526090815261041c816110ca565b5190209788815260028a5261043860ff604083205416156110e6565b88815260028a5260408120805460ff19166001179055833b1561011e576040516340c10f1960e01b81526001600160a01b038416600482015260248101869052818160448183895af1801561051e5761050f575b509083825260038a5260408220908154928684018094116104fe578b7f317276091e0f98226fe28cd525f29e0b1c7b3edd91bf9f85e5f0aba596074ac960c08d8d8d8d8d8d8d8d8d55604051968752898701526040860152606085015260808401521660a0820152a160405160018152f35b634e487b7160e01b81526011600452fd5b610518906110a2565b5f61048c565b6040513d84823e3d90fd5b8b7f6e6f2070656720746f6b656e0000000000000000000000000000000000000000606492600c876040519462461bcd60e51b86526004860152840152820152fd5b8380fd5b60405162461bcd60e51b8152602060048201526019818401527f73656e646572206973206e6f7420746f6b656e207661756c740000000000000081880152606490fd5b60405162461bcd60e51b8152602060048201526014818601527f6e6f742066726f6d207661756c7420636861696e000000000000000000000000818a0152606490fd5b60405162461bcd60e51b815260206004820152601c818701527f63616c6c6572206973206e6f74206d6573736167652062726964676500000000818b0152606490fd5b8680fd5b8580fd5b8480fd5b503461011e5761065336611057565b91926001600160a01b039361066d85600154163314611132565b61067884821461117d565b855b818110610685578680f35b8061069761025f6107599388886111eb565b876106a661025f8487896111eb565b1689526020906004825260408a20896001600160a01b031992168282541617905560056106d761025f85888a6111eb565b928a6106e761025f878d8d6111eb565b168c52528860408b209216908254161790557feabeda8c7848101043c4c7d8a980cbc9078963ea815cd1cdfcab1dfdc80eb91161072861025f8386886111eb565b61073661025f848a8a6111eb565b604080516001600160a01b039384168152929091166020830152819081016102c8565b61067a565b503461011e5760a036600319011261011e57610778610ffa565b9067ffffffffffffffff604435166044350361011e57610796611010565b67ffffffffffffffff6084351660843503610ba0576001600160a01b0383168252600660205260408220546024351115610b5b576001600160a01b038316825260056020526001600160a01b03604083205416928315610b16576001600160a01b0381168352600360205260408320805480602435810311610b0257602435900390556001600160a01b0360405160208101903360601b82526bffffffffffffffffffffffff19808560601b16603483015260243560488301527fffffffffffffffff000000000000000000000000000000000000000000000000908160443560c01b1660688401528660601b1660708301528060843560c01b1660848301524660c01b16608c8201523060601b6094820152608881526108b6816110ca565b5190209283855260026020526108d360ff604087205416156110e6565b838552600260205260408520600160ff198254161790556040519560208701526024356040870152168060608601523360808601528260a086015260a0855261091b856110ca565b6001600160a01b0360075460401c166001600160a01b0385541660405191635c85c1a960e11b835267ffffffffffffffff6044351660048401526024830152606060448301528651806064840152865b818110610aec57508280928189608482868383602099601f9c0101528919998a91011681010301925af1918215610ae1578692610a83575b50507f1b4b8f452b18b4a267e27ea158479a8124cef2cd93a0d59309667a8e933ab2859160e091604051918683523360208401526001600160a01b03861660408401526024356060840152608083015267ffffffffffffffff6084351660a083015260c0820152a16001600160a01b0381163b15610a7f5760405163079cc67960e41b815233600482015260248035908201529083908290604490829084906001600160a01b03165af18015610a745760209350610a65575b50604051908152f35b610a6e906110a2565b82610a5c565b6040513d85823e3d90fd5b8280fd5b9091506020903d602011610ad9575b601f820116820182811067ffffffffffffffff821117610ac55760209183916040528101031261064057518160e06109a3565b634e487b7160e01b87526041600452602487fd5b3d9150610a92565b6040513d88823e3d90fd5b80602080928b010151608482870101520161096b565b634e487b7160e01b85526011600452602485fd5b60405162461bcd60e51b815260206004820152600e60248201527f6e6f207661756c7420746f6b656e0000000000000000000000000000000000006044820152606490fd5b60405162461bcd60e51b815260206004820152601060248201527f616d6f756e7420746f6f20736d616c6c000000000000000000000000000000006044820152606490fd5b5080fd5b503461011e57602036600319011261011e5760209060406001600160a01b039182610bcd610ffa565b16815260058452205416604051908152f35b503461011e578060031936011261011e5760206001600160a01b0360015416604051908152f35b503461011e57602036600319011261011e5760406020916001600160a01b03610c2d610ffa565b168152600683522054604051908152f35b503461011e578060031936011261011e57806001546001600160a01b03196001600160a01b03821691610c72338414611132565b166001557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b503461011e578060031936011261011e5760206001600160a01b0360075460401c16604051908152f35b503461011e57602080600319360112610ba05760043567ffffffffffffffff8111610a7f57610cfa903690600401611026565b6001600160a01b0392919290610d1582600154163314611132565b845b818110610d22578580f35b807f2ff7cbe4f1f12bb7d93999c06304c58410c46ebb8ddbcba627d52d93a6aaffb1610d5561025f610da794868a6111eb565b8086168952600487526040808a2080546001600160a01b03198082169092558816808c5260058a52828c20805490921690915581516001600160a01b03938416815292166020830152819081016102c8565b610d17565b503461011e578060031936011261011e576001600160a01b036020915416604051908152f35b503461011e578060031936011261011e57602067ffffffffffffffff60075416604051908152f35b503461011e57602036600319011261011e5760406020916001600160a01b03610e21610ffa565b168152600383522054604051908152f35b503461011e57602080600319360112610ba05760043567ffffffffffffffff8111610a7f57610e65903690600401611026565b6001600160a01b0392919290610e8082600154163314611132565b845b818110610e8d578580f35b807f2ff7cbe4f1f12bb7d93999c06304c58410c46ebb8ddbcba627d52d93a6aaffb1610ec061025f610f1e94868a6111eb565b808616808a5260058089526040808c20548916808d5260048b52818d2080546001600160a01b0319908116909155938d52918a52808c20805490931690925581516001600160a01b03918216815292166020830152819081016102c8565b610e82565b503461011e57604036600319011261011e57610f3d610fc9565b610f45610fe4565b610f5b6001600160a01b03600154163314611132565b67ffffffffffffffff7bffffffffffffffffffffffffffffffffffffffff00000000000000006007549260401b1692169063ffffffff60e01b16171760075580f35b905034610ba0576020366003190112610ba05760ff604060209360043581526002855220541615158152f35b6004359067ffffffffffffffff82168203610fe057565b5f80fd5b602435906001600160a01b0382168203610fe057565b600435906001600160a01b0382168203610fe057565b606435906001600160a01b0382168203610fe057565b9181601f84011215610fe05782359167ffffffffffffffff8311610fe0576020808501948460051b010111610fe057565b6040600319820112610fe05767ffffffffffffffff91600435838111610fe0578261108491600401611026565b93909392602435918211610fe05761109e91600401611026565b9091565b67ffffffffffffffff81116110b657604052565b634e487b7160e01b5f52604160045260245ffd5b60c0810190811067ffffffffffffffff8211176110b657604052565b156110ed57565b60405162461bcd60e51b815260206004820152600d60248201527f7265636f726420657869737473000000000000000000000000000000000000006044820152606490fd5b1561113957565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b1561118457565b60405162461bcd60e51b815260206004820152600f60248201527f6c656e677468206d69736d6174636800000000000000000000000000000000006044820152606490fd5b5f1981146111d75760010190565b634e487b7160e01b5f52601160045260245ffd5b91908110156111fb5760051b0190565b634e487b7160e01b5f52603260045260245ffd5b356001600160a01b0381168103610fe05790565b35906001600160a01b0382168203610fe05756fea2646970667358221220fb7bb39c3c5d9457bb55f0acddfa7f7badf0c4ed0aee336663eda88a0941d99d64736f6c63430008140033",
}

// PegBridgeABI is the input ABI used to generate the binding from.
// Deprecated: Use PegBridgeMetaData.ABI instead.
var PegBridgeABI = PegBridgeMetaData.ABI

// PegBridgeBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use PegBridgeMetaData.Bin instead.
var PegBridgeBin = PegBridgeMetaData.Bin

// DeployPegBridge deploys a new Ethereum contract, binding an instance of PegBridge to it.
func DeployPegBridge(auth *bind.TransactOpts, backend bind.ContractBackend, _messageBridge common.Address) (common.Address, *types.Transaction, *PegBridge, error) {
	parsed, err := PegBridgeMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(PegBridgeBin), backend, _messageBridge)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &PegBridge{PegBridgeCaller: PegBridgeCaller{contract: contract}, PegBridgeTransactor: PegBridgeTransactor{contract: contract}, PegBridgeFilterer: PegBridgeFilterer{contract: contract}}, nil
}

// PegBridge is an auto generated Go binding around an Ethereum contract.
type PegBridge struct {
	PegBridgeCaller     // Read-only binding to the contract
	PegBridgeTransactor // Write-only binding to the contract
	PegBridgeFilterer   // Log filterer for contract events
}

// PegBridgeCaller is an auto generated read-only Go binding around an Ethereum contract.
type PegBridgeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PegBridgeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type PegBridgeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PegBridgeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type PegBridgeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PegBridgeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type PegBridgeSession struct {
	Contract     *PegBridge        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// PegBridgeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type PegBridgeCallerSession struct {
	Contract *PegBridgeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// PegBridgeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type PegBridgeTransactorSession struct {
	Contract     *PegBridgeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// PegBridgeRaw is an auto generated low-level Go binding around an Ethereum contract.
type PegBridgeRaw struct {
	Contract *PegBridge // Generic contract binding to access the raw methods on
}

// PegBridgeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type PegBridgeCallerRaw struct {
	Contract *PegBridgeCaller // Generic read-only contract binding to access the raw methods on
}

// PegBridgeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type PegBridgeTransactorRaw struct {
	Contract *PegBridgeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewPegBridge creates a new instance of PegBridge, bound to a specific deployed contract.
func NewPegBridge(address common.Address, backend bind.ContractBackend) (*PegBridge, error) {
	contract, err := bindPegBridge(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &PegBridge{PegBridgeCaller: PegBridgeCaller{contract: contract}, PegBridgeTransactor: PegBridgeTransactor{contract: contract}, PegBridgeFilterer: PegBridgeFilterer{contract: contract}}, nil
}

// NewPegBridgeCaller creates a new read-only instance of PegBridge, bound to a specific deployed contract.
func NewPegBridgeCaller(address common.Address, caller bind.ContractCaller) (*PegBridgeCaller, error) {
	contract, err := bindPegBridge(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &PegBridgeCaller{contract: contract}, nil
}

// NewPegBridgeTransactor creates a new write-only instance of PegBridge, bound to a specific deployed contract.
func NewPegBridgeTransactor(address common.Address, transactor bind.ContractTransactor) (*PegBridgeTransactor, error) {
	contract, err := bindPegBridge(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &PegBridgeTransactor{contract: contract}, nil
}

// NewPegBridgeFilterer creates a new log filterer instance of PegBridge, bound to a specific deployed contract.
func NewPegBridgeFilterer(address common.Address, filterer bind.ContractFilterer) (*PegBridgeFilterer, error) {
	contract, err := bindPegBridge(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &PegBridgeFilterer{contract: contract}, nil
}

// bindPegBridge binds a generic wrapper to an already deployed contract.
func bindPegBridge(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := PegBridgeMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_PegBridge *PegBridgeRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _PegBridge.Contract.PegBridgeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_PegBridge *PegBridgeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PegBridge.Contract.PegBridgeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_PegBridge *PegBridgeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _PegBridge.Contract.PegBridgeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_PegBridge *PegBridgeCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _PegBridge.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_PegBridge *PegBridgeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PegBridge.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_PegBridge *PegBridgeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _PegBridge.Contract.contract.Transact(opts, method, params...)
}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_PegBridge *PegBridgeCaller) MessageBridge(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _PegBridge.contract.Call(opts, &out, "messageBridge")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_PegBridge *PegBridgeSession) MessageBridge() (common.Address, error) {
	return _PegBridge.Contract.MessageBridge(&_PegBridge.CallOpts)
}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_PegBridge *PegBridgeCallerSession) MessageBridge() (common.Address, error) {
	return _PegBridge.Contract.MessageBridge(&_PegBridge.CallOpts)
}

// MinBurn is a free data retrieval call binding the contract method 0x7f856013.
//
// Solidity: function minBurn(address ) view returns(uint256)
func (_PegBridge *PegBridgeCaller) MinBurn(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PegBridge.contract.Call(opts, &out, "minBurn", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MinBurn is a free data retrieval call binding the contract method 0x7f856013.
//
// Solidity: function minBurn(address ) view returns(uint256)
func (_PegBridge *PegBridgeSession) MinBurn(arg0 common.Address) (*big.Int, error) {
	return _PegBridge.Contract.MinBurn(&_PegBridge.CallOpts, arg0)
}

// MinBurn is a free data retrieval call binding the contract method 0x7f856013.
//
// Solidity: function minBurn(address ) view returns(uint256)
func (_PegBridge *PegBridgeCallerSession) MinBurn(arg0 common.Address) (*big.Int, error) {
	return _PegBridge.Contract.MinBurn(&_PegBridge.CallOpts, arg0)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_PegBridge *PegBridgeCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _PegBridge.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_PegBridge *PegBridgeSession) Owner() (common.Address, error) {
	return _PegBridge.Contract.Owner(&_PegBridge.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_PegBridge *PegBridgeCallerSession) Owner() (common.Address, error) {
	return _PegBridge.Contract.Owner(&_PegBridge.CallOpts)
}

// PegToVaultTokens is a free data retrieval call binding the contract method 0x90fc2e25.
//
// Solidity: function pegToVaultTokens(address ) view returns(address)
func (_PegBridge *PegBridgeCaller) PegToVaultTokens(opts *bind.CallOpts, arg0 common.Address) (common.Address, error) {
	var out []interface{}
	err := _PegBridge.contract.Call(opts, &out, "pegToVaultTokens", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PegToVaultTokens is a free data retrieval call binding the contract method 0x90fc2e25.
//
// Solidity: function pegToVaultTokens(address ) view returns(address)
func (_PegBridge *PegBridgeSession) PegToVaultTokens(arg0 common.Address) (common.Address, error) {
	return _PegBridge.Contract.PegToVaultTokens(&_PegBridge.CallOpts, arg0)
}

// PegToVaultTokens is a free data retrieval call binding the contract method 0x90fc2e25.
//
// Solidity: function pegToVaultTokens(address ) view returns(address)
func (_PegBridge *PegBridgeCallerSession) PegToVaultTokens(arg0 common.Address) (common.Address, error) {
	return _PegBridge.Contract.PegToVaultTokens(&_PegBridge.CallOpts, arg0)
}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_PegBridge *PegBridgeCaller) Records(opts *bind.CallOpts, arg0 [32]byte) (bool, error) {
	var out []interface{}
	err := _PegBridge.contract.Call(opts, &out, "records", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_PegBridge *PegBridgeSession) Records(arg0 [32]byte) (bool, error) {
	return _PegBridge.Contract.Records(&_PegBridge.CallOpts, arg0)
}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_PegBridge *PegBridgeCallerSession) Records(arg0 [32]byte) (bool, error) {
	return _PegBridge.Contract.Records(&_PegBridge.CallOpts, arg0)
}

// Supplies is a free data retrieval call binding the contract method 0x274cee31.
//
// Solidity: function supplies(address ) view returns(uint256)
func (_PegBridge *PegBridgeCaller) Supplies(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PegBridge.contract.Call(opts, &out, "supplies", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Supplies is a free data retrieval call binding the contract method 0x274cee31.
//
// Solidity: function supplies(address ) view returns(uint256)
func (_PegBridge *PegBridgeSession) Supplies(arg0 common.Address) (*big.Int, error) {
	return _PegBridge.Contract.Supplies(&_PegBridge.CallOpts, arg0)
}

// Supplies is a free data retrieval call binding the contract method 0x274cee31.
//
// Solidity: function supplies(address ) view returns(uint256)
func (_PegBridge *PegBridgeCallerSession) Supplies(arg0 common.Address) (*big.Int, error) {
	return _PegBridge.Contract.Supplies(&_PegBridge.CallOpts, arg0)
}

// VaultAddress is a free data retrieval call binding the contract method 0x430bf08a.
//
// Solidity: function vaultAddress() view returns(address)
func (_PegBridge *PegBridgeCaller) VaultAddress(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _PegBridge.contract.Call(opts, &out, "vaultAddress")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// VaultAddress is a free data retrieval call binding the contract method 0x430bf08a.
//
// Solidity: function vaultAddress() view returns(address)
func (_PegBridge *PegBridgeSession) VaultAddress() (common.Address, error) {
	return _PegBridge.Contract.VaultAddress(&_PegBridge.CallOpts)
}

// VaultAddress is a free data retrieval call binding the contract method 0x430bf08a.
//
// Solidity: function vaultAddress() view returns(address)
func (_PegBridge *PegBridgeCallerSession) VaultAddress() (common.Address, error) {
	return _PegBridge.Contract.VaultAddress(&_PegBridge.CallOpts)
}

// VaultChain is a free data retrieval call binding the contract method 0x32eb41f6.
//
// Solidity: function vaultChain() view returns(uint64)
func (_PegBridge *PegBridgeCaller) VaultChain(opts *bind.CallOpts) (uint64, error) {
	var out []interface{}
	err := _PegBridge.contract.Call(opts, &out, "vaultChain")

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// VaultChain is a free data retrieval call binding the contract method 0x32eb41f6.
//
// Solidity: function vaultChain() view returns(uint64)
func (_PegBridge *PegBridgeSession) VaultChain() (uint64, error) {
	return _PegBridge.Contract.VaultChain(&_PegBridge.CallOpts)
}

// VaultChain is a free data retrieval call binding the contract method 0x32eb41f6.
//
// Solidity: function vaultChain() view returns(uint64)
func (_PegBridge *PegBridgeCallerSession) VaultChain() (uint64, error) {
	return _PegBridge.Contract.VaultChain(&_PegBridge.CallOpts)
}

// VaultToPegTokens is a free data retrieval call binding the contract method 0xfdbcd5db.
//
// Solidity: function vaultToPegTokens(address ) view returns(address)
func (_PegBridge *PegBridgeCaller) VaultToPegTokens(opts *bind.CallOpts, arg0 common.Address) (common.Address, error) {
	var out []interface{}
	err := _PegBridge.contract.Call(opts, &out, "vaultToPegTokens", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// VaultToPegTokens is a free data retrieval call binding the contract method 0xfdbcd5db.
//
// Solidity: function vaultToPegTokens(address ) view returns(address)
func (_PegBridge *PegBridgeSession) VaultToPegTokens(arg0 common.Address) (common.Address, error) {
	return _PegBridge.Contract.VaultToPegTokens(&_PegBridge.CallOpts, arg0)
}

// VaultToPegTokens is a free data retrieval call binding the contract method 0xfdbcd5db.
//
// Solidity: function vaultToPegTokens(address ) view returns(address)
func (_PegBridge *PegBridgeCallerSession) VaultToPegTokens(arg0 common.Address) (common.Address, error) {
	return _PegBridge.Contract.VaultToPegTokens(&_PegBridge.CallOpts, arg0)
}

// Burn is a paid mutator transaction binding the contract method 0xa0029301.
//
// Solidity: function burn(address _token, uint256 _amount, uint64 _toChainId, address _withdrawAccount, uint64 _nonce) returns(bytes32)
func (_PegBridge *PegBridgeTransactor) Burn(opts *bind.TransactOpts, _token common.Address, _amount *big.Int, _toChainId uint64, _withdrawAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _PegBridge.contract.Transact(opts, "burn", _token, _amount, _toChainId, _withdrawAccount, _nonce)
}

// Burn is a paid mutator transaction binding the contract method 0xa0029301.
//
// Solidity: function burn(address _token, uint256 _amount, uint64 _toChainId, address _withdrawAccount, uint64 _nonce) returns(bytes32)
func (_PegBridge *PegBridgeSession) Burn(_token common.Address, _amount *big.Int, _toChainId uint64, _withdrawAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _PegBridge.Contract.Burn(&_PegBridge.TransactOpts, _token, _amount, _toChainId, _withdrawAccount, _nonce)
}

// Burn is a paid mutator transaction binding the contract method 0xa0029301.
//
// Solidity: function burn(address _token, uint256 _amount, uint64 _toChainId, address _withdrawAccount, uint64 _nonce) returns(bytes32)
func (_PegBridge *PegBridgeTransactorSession) Burn(_token common.Address, _amount *big.Int, _toChainId uint64, _withdrawAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _PegBridge.Contract.Burn(&_PegBridge.TransactOpts, _token, _amount, _toChainId, _withdrawAccount, _nonce)
}

// DeletePegTokens is a paid mutator transaction binding the contract method 0x0745fcce.
//
// Solidity: function deletePegTokens(address[] _pegTokens) returns()
func (_PegBridge *PegBridgeTransactor) DeletePegTokens(opts *bind.TransactOpts, _pegTokens []common.Address) (*types.Transaction, error) {
	return _PegBridge.contract.Transact(opts, "deletePegTokens", _pegTokens)
}

// DeletePegTokens is a paid mutator transaction binding the contract method 0x0745fcce.
//
// Solidity: function deletePegTokens(address[] _pegTokens) returns()
func (_PegBridge *PegBridgeSession) DeletePegTokens(_pegTokens []common.Address) (*types.Transaction, error) {
	return _PegBridge.Contract.DeletePegTokens(&_PegBridge.TransactOpts, _pegTokens)
}

// DeletePegTokens is a paid mutator transaction binding the contract method 0x0745fcce.
//
// Solidity: function deletePegTokens(address[] _pegTokens) returns()
func (_PegBridge *PegBridgeTransactorSession) DeletePegTokens(_pegTokens []common.Address) (*types.Transaction, error) {
	return _PegBridge.Contract.DeletePegTokens(&_PegBridge.TransactOpts, _pegTokens)
}

// DeleteVaultTokens is a paid mutator transaction binding the contract method 0x40b6cc34.
//
// Solidity: function deleteVaultTokens(address[] _vaultTokens) returns()
func (_PegBridge *PegBridgeTransactor) DeleteVaultTokens(opts *bind.TransactOpts, _vaultTokens []common.Address) (*types.Transaction, error) {
	return _PegBridge.contract.Transact(opts, "deleteVaultTokens", _vaultTokens)
}

// DeleteVaultTokens is a paid mutator transaction binding the contract method 0x40b6cc34.
//
// Solidity: function deleteVaultTokens(address[] _vaultTokens) returns()
func (_PegBridge *PegBridgeSession) DeleteVaultTokens(_vaultTokens []common.Address) (*types.Transaction, error) {
	return _PegBridge.Contract.DeleteVaultTokens(&_PegBridge.TransactOpts, _vaultTokens)
}

// DeleteVaultTokens is a paid mutator transaction binding the contract method 0x40b6cc34.
//
// Solidity: function deleteVaultTokens(address[] _vaultTokens) returns()
func (_PegBridge *PegBridgeTransactorSession) DeleteVaultTokens(_vaultTokens []common.Address) (*types.Transaction, error) {
	return _PegBridge.Contract.DeleteVaultTokens(&_PegBridge.TransactOpts, _vaultTokens)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 srcChainId, address sender, bytes message, address executor) returns(bool)
func (_PegBridge *PegBridgeTransactor) ExecuteMessage(opts *bind.TransactOpts, srcChainId uint64, sender common.Address, message []byte, executor common.Address) (*types.Transaction, error) {
	return _PegBridge.contract.Transact(opts, "executeMessage", srcChainId, sender, message, executor)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 srcChainId, address sender, bytes message, address executor) returns(bool)
func (_PegBridge *PegBridgeSession) ExecuteMessage(srcChainId uint64, sender common.Address, message []byte, executor common.Address) (*types.Transaction, error) {
	return _PegBridge.Contract.ExecuteMessage(&_PegBridge.TransactOpts, srcChainId, sender, message, executor)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 srcChainId, address sender, bytes message, address executor) returns(bool)
func (_PegBridge *PegBridgeTransactorSession) ExecuteMessage(srcChainId uint64, sender common.Address, message []byte, executor common.Address) (*types.Transaction, error) {
	return _PegBridge.Contract.ExecuteMessage(&_PegBridge.TransactOpts, srcChainId, sender, message, executor)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_PegBridge *PegBridgeTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PegBridge.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_PegBridge *PegBridgeSession) RenounceOwnership() (*types.Transaction, error) {
	return _PegBridge.Contract.RenounceOwnership(&_PegBridge.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_PegBridge *PegBridgeTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _PegBridge.Contract.RenounceOwnership(&_PegBridge.TransactOpts)
}

// SetBridgeTokens is a paid mutator transaction binding the contract method 0xa93ce099.
//
// Solidity: function setBridgeTokens(address[] _vaultTokens, address[] _pegTokens) returns()
func (_PegBridge *PegBridgeTransactor) SetBridgeTokens(opts *bind.TransactOpts, _vaultTokens []common.Address, _pegTokens []common.Address) (*types.Transaction, error) {
	return _PegBridge.contract.Transact(opts, "setBridgeTokens", _vaultTokens, _pegTokens)
}

// SetBridgeTokens is a paid mutator transaction binding the contract method 0xa93ce099.
//
// Solidity: function setBridgeTokens(address[] _vaultTokens, address[] _pegTokens) returns()
func (_PegBridge *PegBridgeSession) SetBridgeTokens(_vaultTokens []common.Address, _pegTokens []common.Address) (*types.Transaction, error) {
	return _PegBridge.Contract.SetBridgeTokens(&_PegBridge.TransactOpts, _vaultTokens, _pegTokens)
}

// SetBridgeTokens is a paid mutator transaction binding the contract method 0xa93ce099.
//
// Solidity: function setBridgeTokens(address[] _vaultTokens, address[] _pegTokens) returns()
func (_PegBridge *PegBridgeTransactorSession) SetBridgeTokens(_vaultTokens []common.Address, _pegTokens []common.Address) (*types.Transaction, error) {
	return _PegBridge.Contract.SetBridgeTokens(&_PegBridge.TransactOpts, _vaultTokens, _pegTokens)
}

// SetMinBurn is a paid mutator transaction binding the contract method 0xbf4816f0.
//
// Solidity: function setMinBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PegBridge *PegBridgeTransactor) SetMinBurn(opts *bind.TransactOpts, _tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PegBridge.contract.Transact(opts, "setMinBurn", _tokens, _amounts)
}

// SetMinBurn is a paid mutator transaction binding the contract method 0xbf4816f0.
//
// Solidity: function setMinBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PegBridge *PegBridgeSession) SetMinBurn(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PegBridge.Contract.SetMinBurn(&_PegBridge.TransactOpts, _tokens, _amounts)
}

// SetMinBurn is a paid mutator transaction binding the contract method 0xbf4816f0.
//
// Solidity: function setMinBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PegBridge *PegBridgeTransactorSession) SetMinBurn(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PegBridge.Contract.SetMinBurn(&_PegBridge.TransactOpts, _tokens, _amounts)
}

// SetTokenVault is a paid mutator transaction binding the contract method 0x04a2cbd0.
//
// Solidity: function setTokenVault(uint64 _vaultChain, address _vaultAddress) returns()
func (_PegBridge *PegBridgeTransactor) SetTokenVault(opts *bind.TransactOpts, _vaultChain uint64, _vaultAddress common.Address) (*types.Transaction, error) {
	return _PegBridge.contract.Transact(opts, "setTokenVault", _vaultChain, _vaultAddress)
}

// SetTokenVault is a paid mutator transaction binding the contract method 0x04a2cbd0.
//
// Solidity: function setTokenVault(uint64 _vaultChain, address _vaultAddress) returns()
func (_PegBridge *PegBridgeSession) SetTokenVault(_vaultChain uint64, _vaultAddress common.Address) (*types.Transaction, error) {
	return _PegBridge.Contract.SetTokenVault(&_PegBridge.TransactOpts, _vaultChain, _vaultAddress)
}

// SetTokenVault is a paid mutator transaction binding the contract method 0x04a2cbd0.
//
// Solidity: function setTokenVault(uint64 _vaultChain, address _vaultAddress) returns()
func (_PegBridge *PegBridgeTransactorSession) SetTokenVault(_vaultChain uint64, _vaultAddress common.Address) (*types.Transaction, error) {
	return _PegBridge.Contract.SetTokenVault(&_PegBridge.TransactOpts, _vaultChain, _vaultAddress)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_PegBridge *PegBridgeTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _PegBridge.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_PegBridge *PegBridgeSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _PegBridge.Contract.TransferOwnership(&_PegBridge.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_PegBridge *PegBridgeTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _PegBridge.Contract.TransferOwnership(&_PegBridge.TransactOpts, newOwner)
}

// PegBridgeBridgeTokenAddedIterator is returned from FilterBridgeTokenAdded and is used to iterate over the raw logs and unpacked data for BridgeTokenAdded events raised by the PegBridge contract.
type PegBridgeBridgeTokenAddedIterator struct {
	Event *PegBridgeBridgeTokenAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PegBridgeBridgeTokenAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PegBridgeBridgeTokenAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PegBridgeBridgeTokenAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PegBridgeBridgeTokenAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PegBridgeBridgeTokenAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PegBridgeBridgeTokenAdded represents a BridgeTokenAdded event raised by the PegBridge contract.
type PegBridgeBridgeTokenAdded struct {
	VaultToken common.Address
	PegToken   common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterBridgeTokenAdded is a free log retrieval operation binding the contract event 0xeabeda8c7848101043c4c7d8a980cbc9078963ea815cd1cdfcab1dfdc80eb911.
//
// Solidity: event BridgeTokenAdded(address vaultToken, address pegToken)
func (_PegBridge *PegBridgeFilterer) FilterBridgeTokenAdded(opts *bind.FilterOpts) (*PegBridgeBridgeTokenAddedIterator, error) {

	logs, sub, err := _PegBridge.contract.FilterLogs(opts, "BridgeTokenAdded")
	if err != nil {
		return nil, err
	}
	return &PegBridgeBridgeTokenAddedIterator{contract: _PegBridge.contract, event: "BridgeTokenAdded", logs: logs, sub: sub}, nil
}

// WatchBridgeTokenAdded is a free log subscription operation binding the contract event 0xeabeda8c7848101043c4c7d8a980cbc9078963ea815cd1cdfcab1dfdc80eb911.
//
// Solidity: event BridgeTokenAdded(address vaultToken, address pegToken)
func (_PegBridge *PegBridgeFilterer) WatchBridgeTokenAdded(opts *bind.WatchOpts, sink chan<- *PegBridgeBridgeTokenAdded) (event.Subscription, error) {

	logs, sub, err := _PegBridge.contract.WatchLogs(opts, "BridgeTokenAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PegBridgeBridgeTokenAdded)
				if err := _PegBridge.contract.UnpackLog(event, "BridgeTokenAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBridgeTokenAdded is a log parse operation binding the contract event 0xeabeda8c7848101043c4c7d8a980cbc9078963ea815cd1cdfcab1dfdc80eb911.
//
// Solidity: event BridgeTokenAdded(address vaultToken, address pegToken)
func (_PegBridge *PegBridgeFilterer) ParseBridgeTokenAdded(log types.Log) (*PegBridgeBridgeTokenAdded, error) {
	event := new(PegBridgeBridgeTokenAdded)
	if err := _PegBridge.contract.UnpackLog(event, "BridgeTokenAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PegBridgeBridgeTokenDeletedIterator is returned from FilterBridgeTokenDeleted and is used to iterate over the raw logs and unpacked data for BridgeTokenDeleted events raised by the PegBridge contract.
type PegBridgeBridgeTokenDeletedIterator struct {
	Event *PegBridgeBridgeTokenDeleted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PegBridgeBridgeTokenDeletedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PegBridgeBridgeTokenDeleted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PegBridgeBridgeTokenDeleted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PegBridgeBridgeTokenDeletedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PegBridgeBridgeTokenDeletedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PegBridgeBridgeTokenDeleted represents a BridgeTokenDeleted event raised by the PegBridge contract.
type PegBridgeBridgeTokenDeleted struct {
	VaultToken common.Address
	PegToken   common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterBridgeTokenDeleted is a free log retrieval operation binding the contract event 0x2ff7cbe4f1f12bb7d93999c06304c58410c46ebb8ddbcba627d52d93a6aaffb1.
//
// Solidity: event BridgeTokenDeleted(address vaultToken, address pegToken)
func (_PegBridge *PegBridgeFilterer) FilterBridgeTokenDeleted(opts *bind.FilterOpts) (*PegBridgeBridgeTokenDeletedIterator, error) {

	logs, sub, err := _PegBridge.contract.FilterLogs(opts, "BridgeTokenDeleted")
	if err != nil {
		return nil, err
	}
	return &PegBridgeBridgeTokenDeletedIterator{contract: _PegBridge.contract, event: "BridgeTokenDeleted", logs: logs, sub: sub}, nil
}

// WatchBridgeTokenDeleted is a free log subscription operation binding the contract event 0x2ff7cbe4f1f12bb7d93999c06304c58410c46ebb8ddbcba627d52d93a6aaffb1.
//
// Solidity: event BridgeTokenDeleted(address vaultToken, address pegToken)
func (_PegBridge *PegBridgeFilterer) WatchBridgeTokenDeleted(opts *bind.WatchOpts, sink chan<- *PegBridgeBridgeTokenDeleted) (event.Subscription, error) {

	logs, sub, err := _PegBridge.contract.WatchLogs(opts, "BridgeTokenDeleted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PegBridgeBridgeTokenDeleted)
				if err := _PegBridge.contract.UnpackLog(event, "BridgeTokenDeleted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBridgeTokenDeleted is a log parse operation binding the contract event 0x2ff7cbe4f1f12bb7d93999c06304c58410c46ebb8ddbcba627d52d93a6aaffb1.
//
// Solidity: event BridgeTokenDeleted(address vaultToken, address pegToken)
func (_PegBridge *PegBridgeFilterer) ParseBridgeTokenDeleted(log types.Log) (*PegBridgeBridgeTokenDeleted, error) {
	event := new(PegBridgeBridgeTokenDeleted)
	if err := _PegBridge.contract.UnpackLog(event, "BridgeTokenDeleted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PegBridgeBurnIterator is returned from FilterBurn and is used to iterate over the raw logs and unpacked data for Burn events raised by the PegBridge contract.
type PegBridgeBurnIterator struct {
	Event *PegBridgeBurn // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PegBridgeBurnIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PegBridgeBurn)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PegBridgeBurn)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PegBridgeBurnIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PegBridgeBurnIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PegBridgeBurn represents a Burn event raised by the PegBridge contract.
type PegBridgeBurn struct {
	BurnId          [32]byte
	BurnAccount     common.Address
	Token           common.Address
	Amount          *big.Int
	WithdrawAccount common.Address
	Nonce           uint64
	MessageId       [32]byte
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterBurn is a free log retrieval operation binding the contract event 0x1b4b8f452b18b4a267e27ea158479a8124cef2cd93a0d59309667a8e933ab285.
//
// Solidity: event Burn(bytes32 burnId, address burnAccount, address token, uint256 amount, address withdrawAccount, uint64 nonce, bytes32 messageId)
func (_PegBridge *PegBridgeFilterer) FilterBurn(opts *bind.FilterOpts) (*PegBridgeBurnIterator, error) {

	logs, sub, err := _PegBridge.contract.FilterLogs(opts, "Burn")
	if err != nil {
		return nil, err
	}
	return &PegBridgeBurnIterator{contract: _PegBridge.contract, event: "Burn", logs: logs, sub: sub}, nil
}

// WatchBurn is a free log subscription operation binding the contract event 0x1b4b8f452b18b4a267e27ea158479a8124cef2cd93a0d59309667a8e933ab285.
//
// Solidity: event Burn(bytes32 burnId, address burnAccount, address token, uint256 amount, address withdrawAccount, uint64 nonce, bytes32 messageId)
func (_PegBridge *PegBridgeFilterer) WatchBurn(opts *bind.WatchOpts, sink chan<- *PegBridgeBurn) (event.Subscription, error) {

	logs, sub, err := _PegBridge.contract.WatchLogs(opts, "Burn")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PegBridgeBurn)
				if err := _PegBridge.contract.UnpackLog(event, "Burn", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBurn is a log parse operation binding the contract event 0x1b4b8f452b18b4a267e27ea158479a8124cef2cd93a0d59309667a8e933ab285.
//
// Solidity: event Burn(bytes32 burnId, address burnAccount, address token, uint256 amount, address withdrawAccount, uint64 nonce, bytes32 messageId)
func (_PegBridge *PegBridgeFilterer) ParseBurn(log types.Log) (*PegBridgeBurn, error) {
	event := new(PegBridgeBurn)
	if err := _PegBridge.contract.UnpackLog(event, "Burn", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PegBridgeMinBurnUpdatedIterator is returned from FilterMinBurnUpdated and is used to iterate over the raw logs and unpacked data for MinBurnUpdated events raised by the PegBridge contract.
type PegBridgeMinBurnUpdatedIterator struct {
	Event *PegBridgeMinBurnUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PegBridgeMinBurnUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PegBridgeMinBurnUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PegBridgeMinBurnUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PegBridgeMinBurnUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PegBridgeMinBurnUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PegBridgeMinBurnUpdated represents a MinBurnUpdated event raised by the PegBridge contract.
type PegBridgeMinBurnUpdated struct {
	Token  common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterMinBurnUpdated is a free log retrieval operation binding the contract event 0x3796cd0b17a8734f8da819920625598e9a18be490f686725282e5383f1d06683.
//
// Solidity: event MinBurnUpdated(address token, uint256 amount)
func (_PegBridge *PegBridgeFilterer) FilterMinBurnUpdated(opts *bind.FilterOpts) (*PegBridgeMinBurnUpdatedIterator, error) {

	logs, sub, err := _PegBridge.contract.FilterLogs(opts, "MinBurnUpdated")
	if err != nil {
		return nil, err
	}
	return &PegBridgeMinBurnUpdatedIterator{contract: _PegBridge.contract, event: "MinBurnUpdated", logs: logs, sub: sub}, nil
}

// WatchMinBurnUpdated is a free log subscription operation binding the contract event 0x3796cd0b17a8734f8da819920625598e9a18be490f686725282e5383f1d06683.
//
// Solidity: event MinBurnUpdated(address token, uint256 amount)
func (_PegBridge *PegBridgeFilterer) WatchMinBurnUpdated(opts *bind.WatchOpts, sink chan<- *PegBridgeMinBurnUpdated) (event.Subscription, error) {

	logs, sub, err := _PegBridge.contract.WatchLogs(opts, "MinBurnUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PegBridgeMinBurnUpdated)
				if err := _PegBridge.contract.UnpackLog(event, "MinBurnUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMinBurnUpdated is a log parse operation binding the contract event 0x3796cd0b17a8734f8da819920625598e9a18be490f686725282e5383f1d06683.
//
// Solidity: event MinBurnUpdated(address token, uint256 amount)
func (_PegBridge *PegBridgeFilterer) ParseMinBurnUpdated(log types.Log) (*PegBridgeMinBurnUpdated, error) {
	event := new(PegBridgeMinBurnUpdated)
	if err := _PegBridge.contract.UnpackLog(event, "MinBurnUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PegBridgeMintIterator is returned from FilterMint and is used to iterate over the raw logs and unpacked data for Mint events raised by the PegBridge contract.
type PegBridgeMintIterator struct {
	Event *PegBridgeMint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PegBridgeMintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PegBridgeMint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PegBridgeMint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PegBridgeMintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PegBridgeMintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PegBridgeMint represents a Mint event raised by the PegBridge contract.
type PegBridgeMint struct {
	MintId    [32]byte
	Account   common.Address
	Token     common.Address
	Amount    *big.Int
	RefId     [32]byte
	Depositor common.Address
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterMint is a free log retrieval operation binding the contract event 0x317276091e0f98226fe28cd525f29e0b1c7b3edd91bf9f85e5f0aba596074ac9.
//
// Solidity: event Mint(bytes32 mintId, address account, address token, uint256 amount, bytes32 refId, address depositor)
func (_PegBridge *PegBridgeFilterer) FilterMint(opts *bind.FilterOpts) (*PegBridgeMintIterator, error) {

	logs, sub, err := _PegBridge.contract.FilterLogs(opts, "Mint")
	if err != nil {
		return nil, err
	}
	return &PegBridgeMintIterator{contract: _PegBridge.contract, event: "Mint", logs: logs, sub: sub}, nil
}

// WatchMint is a free log subscription operation binding the contract event 0x317276091e0f98226fe28cd525f29e0b1c7b3edd91bf9f85e5f0aba596074ac9.
//
// Solidity: event Mint(bytes32 mintId, address account, address token, uint256 amount, bytes32 refId, address depositor)
func (_PegBridge *PegBridgeFilterer) WatchMint(opts *bind.WatchOpts, sink chan<- *PegBridgeMint) (event.Subscription, error) {

	logs, sub, err := _PegBridge.contract.WatchLogs(opts, "Mint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PegBridgeMint)
				if err := _PegBridge.contract.UnpackLog(event, "Mint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMint is a log parse operation binding the contract event 0x317276091e0f98226fe28cd525f29e0b1c7b3edd91bf9f85e5f0aba596074ac9.
//
// Solidity: event Mint(bytes32 mintId, address account, address token, uint256 amount, bytes32 refId, address depositor)
func (_PegBridge *PegBridgeFilterer) ParseMint(log types.Log) (*PegBridgeMint, error) {
	event := new(PegBridgeMint)
	if err := _PegBridge.contract.UnpackLog(event, "Mint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PegBridgeOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the PegBridge contract.
type PegBridgeOwnershipTransferredIterator struct {
	Event *PegBridgeOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PegBridgeOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PegBridgeOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PegBridgeOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PegBridgeOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PegBridgeOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PegBridgeOwnershipTransferred represents a OwnershipTransferred event raised by the PegBridge contract.
type PegBridgeOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_PegBridge *PegBridgeFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*PegBridgeOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _PegBridge.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &PegBridgeOwnershipTransferredIterator{contract: _PegBridge.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_PegBridge *PegBridgeFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *PegBridgeOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _PegBridge.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PegBridgeOwnershipTransferred)
				if err := _PegBridge.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_PegBridge *PegBridgeFilterer) ParseOwnershipTransferred(log types.Log) (*PegBridgeOwnershipTransferred, error) {
	event := new(PegBridgeOwnershipTransferred)
	if err := _PegBridge.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PoolMetaData contains all meta data concerning the Pool contract.
var PoolMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"NoLiquidityToReceiveFees\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolAlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolNotInitialized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint160\",\"name\":\"sqrtPriceCurrentX96\",\"type\":\"uint160\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"name\":\"PriceLimitAlreadyExceeded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"name\":\"PriceLimitOutOfBounds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SwapAmountCannotBeZero\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"}],\"name\":\"TickLiquidityOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"}],\"name\":\"TickLowerOutOfBounds\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"}],\"name\":\"TickNotInitialized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"}],\"name\":\"TickUpperOutOfBounds\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"}],\"name\":\"TicksMisordered\",\"type\":\"error\"}]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212201f9d5a00c252f5b6692072835d0f264c66bdb95f24b7007b98f522277a4eec0c64736f6c63430008140033",
}

// PoolABI is the input ABI used to generate the binding from.
// Deprecated: Use PoolMetaData.ABI instead.
var PoolABI = PoolMetaData.ABI

// PoolBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use PoolMetaData.Bin instead.
var PoolBin = PoolMetaData.Bin

// DeployPool deploys a new Ethereum contract, binding an instance of Pool to it.
func DeployPool(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Pool, error) {
	parsed, err := PoolMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(PoolBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Pool{PoolCaller: PoolCaller{contract: contract}, PoolTransactor: PoolTransactor{contract: contract}, PoolFilterer: PoolFilterer{contract: contract}}, nil
}

// Pool is an auto generated Go binding around an Ethereum contract.
type Pool struct {
	PoolCaller     // Read-only binding to the contract
	PoolTransactor // Write-only binding to the contract
	PoolFilterer   // Log filterer for contract events
}

// PoolCaller is an auto generated read-only Go binding around an Ethereum contract.
type PoolCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PoolTransactor is an auto generated write-only Go binding around an Ethereum contract.
type PoolTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PoolFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type PoolFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PoolSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type PoolSession struct {
	Contract     *Pool             // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// PoolCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type PoolCallerSession struct {
	Contract *PoolCaller   // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// PoolTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type PoolTransactorSession struct {
	Contract     *PoolTransactor   // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// PoolRaw is an auto generated low-level Go binding around an Ethereum contract.
type PoolRaw struct {
	Contract *Pool // Generic contract binding to access the raw methods on
}

// PoolCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type PoolCallerRaw struct {
	Contract *PoolCaller // Generic read-only contract binding to access the raw methods on
}

// PoolTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type PoolTransactorRaw struct {
	Contract *PoolTransactor // Generic write-only contract binding to access the raw methods on
}

// NewPool creates a new instance of Pool, bound to a specific deployed contract.
func NewPool(address common.Address, backend bind.ContractBackend) (*Pool, error) {
	contract, err := bindPool(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Pool{PoolCaller: PoolCaller{contract: contract}, PoolTransactor: PoolTransactor{contract: contract}, PoolFilterer: PoolFilterer{contract: contract}}, nil
}

// NewPoolCaller creates a new read-only instance of Pool, bound to a specific deployed contract.
func NewPoolCaller(address common.Address, caller bind.ContractCaller) (*PoolCaller, error) {
	contract, err := bindPool(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &PoolCaller{contract: contract}, nil
}

// NewPoolTransactor creates a new write-only instance of Pool, bound to a specific deployed contract.
func NewPoolTransactor(address common.Address, transactor bind.ContractTransactor) (*PoolTransactor, error) {
	contract, err := bindPool(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &PoolTransactor{contract: contract}, nil
}

// NewPoolFilterer creates a new log filterer instance of Pool, bound to a specific deployed contract.
func NewPoolFilterer(address common.Address, filterer bind.ContractFilterer) (*PoolFilterer, error) {
	contract, err := bindPool(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &PoolFilterer{contract: contract}, nil
}

// bindPool binds a generic wrapper to an already deployed contract.
func bindPool(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := PoolMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Pool *PoolRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Pool.Contract.PoolCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Pool *PoolRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Pool.Contract.PoolTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Pool *PoolRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Pool.Contract.PoolTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Pool *PoolCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Pool.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Pool *PoolTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Pool.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Pool *PoolTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Pool.Contract.contract.Transact(opts, method, params...)
}

// PoolIdLibraryMetaData contains all meta data concerning the PoolIdLibrary contract.
var PoolIdLibraryMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea2646970667358221220598582b12c1a1d3f16ac7db7c15d1627ece96c470ea935a5d1e1f2d58c69b83264736f6c63430008140033",
}

// PoolIdLibraryABI is the input ABI used to generate the binding from.
// Deprecated: Use PoolIdLibraryMetaData.ABI instead.
var PoolIdLibraryABI = PoolIdLibraryMetaData.ABI

// PoolIdLibraryBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use PoolIdLibraryMetaData.Bin instead.
var PoolIdLibraryBin = PoolIdLibraryMetaData.Bin

// DeployPoolIdLibrary deploys a new Ethereum contract, binding an instance of PoolIdLibrary to it.
func DeployPoolIdLibrary(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *PoolIdLibrary, error) {
	parsed, err := PoolIdLibraryMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(PoolIdLibraryBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &PoolIdLibrary{PoolIdLibraryCaller: PoolIdLibraryCaller{contract: contract}, PoolIdLibraryTransactor: PoolIdLibraryTransactor{contract: contract}, PoolIdLibraryFilterer: PoolIdLibraryFilterer{contract: contract}}, nil
}

// PoolIdLibrary is an auto generated Go binding around an Ethereum contract.
type PoolIdLibrary struct {
	PoolIdLibraryCaller     // Read-only binding to the contract
	PoolIdLibraryTransactor // Write-only binding to the contract
	PoolIdLibraryFilterer   // Log filterer for contract events
}

// PoolIdLibraryCaller is an auto generated read-only Go binding around an Ethereum contract.
type PoolIdLibraryCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PoolIdLibraryTransactor is an auto generated write-only Go binding around an Ethereum contract.
type PoolIdLibraryTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PoolIdLibraryFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type PoolIdLibraryFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PoolIdLibrarySession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type PoolIdLibrarySession struct {
	Contract     *PoolIdLibrary    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// PoolIdLibraryCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type PoolIdLibraryCallerSession struct {
	Contract *PoolIdLibraryCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// PoolIdLibraryTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type PoolIdLibraryTransactorSession struct {
	Contract     *PoolIdLibraryTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// PoolIdLibraryRaw is an auto generated low-level Go binding around an Ethereum contract.
type PoolIdLibraryRaw struct {
	Contract *PoolIdLibrary // Generic contract binding to access the raw methods on
}

// PoolIdLibraryCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type PoolIdLibraryCallerRaw struct {
	Contract *PoolIdLibraryCaller // Generic read-only contract binding to access the raw methods on
}

// PoolIdLibraryTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type PoolIdLibraryTransactorRaw struct {
	Contract *PoolIdLibraryTransactor // Generic write-only contract binding to access the raw methods on
}

// NewPoolIdLibrary creates a new instance of PoolIdLibrary, bound to a specific deployed contract.
func NewPoolIdLibrary(address common.Address, backend bind.ContractBackend) (*PoolIdLibrary, error) {
	contract, err := bindPoolIdLibrary(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &PoolIdLibrary{PoolIdLibraryCaller: PoolIdLibraryCaller{contract: contract}, PoolIdLibraryTransactor: PoolIdLibraryTransactor{contract: contract}, PoolIdLibraryFilterer: PoolIdLibraryFilterer{contract: contract}}, nil
}

// NewPoolIdLibraryCaller creates a new read-only instance of PoolIdLibrary, bound to a specific deployed contract.
func NewPoolIdLibraryCaller(address common.Address, caller bind.ContractCaller) (*PoolIdLibraryCaller, error) {
	contract, err := bindPoolIdLibrary(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &PoolIdLibraryCaller{contract: contract}, nil
}

// NewPoolIdLibraryTransactor creates a new write-only instance of PoolIdLibrary, bound to a specific deployed contract.
func NewPoolIdLibraryTransactor(address common.Address, transactor bind.ContractTransactor) (*PoolIdLibraryTransactor, error) {
	contract, err := bindPoolIdLibrary(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &PoolIdLibraryTransactor{contract: contract}, nil
}

// NewPoolIdLibraryFilterer creates a new log filterer instance of PoolIdLibrary, bound to a specific deployed contract.
func NewPoolIdLibraryFilterer(address common.Address, filterer bind.ContractFilterer) (*PoolIdLibraryFilterer, error) {
	contract, err := bindPoolIdLibrary(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &PoolIdLibraryFilterer{contract: contract}, nil
}

// bindPoolIdLibrary binds a generic wrapper to an already deployed contract.
func bindPoolIdLibrary(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := PoolIdLibraryMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_PoolIdLibrary *PoolIdLibraryRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _PoolIdLibrary.Contract.PoolIdLibraryCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_PoolIdLibrary *PoolIdLibraryRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PoolIdLibrary.Contract.PoolIdLibraryTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_PoolIdLibrary *PoolIdLibraryRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _PoolIdLibrary.Contract.PoolIdLibraryTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_PoolIdLibrary *PoolIdLibraryCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _PoolIdLibrary.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_PoolIdLibrary *PoolIdLibraryTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PoolIdLibrary.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_PoolIdLibrary *PoolIdLibraryTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _PoolIdLibrary.Contract.contract.Transact(opts, method, params...)
}

// PositionMetaData contains all meta data concerning the Position contract.
var PositionMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"CannotUpdateEmptyPosition\",\"type\":\"error\"}]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea2646970667358221220881c698c438a05fc5b842b4572390b3901f6d0c90e363bc1e1a6047ec62b5dec64736f6c63430008140033",
}

// PositionABI is the input ABI used to generate the binding from.
// Deprecated: Use PositionMetaData.ABI instead.
var PositionABI = PositionMetaData.ABI

// PositionBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use PositionMetaData.Bin instead.
var PositionBin = PositionMetaData.Bin

// DeployPosition deploys a new Ethereum contract, binding an instance of Position to it.
func DeployPosition(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Position, error) {
	parsed, err := PositionMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(PositionBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Position{PositionCaller: PositionCaller{contract: contract}, PositionTransactor: PositionTransactor{contract: contract}, PositionFilterer: PositionFilterer{contract: contract}}, nil
}

// Position is an auto generated Go binding around an Ethereum contract.
type Position struct {
	PositionCaller     // Read-only binding to the contract
	PositionTransactor // Write-only binding to the contract
	PositionFilterer   // Log filterer for contract events
}

// PositionCaller is an auto generated read-only Go binding around an Ethereum contract.
type PositionCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PositionTransactor is an auto generated write-only Go binding around an Ethereum contract.
type PositionTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PositionFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type PositionFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PositionSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type PositionSession struct {
	Contract     *Position         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// PositionCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type PositionCallerSession struct {
	Contract *PositionCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// PositionTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type PositionTransactorSession struct {
	Contract     *PositionTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// PositionRaw is an auto generated low-level Go binding around an Ethereum contract.
type PositionRaw struct {
	Contract *Position // Generic contract binding to access the raw methods on
}

// PositionCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type PositionCallerRaw struct {
	Contract *PositionCaller // Generic read-only contract binding to access the raw methods on
}

// PositionTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type PositionTransactorRaw struct {
	Contract *PositionTransactor // Generic write-only contract binding to access the raw methods on
}

// NewPosition creates a new instance of Position, bound to a specific deployed contract.
func NewPosition(address common.Address, backend bind.ContractBackend) (*Position, error) {
	contract, err := bindPosition(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Position{PositionCaller: PositionCaller{contract: contract}, PositionTransactor: PositionTransactor{contract: contract}, PositionFilterer: PositionFilterer{contract: contract}}, nil
}

// NewPositionCaller creates a new read-only instance of Position, bound to a specific deployed contract.
func NewPositionCaller(address common.Address, caller bind.ContractCaller) (*PositionCaller, error) {
	contract, err := bindPosition(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &PositionCaller{contract: contract}, nil
}

// NewPositionTransactor creates a new write-only instance of Position, bound to a specific deployed contract.
func NewPositionTransactor(address common.Address, transactor bind.ContractTransactor) (*PositionTransactor, error) {
	contract, err := bindPosition(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &PositionTransactor{contract: contract}, nil
}

// NewPositionFilterer creates a new log filterer instance of Position, bound to a specific deployed contract.
func NewPositionFilterer(address common.Address, filterer bind.ContractFilterer) (*PositionFilterer, error) {
	contract, err := bindPosition(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &PositionFilterer{contract: contract}, nil
}

// bindPosition binds a generic wrapper to an already deployed contract.
func bindPosition(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := PositionMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Position *PositionRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Position.Contract.PositionCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Position *PositionRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Position.Contract.PositionTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Position *PositionRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Position.Contract.PositionTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Position *PositionCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Position.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Position *PositionTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Position.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Position *PositionTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Position.Contract.contract.Transact(opts, method, params...)
}

// RLPReaderMetaData contains all meta data concerning the RLPReader contract.
var RLPReaderMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212201c303cddb168f46ddce711922a3ec5ea6de36d3f9c896b35b2bac58b0556763264736f6c63430008140033",
}

// RLPReaderABI is the input ABI used to generate the binding from.
// Deprecated: Use RLPReaderMetaData.ABI instead.
var RLPReaderABI = RLPReaderMetaData.ABI

// RLPReaderBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use RLPReaderMetaData.Bin instead.
var RLPReaderBin = RLPReaderMetaData.Bin

// DeployRLPReader deploys a new Ethereum contract, binding an instance of RLPReader to it.
func DeployRLPReader(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *RLPReader, error) {
	parsed, err := RLPReaderMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(RLPReaderBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &RLPReader{RLPReaderCaller: RLPReaderCaller{contract: contract}, RLPReaderTransactor: RLPReaderTransactor{contract: contract}, RLPReaderFilterer: RLPReaderFilterer{contract: contract}}, nil
}

// RLPReader is an auto generated Go binding around an Ethereum contract.
type RLPReader struct {
	RLPReaderCaller     // Read-only binding to the contract
	RLPReaderTransactor // Write-only binding to the contract
	RLPReaderFilterer   // Log filterer for contract events
}

// RLPReaderCaller is an auto generated read-only Go binding around an Ethereum contract.
type RLPReaderCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RLPReaderTransactor is an auto generated write-only Go binding around an Ethereum contract.
type RLPReaderTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RLPReaderFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type RLPReaderFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RLPReaderSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type RLPReaderSession struct {
	Contract     *RLPReader        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// RLPReaderCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type RLPReaderCallerSession struct {
	Contract *RLPReaderCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// RLPReaderTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type RLPReaderTransactorSession struct {
	Contract     *RLPReaderTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// RLPReaderRaw is an auto generated low-level Go binding around an Ethereum contract.
type RLPReaderRaw struct {
	Contract *RLPReader // Generic contract binding to access the raw methods on
}

// RLPReaderCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type RLPReaderCallerRaw struct {
	Contract *RLPReaderCaller // Generic read-only contract binding to access the raw methods on
}

// RLPReaderTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type RLPReaderTransactorRaw struct {
	Contract *RLPReaderTransactor // Generic write-only contract binding to access the raw methods on
}

// NewRLPReader creates a new instance of RLPReader, bound to a specific deployed contract.
func NewRLPReader(address common.Address, backend bind.ContractBackend) (*RLPReader, error) {
	contract, err := bindRLPReader(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &RLPReader{RLPReaderCaller: RLPReaderCaller{contract: contract}, RLPReaderTransactor: RLPReaderTransactor{contract: contract}, RLPReaderFilterer: RLPReaderFilterer{contract: contract}}, nil
}

// NewRLPReaderCaller creates a new read-only instance of RLPReader, bound to a specific deployed contract.
func NewRLPReaderCaller(address common.Address, caller bind.ContractCaller) (*RLPReaderCaller, error) {
	contract, err := bindRLPReader(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &RLPReaderCaller{contract: contract}, nil
}

// NewRLPReaderTransactor creates a new write-only instance of RLPReader, bound to a specific deployed contract.
func NewRLPReaderTransactor(address common.Address, transactor bind.ContractTransactor) (*RLPReaderTransactor, error) {
	contract, err := bindRLPReader(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &RLPReaderTransactor{contract: contract}, nil
}

// NewRLPReaderFilterer creates a new log filterer instance of RLPReader, bound to a specific deployed contract.
func NewRLPReaderFilterer(address common.Address, filterer bind.ContractFilterer) (*RLPReaderFilterer, error) {
	contract, err := bindRLPReader(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &RLPReaderFilterer{contract: contract}, nil
}

// bindRLPReader binds a generic wrapper to an already deployed contract.
func bindRLPReader(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := RLPReaderMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_RLPReader *RLPReaderRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _RLPReader.Contract.RLPReaderCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_RLPReader *RLPReaderRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RLPReader.Contract.RLPReaderTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_RLPReader *RLPReaderRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _RLPReader.Contract.RLPReaderTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_RLPReader *RLPReaderCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _RLPReader.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_RLPReader *RLPReaderTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RLPReader.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_RLPReader *RLPReaderTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _RLPReader.Contract.contract.Transact(opts, method, params...)
}

// ReceiptVerifierMetaData contains all meta data concerning the ReceiptVerifier contract.
var ReceiptVerifierMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_blockChunks\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"UpdateBlockChunks\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"UpdateVerifierAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"receiptHash\",\"type\":\"bytes32\"}],\"name\":\"VerifiedReceipt\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"blockChunks\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"receiptRaw\",\"type\":\"bytes\"}],\"name\":\"decodeReceipt\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"blkHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"blkTime\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"topics\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"structIReceiptVerifier.LogInfo[]\",\"name\":\"logs\",\"type\":\"tuple[]\"}],\"internalType\":\"structIReceiptVerifier.ReceiptInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_blockChunks\",\"type\":\"address\"}],\"name\":\"updateBlockChunks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_verifierAddress\",\"type\":\"address\"}],\"name\":\"updateVerifierAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"verifierAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"receiptRaw\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"auxiBlkVerifyInfo\",\"type\":\"bytes\"}],\"name\":\"verifyReceipt\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"blkHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"blkTime\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"topics\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"structIReceiptVerifier.LogInfo[]\",\"name\":\"logs\",\"type\":\"tuple[]\"}],\"internalType\":\"structIReceiptVerifier.ReceiptInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"receiptRaw\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"auxiBlkVerifyInfo\",\"type\":\"bytes\"}],\"name\":\"verifyReceiptAndLog\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"blkHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"blkTime\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"topics\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"structIReceiptVerifier.LogInfo[]\",\"name\":\"logs\",\"type\":\"tuple[]\"}],\"internalType\":\"structIReceiptVerifier.ReceiptInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x6080346100a457601f6119f138819003918201601f19168301916001600160401b038311848410176100a8578084926020946040528339810103126100a457516001600160a01b0390818116908190036100a4575f5460018060a01b03199033828216175f55604051933391167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3600254161760025561193490816100bd8239f35b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe60806040526004361015610011575f80fd5b5f803560e01c9081631eeb86da146100a7575080633996da7a146100a257806368ac2f781461009d578063724796ed146100985780638da5cb5b14610093578063c109ae5d1461008e578063ec4ffc5214610089578063f2fde38b146100845763f5cec6af1461007f575f80fd5b610615565b61052b565b610489565b610435565b610410565b6103ea565b6103be565b610330565b34610124576020366003190112610124577f0addee9cb6aa9328bbfbe8282179a6737af344619320736b6918af70b6a94a9860206100e3610127565b6001600160a01b03906100fa828654163314610657565b168073ffffffffffffffffffffffffffffffffffffffff196002541617600255604051908152a180f35b80fd5b600435906001600160a01b038216820361013d57565b5f80fd5b9181601f8401121561013d5782359167ffffffffffffffff831161013d576020838186019501011161013d57565b90606060031983011261013d5767ffffffffffffffff60043581811161013d578361019c91600401610141565b9390939260243583811161013d57826101b791600401610141565b9390939260443591821161013d576101d191600401610141565b9091565b5f5b8381106101e65750505f910152565b81810151838201526020016101d7565b602080825260e0820190835115158184015267ffffffffffffffff928382860151166040908183015260a081870151966060978885015263ffffffff8882015116966080978886015287820151168285015201519560c08084015286518095526101009184838501938760051b8601019801965f9081955b888710610282575050505050505050505090565b9091929394959697989960ff19828203018752888b51878301926001600160a01b0382511681528783830151928a8584015283518096528488840194019589905b808210610313575050600195509184939184930151908a8184039101526102f5815180928185528580860191016101d5565b601f01601f191601019c019a9998919091019601949392919061026e565b87518652968601968f9695909501948b93506001909101906102c3565b3461013d576103ba61039c7fa5db3bb7a25cc2804c7835ab71b15513b8c68585e3593c3fdee39a8837547366604061038461036a3661016f565b9261037c999599969496929192610728565b50868a610973565b9467ffffffffffffffff602087015116923691610785565b6020815191012082519182526020820152a1604051918291826101f6565b0390f35b3461013d576103ba6103de6103d23661016f565b94939093929192610973565b604051918291826101f6565b3461013d575f36600319011261013d5760206001600160a01b0360025416604051908152f35b3461013d575f36600319011261013d5760206001600160a01b035f5416604051908152f35b3461013d57602036600319011261013d5760043567ffffffffffffffff811161013d576103de61046c6103ba923690600401610141565b90611024565b6004359067ffffffffffffffff8216820361013d57565b3461013d57604036600319011261013d576104a2610472565b602435906001600160a01b039182811680910361013d5767ffffffffffffffff6040926104f47ffd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f955f54163314610657565b1690815f526001602052825f208173ffffffffffffffffffffffffffffffffffffffff1982541617905582519182526020820152a1005b3461013d57602036600319011261013d57610544610127565b5f908154906001600160a01b0380831691610560338414610657565b169182156105aa5773ffffffffffffffffffffffffffffffffffffffff1916821783557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608490fd5b3461013d57602036600319011261013d5767ffffffffffffffff610637610472565b165f52600160205260206001600160a01b0360405f205416604051908152f35b1561065e57565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b634e487b7160e01b5f52604160045260245ffd5b6040810190811067ffffffffffffffff8211176106d257604052565b6106a2565b90601f8019910116810190811067ffffffffffffffff8211176106d257604052565b6040519060c0820182811067ffffffffffffffff8211176106d257604052565b60405190610726826106b6565b565b6040519060c0820182811067ffffffffffffffff8211176106d257604052606060a0835f81525f60208201525f60408201525f838201525f60808201520152565b67ffffffffffffffff81116106d257601f01601f191660200190565b92919261079182610769565b9161079f60405193846106d7565b82948184528183011161013d578281602093845f960137010152565b156107c257565b60405162461bcd60e51b815260206004820152600f60248201527f70726f6f66206e6f742076616c696400000000000000000000000000000000006044820152606490fd5b6020908361072693959495604051968361082a89955180928880890191016101d5565b84019185830137015f838201520380855201836106d7565b1561084957565b60405162461bcd60e51b815260206004820152601260248201527f6c65616648617368206e6f74206d6174636800000000000000000000000000006044820152606490fd5b9081602091031261013d5751801515810361013d5790565b91909161018081019267ffffffffffffffff815116825260a08063ffffffff926020938085830151168587015260408201516040870152606082015160608701526080820151166080860152015192015f905b600782106109075750505050565b828060019286518152019401910190926108f9565b6040513d5f823e3d90fd5b1561092e57565b60405162461bcd60e51b815260206004820152600f60248201527f696e76616c696420626c6b4861736800000000000000000000000000000000006044820152606490fd5b9594610a9994939291610984610728565b506109b76109b261099586866113a1565b9560808701956109ad875167ffffffffffffffff1690565b611237565b6107bb565b6109e56109c9828a60a0880151610807565b928351966109e06020988980970120885114610842565b610d97565b85519294919267ffffffffffffffff1690610a556040890194610a0c865163ffffffff1690565b97858b0198610a3e8a5191610a32610a226106f9565b67ffffffffffffffff9099168952565b63ffffffff1687890152565b6040860152606085015263ffffffff166080840152565b60a0820152610a7e610a72610a726002546001600160a01b031690565b6001600160a01b031690565b60405180809b8194631513dce960e21b8352600483016108a6565b03915afa918215610b6557610af26060610b2897610b1a96610adc610b039560409f610ad76107269f9a8f9b610b0d9c5f92610b38575b5050610927565b611024565b9d8e9151910152015167ffffffffffffffff1690565b67ffffffffffffffff1660808b0152565b5163ffffffff1690565b63ffffffff166060880152565b5167ffffffffffffffff1690565b67ffffffffffffffff1690840152565b610b579250803d10610b5e575b610b4f81836106d7565b81019061088e565b8f80610ad0565b503d610b45565b61091c565b15610b7157565b60405162461bcd60e51b815260206004820152601b60248201527f696e636f72726563742061757869426c6b566572696679496e666f00000000006044820152606490fd5b9060201161013d5790602090565b9060241161013d5760200190600490565b906101041161013d5760e40190602090565b909291928360011161013d57831161013d57600101915f190190565b906101801161013d576101700190601090565b906101a01161013d576101800190602090565b906101c01161013d576101b00190601090565b906101e01161013d576101dc0190600490565b906102001161013d576101f80190600890565b906102081161013d576102000190600890565b9291926102089184831161013d57841161013d570191610207190190565b9093929384831161013d57841161013d578101920390565b359060208110610cb9575090565b5f199060200360031b1b1690565b7fffffffff000000000000000000000000000000000000000000000000000000009035818116939260048110610cfc57505050565b60040360031b82901b16169150565b634e487b7160e01b5f52601160045260245ffd5b60ff1660ff8114610d305760010190565b610d0b565b60051b90611fe060e0831692168203610d3057565b60ff166024019060ff8211610d3057565b60ff60019116019060ff8211610d3057565b634e487b7160e01b5f52603260045260245ffd5b906007811015610d925760051b0190565b610d6d565b916040519060e0820182811067ffffffffffffffff8211176106d25760405260e036833781610dc96101048514610b6a565b610ddc610dd68587610bb6565b90610cab565b93610df9610df3610ded8389610bc4565b90610cc7565b60e01c90565b945f5b60ff808216906006821015610e5e5790610e53610e4c610dd685948d89610e2d610e28610e599a610d35565b610d4a565b9280610e43610e28610e3e8c610d5b565b610d35565b16931691610c93565b9189610d81565b52610d1f565b610dfc565b50505095610dd660c092610e7492969496610bd5565b910152565b9015610d925790565b15610e8957565b60405162461bcd60e51b815260206004820152601660248201527f6e6f7420612044796e616d6963466565547854797065000000000000000000006044820152606490fd5b805115610d925760200190565b805160031015610d925760800190565b805160011015610d925760400190565b805160021015610d925760600190565b8051821015610d925760209160051b010190565b906020825192015160ff60f81b908181169360018110610f3e57505050565b60010360031b82901b16169150565b67ffffffffffffffff81116106d25760051b60200190565b90610f6f82610f4d565b604090610f7e825191826106d7565b8381528093610f8f601f1991610f4d565b01905f92835b838110610fa3575050505050565b8151906060918281019281841067ffffffffffffffff8511176106d25760209385528782528390808284015285830152828601015201610f95565b90610fe882610f4d565b610ff560405191826106d7565b8281528092611006601f1991610f4d565b0190602036910137565b602081519101519060208110610cb9575090565b6110f86110f26110a261109d61109861109161103e610728565b978060ff9861108c60028b61108561107f6110598787610e79565b357fff000000000000000000000000000000000000000000000000000000000000001690565b60f81c90565b1614610e82565b610be7565b3691610785565b6114c5565b611514565b600160f81b7fff000000000000000000000000000000000000000000000000000000000000006110e26110dd6110d785610ece565b516116e1565b610f1f565b1614611207575b94939294610edb565b51611514565b926111038451610f65565b915f80945b865191848716928310156111f9576111236110f2848a610f0b565b976111526111396111338b610ece565b51611609565b611143868a610f0b565b51906001600160a01b03169052565b61115e6110f28a610eeb565b926111698451610fde565b9560209687611178888c610f0b565b510152835b8551898216908110156111c157908a610e53838b6111b48c6111ae6111a96110d78f9a6111bc9b610f0b565b611010565b95610f0b565b510151610f0b565b61117d565b505098929550986111f093506111e86111e16110d7604093979497610efb565b9289610f0b565b510152610d1f565b94919095611108565b5094505093505060a0830152565b600185526110e9565b90918060409360208452816020850152848401375f828201840152601f01601f1916010190565b909167ffffffffffffffff82165f5260016020526001600160a01b0360405f205416156112e3576112b392611296610a72610a7261128960209667ffffffffffffffff165f52600160205260405f2090565b546001600160a01b031690565b906040518095819482936322bb937360e11b845260048401611210565b03915afa908115610b65575f916112c8575090565b6112e0915060203d8111610b5e57610b4f81836106d7565b90565b60405162461bcd60e51b815260206004820152601660248201527f636861696e207665726966696572206e6f7420736574000000000000000000006044820152606490fd5b6fffffffffffffffffffffffffffffffff19903581811693926010811061134e57505050565b60100360031b82901b16169150565b7fffffffffffffffff000000000000000000000000000000000000000000000000903581811693926008811061139257505050565b60080360031b82901b16169150565b91906113ab610728565b92816101601161013d578180826113f26113dd6113d76113d16114a69861109198610c03565b90611328565b60801c90565b6fffffffffffffffffffffffffffffffff1690565b61014082013560801b17875261141461140e610dd68484610c16565b60801b90565b6114276113dd6113d76113d18686610c29565b17602088015261144d611440610df3610ded8585610c3c565b63ffffffff166040890152565b61147d61146c6114666114608585610c4f565b9061135d565b60c01c90565b67ffffffffffffffff166060890152565b6114a16114906114666114608585610c62565b67ffffffffffffffff166080890152565b610c75565b60a0830152565b604051906114ba826106b6565b5f6020838281520152565b6114cd6114ad565b506020815191604051926114e0846106b6565b835201602082015290565b9060018201809211610d3057565b91908201809211610d3057565b5f198114610d305760010190565b61151d816115e5565b1561013d5761152b8161172e565b61153481610f4d565b9161154260405193846106d7565b818352601f1961155183610f4d565b015f5b8181106115ce57505061157560208092015161156f81611814565b906114f9565b5f905b838210611586575050505090565b6115c2816115966115c89361178f565b9061159f610719565b82815281878201526115b1868a610f0b565b526115bc8589610f0b565b506114f9565b91611506565b90611578565b6020906115d96114ad565b82828801015201611554565b80511561160457602060c0910151515f1a1061160057600190565b5f90565b505f90565b80516015810361013d578015159081611651575b501561013d576116346001600160a01b03916116b5565b9051906020811061164457501690565b6020036101000a90041690565b6021915011155f61161d565b60bf19810191908211610d3057565b607f19810191908211610d3057565b6020039060208211610d3057565b5f19810191908211610d3057565b60f619810191908211610d3057565b60b619810191908211610d3057565b9060208201916116c58351611814565b925190838201809211610d305751928303928311610d30579190565b80511561013d576116f46112e0916116b5565b61170081939293610769565b9261170e60405194856106d7565b818452601f1961171d83610769565b013660208601378360200190611881565b805115611604575f906020810190815161174781611814565b8101809111610d3057915190518101809111610d305791905b82811061176d5750905090565b6117768161178f565b8101809111610d30576117899091611506565b90611760565b80515f1a9060808210156117a4575050600190565b60b88210156117bf57506117ba6112e09161166c565b6114eb565b9060c08110156117e35760b51991600160b783602003016101000a91015104010190565b9060f88210156117fa57506117ba6112e09161165d565b60010151602082900360f7016101000a90040160f5190190565b515f1a608081101561182557505f90565b60b88110801561185c575b1561183b5750600190565b60c0811015611850576117ba6112e0916116a6565b6117ba6112e091611697565b5060c08110158015611830575060f88110611830565b601f8111610d30576101000a90565b9290919283156118f85792915b6020938484106118c35780518252848101809111610d3057938101809111610d305791601f198101908111610d30579161188e565b91935091806118d157505050565b6118e56118e06118ea9261167b565b611872565b611689565b905182518216911916179052565b5091505056fea2646970667358221220db33f16f0bf1d71b72b0bfb23e8eeb6a86c6e68ba97c81f6276971b44d056d0464736f6c63430008140033",
}

// ReceiptVerifierABI is the input ABI used to generate the binding from.
// Deprecated: Use ReceiptVerifierMetaData.ABI instead.
var ReceiptVerifierABI = ReceiptVerifierMetaData.ABI

// ReceiptVerifierBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use ReceiptVerifierMetaData.Bin instead.
var ReceiptVerifierBin = ReceiptVerifierMetaData.Bin

// DeployReceiptVerifier deploys a new Ethereum contract, binding an instance of ReceiptVerifier to it.
func DeployReceiptVerifier(auth *bind.TransactOpts, backend bind.ContractBackend, _blockChunks common.Address) (common.Address, *types.Transaction, *ReceiptVerifier, error) {
	parsed, err := ReceiptVerifierMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(ReceiptVerifierBin), backend, _blockChunks)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ReceiptVerifier{ReceiptVerifierCaller: ReceiptVerifierCaller{contract: contract}, ReceiptVerifierTransactor: ReceiptVerifierTransactor{contract: contract}, ReceiptVerifierFilterer: ReceiptVerifierFilterer{contract: contract}}, nil
}

// ReceiptVerifier is an auto generated Go binding around an Ethereum contract.
type ReceiptVerifier struct {
	ReceiptVerifierCaller     // Read-only binding to the contract
	ReceiptVerifierTransactor // Write-only binding to the contract
	ReceiptVerifierFilterer   // Log filterer for contract events
}

// ReceiptVerifierCaller is an auto generated read-only Go binding around an Ethereum contract.
type ReceiptVerifierCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ReceiptVerifierTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ReceiptVerifierTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ReceiptVerifierFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ReceiptVerifierFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ReceiptVerifierSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ReceiptVerifierSession struct {
	Contract     *ReceiptVerifier  // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ReceiptVerifierCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ReceiptVerifierCallerSession struct {
	Contract *ReceiptVerifierCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts          // Call options to use throughout this session
}

// ReceiptVerifierTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ReceiptVerifierTransactorSession struct {
	Contract     *ReceiptVerifierTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts          // Transaction auth options to use throughout this session
}

// ReceiptVerifierRaw is an auto generated low-level Go binding around an Ethereum contract.
type ReceiptVerifierRaw struct {
	Contract *ReceiptVerifier // Generic contract binding to access the raw methods on
}

// ReceiptVerifierCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ReceiptVerifierCallerRaw struct {
	Contract *ReceiptVerifierCaller // Generic read-only contract binding to access the raw methods on
}

// ReceiptVerifierTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ReceiptVerifierTransactorRaw struct {
	Contract *ReceiptVerifierTransactor // Generic write-only contract binding to access the raw methods on
}

// NewReceiptVerifier creates a new instance of ReceiptVerifier, bound to a specific deployed contract.
func NewReceiptVerifier(address common.Address, backend bind.ContractBackend) (*ReceiptVerifier, error) {
	contract, err := bindReceiptVerifier(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ReceiptVerifier{ReceiptVerifierCaller: ReceiptVerifierCaller{contract: contract}, ReceiptVerifierTransactor: ReceiptVerifierTransactor{contract: contract}, ReceiptVerifierFilterer: ReceiptVerifierFilterer{contract: contract}}, nil
}

// NewReceiptVerifierCaller creates a new read-only instance of ReceiptVerifier, bound to a specific deployed contract.
func NewReceiptVerifierCaller(address common.Address, caller bind.ContractCaller) (*ReceiptVerifierCaller, error) {
	contract, err := bindReceiptVerifier(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ReceiptVerifierCaller{contract: contract}, nil
}

// NewReceiptVerifierTransactor creates a new write-only instance of ReceiptVerifier, bound to a specific deployed contract.
func NewReceiptVerifierTransactor(address common.Address, transactor bind.ContractTransactor) (*ReceiptVerifierTransactor, error) {
	contract, err := bindReceiptVerifier(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ReceiptVerifierTransactor{contract: contract}, nil
}

// NewReceiptVerifierFilterer creates a new log filterer instance of ReceiptVerifier, bound to a specific deployed contract.
func NewReceiptVerifierFilterer(address common.Address, filterer bind.ContractFilterer) (*ReceiptVerifierFilterer, error) {
	contract, err := bindReceiptVerifier(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ReceiptVerifierFilterer{contract: contract}, nil
}

// bindReceiptVerifier binds a generic wrapper to an already deployed contract.
func bindReceiptVerifier(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ReceiptVerifierMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ReceiptVerifier *ReceiptVerifierRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ReceiptVerifier.Contract.ReceiptVerifierCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ReceiptVerifier *ReceiptVerifierRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ReceiptVerifier.Contract.ReceiptVerifierTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ReceiptVerifier *ReceiptVerifierRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ReceiptVerifier.Contract.ReceiptVerifierTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ReceiptVerifier *ReceiptVerifierCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ReceiptVerifier.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ReceiptVerifier *ReceiptVerifierTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ReceiptVerifier.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ReceiptVerifier *ReceiptVerifierTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ReceiptVerifier.Contract.contract.Transact(opts, method, params...)
}

// BlockChunks is a free data retrieval call binding the contract method 0x724796ed.
//
// Solidity: function blockChunks() view returns(address)
func (_ReceiptVerifier *ReceiptVerifierCaller) BlockChunks(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _ReceiptVerifier.contract.Call(opts, &out, "blockChunks")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// BlockChunks is a free data retrieval call binding the contract method 0x724796ed.
//
// Solidity: function blockChunks() view returns(address)
func (_ReceiptVerifier *ReceiptVerifierSession) BlockChunks() (common.Address, error) {
	return _ReceiptVerifier.Contract.BlockChunks(&_ReceiptVerifier.CallOpts)
}

// BlockChunks is a free data retrieval call binding the contract method 0x724796ed.
//
// Solidity: function blockChunks() view returns(address)
func (_ReceiptVerifier *ReceiptVerifierCallerSession) BlockChunks() (common.Address, error) {
	return _ReceiptVerifier.Contract.BlockChunks(&_ReceiptVerifier.CallOpts)
}

// DecodeReceipt is a free data retrieval call binding the contract method 0xc109ae5d.
//
// Solidity: function decodeReceipt(bytes receiptRaw) pure returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) info)
func (_ReceiptVerifier *ReceiptVerifierCaller) DecodeReceipt(opts *bind.CallOpts, receiptRaw []byte) (IReceiptVerifierReceiptInfo, error) {
	var out []interface{}
	err := _ReceiptVerifier.contract.Call(opts, &out, "decodeReceipt", receiptRaw)

	if err != nil {
		return *new(IReceiptVerifierReceiptInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(IReceiptVerifierReceiptInfo)).(*IReceiptVerifierReceiptInfo)

	return out0, err

}

// DecodeReceipt is a free data retrieval call binding the contract method 0xc109ae5d.
//
// Solidity: function decodeReceipt(bytes receiptRaw) pure returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) info)
func (_ReceiptVerifier *ReceiptVerifierSession) DecodeReceipt(receiptRaw []byte) (IReceiptVerifierReceiptInfo, error) {
	return _ReceiptVerifier.Contract.DecodeReceipt(&_ReceiptVerifier.CallOpts, receiptRaw)
}

// DecodeReceipt is a free data retrieval call binding the contract method 0xc109ae5d.
//
// Solidity: function decodeReceipt(bytes receiptRaw) pure returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) info)
func (_ReceiptVerifier *ReceiptVerifierCallerSession) DecodeReceipt(receiptRaw []byte) (IReceiptVerifierReceiptInfo, error) {
	return _ReceiptVerifier.Contract.DecodeReceipt(&_ReceiptVerifier.CallOpts, receiptRaw)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ReceiptVerifier *ReceiptVerifierCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _ReceiptVerifier.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ReceiptVerifier *ReceiptVerifierSession) Owner() (common.Address, error) {
	return _ReceiptVerifier.Contract.Owner(&_ReceiptVerifier.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_ReceiptVerifier *ReceiptVerifierCallerSession) Owner() (common.Address, error) {
	return _ReceiptVerifier.Contract.Owner(&_ReceiptVerifier.CallOpts)
}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_ReceiptVerifier *ReceiptVerifierCaller) VerifierAddresses(opts *bind.CallOpts, arg0 uint64) (common.Address, error) {
	var out []interface{}
	err := _ReceiptVerifier.contract.Call(opts, &out, "verifierAddresses", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_ReceiptVerifier *ReceiptVerifierSession) VerifierAddresses(arg0 uint64) (common.Address, error) {
	return _ReceiptVerifier.Contract.VerifierAddresses(&_ReceiptVerifier.CallOpts, arg0)
}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_ReceiptVerifier *ReceiptVerifierCallerSession) VerifierAddresses(arg0 uint64) (common.Address, error) {
	return _ReceiptVerifier.Contract.VerifierAddresses(&_ReceiptVerifier.CallOpts, arg0)
}

// VerifyReceipt is a free data retrieval call binding the contract method 0x68ac2f78.
//
// Solidity: function verifyReceipt(bytes receiptRaw, bytes proofData, bytes auxiBlkVerifyInfo) view returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) info)
func (_ReceiptVerifier *ReceiptVerifierCaller) VerifyReceipt(opts *bind.CallOpts, receiptRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (IReceiptVerifierReceiptInfo, error) {
	var out []interface{}
	err := _ReceiptVerifier.contract.Call(opts, &out, "verifyReceipt", receiptRaw, proofData, auxiBlkVerifyInfo)

	if err != nil {
		return *new(IReceiptVerifierReceiptInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(IReceiptVerifierReceiptInfo)).(*IReceiptVerifierReceiptInfo)

	return out0, err

}

// VerifyReceipt is a free data retrieval call binding the contract method 0x68ac2f78.
//
// Solidity: function verifyReceipt(bytes receiptRaw, bytes proofData, bytes auxiBlkVerifyInfo) view returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) info)
func (_ReceiptVerifier *ReceiptVerifierSession) VerifyReceipt(receiptRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (IReceiptVerifierReceiptInfo, error) {
	return _ReceiptVerifier.Contract.VerifyReceipt(&_ReceiptVerifier.CallOpts, receiptRaw, proofData, auxiBlkVerifyInfo)
}

// VerifyReceipt is a free data retrieval call binding the contract method 0x68ac2f78.
//
// Solidity: function verifyReceipt(bytes receiptRaw, bytes proofData, bytes auxiBlkVerifyInfo) view returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) info)
func (_ReceiptVerifier *ReceiptVerifierCallerSession) VerifyReceipt(receiptRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (IReceiptVerifierReceiptInfo, error) {
	return _ReceiptVerifier.Contract.VerifyReceipt(&_ReceiptVerifier.CallOpts, receiptRaw, proofData, auxiBlkVerifyInfo)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_ReceiptVerifier *ReceiptVerifierTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _ReceiptVerifier.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_ReceiptVerifier *ReceiptVerifierSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _ReceiptVerifier.Contract.TransferOwnership(&_ReceiptVerifier.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_ReceiptVerifier *ReceiptVerifierTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _ReceiptVerifier.Contract.TransferOwnership(&_ReceiptVerifier.TransactOpts, newOwner)
}

// UpdateBlockChunks is a paid mutator transaction binding the contract method 0x1eeb86da.
//
// Solidity: function updateBlockChunks(address _blockChunks) returns()
func (_ReceiptVerifier *ReceiptVerifierTransactor) UpdateBlockChunks(opts *bind.TransactOpts, _blockChunks common.Address) (*types.Transaction, error) {
	return _ReceiptVerifier.contract.Transact(opts, "updateBlockChunks", _blockChunks)
}

// UpdateBlockChunks is a paid mutator transaction binding the contract method 0x1eeb86da.
//
// Solidity: function updateBlockChunks(address _blockChunks) returns()
func (_ReceiptVerifier *ReceiptVerifierSession) UpdateBlockChunks(_blockChunks common.Address) (*types.Transaction, error) {
	return _ReceiptVerifier.Contract.UpdateBlockChunks(&_ReceiptVerifier.TransactOpts, _blockChunks)
}

// UpdateBlockChunks is a paid mutator transaction binding the contract method 0x1eeb86da.
//
// Solidity: function updateBlockChunks(address _blockChunks) returns()
func (_ReceiptVerifier *ReceiptVerifierTransactorSession) UpdateBlockChunks(_blockChunks common.Address) (*types.Transaction, error) {
	return _ReceiptVerifier.Contract.UpdateBlockChunks(&_ReceiptVerifier.TransactOpts, _blockChunks)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_ReceiptVerifier *ReceiptVerifierTransactor) UpdateVerifierAddress(opts *bind.TransactOpts, _chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _ReceiptVerifier.contract.Transact(opts, "updateVerifierAddress", _chainId, _verifierAddress)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_ReceiptVerifier *ReceiptVerifierSession) UpdateVerifierAddress(_chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _ReceiptVerifier.Contract.UpdateVerifierAddress(&_ReceiptVerifier.TransactOpts, _chainId, _verifierAddress)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_ReceiptVerifier *ReceiptVerifierTransactorSession) UpdateVerifierAddress(_chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _ReceiptVerifier.Contract.UpdateVerifierAddress(&_ReceiptVerifier.TransactOpts, _chainId, _verifierAddress)
}

// VerifyReceiptAndLog is a paid mutator transaction binding the contract method 0x3996da7a.
//
// Solidity: function verifyReceiptAndLog(bytes receiptRaw, bytes proofData, bytes auxiBlkVerifyInfo) returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) info)
func (_ReceiptVerifier *ReceiptVerifierTransactor) VerifyReceiptAndLog(opts *bind.TransactOpts, receiptRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (*types.Transaction, error) {
	return _ReceiptVerifier.contract.Transact(opts, "verifyReceiptAndLog", receiptRaw, proofData, auxiBlkVerifyInfo)
}

// VerifyReceiptAndLog is a paid mutator transaction binding the contract method 0x3996da7a.
//
// Solidity: function verifyReceiptAndLog(bytes receiptRaw, bytes proofData, bytes auxiBlkVerifyInfo) returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) info)
func (_ReceiptVerifier *ReceiptVerifierSession) VerifyReceiptAndLog(receiptRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (*types.Transaction, error) {
	return _ReceiptVerifier.Contract.VerifyReceiptAndLog(&_ReceiptVerifier.TransactOpts, receiptRaw, proofData, auxiBlkVerifyInfo)
}

// VerifyReceiptAndLog is a paid mutator transaction binding the contract method 0x3996da7a.
//
// Solidity: function verifyReceiptAndLog(bytes receiptRaw, bytes proofData, bytes auxiBlkVerifyInfo) returns((bool,uint64,bytes32,uint32,uint64,(address,bytes32[],bytes)[]) info)
func (_ReceiptVerifier *ReceiptVerifierTransactorSession) VerifyReceiptAndLog(receiptRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (*types.Transaction, error) {
	return _ReceiptVerifier.Contract.VerifyReceiptAndLog(&_ReceiptVerifier.TransactOpts, receiptRaw, proofData, auxiBlkVerifyInfo)
}

// ReceiptVerifierOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the ReceiptVerifier contract.
type ReceiptVerifierOwnershipTransferredIterator struct {
	Event *ReceiptVerifierOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ReceiptVerifierOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ReceiptVerifierOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ReceiptVerifierOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ReceiptVerifierOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ReceiptVerifierOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ReceiptVerifierOwnershipTransferred represents a OwnershipTransferred event raised by the ReceiptVerifier contract.
type ReceiptVerifierOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_ReceiptVerifier *ReceiptVerifierFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*ReceiptVerifierOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _ReceiptVerifier.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &ReceiptVerifierOwnershipTransferredIterator{contract: _ReceiptVerifier.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_ReceiptVerifier *ReceiptVerifierFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *ReceiptVerifierOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _ReceiptVerifier.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ReceiptVerifierOwnershipTransferred)
				if err := _ReceiptVerifier.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_ReceiptVerifier *ReceiptVerifierFilterer) ParseOwnershipTransferred(log types.Log) (*ReceiptVerifierOwnershipTransferred, error) {
	event := new(ReceiptVerifierOwnershipTransferred)
	if err := _ReceiptVerifier.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ReceiptVerifierUpdateBlockChunksIterator is returned from FilterUpdateBlockChunks and is used to iterate over the raw logs and unpacked data for UpdateBlockChunks events raised by the ReceiptVerifier contract.
type ReceiptVerifierUpdateBlockChunksIterator struct {
	Event *ReceiptVerifierUpdateBlockChunks // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ReceiptVerifierUpdateBlockChunksIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ReceiptVerifierUpdateBlockChunks)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ReceiptVerifierUpdateBlockChunks)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ReceiptVerifierUpdateBlockChunksIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ReceiptVerifierUpdateBlockChunksIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ReceiptVerifierUpdateBlockChunks represents a UpdateBlockChunks event raised by the ReceiptVerifier contract.
type ReceiptVerifierUpdateBlockChunks struct {
	NewAddress common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterUpdateBlockChunks is a free log retrieval operation binding the contract event 0x0addee9cb6aa9328bbfbe8282179a6737af344619320736b6918af70b6a94a98.
//
// Solidity: event UpdateBlockChunks(address newAddress)
func (_ReceiptVerifier *ReceiptVerifierFilterer) FilterUpdateBlockChunks(opts *bind.FilterOpts) (*ReceiptVerifierUpdateBlockChunksIterator, error) {

	logs, sub, err := _ReceiptVerifier.contract.FilterLogs(opts, "UpdateBlockChunks")
	if err != nil {
		return nil, err
	}
	return &ReceiptVerifierUpdateBlockChunksIterator{contract: _ReceiptVerifier.contract, event: "UpdateBlockChunks", logs: logs, sub: sub}, nil
}

// WatchUpdateBlockChunks is a free log subscription operation binding the contract event 0x0addee9cb6aa9328bbfbe8282179a6737af344619320736b6918af70b6a94a98.
//
// Solidity: event UpdateBlockChunks(address newAddress)
func (_ReceiptVerifier *ReceiptVerifierFilterer) WatchUpdateBlockChunks(opts *bind.WatchOpts, sink chan<- *ReceiptVerifierUpdateBlockChunks) (event.Subscription, error) {

	logs, sub, err := _ReceiptVerifier.contract.WatchLogs(opts, "UpdateBlockChunks")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ReceiptVerifierUpdateBlockChunks)
				if err := _ReceiptVerifier.contract.UnpackLog(event, "UpdateBlockChunks", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdateBlockChunks is a log parse operation binding the contract event 0x0addee9cb6aa9328bbfbe8282179a6737af344619320736b6918af70b6a94a98.
//
// Solidity: event UpdateBlockChunks(address newAddress)
func (_ReceiptVerifier *ReceiptVerifierFilterer) ParseUpdateBlockChunks(log types.Log) (*ReceiptVerifierUpdateBlockChunks, error) {
	event := new(ReceiptVerifierUpdateBlockChunks)
	if err := _ReceiptVerifier.contract.UnpackLog(event, "UpdateBlockChunks", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ReceiptVerifierUpdateVerifierAddressIterator is returned from FilterUpdateVerifierAddress and is used to iterate over the raw logs and unpacked data for UpdateVerifierAddress events raised by the ReceiptVerifier contract.
type ReceiptVerifierUpdateVerifierAddressIterator struct {
	Event *ReceiptVerifierUpdateVerifierAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ReceiptVerifierUpdateVerifierAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ReceiptVerifierUpdateVerifierAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ReceiptVerifierUpdateVerifierAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ReceiptVerifierUpdateVerifierAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ReceiptVerifierUpdateVerifierAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ReceiptVerifierUpdateVerifierAddress represents a UpdateVerifierAddress event raised by the ReceiptVerifier contract.
type ReceiptVerifierUpdateVerifierAddress struct {
	ChainId    uint64
	NewAddress common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterUpdateVerifierAddress is a free log retrieval operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_ReceiptVerifier *ReceiptVerifierFilterer) FilterUpdateVerifierAddress(opts *bind.FilterOpts) (*ReceiptVerifierUpdateVerifierAddressIterator, error) {

	logs, sub, err := _ReceiptVerifier.contract.FilterLogs(opts, "UpdateVerifierAddress")
	if err != nil {
		return nil, err
	}
	return &ReceiptVerifierUpdateVerifierAddressIterator{contract: _ReceiptVerifier.contract, event: "UpdateVerifierAddress", logs: logs, sub: sub}, nil
}

// WatchUpdateVerifierAddress is a free log subscription operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_ReceiptVerifier *ReceiptVerifierFilterer) WatchUpdateVerifierAddress(opts *bind.WatchOpts, sink chan<- *ReceiptVerifierUpdateVerifierAddress) (event.Subscription, error) {

	logs, sub, err := _ReceiptVerifier.contract.WatchLogs(opts, "UpdateVerifierAddress")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ReceiptVerifierUpdateVerifierAddress)
				if err := _ReceiptVerifier.contract.UnpackLog(event, "UpdateVerifierAddress", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdateVerifierAddress is a log parse operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_ReceiptVerifier *ReceiptVerifierFilterer) ParseUpdateVerifierAddress(log types.Log) (*ReceiptVerifierUpdateVerifierAddress, error) {
	event := new(ReceiptVerifierUpdateVerifierAddress)
	if err := _ReceiptVerifier.contract.UnpackLog(event, "UpdateVerifierAddress", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ReceiptVerifierVerifiedReceiptIterator is returned from FilterVerifiedReceipt and is used to iterate over the raw logs and unpacked data for VerifiedReceipt events raised by the ReceiptVerifier contract.
type ReceiptVerifierVerifiedReceiptIterator struct {
	Event *ReceiptVerifierVerifiedReceipt // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ReceiptVerifierVerifiedReceiptIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ReceiptVerifierVerifiedReceipt)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ReceiptVerifierVerifiedReceipt)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ReceiptVerifierVerifiedReceiptIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ReceiptVerifierVerifiedReceiptIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ReceiptVerifierVerifiedReceipt represents a VerifiedReceipt event raised by the ReceiptVerifier contract.
type ReceiptVerifierVerifiedReceipt struct {
	ChainId     uint64
	ReceiptHash [32]byte
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterVerifiedReceipt is a free log retrieval operation binding the contract event 0xa5db3bb7a25cc2804c7835ab71b15513b8c68585e3593c3fdee39a8837547366.
//
// Solidity: event VerifiedReceipt(uint64 chainId, bytes32 receiptHash)
func (_ReceiptVerifier *ReceiptVerifierFilterer) FilterVerifiedReceipt(opts *bind.FilterOpts) (*ReceiptVerifierVerifiedReceiptIterator, error) {

	logs, sub, err := _ReceiptVerifier.contract.FilterLogs(opts, "VerifiedReceipt")
	if err != nil {
		return nil, err
	}
	return &ReceiptVerifierVerifiedReceiptIterator{contract: _ReceiptVerifier.contract, event: "VerifiedReceipt", logs: logs, sub: sub}, nil
}

// WatchVerifiedReceipt is a free log subscription operation binding the contract event 0xa5db3bb7a25cc2804c7835ab71b15513b8c68585e3593c3fdee39a8837547366.
//
// Solidity: event VerifiedReceipt(uint64 chainId, bytes32 receiptHash)
func (_ReceiptVerifier *ReceiptVerifierFilterer) WatchVerifiedReceipt(opts *bind.WatchOpts, sink chan<- *ReceiptVerifierVerifiedReceipt) (event.Subscription, error) {

	logs, sub, err := _ReceiptVerifier.contract.WatchLogs(opts, "VerifiedReceipt")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ReceiptVerifierVerifiedReceipt)
				if err := _ReceiptVerifier.contract.UnpackLog(event, "VerifiedReceipt", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseVerifiedReceipt is a log parse operation binding the contract event 0xa5db3bb7a25cc2804c7835ab71b15513b8c68585e3593c3fdee39a8837547366.
//
// Solidity: event VerifiedReceipt(uint64 chainId, bytes32 receiptHash)
func (_ReceiptVerifier *ReceiptVerifierFilterer) ParseVerifiedReceipt(log types.Log) (*ReceiptVerifierVerifiedReceipt, error) {
	event := new(ReceiptVerifierVerifiedReceipt)
	if err := _ReceiptVerifier.contract.UnpackLog(event, "VerifiedReceipt", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ReentrancyGuardMetaData contains all meta data concerning the ReentrancyGuard contract.
var ReentrancyGuardMetaData = &bind.MetaData{
	ABI: "[]",
}

// ReentrancyGuardABI is the input ABI used to generate the binding from.
// Deprecated: Use ReentrancyGuardMetaData.ABI instead.
var ReentrancyGuardABI = ReentrancyGuardMetaData.ABI

// ReentrancyGuard is an auto generated Go binding around an Ethereum contract.
type ReentrancyGuard struct {
	ReentrancyGuardCaller     // Read-only binding to the contract
	ReentrancyGuardTransactor // Write-only binding to the contract
	ReentrancyGuardFilterer   // Log filterer for contract events
}

// ReentrancyGuardCaller is an auto generated read-only Go binding around an Ethereum contract.
type ReentrancyGuardCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ReentrancyGuardTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ReentrancyGuardTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ReentrancyGuardFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ReentrancyGuardFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ReentrancyGuardSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ReentrancyGuardSession struct {
	Contract     *ReentrancyGuard  // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ReentrancyGuardCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ReentrancyGuardCallerSession struct {
	Contract *ReentrancyGuardCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts          // Call options to use throughout this session
}

// ReentrancyGuardTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ReentrancyGuardTransactorSession struct {
	Contract     *ReentrancyGuardTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts          // Transaction auth options to use throughout this session
}

// ReentrancyGuardRaw is an auto generated low-level Go binding around an Ethereum contract.
type ReentrancyGuardRaw struct {
	Contract *ReentrancyGuard // Generic contract binding to access the raw methods on
}

// ReentrancyGuardCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ReentrancyGuardCallerRaw struct {
	Contract *ReentrancyGuardCaller // Generic read-only contract binding to access the raw methods on
}

// ReentrancyGuardTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ReentrancyGuardTransactorRaw struct {
	Contract *ReentrancyGuardTransactor // Generic write-only contract binding to access the raw methods on
}

// NewReentrancyGuard creates a new instance of ReentrancyGuard, bound to a specific deployed contract.
func NewReentrancyGuard(address common.Address, backend bind.ContractBackend) (*ReentrancyGuard, error) {
	contract, err := bindReentrancyGuard(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ReentrancyGuard{ReentrancyGuardCaller: ReentrancyGuardCaller{contract: contract}, ReentrancyGuardTransactor: ReentrancyGuardTransactor{contract: contract}, ReentrancyGuardFilterer: ReentrancyGuardFilterer{contract: contract}}, nil
}

// NewReentrancyGuardCaller creates a new read-only instance of ReentrancyGuard, bound to a specific deployed contract.
func NewReentrancyGuardCaller(address common.Address, caller bind.ContractCaller) (*ReentrancyGuardCaller, error) {
	contract, err := bindReentrancyGuard(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ReentrancyGuardCaller{contract: contract}, nil
}

// NewReentrancyGuardTransactor creates a new write-only instance of ReentrancyGuard, bound to a specific deployed contract.
func NewReentrancyGuardTransactor(address common.Address, transactor bind.ContractTransactor) (*ReentrancyGuardTransactor, error) {
	contract, err := bindReentrancyGuard(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ReentrancyGuardTransactor{contract: contract}, nil
}

// NewReentrancyGuardFilterer creates a new log filterer instance of ReentrancyGuard, bound to a specific deployed contract.
func NewReentrancyGuardFilterer(address common.Address, filterer bind.ContractFilterer) (*ReentrancyGuardFilterer, error) {
	contract, err := bindReentrancyGuard(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ReentrancyGuardFilterer{contract: contract}, nil
}

// bindReentrancyGuard binds a generic wrapper to an already deployed contract.
func bindReentrancyGuard(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ReentrancyGuardMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ReentrancyGuard *ReentrancyGuardRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ReentrancyGuard.Contract.ReentrancyGuardCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ReentrancyGuard *ReentrancyGuardRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ReentrancyGuard.Contract.ReentrancyGuardTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ReentrancyGuard *ReentrancyGuardRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ReentrancyGuard.Contract.ReentrancyGuardTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ReentrancyGuard *ReentrancyGuardCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ReentrancyGuard.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ReentrancyGuard *ReentrancyGuardTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ReentrancyGuard.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ReentrancyGuard *ReentrancyGuardTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ReentrancyGuard.Contract.contract.Transact(opts, method, params...)
}

// SMTMetaData contains all meta data concerning the SMT contract.
var SMTMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint64[]\",\"name\":\"_chainIds\",\"type\":\"uint64[]\"},{\"internalType\":\"address[]\",\"name\":\"_anchorProviders\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_verifiers\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_initRoots\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"anchorProvider\",\"type\":\"address\"}],\"name\":\"AnchorProviderUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"smtRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"endBlockNum\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"SmtRootUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"verifier\",\"type\":\"address\"}],\"name\":\"VerifierUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addPausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"addProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"anchorProviders\",\"outputs\":[{\"internalType\":\"contractIAnchorBlocks\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"getLatestRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isActiveProver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"smtRoot\",\"type\":\"bytes32\"}],\"name\":\"isSmtRootValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"latestRoots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numPausers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numProvers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pauserList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proverStates\",\"outputs\":[{\"internalType\":\"enumBrevisAccess.ProverState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"provers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removePausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"removeProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"anchorProvider\",\"type\":\"address\"}],\"name\":\"setAnchorProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"verifier\",\"type\":\"address\"}],\"name\":\"setVerifier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"smtRoots\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"newSmtRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"endBlockNum\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"endBlockHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"nextChunkMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[8]\",\"name\":\"proof\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commit\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"knowledgeProof\",\"type\":\"uint256[2]\"}],\"internalType\":\"structISMT.SmtUpdate\",\"name\":\"u\",\"type\":\"tuple\"}],\"name\":\"updateRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"verifiers\",\"outputs\":[{\"internalType\":\"contractIVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x604060808152346200039b5762001daa90813803806200001f81620003b9565b93843982016080838203126200039b5782516001600160401b0391908281116200039b5784019381601f860112156200039b578451916200006a6200006484620003f3565b620003b9565b908196848352602080930183600596871b830101918383116200039b578401905b8282106200039f57505050818301518581116200039b5781620000b09185016200040b565b96868401518681116200039b5782620000cb9186016200040b565b936060810151908782116200039b57019180601f840112156200039b578251620000f96200006482620003f3565b938580868481520192891b8201019283116200039b5785809101915b8383106200038a5750505f80548a519891976001600160a01b0394509250338482167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08a80a36001600160a81b0319163360ff60a01b198116919091178855875260018087528a88205490989060ff166200034857506002549a680100000000000000008c10156200033457888c01806002558c101562000320578a99899c957f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8898c9860028d52818d20019d60018060a01b03199e8f3390825416179055338d52898252808d2060ff199a8b82541617905551338152a16200021c815184511462000479565b6200022b815186511462000479565b6200023a815189511462000479565b899d5b62000252575b8c516118cb9081620004df8239f35b8d815111156200031a578d808e8e8c828f8c8c878d838e8e620002778f8690620004b5565b51169c6200028591620004b5565b5116908b865287528585209088825416179055620002a391620004b5565b51169287825260069052209182541617905560078c52818d8c83822092620002cb91620004b5565b5190528c528c208d8a825416179055620002e6908a620004b5565b51908b5260088a528d8b20555f198e1462000306579c8a019c8a6200023d565b634e487b7160e01b8a52601160045260248afd5b62000243565b634e487b7160e01b88526032600452602488fd5b634e487b7160e01b88526041600452602488fd5b62461bcd60e51b815260048101879052601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152606490fd5b825181529181019186910162000115565b5f80fd5b815188811681036200039b5781529084019084016200008b565b6040519190601f01601f191682016001600160401b03811183821017620003df57604052565b634e487b7160e01b5f52604160045260245ffd5b6001600160401b038111620003df5760051b60200190565b9080601f830112156200039b578151906200042a6200006483620003f3565b9182938184526020808095019260051b8201019283116200039b578301905b82821062000458575050505090565b81516001600160a01b03811681036200039b57815290830190830162000449565b156200048157565b60405162461bcd60e51b815260206004820152600c60248201526b0d8cadc40dad2e6dac2e8c6d60a31b6044820152606490fd5b8051821015620004ca5760209160051b010190565b634e487b7160e01b5f52603260045260245ffdfe6080806040526004361015610012575f80fd5b5f3560e01c9081631019b6161461115557508063158535ff1461112457806338702532146110da5780633f4ba83a14610fda57806346fbf68e14610ca3578063479aa6da14610d2f5780634f4fef1814610fbd57806358a16b4414610fa05780635c975abb14610f7c5780635ca32bd814610ebf578063677625f214610d685780636ae3e08014610d2f5780636b2c0f5514610cf95780636ef8d66d14610ce057806380f51c1214610ca35780638195408d14610c6157806382dc1ec414610c2b5780638456cb5914610b145780638da5cb5b14610aef57806397c7c3091461051d5780639c8413c51461045b578063a036e7991461040d578063afe8154b146103cb578063e6c6fcec1461037d578063e79b7a5114610328578063ec64842e146102e0578063f2fde38b146101f8578063fabc74f5146101a05763fd1190ea1461015b575f80fd5b3461019c57602036600319011261019c5760043560045481101561019c576001600160a01b0361018c6020926111fa565b9190546040519260031b1c168152f35b5f80fd5b3461019c57602036600319011261019c576001600160a01b036101c161122f565b165f52600360205260ff60405f20541660405160038210156101e4576020918152f35b634e487b7160e01b5f52602160045260245ffd5b3461019c57602036600319011261019c5761021161122f565b5f54906001600160a01b038083169161022b338414611351565b169182156102755773ffffffffffffffffffffffffffffffffffffffff19839116175f557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3005b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608490fd5b3461019c57602036600319011261019c576001600160a01b0361030161122f565b165f52600360205260ff60405f20541660038110156101e457602090600160405191148152f35b3461019c5761033636611299565b6001600160a01b039061034d825f54163314611351565b5f5b815181101561037b57806103718461036a61037694866113be565b51166115f4565b61139c565b61034f565b005b3461019c5761038b36611299565b6001600160a01b03906103a2825f54163314611351565b5f5b815181101561037b5780610371846103bf6103c694866113be565b511661141e565b6103a4565b3461019c57602036600319011261019c5767ffffffffffffffff6103ed61119a565b165f52600560205260206001600160a01b0360405f205416604051908152f35b3461019c5761041b36611299565b6001600160a01b0390610432825f54163314611351565b5f5b815181101561037b57806103718461044f61045694866113be565b51166116d9565b610434565b3461019c57604036600319011261019c577fb78ea0eaf11776732556ef6189312ceb60eab6b3177526b3a12d966e37be816261049561119a565b61049d611245565b906001600160a01b036104b4815f54163314611351565b67ffffffffffffffff82165f52600660205260405f2090831673ffffffffffffffffffffffffffffffffffffffff19825416179055610518604051928392839092916001600160a01b0360209167ffffffffffffffff604085019616845216910152565b0390a1005b3461019c5761022036600319011261019c5761053761119a565b61020036602319011261019c576040519060e0820182811067ffffffffffffffff8211176108fc57604052602435825260443567ffffffffffffffff8116810361019c576020830152606435604083015260843560608301523660c3121561019c57604051610100810181811067ffffffffffffffff8211176108fc57604052806101a49136831161019c5760a4905b838210610adf5750506080840152366101c3121561019c57604051906105ec8261125b565b8190366101e41161019c57905b6101e48210610acf57505060a083015236610203121561019c5760405161061f8161125b565b80366102241161019c576101e4905b6102248210610abf57505060c0830152335f52600360205260ff60405f20541660038110156101e457600103610a7a57606082015115610955575b67ffffffffffffffff81165f52600860205260405f205460066020526001600160a01b0360405f205416801561091057604051918261012081011067ffffffffffffffff610120850111176108fc5761012083016040526101203684378060801c83526fffffffffffffffffffffffffffffffff8091166020840152845160801c6040840152808551166060840152604085015160801c60808401528060408601511660a084015267ffffffffffffffff60208601511660c0840152606085015160801c60e0840152606085015116610100830152608084015160a08501519260c0860151604051948593633072c1a360e11b8552600485015f905b600882106108e2575050509061078361078e9261010486019061132a565b61014484019061132a565b5f61018483015b600982106108c8575050506102a4816020935afa9081156108bd575f91610882575b501561083d577fe8e2da79405f6328030a49e89981740387fc8c731042ec804a6461e796ec6f0b9167ffffffffffffffff8281606094165f52600760205260405f2083515f5260205260405f20600160ff1982541617905582518282165f52600860205260405f20558160208451940151166040519384526020840152166040820152a1005b60405162461bcd60e51b815260206004820152601060248201527f696e76616c6964207a6b2070726f6f66000000000000000000000000000000006044820152606490fd5b90506020813d6020116108b5575b8161089d60209383611277565b8101031261019c5751801515810361019c57836107b7565b3d9150610890565b6040513d5f823e3d90fd5b829350602080916001939451815201930191018492610795565b825181528896506020928301926001929092019101610765565b634e487b7160e01b5f52604160045260245ffd5b60405162461bcd60e51b815260206004820152601760248201527f6e6f20766572696669657220666f7220636861696e49640000000000000000006044820152606490fd5b67ffffffffffffffff81165f5260056020526001600160a01b0360405f2054168015610a3557602067ffffffffffffffff818501511660246040518094819363f25b3f9960e01b835260048301525afa9081156108bd575f91610a03575b506040830151146106695760405162461bcd60e51b815260206004820152601360248201527f616e63686f7220636865636b206661696c6564000000000000000000000000006044820152606490fd5b90506020813d602011610a2d575b81610a1e60209383611277565b8101031261019c5751836109b3565b3d9150610a11565b60405162461bcd60e51b815260206004820152601760248201527f756e6b6e6f776e20616e63686f722070726f76696465720000000000000000006044820152606490fd5b60405162461bcd60e51b815260206004820152601260248201527f6e6f7420696e76616c69642070726f76657200000000000000000000000000006044820152606490fd5b813581526020918201910161062e565b81358152602091820191016105f9565b81358152602091820191016105c7565b3461019c575f36600319011261019c5760206001600160a01b035f5416604051908152f35b3461019c575f36600319011261019c57335f526001602090808252610b3f60ff60405f2054166113d2565b5f5460ff8160a01c16610be65760ff60a01b19740100000000000000000000000000000000000000009116175f557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a25882604051338152a15f815b610b9f57005b60045481101561037b57806001600160a01b03610bbe610be0936111fa565b919054600392831b1c165f52845260405f20600260ff1982541617905561139c565b81610b99565b60405162461bcd60e51b815260048101849052601060248201527f5061757361626c653a20706175736564000000000000000000000000000000006044820152606490fd5b3461019c57602036600319011261019c5761037b610c4761122f565b610c5c6001600160a01b035f54163314611351565b6115f4565b3461019c57602036600319011261019c5767ffffffffffffffff610c8361119a565b165f52600660205260206001600160a01b0360405f205416604051908152f35b3461019c57602036600319011261019c576001600160a01b03610cc461122f565b165f526001602052602060ff60405f2054166040519015158152f35b3461019c575f36600319011261019c5761037b336116d9565b3461019c57602036600319011261019c5761037b610d1561122f565b610d2a6001600160a01b035f54163314611351565b6116d9565b3461019c57602036600319011261019c5767ffffffffffffffff610d5161119a565b165f526008602052602060405f2054604051908152f35b3461019c57610d7636611299565b5f54906001600160a01b0391610d8f3384831614611351565b60ff9060a01c811615610eb7576002925b5f5b835181101561037b5781610db682866113be565b511690815f52600360208181528560405f205416828110156101e457610e7357600454680100000000000000008110156108fc5784610dfe826001610e1e94016004556111fa565b90919082549060031b916001600160a01b03809116831b921b1916179055565b835f5281815260405f20918810156101e457610e6e937fef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd0396849260ff19815416888b16179055604051908152a161139c565b610da2565b6064906040519062461bcd60e51b82526004820152601160248201527f6163636f756e742069732070726f7665720000000000000000000000000000006044820152fd5b600192610da0565b3461019c57604036600319011261019c577fd621c244f07f12e1f37bb9c40d61e278041fc4f2859a6736794b26f4297c8090610ef961119a565b610f01611245565b906001600160a01b03610f18815f54163314611351565b67ffffffffffffffff82165f52600560205260405f2090831673ffffffffffffffffffffffffffffffffffffffff19825416179055610518604051928392839092916001600160a01b0360209167ffffffffffffffff604085019616845216910152565b3461019c575f36600319011261019c57602060ff5f5460a01c166040519015158152f35b3461019c575f36600319011261019c576020600254604051908152f35b3461019c575f36600319011261019c576020600454604051908152f35b3461019c575f36600319011261019c57335f52600160209080825261100560ff60405f2054166113d2565b5f5460ff8160a01c16156110955760ff60a01b19165f557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa82604051338152a15f815b61104e57005b60045481101561037b5761108f816001600160a01b0361106e85946111fa565b919054600392831b1c165f52855260405f208360ff1982541617905561139c565b90611048565b60405162461bcd60e51b815260048101849052601460248201527f5061757361626c653a206e6f74207061757365640000000000000000000000006044820152606490fd5b3461019c57604036600319011261019c5767ffffffffffffffff6110fc61119a565b165f52600760205260405f206024355f52602052602060ff60405f2054166040519015158152f35b3461019c57602036600319011261019c5760043560025481101561019c576001600160a01b0361018c6020926111b1565b3461019c57604036600319011261019c5760209067ffffffffffffffff61117a61119a565b165f526007825260405f206024355f52825260ff60405f20541615158152f35b6004359067ffffffffffffffff8216820361019c57565b6002548110156111e65760025f527f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace01905f90565b634e487b7160e01b5f52603260045260245ffd5b6004548110156111e65760045f527f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b01905f90565b600435906001600160a01b038216820361019c57565b602435906001600160a01b038216820361019c57565b6040810190811067ffffffffffffffff8211176108fc57604052565b90601f8019910116810190811067ffffffffffffffff8211176108fc57604052565b60208060031983011261019c5767ffffffffffffffff9160043583811161019c578160238201121561019c5780600401359384116108fc578360051b90604051946112e685840187611277565b855260248486019282010192831161019c57602401905b82821061130b575050505090565b81356001600160a01b038116810361019c5781529083019083016112fd565b5f915b6002831061133a57505050565b60019082518152602080910192019201919061132d565b1561135857565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b5f1981146113aa5760010190565b634e487b7160e01b5f52601160045260245ffd5b80518210156111e65760209160051b010190565b156113d957565b60405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f74207061757365720000000000000000000000006044820152606490fd5b6001600160a01b03809116915f83815260039360209185835260409060ff8282205416878110156115e0571561159c576004968754965f199081890198891161158957835b8a54811015611546578682611477836111fa565b905490871b1c16146114915761148c9061139c565b611463565b909192939495969798808210611521575b5050508754801561150e5797849392917fd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985989901906114f86114e3836111fa565b6001600160a01b0382549160031b1b19169055565b55848252855220805460ff1916905551908152a1565b634e487b7160e01b845260318952602484fd5b61153e92611531610dfe926111fa565b905490871b1c16916111fa565b5f80806114a2565b855162461bcd60e51b8152808c01899052601060248201527f70726f766572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b634e487b7160e01b845260118a52602484fd5b815162461bcd60e51b815260048101859052601560248201527f6163636f756e74206973206e6f742070726f76657200000000000000000000006044820152606490fd5b634e487b7160e01b82526021600452602482fd5b6001600160a01b038116905f90828252600160205260ff6040832054166116945760025468010000000000000000811015611680576020926116647f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f89593610dfe846001604096016002556111b1565b8281526001845220600160ff19825416179055604051908152a1565b634e487b7160e01b83526041600452602483fd5b60405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152606490fd5b6001600160a01b03809116905f9282845260019060209382855260409360ff858820541615611851576002805490915f199182810190811161183d57908695949392918a975b611768575b885162461bcd60e51b8152600481018b9052601060248201527f706175736572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b8399989799548a10156118345781856117808c6111b1565b929054600393841b1c16146117a957506117a08798999a9795969761139c565b9796959461171f565b929394979695999181831061180f575b50505050815480156117fb57918493917fcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e98999301906114f86114e3836111b1565b634e487b7160e01b89526031600452602489fd5b61182b9361181f610dfe936111b1565b9054911b1c16916111b1565b5f8080806117b9565b87989950611724565b634e487b7160e01b8a52601160045260248afd5b845162461bcd60e51b815260048101879052601560248201527f4163636f756e74206973206e6f742070617573657200000000000000000000006044820152606490fdfea2646970667358221220213f0eaa2bb45da06d71992d8bc2c8cec71a98ead3c89f8b2080a6fd2bc9e60364736f6c63430008140033",
}

// SMTABI is the input ABI used to generate the binding from.
// Deprecated: Use SMTMetaData.ABI instead.
var SMTABI = SMTMetaData.ABI

// SMTBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use SMTMetaData.Bin instead.
var SMTBin = SMTMetaData.Bin

// DeploySMT deploys a new Ethereum contract, binding an instance of SMT to it.
func DeploySMT(auth *bind.TransactOpts, backend bind.ContractBackend, _chainIds []uint64, _anchorProviders []common.Address, _verifiers []common.Address, _initRoots [][32]byte) (common.Address, *types.Transaction, *SMT, error) {
	parsed, err := SMTMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(SMTBin), backend, _chainIds, _anchorProviders, _verifiers, _initRoots)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SMT{SMTCaller: SMTCaller{contract: contract}, SMTTransactor: SMTTransactor{contract: contract}, SMTFilterer: SMTFilterer{contract: contract}}, nil
}

// SMT is an auto generated Go binding around an Ethereum contract.
type SMT struct {
	SMTCaller     // Read-only binding to the contract
	SMTTransactor // Write-only binding to the contract
	SMTFilterer   // Log filterer for contract events
}

// SMTCaller is an auto generated read-only Go binding around an Ethereum contract.
type SMTCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SMTTransactor is an auto generated write-only Go binding around an Ethereum contract.
type SMTTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SMTFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SMTFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SMTSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SMTSession struct {
	Contract     *SMT              // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// SMTCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SMTCallerSession struct {
	Contract *SMTCaller    // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// SMTTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SMTTransactorSession struct {
	Contract     *SMTTransactor    // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// SMTRaw is an auto generated low-level Go binding around an Ethereum contract.
type SMTRaw struct {
	Contract *SMT // Generic contract binding to access the raw methods on
}

// SMTCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SMTCallerRaw struct {
	Contract *SMTCaller // Generic read-only contract binding to access the raw methods on
}

// SMTTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SMTTransactorRaw struct {
	Contract *SMTTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSMT creates a new instance of SMT, bound to a specific deployed contract.
func NewSMT(address common.Address, backend bind.ContractBackend) (*SMT, error) {
	contract, err := bindSMT(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SMT{SMTCaller: SMTCaller{contract: contract}, SMTTransactor: SMTTransactor{contract: contract}, SMTFilterer: SMTFilterer{contract: contract}}, nil
}

// NewSMTCaller creates a new read-only instance of SMT, bound to a specific deployed contract.
func NewSMTCaller(address common.Address, caller bind.ContractCaller) (*SMTCaller, error) {
	contract, err := bindSMT(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SMTCaller{contract: contract}, nil
}

// NewSMTTransactor creates a new write-only instance of SMT, bound to a specific deployed contract.
func NewSMTTransactor(address common.Address, transactor bind.ContractTransactor) (*SMTTransactor, error) {
	contract, err := bindSMT(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SMTTransactor{contract: contract}, nil
}

// NewSMTFilterer creates a new log filterer instance of SMT, bound to a specific deployed contract.
func NewSMTFilterer(address common.Address, filterer bind.ContractFilterer) (*SMTFilterer, error) {
	contract, err := bindSMT(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SMTFilterer{contract: contract}, nil
}

// bindSMT binds a generic wrapper to an already deployed contract.
func bindSMT(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := SMTMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SMT *SMTRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SMT.Contract.SMTCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SMT *SMTRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SMT.Contract.SMTTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SMT *SMTRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SMT.Contract.SMTTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SMT *SMTCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SMT.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SMT *SMTTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SMT.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SMT *SMTTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SMT.Contract.contract.Transact(opts, method, params...)
}

// AnchorProviders is a free data retrieval call binding the contract method 0xafe8154b.
//
// Solidity: function anchorProviders(uint64 ) view returns(address)
func (_SMT *SMTCaller) AnchorProviders(opts *bind.CallOpts, arg0 uint64) (common.Address, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "anchorProviders", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// AnchorProviders is a free data retrieval call binding the contract method 0xafe8154b.
//
// Solidity: function anchorProviders(uint64 ) view returns(address)
func (_SMT *SMTSession) AnchorProviders(arg0 uint64) (common.Address, error) {
	return _SMT.Contract.AnchorProviders(&_SMT.CallOpts, arg0)
}

// AnchorProviders is a free data retrieval call binding the contract method 0xafe8154b.
//
// Solidity: function anchorProviders(uint64 ) view returns(address)
func (_SMT *SMTCallerSession) AnchorProviders(arg0 uint64) (common.Address, error) {
	return _SMT.Contract.AnchorProviders(&_SMT.CallOpts, arg0)
}

// GetLatestRoot is a free data retrieval call binding the contract method 0x479aa6da.
//
// Solidity: function getLatestRoot(uint64 chainId) view returns(bytes32)
func (_SMT *SMTCaller) GetLatestRoot(opts *bind.CallOpts, chainId uint64) ([32]byte, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "getLatestRoot", chainId)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// GetLatestRoot is a free data retrieval call binding the contract method 0x479aa6da.
//
// Solidity: function getLatestRoot(uint64 chainId) view returns(bytes32)
func (_SMT *SMTSession) GetLatestRoot(chainId uint64) ([32]byte, error) {
	return _SMT.Contract.GetLatestRoot(&_SMT.CallOpts, chainId)
}

// GetLatestRoot is a free data retrieval call binding the contract method 0x479aa6da.
//
// Solidity: function getLatestRoot(uint64 chainId) view returns(bytes32)
func (_SMT *SMTCallerSession) GetLatestRoot(chainId uint64) ([32]byte, error) {
	return _SMT.Contract.GetLatestRoot(&_SMT.CallOpts, chainId)
}

// IsActiveProver is a free data retrieval call binding the contract method 0xec64842e.
//
// Solidity: function isActiveProver(address _account) view returns(bool)
func (_SMT *SMTCaller) IsActiveProver(opts *bind.CallOpts, _account common.Address) (bool, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "isActiveProver", _account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsActiveProver is a free data retrieval call binding the contract method 0xec64842e.
//
// Solidity: function isActiveProver(address _account) view returns(bool)
func (_SMT *SMTSession) IsActiveProver(_account common.Address) (bool, error) {
	return _SMT.Contract.IsActiveProver(&_SMT.CallOpts, _account)
}

// IsActiveProver is a free data retrieval call binding the contract method 0xec64842e.
//
// Solidity: function isActiveProver(address _account) view returns(bool)
func (_SMT *SMTCallerSession) IsActiveProver(_account common.Address) (bool, error) {
	return _SMT.Contract.IsActiveProver(&_SMT.CallOpts, _account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_SMT *SMTCaller) IsPauser(opts *bind.CallOpts, account common.Address) (bool, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "isPauser", account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_SMT *SMTSession) IsPauser(account common.Address) (bool, error) {
	return _SMT.Contract.IsPauser(&_SMT.CallOpts, account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_SMT *SMTCallerSession) IsPauser(account common.Address) (bool, error) {
	return _SMT.Contract.IsPauser(&_SMT.CallOpts, account)
}

// IsSmtRootValid is a free data retrieval call binding the contract method 0x1019b616.
//
// Solidity: function isSmtRootValid(uint64 chainId, bytes32 smtRoot) view returns(bool)
func (_SMT *SMTCaller) IsSmtRootValid(opts *bind.CallOpts, chainId uint64, smtRoot [32]byte) (bool, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "isSmtRootValid", chainId, smtRoot)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsSmtRootValid is a free data retrieval call binding the contract method 0x1019b616.
//
// Solidity: function isSmtRootValid(uint64 chainId, bytes32 smtRoot) view returns(bool)
func (_SMT *SMTSession) IsSmtRootValid(chainId uint64, smtRoot [32]byte) (bool, error) {
	return _SMT.Contract.IsSmtRootValid(&_SMT.CallOpts, chainId, smtRoot)
}

// IsSmtRootValid is a free data retrieval call binding the contract method 0x1019b616.
//
// Solidity: function isSmtRootValid(uint64 chainId, bytes32 smtRoot) view returns(bool)
func (_SMT *SMTCallerSession) IsSmtRootValid(chainId uint64, smtRoot [32]byte) (bool, error) {
	return _SMT.Contract.IsSmtRootValid(&_SMT.CallOpts, chainId, smtRoot)
}

// LatestRoots is a free data retrieval call binding the contract method 0x6ae3e080.
//
// Solidity: function latestRoots(uint64 ) view returns(bytes32)
func (_SMT *SMTCaller) LatestRoots(opts *bind.CallOpts, arg0 uint64) ([32]byte, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "latestRoots", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// LatestRoots is a free data retrieval call binding the contract method 0x6ae3e080.
//
// Solidity: function latestRoots(uint64 ) view returns(bytes32)
func (_SMT *SMTSession) LatestRoots(arg0 uint64) ([32]byte, error) {
	return _SMT.Contract.LatestRoots(&_SMT.CallOpts, arg0)
}

// LatestRoots is a free data retrieval call binding the contract method 0x6ae3e080.
//
// Solidity: function latestRoots(uint64 ) view returns(bytes32)
func (_SMT *SMTCallerSession) LatestRoots(arg0 uint64) ([32]byte, error) {
	return _SMT.Contract.LatestRoots(&_SMT.CallOpts, arg0)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_SMT *SMTCaller) NumPausers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "numPausers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_SMT *SMTSession) NumPausers() (*big.Int, error) {
	return _SMT.Contract.NumPausers(&_SMT.CallOpts)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_SMT *SMTCallerSession) NumPausers() (*big.Int, error) {
	return _SMT.Contract.NumPausers(&_SMT.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_SMT *SMTCaller) NumProvers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "numProvers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_SMT *SMTSession) NumProvers() (*big.Int, error) {
	return _SMT.Contract.NumProvers(&_SMT.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_SMT *SMTCallerSession) NumProvers() (*big.Int, error) {
	return _SMT.Contract.NumProvers(&_SMT.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_SMT *SMTCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_SMT *SMTSession) Owner() (common.Address, error) {
	return _SMT.Contract.Owner(&_SMT.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_SMT *SMTCallerSession) Owner() (common.Address, error) {
	return _SMT.Contract.Owner(&_SMT.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_SMT *SMTCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_SMT *SMTSession) Paused() (bool, error) {
	return _SMT.Contract.Paused(&_SMT.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_SMT *SMTCallerSession) Paused() (bool, error) {
	return _SMT.Contract.Paused(&_SMT.CallOpts)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_SMT *SMTCaller) PauserList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "pauserList", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_SMT *SMTSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _SMT.Contract.PauserList(&_SMT.CallOpts, arg0)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_SMT *SMTCallerSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _SMT.Contract.PauserList(&_SMT.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_SMT *SMTCaller) Pausers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "pausers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_SMT *SMTSession) Pausers(arg0 common.Address) (bool, error) {
	return _SMT.Contract.Pausers(&_SMT.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_SMT *SMTCallerSession) Pausers(arg0 common.Address) (bool, error) {
	return _SMT.Contract.Pausers(&_SMT.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_SMT *SMTCaller) ProverStates(opts *bind.CallOpts, arg0 common.Address) (uint8, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "proverStates", arg0)

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_SMT *SMTSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _SMT.Contract.ProverStates(&_SMT.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_SMT *SMTCallerSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _SMT.Contract.ProverStates(&_SMT.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_SMT *SMTCaller) Provers(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "provers", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_SMT *SMTSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _SMT.Contract.Provers(&_SMT.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_SMT *SMTCallerSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _SMT.Contract.Provers(&_SMT.CallOpts, arg0)
}

// SmtRoots is a free data retrieval call binding the contract method 0x38702532.
//
// Solidity: function smtRoots(uint64 , bytes32 ) view returns(bool)
func (_SMT *SMTCaller) SmtRoots(opts *bind.CallOpts, arg0 uint64, arg1 [32]byte) (bool, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "smtRoots", arg0, arg1)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SmtRoots is a free data retrieval call binding the contract method 0x38702532.
//
// Solidity: function smtRoots(uint64 , bytes32 ) view returns(bool)
func (_SMT *SMTSession) SmtRoots(arg0 uint64, arg1 [32]byte) (bool, error) {
	return _SMT.Contract.SmtRoots(&_SMT.CallOpts, arg0, arg1)
}

// SmtRoots is a free data retrieval call binding the contract method 0x38702532.
//
// Solidity: function smtRoots(uint64 , bytes32 ) view returns(bool)
func (_SMT *SMTCallerSession) SmtRoots(arg0 uint64, arg1 [32]byte) (bool, error) {
	return _SMT.Contract.SmtRoots(&_SMT.CallOpts, arg0, arg1)
}

// Verifiers is a free data retrieval call binding the contract method 0x8195408d.
//
// Solidity: function verifiers(uint64 ) view returns(address)
func (_SMT *SMTCaller) Verifiers(opts *bind.CallOpts, arg0 uint64) (common.Address, error) {
	var out []interface{}
	err := _SMT.contract.Call(opts, &out, "verifiers", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Verifiers is a free data retrieval call binding the contract method 0x8195408d.
//
// Solidity: function verifiers(uint64 ) view returns(address)
func (_SMT *SMTSession) Verifiers(arg0 uint64) (common.Address, error) {
	return _SMT.Contract.Verifiers(&_SMT.CallOpts, arg0)
}

// Verifiers is a free data retrieval call binding the contract method 0x8195408d.
//
// Solidity: function verifiers(uint64 ) view returns(address)
func (_SMT *SMTCallerSession) Verifiers(arg0 uint64) (common.Address, error) {
	return _SMT.Contract.Verifiers(&_SMT.CallOpts, arg0)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_SMT *SMTTransactor) AddPauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _SMT.contract.Transact(opts, "addPauser", account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_SMT *SMTSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _SMT.Contract.AddPauser(&_SMT.TransactOpts, account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_SMT *SMTTransactorSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _SMT.Contract.AddPauser(&_SMT.TransactOpts, account)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_SMT *SMTTransactor) AddPausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _SMT.contract.Transact(opts, "addPausers", accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_SMT *SMTSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _SMT.Contract.AddPausers(&_SMT.TransactOpts, accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_SMT *SMTTransactorSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _SMT.Contract.AddPausers(&_SMT.TransactOpts, accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_SMT *SMTTransactor) AddProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _SMT.contract.Transact(opts, "addProvers", _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_SMT *SMTSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _SMT.Contract.AddProvers(&_SMT.TransactOpts, _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_SMT *SMTTransactorSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _SMT.Contract.AddProvers(&_SMT.TransactOpts, _accounts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_SMT *SMTTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SMT.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_SMT *SMTSession) Pause() (*types.Transaction, error) {
	return _SMT.Contract.Pause(&_SMT.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_SMT *SMTTransactorSession) Pause() (*types.Transaction, error) {
	return _SMT.Contract.Pause(&_SMT.TransactOpts)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_SMT *SMTTransactor) RemovePauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _SMT.contract.Transact(opts, "removePauser", account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_SMT *SMTSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _SMT.Contract.RemovePauser(&_SMT.TransactOpts, account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_SMT *SMTTransactorSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _SMT.Contract.RemovePauser(&_SMT.TransactOpts, account)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_SMT *SMTTransactor) RemovePausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _SMT.contract.Transact(opts, "removePausers", accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_SMT *SMTSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _SMT.Contract.RemovePausers(&_SMT.TransactOpts, accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_SMT *SMTTransactorSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _SMT.Contract.RemovePausers(&_SMT.TransactOpts, accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_SMT *SMTTransactor) RemoveProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _SMT.contract.Transact(opts, "removeProvers", _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_SMT *SMTSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _SMT.Contract.RemoveProvers(&_SMT.TransactOpts, _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_SMT *SMTTransactorSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _SMT.Contract.RemoveProvers(&_SMT.TransactOpts, _accounts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_SMT *SMTTransactor) RenouncePauser(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SMT.contract.Transact(opts, "renouncePauser")
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_SMT *SMTSession) RenouncePauser() (*types.Transaction, error) {
	return _SMT.Contract.RenouncePauser(&_SMT.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_SMT *SMTTransactorSession) RenouncePauser() (*types.Transaction, error) {
	return _SMT.Contract.RenouncePauser(&_SMT.TransactOpts)
}

// SetAnchorProvider is a paid mutator transaction binding the contract method 0x5ca32bd8.
//
// Solidity: function setAnchorProvider(uint64 chainId, address anchorProvider) returns()
func (_SMT *SMTTransactor) SetAnchorProvider(opts *bind.TransactOpts, chainId uint64, anchorProvider common.Address) (*types.Transaction, error) {
	return _SMT.contract.Transact(opts, "setAnchorProvider", chainId, anchorProvider)
}

// SetAnchorProvider is a paid mutator transaction binding the contract method 0x5ca32bd8.
//
// Solidity: function setAnchorProvider(uint64 chainId, address anchorProvider) returns()
func (_SMT *SMTSession) SetAnchorProvider(chainId uint64, anchorProvider common.Address) (*types.Transaction, error) {
	return _SMT.Contract.SetAnchorProvider(&_SMT.TransactOpts, chainId, anchorProvider)
}

// SetAnchorProvider is a paid mutator transaction binding the contract method 0x5ca32bd8.
//
// Solidity: function setAnchorProvider(uint64 chainId, address anchorProvider) returns()
func (_SMT *SMTTransactorSession) SetAnchorProvider(chainId uint64, anchorProvider common.Address) (*types.Transaction, error) {
	return _SMT.Contract.SetAnchorProvider(&_SMT.TransactOpts, chainId, anchorProvider)
}

// SetVerifier is a paid mutator transaction binding the contract method 0x9c8413c5.
//
// Solidity: function setVerifier(uint64 chainId, address verifier) returns()
func (_SMT *SMTTransactor) SetVerifier(opts *bind.TransactOpts, chainId uint64, verifier common.Address) (*types.Transaction, error) {
	return _SMT.contract.Transact(opts, "setVerifier", chainId, verifier)
}

// SetVerifier is a paid mutator transaction binding the contract method 0x9c8413c5.
//
// Solidity: function setVerifier(uint64 chainId, address verifier) returns()
func (_SMT *SMTSession) SetVerifier(chainId uint64, verifier common.Address) (*types.Transaction, error) {
	return _SMT.Contract.SetVerifier(&_SMT.TransactOpts, chainId, verifier)
}

// SetVerifier is a paid mutator transaction binding the contract method 0x9c8413c5.
//
// Solidity: function setVerifier(uint64 chainId, address verifier) returns()
func (_SMT *SMTTransactorSession) SetVerifier(chainId uint64, verifier common.Address) (*types.Transaction, error) {
	return _SMT.Contract.SetVerifier(&_SMT.TransactOpts, chainId, verifier)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_SMT *SMTTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _SMT.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_SMT *SMTSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _SMT.Contract.TransferOwnership(&_SMT.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_SMT *SMTTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _SMT.Contract.TransferOwnership(&_SMT.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_SMT *SMTTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SMT.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_SMT *SMTSession) Unpause() (*types.Transaction, error) {
	return _SMT.Contract.Unpause(&_SMT.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_SMT *SMTTransactorSession) Unpause() (*types.Transaction, error) {
	return _SMT.Contract.Unpause(&_SMT.TransactOpts)
}

// UpdateRoot is a paid mutator transaction binding the contract method 0x97c7c309.
//
// Solidity: function updateRoot(uint64 chainId, (bytes32,uint64,bytes32,bytes32,uint256[8],uint256[2],uint256[2]) u) returns()
func (_SMT *SMTTransactor) UpdateRoot(opts *bind.TransactOpts, chainId uint64, u ISMTSmtUpdate) (*types.Transaction, error) {
	return _SMT.contract.Transact(opts, "updateRoot", chainId, u)
}

// UpdateRoot is a paid mutator transaction binding the contract method 0x97c7c309.
//
// Solidity: function updateRoot(uint64 chainId, (bytes32,uint64,bytes32,bytes32,uint256[8],uint256[2],uint256[2]) u) returns()
func (_SMT *SMTSession) UpdateRoot(chainId uint64, u ISMTSmtUpdate) (*types.Transaction, error) {
	return _SMT.Contract.UpdateRoot(&_SMT.TransactOpts, chainId, u)
}

// UpdateRoot is a paid mutator transaction binding the contract method 0x97c7c309.
//
// Solidity: function updateRoot(uint64 chainId, (bytes32,uint64,bytes32,bytes32,uint256[8],uint256[2],uint256[2]) u) returns()
func (_SMT *SMTTransactorSession) UpdateRoot(chainId uint64, u ISMTSmtUpdate) (*types.Transaction, error) {
	return _SMT.Contract.UpdateRoot(&_SMT.TransactOpts, chainId, u)
}

// SMTAnchorProviderUpdatedIterator is returned from FilterAnchorProviderUpdated and is used to iterate over the raw logs and unpacked data for AnchorProviderUpdated events raised by the SMT contract.
type SMTAnchorProviderUpdatedIterator struct {
	Event *SMTAnchorProviderUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SMTAnchorProviderUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SMTAnchorProviderUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SMTAnchorProviderUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SMTAnchorProviderUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SMTAnchorProviderUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SMTAnchorProviderUpdated represents a AnchorProviderUpdated event raised by the SMT contract.
type SMTAnchorProviderUpdated struct {
	ChainId        uint64
	AnchorProvider common.Address
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterAnchorProviderUpdated is a free log retrieval operation binding the contract event 0xd621c244f07f12e1f37bb9c40d61e278041fc4f2859a6736794b26f4297c8090.
//
// Solidity: event AnchorProviderUpdated(uint64 chainId, address anchorProvider)
func (_SMT *SMTFilterer) FilterAnchorProviderUpdated(opts *bind.FilterOpts) (*SMTAnchorProviderUpdatedIterator, error) {

	logs, sub, err := _SMT.contract.FilterLogs(opts, "AnchorProviderUpdated")
	if err != nil {
		return nil, err
	}
	return &SMTAnchorProviderUpdatedIterator{contract: _SMT.contract, event: "AnchorProviderUpdated", logs: logs, sub: sub}, nil
}

// WatchAnchorProviderUpdated is a free log subscription operation binding the contract event 0xd621c244f07f12e1f37bb9c40d61e278041fc4f2859a6736794b26f4297c8090.
//
// Solidity: event AnchorProviderUpdated(uint64 chainId, address anchorProvider)
func (_SMT *SMTFilterer) WatchAnchorProviderUpdated(opts *bind.WatchOpts, sink chan<- *SMTAnchorProviderUpdated) (event.Subscription, error) {

	logs, sub, err := _SMT.contract.WatchLogs(opts, "AnchorProviderUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SMTAnchorProviderUpdated)
				if err := _SMT.contract.UnpackLog(event, "AnchorProviderUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAnchorProviderUpdated is a log parse operation binding the contract event 0xd621c244f07f12e1f37bb9c40d61e278041fc4f2859a6736794b26f4297c8090.
//
// Solidity: event AnchorProviderUpdated(uint64 chainId, address anchorProvider)
func (_SMT *SMTFilterer) ParseAnchorProviderUpdated(log types.Log) (*SMTAnchorProviderUpdated, error) {
	event := new(SMTAnchorProviderUpdated)
	if err := _SMT.contract.UnpackLog(event, "AnchorProviderUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SMTOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the SMT contract.
type SMTOwnershipTransferredIterator struct {
	Event *SMTOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SMTOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SMTOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SMTOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SMTOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SMTOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SMTOwnershipTransferred represents a OwnershipTransferred event raised by the SMT contract.
type SMTOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_SMT *SMTFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*SMTOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _SMT.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &SMTOwnershipTransferredIterator{contract: _SMT.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_SMT *SMTFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *SMTOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _SMT.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SMTOwnershipTransferred)
				if err := _SMT.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_SMT *SMTFilterer) ParseOwnershipTransferred(log types.Log) (*SMTOwnershipTransferred, error) {
	event := new(SMTOwnershipTransferred)
	if err := _SMT.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SMTPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the SMT contract.
type SMTPausedIterator struct {
	Event *SMTPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SMTPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SMTPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SMTPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SMTPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SMTPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SMTPaused represents a Paused event raised by the SMT contract.
type SMTPaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_SMT *SMTFilterer) FilterPaused(opts *bind.FilterOpts) (*SMTPausedIterator, error) {

	logs, sub, err := _SMT.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &SMTPausedIterator{contract: _SMT.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_SMT *SMTFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *SMTPaused) (event.Subscription, error) {

	logs, sub, err := _SMT.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SMTPaused)
				if err := _SMT.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_SMT *SMTFilterer) ParsePaused(log types.Log) (*SMTPaused, error) {
	event := new(SMTPaused)
	if err := _SMT.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SMTPauserAddedIterator is returned from FilterPauserAdded and is used to iterate over the raw logs and unpacked data for PauserAdded events raised by the SMT contract.
type SMTPauserAddedIterator struct {
	Event *SMTPauserAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SMTPauserAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SMTPauserAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SMTPauserAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SMTPauserAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SMTPauserAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SMTPauserAdded represents a PauserAdded event raised by the SMT contract.
type SMTPauserAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserAdded is a free log retrieval operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_SMT *SMTFilterer) FilterPauserAdded(opts *bind.FilterOpts) (*SMTPauserAddedIterator, error) {

	logs, sub, err := _SMT.contract.FilterLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return &SMTPauserAddedIterator{contract: _SMT.contract, event: "PauserAdded", logs: logs, sub: sub}, nil
}

// WatchPauserAdded is a free log subscription operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_SMT *SMTFilterer) WatchPauserAdded(opts *bind.WatchOpts, sink chan<- *SMTPauserAdded) (event.Subscription, error) {

	logs, sub, err := _SMT.contract.WatchLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SMTPauserAdded)
				if err := _SMT.contract.UnpackLog(event, "PauserAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserAdded is a log parse operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_SMT *SMTFilterer) ParsePauserAdded(log types.Log) (*SMTPauserAdded, error) {
	event := new(SMTPauserAdded)
	if err := _SMT.contract.UnpackLog(event, "PauserAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SMTPauserRemovedIterator is returned from FilterPauserRemoved and is used to iterate over the raw logs and unpacked data for PauserRemoved events raised by the SMT contract.
type SMTPauserRemovedIterator struct {
	Event *SMTPauserRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SMTPauserRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SMTPauserRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SMTPauserRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SMTPauserRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SMTPauserRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SMTPauserRemoved represents a PauserRemoved event raised by the SMT contract.
type SMTPauserRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserRemoved is a free log retrieval operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_SMT *SMTFilterer) FilterPauserRemoved(opts *bind.FilterOpts) (*SMTPauserRemovedIterator, error) {

	logs, sub, err := _SMT.contract.FilterLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return &SMTPauserRemovedIterator{contract: _SMT.contract, event: "PauserRemoved", logs: logs, sub: sub}, nil
}

// WatchPauserRemoved is a free log subscription operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_SMT *SMTFilterer) WatchPauserRemoved(opts *bind.WatchOpts, sink chan<- *SMTPauserRemoved) (event.Subscription, error) {

	logs, sub, err := _SMT.contract.WatchLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SMTPauserRemoved)
				if err := _SMT.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserRemoved is a log parse operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_SMT *SMTFilterer) ParsePauserRemoved(log types.Log) (*SMTPauserRemoved, error) {
	event := new(SMTPauserRemoved)
	if err := _SMT.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SMTProverAddedIterator is returned from FilterProverAdded and is used to iterate over the raw logs and unpacked data for ProverAdded events raised by the SMT contract.
type SMTProverAddedIterator struct {
	Event *SMTProverAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SMTProverAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SMTProverAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SMTProverAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SMTProverAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SMTProverAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SMTProverAdded represents a ProverAdded event raised by the SMT contract.
type SMTProverAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverAdded is a free log retrieval operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_SMT *SMTFilterer) FilterProverAdded(opts *bind.FilterOpts) (*SMTProverAddedIterator, error) {

	logs, sub, err := _SMT.contract.FilterLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return &SMTProverAddedIterator{contract: _SMT.contract, event: "ProverAdded", logs: logs, sub: sub}, nil
}

// WatchProverAdded is a free log subscription operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_SMT *SMTFilterer) WatchProverAdded(opts *bind.WatchOpts, sink chan<- *SMTProverAdded) (event.Subscription, error) {

	logs, sub, err := _SMT.contract.WatchLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SMTProverAdded)
				if err := _SMT.contract.UnpackLog(event, "ProverAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverAdded is a log parse operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_SMT *SMTFilterer) ParseProverAdded(log types.Log) (*SMTProverAdded, error) {
	event := new(SMTProverAdded)
	if err := _SMT.contract.UnpackLog(event, "ProverAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SMTProverRemovedIterator is returned from FilterProverRemoved and is used to iterate over the raw logs and unpacked data for ProverRemoved events raised by the SMT contract.
type SMTProverRemovedIterator struct {
	Event *SMTProverRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SMTProverRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SMTProverRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SMTProverRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SMTProverRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SMTProverRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SMTProverRemoved represents a ProverRemoved event raised by the SMT contract.
type SMTProverRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverRemoved is a free log retrieval operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_SMT *SMTFilterer) FilterProverRemoved(opts *bind.FilterOpts) (*SMTProverRemovedIterator, error) {

	logs, sub, err := _SMT.contract.FilterLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return &SMTProverRemovedIterator{contract: _SMT.contract, event: "ProverRemoved", logs: logs, sub: sub}, nil
}

// WatchProverRemoved is a free log subscription operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_SMT *SMTFilterer) WatchProverRemoved(opts *bind.WatchOpts, sink chan<- *SMTProverRemoved) (event.Subscription, error) {

	logs, sub, err := _SMT.contract.WatchLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SMTProverRemoved)
				if err := _SMT.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverRemoved is a log parse operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_SMT *SMTFilterer) ParseProverRemoved(log types.Log) (*SMTProverRemoved, error) {
	event := new(SMTProverRemoved)
	if err := _SMT.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SMTSmtRootUpdatedIterator is returned from FilterSmtRootUpdated and is used to iterate over the raw logs and unpacked data for SmtRootUpdated events raised by the SMT contract.
type SMTSmtRootUpdatedIterator struct {
	Event *SMTSmtRootUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SMTSmtRootUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SMTSmtRootUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SMTSmtRootUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SMTSmtRootUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SMTSmtRootUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SMTSmtRootUpdated represents a SmtRootUpdated event raised by the SMT contract.
type SMTSmtRootUpdated struct {
	SmtRoot     [32]byte
	EndBlockNum uint64
	ChainId     uint64
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterSmtRootUpdated is a free log retrieval operation binding the contract event 0xe8e2da79405f6328030a49e89981740387fc8c731042ec804a6461e796ec6f0b.
//
// Solidity: event SmtRootUpdated(bytes32 smtRoot, uint64 endBlockNum, uint64 chainId)
func (_SMT *SMTFilterer) FilterSmtRootUpdated(opts *bind.FilterOpts) (*SMTSmtRootUpdatedIterator, error) {

	logs, sub, err := _SMT.contract.FilterLogs(opts, "SmtRootUpdated")
	if err != nil {
		return nil, err
	}
	return &SMTSmtRootUpdatedIterator{contract: _SMT.contract, event: "SmtRootUpdated", logs: logs, sub: sub}, nil
}

// WatchSmtRootUpdated is a free log subscription operation binding the contract event 0xe8e2da79405f6328030a49e89981740387fc8c731042ec804a6461e796ec6f0b.
//
// Solidity: event SmtRootUpdated(bytes32 smtRoot, uint64 endBlockNum, uint64 chainId)
func (_SMT *SMTFilterer) WatchSmtRootUpdated(opts *bind.WatchOpts, sink chan<- *SMTSmtRootUpdated) (event.Subscription, error) {

	logs, sub, err := _SMT.contract.WatchLogs(opts, "SmtRootUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SMTSmtRootUpdated)
				if err := _SMT.contract.UnpackLog(event, "SmtRootUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSmtRootUpdated is a log parse operation binding the contract event 0xe8e2da79405f6328030a49e89981740387fc8c731042ec804a6461e796ec6f0b.
//
// Solidity: event SmtRootUpdated(bytes32 smtRoot, uint64 endBlockNum, uint64 chainId)
func (_SMT *SMTFilterer) ParseSmtRootUpdated(log types.Log) (*SMTSmtRootUpdated, error) {
	event := new(SMTSmtRootUpdated)
	if err := _SMT.contract.UnpackLog(event, "SmtRootUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SMTUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the SMT contract.
type SMTUnpausedIterator struct {
	Event *SMTUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SMTUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SMTUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SMTUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SMTUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SMTUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SMTUnpaused represents a Unpaused event raised by the SMT contract.
type SMTUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_SMT *SMTFilterer) FilterUnpaused(opts *bind.FilterOpts) (*SMTUnpausedIterator, error) {

	logs, sub, err := _SMT.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &SMTUnpausedIterator{contract: _SMT.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_SMT *SMTFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *SMTUnpaused) (event.Subscription, error) {

	logs, sub, err := _SMT.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SMTUnpaused)
				if err := _SMT.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_SMT *SMTFilterer) ParseUnpaused(log types.Log) (*SMTUnpaused, error) {
	event := new(SMTUnpaused)
	if err := _SMT.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SMTVerifierUpdatedIterator is returned from FilterVerifierUpdated and is used to iterate over the raw logs and unpacked data for VerifierUpdated events raised by the SMT contract.
type SMTVerifierUpdatedIterator struct {
	Event *SMTVerifierUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SMTVerifierUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SMTVerifierUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SMTVerifierUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SMTVerifierUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SMTVerifierUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SMTVerifierUpdated represents a VerifierUpdated event raised by the SMT contract.
type SMTVerifierUpdated struct {
	ChainId  uint64
	Verifier common.Address
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterVerifierUpdated is a free log retrieval operation binding the contract event 0xb78ea0eaf11776732556ef6189312ceb60eab6b3177526b3a12d966e37be8162.
//
// Solidity: event VerifierUpdated(uint64 chainId, address verifier)
func (_SMT *SMTFilterer) FilterVerifierUpdated(opts *bind.FilterOpts) (*SMTVerifierUpdatedIterator, error) {

	logs, sub, err := _SMT.contract.FilterLogs(opts, "VerifierUpdated")
	if err != nil {
		return nil, err
	}
	return &SMTVerifierUpdatedIterator{contract: _SMT.contract, event: "VerifierUpdated", logs: logs, sub: sub}, nil
}

// WatchVerifierUpdated is a free log subscription operation binding the contract event 0xb78ea0eaf11776732556ef6189312ceb60eab6b3177526b3a12d966e37be8162.
//
// Solidity: event VerifierUpdated(uint64 chainId, address verifier)
func (_SMT *SMTFilterer) WatchVerifierUpdated(opts *bind.WatchOpts, sink chan<- *SMTVerifierUpdated) (event.Subscription, error) {

	logs, sub, err := _SMT.contract.WatchLogs(opts, "VerifierUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SMTVerifierUpdated)
				if err := _SMT.contract.UnpackLog(event, "VerifierUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseVerifierUpdated is a log parse operation binding the contract event 0xb78ea0eaf11776732556ef6189312ceb60eab6b3177526b3a12d966e37be8162.
//
// Solidity: event VerifierUpdated(uint64 chainId, address verifier)
func (_SMT *SMTFilterer) ParseVerifierUpdated(log types.Log) (*SMTVerifierUpdated, error) {
	event := new(SMTVerifierUpdated)
	if err := _SMT.contract.UnpackLog(event, "VerifierUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SafeCastMetaData contains all meta data concerning the SafeCast contract.
var SafeCastMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212204f475c892cbda698f12a0b91db9c6366c91dca0d42d74a2c5ab56b1cf6ee56c264736f6c63430008140033",
}

// SafeCastABI is the input ABI used to generate the binding from.
// Deprecated: Use SafeCastMetaData.ABI instead.
var SafeCastABI = SafeCastMetaData.ABI

// SafeCastBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use SafeCastMetaData.Bin instead.
var SafeCastBin = SafeCastMetaData.Bin

// DeploySafeCast deploys a new Ethereum contract, binding an instance of SafeCast to it.
func DeploySafeCast(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *SafeCast, error) {
	parsed, err := SafeCastMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(SafeCastBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SafeCast{SafeCastCaller: SafeCastCaller{contract: contract}, SafeCastTransactor: SafeCastTransactor{contract: contract}, SafeCastFilterer: SafeCastFilterer{contract: contract}}, nil
}

// SafeCast is an auto generated Go binding around an Ethereum contract.
type SafeCast struct {
	SafeCastCaller     // Read-only binding to the contract
	SafeCastTransactor // Write-only binding to the contract
	SafeCastFilterer   // Log filterer for contract events
}

// SafeCastCaller is an auto generated read-only Go binding around an Ethereum contract.
type SafeCastCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeCastTransactor is an auto generated write-only Go binding around an Ethereum contract.
type SafeCastTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeCastFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SafeCastFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeCastSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SafeCastSession struct {
	Contract     *SafeCast         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// SafeCastCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SafeCastCallerSession struct {
	Contract *SafeCastCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// SafeCastTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SafeCastTransactorSession struct {
	Contract     *SafeCastTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// SafeCastRaw is an auto generated low-level Go binding around an Ethereum contract.
type SafeCastRaw struct {
	Contract *SafeCast // Generic contract binding to access the raw methods on
}

// SafeCastCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SafeCastCallerRaw struct {
	Contract *SafeCastCaller // Generic read-only contract binding to access the raw methods on
}

// SafeCastTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SafeCastTransactorRaw struct {
	Contract *SafeCastTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSafeCast creates a new instance of SafeCast, bound to a specific deployed contract.
func NewSafeCast(address common.Address, backend bind.ContractBackend) (*SafeCast, error) {
	contract, err := bindSafeCast(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SafeCast{SafeCastCaller: SafeCastCaller{contract: contract}, SafeCastTransactor: SafeCastTransactor{contract: contract}, SafeCastFilterer: SafeCastFilterer{contract: contract}}, nil
}

// NewSafeCastCaller creates a new read-only instance of SafeCast, bound to a specific deployed contract.
func NewSafeCastCaller(address common.Address, caller bind.ContractCaller) (*SafeCastCaller, error) {
	contract, err := bindSafeCast(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SafeCastCaller{contract: contract}, nil
}

// NewSafeCastTransactor creates a new write-only instance of SafeCast, bound to a specific deployed contract.
func NewSafeCastTransactor(address common.Address, transactor bind.ContractTransactor) (*SafeCastTransactor, error) {
	contract, err := bindSafeCast(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SafeCastTransactor{contract: contract}, nil
}

// NewSafeCastFilterer creates a new log filterer instance of SafeCast, bound to a specific deployed contract.
func NewSafeCastFilterer(address common.Address, filterer bind.ContractFilterer) (*SafeCastFilterer, error) {
	contract, err := bindSafeCast(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SafeCastFilterer{contract: contract}, nil
}

// bindSafeCast binds a generic wrapper to an already deployed contract.
func bindSafeCast(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := SafeCastMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SafeCast *SafeCastRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SafeCast.Contract.SafeCastCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SafeCast *SafeCastRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SafeCast.Contract.SafeCastTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SafeCast *SafeCastRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SafeCast.Contract.SafeCastTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SafeCast *SafeCastCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SafeCast.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SafeCast *SafeCastTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SafeCast.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SafeCast *SafeCastTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SafeCast.Contract.contract.Transact(opts, method, params...)
}

// SafeERC20MetaData contains all meta data concerning the SafeERC20 contract.
var SafeERC20MetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea2646970667358221220e4452412b1c842239525529cee107192565885a28e2498d223386853155461ed64736f6c63430008140033",
}

// SafeERC20ABI is the input ABI used to generate the binding from.
// Deprecated: Use SafeERC20MetaData.ABI instead.
var SafeERC20ABI = SafeERC20MetaData.ABI

// SafeERC20Bin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use SafeERC20MetaData.Bin instead.
var SafeERC20Bin = SafeERC20MetaData.Bin

// DeploySafeERC20 deploys a new Ethereum contract, binding an instance of SafeERC20 to it.
func DeploySafeERC20(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *SafeERC20, error) {
	parsed, err := SafeERC20MetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(SafeERC20Bin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SafeERC20{SafeERC20Caller: SafeERC20Caller{contract: contract}, SafeERC20Transactor: SafeERC20Transactor{contract: contract}, SafeERC20Filterer: SafeERC20Filterer{contract: contract}}, nil
}

// SafeERC20 is an auto generated Go binding around an Ethereum contract.
type SafeERC20 struct {
	SafeERC20Caller     // Read-only binding to the contract
	SafeERC20Transactor // Write-only binding to the contract
	SafeERC20Filterer   // Log filterer for contract events
}

// SafeERC20Caller is an auto generated read-only Go binding around an Ethereum contract.
type SafeERC20Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeERC20Transactor is an auto generated write-only Go binding around an Ethereum contract.
type SafeERC20Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeERC20Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SafeERC20Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeERC20Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SafeERC20Session struct {
	Contract     *SafeERC20        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// SafeERC20CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SafeERC20CallerSession struct {
	Contract *SafeERC20Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// SafeERC20TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SafeERC20TransactorSession struct {
	Contract     *SafeERC20Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// SafeERC20Raw is an auto generated low-level Go binding around an Ethereum contract.
type SafeERC20Raw struct {
	Contract *SafeERC20 // Generic contract binding to access the raw methods on
}

// SafeERC20CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SafeERC20CallerRaw struct {
	Contract *SafeERC20Caller // Generic read-only contract binding to access the raw methods on
}

// SafeERC20TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SafeERC20TransactorRaw struct {
	Contract *SafeERC20Transactor // Generic write-only contract binding to access the raw methods on
}

// NewSafeERC20 creates a new instance of SafeERC20, bound to a specific deployed contract.
func NewSafeERC20(address common.Address, backend bind.ContractBackend) (*SafeERC20, error) {
	contract, err := bindSafeERC20(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SafeERC20{SafeERC20Caller: SafeERC20Caller{contract: contract}, SafeERC20Transactor: SafeERC20Transactor{contract: contract}, SafeERC20Filterer: SafeERC20Filterer{contract: contract}}, nil
}

// NewSafeERC20Caller creates a new read-only instance of SafeERC20, bound to a specific deployed contract.
func NewSafeERC20Caller(address common.Address, caller bind.ContractCaller) (*SafeERC20Caller, error) {
	contract, err := bindSafeERC20(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SafeERC20Caller{contract: contract}, nil
}

// NewSafeERC20Transactor creates a new write-only instance of SafeERC20, bound to a specific deployed contract.
func NewSafeERC20Transactor(address common.Address, transactor bind.ContractTransactor) (*SafeERC20Transactor, error) {
	contract, err := bindSafeERC20(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SafeERC20Transactor{contract: contract}, nil
}

// NewSafeERC20Filterer creates a new log filterer instance of SafeERC20, bound to a specific deployed contract.
func NewSafeERC20Filterer(address common.Address, filterer bind.ContractFilterer) (*SafeERC20Filterer, error) {
	contract, err := bindSafeERC20(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SafeERC20Filterer{contract: contract}, nil
}

// bindSafeERC20 binds a generic wrapper to an already deployed contract.
func bindSafeERC20(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := SafeERC20MetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SafeERC20 *SafeERC20Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SafeERC20.Contract.SafeERC20Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SafeERC20 *SafeERC20Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SafeERC20.Contract.SafeERC20Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SafeERC20 *SafeERC20Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SafeERC20.Contract.SafeERC20Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SafeERC20 *SafeERC20CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SafeERC20.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SafeERC20 *SafeERC20TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SafeERC20.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SafeERC20 *SafeERC20TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SafeERC20.Contract.contract.Transact(opts, method, params...)
}

// SameChainAnchorBlocksMetaData contains all meta data concerning the SameChainAnchorBlocks contract.
var SameChainAnchorBlocksMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"}],\"name\":\"blocks\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x6080806040523461005a575f8054336001600160a01b0319821681178355916001600160a01b03909116907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09080a3610211908161005f8239f35b5f80fdfe6080806040526004361015610012575f80fd5b5f90813560e01c9081638da5cb5b146101a757508063f25b3f99146101885763f2fde38b1461003f575f80fd5b346101855760203660031901126101855760043573ffffffffffffffffffffffffffffffffffffffff8082168092036101815782549081169033820361013d5782156100d2577fffffffffffffffffffffffff000000000000000000000000000000000000000016821783557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608490fd5b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b8280fd5b80fd5b5034610185576020366003190112610185576020604051600435408152f35b9050346101d757816003193601126101d75773ffffffffffffffffffffffffffffffffffffffff60209254168152f35b5080fdfea26469706673582212205e5ffe9317aae71c622720c397618703d8c3c5ee1a5afd82bc1c200569d6c10364736f6c63430008140033",
}

// SameChainAnchorBlocksABI is the input ABI used to generate the binding from.
// Deprecated: Use SameChainAnchorBlocksMetaData.ABI instead.
var SameChainAnchorBlocksABI = SameChainAnchorBlocksMetaData.ABI

// SameChainAnchorBlocksBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use SameChainAnchorBlocksMetaData.Bin instead.
var SameChainAnchorBlocksBin = SameChainAnchorBlocksMetaData.Bin

// DeploySameChainAnchorBlocks deploys a new Ethereum contract, binding an instance of SameChainAnchorBlocks to it.
func DeploySameChainAnchorBlocks(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *SameChainAnchorBlocks, error) {
	parsed, err := SameChainAnchorBlocksMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(SameChainAnchorBlocksBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SameChainAnchorBlocks{SameChainAnchorBlocksCaller: SameChainAnchorBlocksCaller{contract: contract}, SameChainAnchorBlocksTransactor: SameChainAnchorBlocksTransactor{contract: contract}, SameChainAnchorBlocksFilterer: SameChainAnchorBlocksFilterer{contract: contract}}, nil
}

// SameChainAnchorBlocks is an auto generated Go binding around an Ethereum contract.
type SameChainAnchorBlocks struct {
	SameChainAnchorBlocksCaller     // Read-only binding to the contract
	SameChainAnchorBlocksTransactor // Write-only binding to the contract
	SameChainAnchorBlocksFilterer   // Log filterer for contract events
}

// SameChainAnchorBlocksCaller is an auto generated read-only Go binding around an Ethereum contract.
type SameChainAnchorBlocksCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SameChainAnchorBlocksTransactor is an auto generated write-only Go binding around an Ethereum contract.
type SameChainAnchorBlocksTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SameChainAnchorBlocksFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SameChainAnchorBlocksFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SameChainAnchorBlocksSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SameChainAnchorBlocksSession struct {
	Contract     *SameChainAnchorBlocks // Generic contract binding to set the session for
	CallOpts     bind.CallOpts          // Call options to use throughout this session
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// SameChainAnchorBlocksCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SameChainAnchorBlocksCallerSession struct {
	Contract *SameChainAnchorBlocksCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts                // Call options to use throughout this session
}

// SameChainAnchorBlocksTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SameChainAnchorBlocksTransactorSession struct {
	Contract     *SameChainAnchorBlocksTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts                // Transaction auth options to use throughout this session
}

// SameChainAnchorBlocksRaw is an auto generated low-level Go binding around an Ethereum contract.
type SameChainAnchorBlocksRaw struct {
	Contract *SameChainAnchorBlocks // Generic contract binding to access the raw methods on
}

// SameChainAnchorBlocksCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SameChainAnchorBlocksCallerRaw struct {
	Contract *SameChainAnchorBlocksCaller // Generic read-only contract binding to access the raw methods on
}

// SameChainAnchorBlocksTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SameChainAnchorBlocksTransactorRaw struct {
	Contract *SameChainAnchorBlocksTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSameChainAnchorBlocks creates a new instance of SameChainAnchorBlocks, bound to a specific deployed contract.
func NewSameChainAnchorBlocks(address common.Address, backend bind.ContractBackend) (*SameChainAnchorBlocks, error) {
	contract, err := bindSameChainAnchorBlocks(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SameChainAnchorBlocks{SameChainAnchorBlocksCaller: SameChainAnchorBlocksCaller{contract: contract}, SameChainAnchorBlocksTransactor: SameChainAnchorBlocksTransactor{contract: contract}, SameChainAnchorBlocksFilterer: SameChainAnchorBlocksFilterer{contract: contract}}, nil
}

// NewSameChainAnchorBlocksCaller creates a new read-only instance of SameChainAnchorBlocks, bound to a specific deployed contract.
func NewSameChainAnchorBlocksCaller(address common.Address, caller bind.ContractCaller) (*SameChainAnchorBlocksCaller, error) {
	contract, err := bindSameChainAnchorBlocks(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SameChainAnchorBlocksCaller{contract: contract}, nil
}

// NewSameChainAnchorBlocksTransactor creates a new write-only instance of SameChainAnchorBlocks, bound to a specific deployed contract.
func NewSameChainAnchorBlocksTransactor(address common.Address, transactor bind.ContractTransactor) (*SameChainAnchorBlocksTransactor, error) {
	contract, err := bindSameChainAnchorBlocks(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SameChainAnchorBlocksTransactor{contract: contract}, nil
}

// NewSameChainAnchorBlocksFilterer creates a new log filterer instance of SameChainAnchorBlocks, bound to a specific deployed contract.
func NewSameChainAnchorBlocksFilterer(address common.Address, filterer bind.ContractFilterer) (*SameChainAnchorBlocksFilterer, error) {
	contract, err := bindSameChainAnchorBlocks(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SameChainAnchorBlocksFilterer{contract: contract}, nil
}

// bindSameChainAnchorBlocks binds a generic wrapper to an already deployed contract.
func bindSameChainAnchorBlocks(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := SameChainAnchorBlocksMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SameChainAnchorBlocks *SameChainAnchorBlocksRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SameChainAnchorBlocks.Contract.SameChainAnchorBlocksCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SameChainAnchorBlocks *SameChainAnchorBlocksRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SameChainAnchorBlocks.Contract.SameChainAnchorBlocksTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SameChainAnchorBlocks *SameChainAnchorBlocksRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SameChainAnchorBlocks.Contract.SameChainAnchorBlocksTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SameChainAnchorBlocks *SameChainAnchorBlocksCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SameChainAnchorBlocks.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SameChainAnchorBlocks *SameChainAnchorBlocksTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SameChainAnchorBlocks.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SameChainAnchorBlocks *SameChainAnchorBlocksTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SameChainAnchorBlocks.Contract.contract.Transact(opts, method, params...)
}

// Blocks is a free data retrieval call binding the contract method 0xf25b3f99.
//
// Solidity: function blocks(uint256 blockNum) view returns(bytes32)
func (_SameChainAnchorBlocks *SameChainAnchorBlocksCaller) Blocks(opts *bind.CallOpts, blockNum *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _SameChainAnchorBlocks.contract.Call(opts, &out, "blocks", blockNum)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// Blocks is a free data retrieval call binding the contract method 0xf25b3f99.
//
// Solidity: function blocks(uint256 blockNum) view returns(bytes32)
func (_SameChainAnchorBlocks *SameChainAnchorBlocksSession) Blocks(blockNum *big.Int) ([32]byte, error) {
	return _SameChainAnchorBlocks.Contract.Blocks(&_SameChainAnchorBlocks.CallOpts, blockNum)
}

// Blocks is a free data retrieval call binding the contract method 0xf25b3f99.
//
// Solidity: function blocks(uint256 blockNum) view returns(bytes32)
func (_SameChainAnchorBlocks *SameChainAnchorBlocksCallerSession) Blocks(blockNum *big.Int) ([32]byte, error) {
	return _SameChainAnchorBlocks.Contract.Blocks(&_SameChainAnchorBlocks.CallOpts, blockNum)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_SameChainAnchorBlocks *SameChainAnchorBlocksCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _SameChainAnchorBlocks.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_SameChainAnchorBlocks *SameChainAnchorBlocksSession) Owner() (common.Address, error) {
	return _SameChainAnchorBlocks.Contract.Owner(&_SameChainAnchorBlocks.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_SameChainAnchorBlocks *SameChainAnchorBlocksCallerSession) Owner() (common.Address, error) {
	return _SameChainAnchorBlocks.Contract.Owner(&_SameChainAnchorBlocks.CallOpts)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_SameChainAnchorBlocks *SameChainAnchorBlocksTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _SameChainAnchorBlocks.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_SameChainAnchorBlocks *SameChainAnchorBlocksSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _SameChainAnchorBlocks.Contract.TransferOwnership(&_SameChainAnchorBlocks.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_SameChainAnchorBlocks *SameChainAnchorBlocksTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _SameChainAnchorBlocks.Contract.TransferOwnership(&_SameChainAnchorBlocks.TransactOpts, newOwner)
}

// SameChainAnchorBlocksOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the SameChainAnchorBlocks contract.
type SameChainAnchorBlocksOwnershipTransferredIterator struct {
	Event *SameChainAnchorBlocksOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SameChainAnchorBlocksOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SameChainAnchorBlocksOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SameChainAnchorBlocksOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SameChainAnchorBlocksOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SameChainAnchorBlocksOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SameChainAnchorBlocksOwnershipTransferred represents a OwnershipTransferred event raised by the SameChainAnchorBlocks contract.
type SameChainAnchorBlocksOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_SameChainAnchorBlocks *SameChainAnchorBlocksFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*SameChainAnchorBlocksOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _SameChainAnchorBlocks.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &SameChainAnchorBlocksOwnershipTransferredIterator{contract: _SameChainAnchorBlocks.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_SameChainAnchorBlocks *SameChainAnchorBlocksFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *SameChainAnchorBlocksOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _SameChainAnchorBlocks.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SameChainAnchorBlocksOwnershipTransferred)
				if err := _SameChainAnchorBlocks.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_SameChainAnchorBlocks *SameChainAnchorBlocksFilterer) ParseOwnershipTransferred(log types.Log) (*SameChainAnchorBlocksOwnershipTransferred, error) {
	event := new(SameChainAnchorBlocksOwnershipTransferred)
	if err := _SameChainAnchorBlocks.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SlotValueMetaData contains all meta data concerning the SlotValue contract.
var SlotValueMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"contractISlotValueVerifier\",\"name\":\"_verifier\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"addrHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"slotKeyHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"slotValue\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"blkHash\",\"type\":\"bytes32\"}],\"name\":\"VerifiedSlotValueProof\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"slotValueVerifier\",\"outputs\":[{\"internalType\":\"contractISlotValueVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"blkVerifyInfo\",\"type\":\"bytes\"}],\"name\":\"submitSlotValuePoof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x60803461007357601f6103ad38819003918201601f19168301916001600160401b038311848410176100775780849260209460405283398101031261007357516001600160a01b03811690819003610073575f80546001600160a01b031916919091179055604051610321908161008c8239f35b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe6080604081815260049081361015610015575f80fd5b5f92833560e01c90816363c6ccb214610265575063de833bb214610037575f80fd5b3461026157600319906060368301811361025d57833567ffffffffffffffff8082168092036102195760243581811161021d576100779036908801610299565b604493919335838111610259576100919036908a01610299565b979092896100ee73ffffffffffffffffffffffffffffffffffffffff8d5416936100da8b51998a9788968796630b885e5360e01b88528701528c602487015260648601916102cb565b9083820301604484015260c09b8c976102cb565b03915afa91821561024f578792610166575b507fef78dd50ef8d260919879b24e31d3f411c6014c0b43f575b9539fef1ad185897955081511692602082015192808301516080840151928063ffffffff60a0870151169501519581519788526020880152860152840152608083015260a0820152a180f35b90915084953d8611610247575b601f8701601f191682019683881183891017610234578287918101031261021d57858701908782108483111761022157508452805190828216820361021d5760a091875260208101516020880152848101518588015283810151848801526080810151608088015201519463ffffffff86168603610219577fef78dd50ef8d260919879b24e31d3f411c6014c0b43f575b9539fef1ad1858979560a0820152905f610100565b8680fd5b8780fd5b634e487b7160e01b895260419052602488fd5b634e487b7160e01b895260418252602489fd5b3d9650610173565b84513d89823e3d90fd5b8980fd5b8480fd5b8280fd5b84903461029557816003193601126102955773ffffffffffffffffffffffffffffffffffffffff60209254168152f35b5080fd5b9181601f840112156102c75782359167ffffffffffffffff83116102c757602083818601950101116102c757565b5f80fd5b908060209392818452848401375f828201840152601f01601f191601019056fea2646970667358221220024e66dce9143896bf635b7816c6784747ebc88a49830508de74760d4ce7a43e64736f6c63430008140033",
}

// SlotValueABI is the input ABI used to generate the binding from.
// Deprecated: Use SlotValueMetaData.ABI instead.
var SlotValueABI = SlotValueMetaData.ABI

// SlotValueBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use SlotValueMetaData.Bin instead.
var SlotValueBin = SlotValueMetaData.Bin

// DeploySlotValue deploys a new Ethereum contract, binding an instance of SlotValue to it.
func DeploySlotValue(auth *bind.TransactOpts, backend bind.ContractBackend, _verifier common.Address) (common.Address, *types.Transaction, *SlotValue, error) {
	parsed, err := SlotValueMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(SlotValueBin), backend, _verifier)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SlotValue{SlotValueCaller: SlotValueCaller{contract: contract}, SlotValueTransactor: SlotValueTransactor{contract: contract}, SlotValueFilterer: SlotValueFilterer{contract: contract}}, nil
}

// SlotValue is an auto generated Go binding around an Ethereum contract.
type SlotValue struct {
	SlotValueCaller     // Read-only binding to the contract
	SlotValueTransactor // Write-only binding to the contract
	SlotValueFilterer   // Log filterer for contract events
}

// SlotValueCaller is an auto generated read-only Go binding around an Ethereum contract.
type SlotValueCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SlotValueTransactor is an auto generated write-only Go binding around an Ethereum contract.
type SlotValueTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SlotValueFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SlotValueFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SlotValueSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SlotValueSession struct {
	Contract     *SlotValue        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// SlotValueCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SlotValueCallerSession struct {
	Contract *SlotValueCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// SlotValueTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SlotValueTransactorSession struct {
	Contract     *SlotValueTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// SlotValueRaw is an auto generated low-level Go binding around an Ethereum contract.
type SlotValueRaw struct {
	Contract *SlotValue // Generic contract binding to access the raw methods on
}

// SlotValueCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SlotValueCallerRaw struct {
	Contract *SlotValueCaller // Generic read-only contract binding to access the raw methods on
}

// SlotValueTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SlotValueTransactorRaw struct {
	Contract *SlotValueTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSlotValue creates a new instance of SlotValue, bound to a specific deployed contract.
func NewSlotValue(address common.Address, backend bind.ContractBackend) (*SlotValue, error) {
	contract, err := bindSlotValue(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SlotValue{SlotValueCaller: SlotValueCaller{contract: contract}, SlotValueTransactor: SlotValueTransactor{contract: contract}, SlotValueFilterer: SlotValueFilterer{contract: contract}}, nil
}

// NewSlotValueCaller creates a new read-only instance of SlotValue, bound to a specific deployed contract.
func NewSlotValueCaller(address common.Address, caller bind.ContractCaller) (*SlotValueCaller, error) {
	contract, err := bindSlotValue(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SlotValueCaller{contract: contract}, nil
}

// NewSlotValueTransactor creates a new write-only instance of SlotValue, bound to a specific deployed contract.
func NewSlotValueTransactor(address common.Address, transactor bind.ContractTransactor) (*SlotValueTransactor, error) {
	contract, err := bindSlotValue(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SlotValueTransactor{contract: contract}, nil
}

// NewSlotValueFilterer creates a new log filterer instance of SlotValue, bound to a specific deployed contract.
func NewSlotValueFilterer(address common.Address, filterer bind.ContractFilterer) (*SlotValueFilterer, error) {
	contract, err := bindSlotValue(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SlotValueFilterer{contract: contract}, nil
}

// bindSlotValue binds a generic wrapper to an already deployed contract.
func bindSlotValue(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := SlotValueMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SlotValue *SlotValueRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SlotValue.Contract.SlotValueCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SlotValue *SlotValueRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SlotValue.Contract.SlotValueTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SlotValue *SlotValueRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SlotValue.Contract.SlotValueTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SlotValue *SlotValueCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SlotValue.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SlotValue *SlotValueTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SlotValue.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SlotValue *SlotValueTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SlotValue.Contract.contract.Transact(opts, method, params...)
}

// SlotValueVerifier is a free data retrieval call binding the contract method 0x63c6ccb2.
//
// Solidity: function slotValueVerifier() view returns(address)
func (_SlotValue *SlotValueCaller) SlotValueVerifier(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _SlotValue.contract.Call(opts, &out, "slotValueVerifier")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SlotValueVerifier is a free data retrieval call binding the contract method 0x63c6ccb2.
//
// Solidity: function slotValueVerifier() view returns(address)
func (_SlotValue *SlotValueSession) SlotValueVerifier() (common.Address, error) {
	return _SlotValue.Contract.SlotValueVerifier(&_SlotValue.CallOpts)
}

// SlotValueVerifier is a free data retrieval call binding the contract method 0x63c6ccb2.
//
// Solidity: function slotValueVerifier() view returns(address)
func (_SlotValue *SlotValueCallerSession) SlotValueVerifier() (common.Address, error) {
	return _SlotValue.Contract.SlotValueVerifier(&_SlotValue.CallOpts)
}

// SubmitSlotValuePoof is a paid mutator transaction binding the contract method 0xde833bb2.
//
// Solidity: function submitSlotValuePoof(uint64 chainId, bytes proofData, bytes blkVerifyInfo) returns()
func (_SlotValue *SlotValueTransactor) SubmitSlotValuePoof(opts *bind.TransactOpts, chainId uint64, proofData []byte, blkVerifyInfo []byte) (*types.Transaction, error) {
	return _SlotValue.contract.Transact(opts, "submitSlotValuePoof", chainId, proofData, blkVerifyInfo)
}

// SubmitSlotValuePoof is a paid mutator transaction binding the contract method 0xde833bb2.
//
// Solidity: function submitSlotValuePoof(uint64 chainId, bytes proofData, bytes blkVerifyInfo) returns()
func (_SlotValue *SlotValueSession) SubmitSlotValuePoof(chainId uint64, proofData []byte, blkVerifyInfo []byte) (*types.Transaction, error) {
	return _SlotValue.Contract.SubmitSlotValuePoof(&_SlotValue.TransactOpts, chainId, proofData, blkVerifyInfo)
}

// SubmitSlotValuePoof is a paid mutator transaction binding the contract method 0xde833bb2.
//
// Solidity: function submitSlotValuePoof(uint64 chainId, bytes proofData, bytes blkVerifyInfo) returns()
func (_SlotValue *SlotValueTransactorSession) SubmitSlotValuePoof(chainId uint64, proofData []byte, blkVerifyInfo []byte) (*types.Transaction, error) {
	return _SlotValue.Contract.SubmitSlotValuePoof(&_SlotValue.TransactOpts, chainId, proofData, blkVerifyInfo)
}

// SlotValueVerifiedSlotValueProofIterator is returned from FilterVerifiedSlotValueProof and is used to iterate over the raw logs and unpacked data for VerifiedSlotValueProof events raised by the SlotValue contract.
type SlotValueVerifiedSlotValueProofIterator struct {
	Event *SlotValueVerifiedSlotValueProof // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SlotValueVerifiedSlotValueProofIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SlotValueVerifiedSlotValueProof)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SlotValueVerifiedSlotValueProof)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SlotValueVerifiedSlotValueProofIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SlotValueVerifiedSlotValueProofIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SlotValueVerifiedSlotValueProof represents a VerifiedSlotValueProof event raised by the SlotValue contract.
type SlotValueVerifiedSlotValueProof struct {
	ChainId     uint64
	AddrHash    [32]byte
	SlotKeyHash [32]byte
	SlotValue   [32]byte
	BlkNum      uint32
	BlkHash     [32]byte
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterVerifiedSlotValueProof is a free log retrieval operation binding the contract event 0xef78dd50ef8d260919879b24e31d3f411c6014c0b43f575b9539fef1ad185897.
//
// Solidity: event VerifiedSlotValueProof(uint64 chainId, bytes32 addrHash, bytes32 slotKeyHash, bytes32 slotValue, uint32 blkNum, bytes32 blkHash)
func (_SlotValue *SlotValueFilterer) FilterVerifiedSlotValueProof(opts *bind.FilterOpts) (*SlotValueVerifiedSlotValueProofIterator, error) {

	logs, sub, err := _SlotValue.contract.FilterLogs(opts, "VerifiedSlotValueProof")
	if err != nil {
		return nil, err
	}
	return &SlotValueVerifiedSlotValueProofIterator{contract: _SlotValue.contract, event: "VerifiedSlotValueProof", logs: logs, sub: sub}, nil
}

// WatchVerifiedSlotValueProof is a free log subscription operation binding the contract event 0xef78dd50ef8d260919879b24e31d3f411c6014c0b43f575b9539fef1ad185897.
//
// Solidity: event VerifiedSlotValueProof(uint64 chainId, bytes32 addrHash, bytes32 slotKeyHash, bytes32 slotValue, uint32 blkNum, bytes32 blkHash)
func (_SlotValue *SlotValueFilterer) WatchVerifiedSlotValueProof(opts *bind.WatchOpts, sink chan<- *SlotValueVerifiedSlotValueProof) (event.Subscription, error) {

	logs, sub, err := _SlotValue.contract.WatchLogs(opts, "VerifiedSlotValueProof")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SlotValueVerifiedSlotValueProof)
				if err := _SlotValue.contract.UnpackLog(event, "VerifiedSlotValueProof", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseVerifiedSlotValueProof is a log parse operation binding the contract event 0xef78dd50ef8d260919879b24e31d3f411c6014c0b43f575b9539fef1ad185897.
//
// Solidity: event VerifiedSlotValueProof(uint64 chainId, bytes32 addrHash, bytes32 slotKeyHash, bytes32 slotValue, uint32 blkNum, bytes32 blkHash)
func (_SlotValue *SlotValueFilterer) ParseVerifiedSlotValueProof(log types.Log) (*SlotValueVerifiedSlotValueProof, error) {
	event := new(SlotValueVerifiedSlotValueProof)
	if err := _SlotValue.contract.UnpackLog(event, "VerifiedSlotValueProof", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SlotValueVerifierMetaData contains all meta data concerning the SlotValueVerifier contract.
var SlotValueVerifierMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_blocChunks\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"UpdateBlockChunks\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"UpdateVerifierAddress\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BlockChunks\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_BlockChunks\",\"type\":\"address\"}],\"name\":\"updateBlockChunks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_verifierAddress\",\"type\":\"address\"}],\"name\":\"updateVerifierAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"verifierAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"blkVerifyInfo\",\"type\":\"bytes\"}],\"name\":\"verifySlotValue\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"addrHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"blkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"slotKeyHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"slotValue\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"}],\"internalType\":\"structISlotValueVerifier.SlotInfo\",\"name\":\"slotInfo\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x6080346100a457601f610af638819003918201601f19168301916001600160401b038311848410176100a8578084926020946040528339810103126100a457516001600160a01b0390818116908190036100a4575f5460018060a01b03199033828216175f55604051933391167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a36002541617600255610a3990816100bd8239f35b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe6080806040526004361015610012575f80fd5b5f3560e01c9081630215d013146108be575080630b885e53146102da5780631eeb86da1461025e5780638da5cb5b14610239578063ec4ffc5214610197578063f2fde38b146100af5763f5cec6af14610069575f80fd5b346100ab5760203660031901126100ab5767ffffffffffffffff61008b6108e1565b165f52600160205260206001600160a01b0360405f205416604051908152f35b5f80fd5b346100ab5760203660031901126100ab576100c8610926565b5f54906001600160a01b03808316916100e233841461093c565b1691821561012c5773ffffffffffffffffffffffffffffffffffffffff19839116175f557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3005b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608490fd5b346100ab5760403660031901126100ab576101b06108e1565b602435906001600160a01b03918281168091036100ab5767ffffffffffffffff6040926102027ffd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f955f5416331461093c565b1690815f526001602052825f208173ffffffffffffffffffffffffffffffffffffffff1982541617905582519182526020820152a1005b346100ab575f3660031901126100ab5760206001600160a01b035f5416604051908152f35b346100ab5760203660031901126100ab577f0addee9cb6aa9328bbfbe8282179a6737af344619320736b6918af70b6a94a98602061029a610926565b6001600160a01b03906102b1825f5416331461093c565b168073ffffffffffffffffffffffffffffffffffffffff196002541617600255604051908152a1005b346100ab5760603660031901126100ab576102f36108e1565b60243567ffffffffffffffff81116100ab576103139036906004016108f8565b9160443567ffffffffffffffff81116100ab576103349036906004016108f8565b92906040519461034386610987565b5f86525f60208701525f60408701525f60608701525f60808701525f60a087015267ffffffffffffffff84165f5260016020526001600160a01b0360405f205416156108795767ffffffffffffffff84165f5260016020526001600160a01b0360405f205416602060405180926322bb937360e11b8252826004830152846024830152848760448401375f6044868401015281604481601f19601f89011681010301915afa9081156107dc575f9161085a575b50156100ab576040519360e0850185811067ffffffffffffffff8211176108015760405260e0368637610104860361081557856020116100ab57856024116100ab575f5b60ff6006818316101561050057610458610453836109dd565b6109f2565b906001818416018181116104c15761047361045383926109dd565b1680828416116100ab578981116100ab57918116868101359203602081106104e9575b50600790831610156104d557611fe08260051b1687015260ff8091169081146104c15760010161043a565b634e487b7160e01b5f52601160045260245ffd5b634e487b7160e01b5f52603260045260245ffd5b5f1960209190910360031b1b909116906007610496565b50508684868589610104116100ab5760e481013560c08301526040519560a0870187811067ffffffffffffffff8211176108015760405280610160116100ab5780610180116100ab5761017084013560801c61014085013560801b178752806101a0116100ab57806101c0116100ab576101b084013560801c61018085013560801b176020880152806101e0116100ab5780610200116100ab576101f084013560801c6101c085013560801b17604088015280610220116100ab5780610240116100ab5761023084013560801c61020085013560801b176060880152610260116100ab57906020839261025c60a095013560e01c60808901526040519361060685610987565b67ffffffffffffffff8816855261025c81013560e01c8386015261014061017082013560801c91013560801b17604085015280356060850152013560e01c6080830152828201526001600160a01b036002541690604051928391631513dce960e21b835267ffffffffffffffff815116600484015263ffffffff6020820151166024840152604081015160448401526060810151606484015263ffffffff6080820151166084840152015160a482015f905b600782106107e757505050610184816020935afa9081156107dc575f916107ad575b50156107685760a063ffffffff91606060c09567ffffffffffffffff86168352805160408401526020810151602084015284608082015116848401526040810151828401520151608082015267ffffffffffffffff604051941684526020810151602085015260408101516040850152606081015160608501526080810151608085015201511660a0820152f35b60405162461bcd60e51b815260206004820152600f60248201527f696e76616c696420626c6b4861736800000000000000000000000000000000006044820152606490fd5b6107cf915060203d6020116107d5575b6107c781836109a3565b8101906109c5565b846106da565b503d6107bd565b6040513d5f823e3d90fd5b8293506020809160019394518152019301910184926106b8565b634e487b7160e01b5f52604160045260245ffd5b60405162461bcd60e51b815260206004820152601760248201527f696e636f727265637420626c6b566572696679496e666f0000000000000000006044820152606490fd5b610873915060203d6020116107d5576107c781836109a3565b876103f6565b60405162461bcd60e51b815260206004820152601660248201527f636861696e207665726966696572206e6f7420736574000000000000000000006044820152606490fd5b346100ab575f3660031901126100ab576020906001600160a01b03600254168152f35b6004359067ffffffffffffffff821682036100ab57565b9181601f840112156100ab5782359167ffffffffffffffff83116100ab57602083818601950101116100ab57565b600435906001600160a01b03821682036100ab57565b1561094357565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b60c0810190811067ffffffffffffffff82111761080157604052565b90601f8019910116810190811067ffffffffffffffff82111761080157604052565b908160209103126100ab575180151581036100ab5790565b60051b90611fe060e08316921682036104c157565b60ff166024019060ff82116104c15756fea26469706673582212208cc7485a6ba1c922b7e9e84999d0c63ce99c4499bb7d3ccf1bcbc8d025095e1764736f6c63430008140033",
}

// SlotValueVerifierABI is the input ABI used to generate the binding from.
// Deprecated: Use SlotValueVerifierMetaData.ABI instead.
var SlotValueVerifierABI = SlotValueVerifierMetaData.ABI

// SlotValueVerifierBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use SlotValueVerifierMetaData.Bin instead.
var SlotValueVerifierBin = SlotValueVerifierMetaData.Bin

// DeploySlotValueVerifier deploys a new Ethereum contract, binding an instance of SlotValueVerifier to it.
func DeploySlotValueVerifier(auth *bind.TransactOpts, backend bind.ContractBackend, _blocChunks common.Address) (common.Address, *types.Transaction, *SlotValueVerifier, error) {
	parsed, err := SlotValueVerifierMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(SlotValueVerifierBin), backend, _blocChunks)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SlotValueVerifier{SlotValueVerifierCaller: SlotValueVerifierCaller{contract: contract}, SlotValueVerifierTransactor: SlotValueVerifierTransactor{contract: contract}, SlotValueVerifierFilterer: SlotValueVerifierFilterer{contract: contract}}, nil
}

// SlotValueVerifier is an auto generated Go binding around an Ethereum contract.
type SlotValueVerifier struct {
	SlotValueVerifierCaller     // Read-only binding to the contract
	SlotValueVerifierTransactor // Write-only binding to the contract
	SlotValueVerifierFilterer   // Log filterer for contract events
}

// SlotValueVerifierCaller is an auto generated read-only Go binding around an Ethereum contract.
type SlotValueVerifierCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SlotValueVerifierTransactor is an auto generated write-only Go binding around an Ethereum contract.
type SlotValueVerifierTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SlotValueVerifierFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SlotValueVerifierFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SlotValueVerifierSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SlotValueVerifierSession struct {
	Contract     *SlotValueVerifier // Generic contract binding to set the session for
	CallOpts     bind.CallOpts      // Call options to use throughout this session
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// SlotValueVerifierCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SlotValueVerifierCallerSession struct {
	Contract *SlotValueVerifierCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts            // Call options to use throughout this session
}

// SlotValueVerifierTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SlotValueVerifierTransactorSession struct {
	Contract     *SlotValueVerifierTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts            // Transaction auth options to use throughout this session
}

// SlotValueVerifierRaw is an auto generated low-level Go binding around an Ethereum contract.
type SlotValueVerifierRaw struct {
	Contract *SlotValueVerifier // Generic contract binding to access the raw methods on
}

// SlotValueVerifierCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SlotValueVerifierCallerRaw struct {
	Contract *SlotValueVerifierCaller // Generic read-only contract binding to access the raw methods on
}

// SlotValueVerifierTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SlotValueVerifierTransactorRaw struct {
	Contract *SlotValueVerifierTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSlotValueVerifier creates a new instance of SlotValueVerifier, bound to a specific deployed contract.
func NewSlotValueVerifier(address common.Address, backend bind.ContractBackend) (*SlotValueVerifier, error) {
	contract, err := bindSlotValueVerifier(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SlotValueVerifier{SlotValueVerifierCaller: SlotValueVerifierCaller{contract: contract}, SlotValueVerifierTransactor: SlotValueVerifierTransactor{contract: contract}, SlotValueVerifierFilterer: SlotValueVerifierFilterer{contract: contract}}, nil
}

// NewSlotValueVerifierCaller creates a new read-only instance of SlotValueVerifier, bound to a specific deployed contract.
func NewSlotValueVerifierCaller(address common.Address, caller bind.ContractCaller) (*SlotValueVerifierCaller, error) {
	contract, err := bindSlotValueVerifier(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SlotValueVerifierCaller{contract: contract}, nil
}

// NewSlotValueVerifierTransactor creates a new write-only instance of SlotValueVerifier, bound to a specific deployed contract.
func NewSlotValueVerifierTransactor(address common.Address, transactor bind.ContractTransactor) (*SlotValueVerifierTransactor, error) {
	contract, err := bindSlotValueVerifier(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SlotValueVerifierTransactor{contract: contract}, nil
}

// NewSlotValueVerifierFilterer creates a new log filterer instance of SlotValueVerifier, bound to a specific deployed contract.
func NewSlotValueVerifierFilterer(address common.Address, filterer bind.ContractFilterer) (*SlotValueVerifierFilterer, error) {
	contract, err := bindSlotValueVerifier(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SlotValueVerifierFilterer{contract: contract}, nil
}

// bindSlotValueVerifier binds a generic wrapper to an already deployed contract.
func bindSlotValueVerifier(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := SlotValueVerifierMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SlotValueVerifier *SlotValueVerifierRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SlotValueVerifier.Contract.SlotValueVerifierCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SlotValueVerifier *SlotValueVerifierRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SlotValueVerifier.Contract.SlotValueVerifierTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SlotValueVerifier *SlotValueVerifierRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SlotValueVerifier.Contract.SlotValueVerifierTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SlotValueVerifier *SlotValueVerifierCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SlotValueVerifier.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SlotValueVerifier *SlotValueVerifierTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SlotValueVerifier.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SlotValueVerifier *SlotValueVerifierTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SlotValueVerifier.Contract.contract.Transact(opts, method, params...)
}

// BlockChunks is a free data retrieval call binding the contract method 0x0215d013.
//
// Solidity: function BlockChunks() view returns(address)
func (_SlotValueVerifier *SlotValueVerifierCaller) BlockChunks(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _SlotValueVerifier.contract.Call(opts, &out, "BlockChunks")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// BlockChunks is a free data retrieval call binding the contract method 0x0215d013.
//
// Solidity: function BlockChunks() view returns(address)
func (_SlotValueVerifier *SlotValueVerifierSession) BlockChunks() (common.Address, error) {
	return _SlotValueVerifier.Contract.BlockChunks(&_SlotValueVerifier.CallOpts)
}

// BlockChunks is a free data retrieval call binding the contract method 0x0215d013.
//
// Solidity: function BlockChunks() view returns(address)
func (_SlotValueVerifier *SlotValueVerifierCallerSession) BlockChunks() (common.Address, error) {
	return _SlotValueVerifier.Contract.BlockChunks(&_SlotValueVerifier.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_SlotValueVerifier *SlotValueVerifierCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _SlotValueVerifier.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_SlotValueVerifier *SlotValueVerifierSession) Owner() (common.Address, error) {
	return _SlotValueVerifier.Contract.Owner(&_SlotValueVerifier.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_SlotValueVerifier *SlotValueVerifierCallerSession) Owner() (common.Address, error) {
	return _SlotValueVerifier.Contract.Owner(&_SlotValueVerifier.CallOpts)
}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_SlotValueVerifier *SlotValueVerifierCaller) VerifierAddresses(opts *bind.CallOpts, arg0 uint64) (common.Address, error) {
	var out []interface{}
	err := _SlotValueVerifier.contract.Call(opts, &out, "verifierAddresses", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_SlotValueVerifier *SlotValueVerifierSession) VerifierAddresses(arg0 uint64) (common.Address, error) {
	return _SlotValueVerifier.Contract.VerifierAddresses(&_SlotValueVerifier.CallOpts, arg0)
}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_SlotValueVerifier *SlotValueVerifierCallerSession) VerifierAddresses(arg0 uint64) (common.Address, error) {
	return _SlotValueVerifier.Contract.VerifierAddresses(&_SlotValueVerifier.CallOpts, arg0)
}

// VerifySlotValue is a free data retrieval call binding the contract method 0x0b885e53.
//
// Solidity: function verifySlotValue(uint64 chainId, bytes proofData, bytes blkVerifyInfo) view returns((uint64,bytes32,bytes32,bytes32,bytes32,uint32) slotInfo)
func (_SlotValueVerifier *SlotValueVerifierCaller) VerifySlotValue(opts *bind.CallOpts, chainId uint64, proofData []byte, blkVerifyInfo []byte) (ISlotValueVerifierSlotInfo, error) {
	var out []interface{}
	err := _SlotValueVerifier.contract.Call(opts, &out, "verifySlotValue", chainId, proofData, blkVerifyInfo)

	if err != nil {
		return *new(ISlotValueVerifierSlotInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(ISlotValueVerifierSlotInfo)).(*ISlotValueVerifierSlotInfo)

	return out0, err

}

// VerifySlotValue is a free data retrieval call binding the contract method 0x0b885e53.
//
// Solidity: function verifySlotValue(uint64 chainId, bytes proofData, bytes blkVerifyInfo) view returns((uint64,bytes32,bytes32,bytes32,bytes32,uint32) slotInfo)
func (_SlotValueVerifier *SlotValueVerifierSession) VerifySlotValue(chainId uint64, proofData []byte, blkVerifyInfo []byte) (ISlotValueVerifierSlotInfo, error) {
	return _SlotValueVerifier.Contract.VerifySlotValue(&_SlotValueVerifier.CallOpts, chainId, proofData, blkVerifyInfo)
}

// VerifySlotValue is a free data retrieval call binding the contract method 0x0b885e53.
//
// Solidity: function verifySlotValue(uint64 chainId, bytes proofData, bytes blkVerifyInfo) view returns((uint64,bytes32,bytes32,bytes32,bytes32,uint32) slotInfo)
func (_SlotValueVerifier *SlotValueVerifierCallerSession) VerifySlotValue(chainId uint64, proofData []byte, blkVerifyInfo []byte) (ISlotValueVerifierSlotInfo, error) {
	return _SlotValueVerifier.Contract.VerifySlotValue(&_SlotValueVerifier.CallOpts, chainId, proofData, blkVerifyInfo)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_SlotValueVerifier *SlotValueVerifierTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _SlotValueVerifier.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_SlotValueVerifier *SlotValueVerifierSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _SlotValueVerifier.Contract.TransferOwnership(&_SlotValueVerifier.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_SlotValueVerifier *SlotValueVerifierTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _SlotValueVerifier.Contract.TransferOwnership(&_SlotValueVerifier.TransactOpts, newOwner)
}

// UpdateBlockChunks is a paid mutator transaction binding the contract method 0x1eeb86da.
//
// Solidity: function updateBlockChunks(address _BlockChunks) returns()
func (_SlotValueVerifier *SlotValueVerifierTransactor) UpdateBlockChunks(opts *bind.TransactOpts, _BlockChunks common.Address) (*types.Transaction, error) {
	return _SlotValueVerifier.contract.Transact(opts, "updateBlockChunks", _BlockChunks)
}

// UpdateBlockChunks is a paid mutator transaction binding the contract method 0x1eeb86da.
//
// Solidity: function updateBlockChunks(address _BlockChunks) returns()
func (_SlotValueVerifier *SlotValueVerifierSession) UpdateBlockChunks(_BlockChunks common.Address) (*types.Transaction, error) {
	return _SlotValueVerifier.Contract.UpdateBlockChunks(&_SlotValueVerifier.TransactOpts, _BlockChunks)
}

// UpdateBlockChunks is a paid mutator transaction binding the contract method 0x1eeb86da.
//
// Solidity: function updateBlockChunks(address _BlockChunks) returns()
func (_SlotValueVerifier *SlotValueVerifierTransactorSession) UpdateBlockChunks(_BlockChunks common.Address) (*types.Transaction, error) {
	return _SlotValueVerifier.Contract.UpdateBlockChunks(&_SlotValueVerifier.TransactOpts, _BlockChunks)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_SlotValueVerifier *SlotValueVerifierTransactor) UpdateVerifierAddress(opts *bind.TransactOpts, _chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _SlotValueVerifier.contract.Transact(opts, "updateVerifierAddress", _chainId, _verifierAddress)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_SlotValueVerifier *SlotValueVerifierSession) UpdateVerifierAddress(_chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _SlotValueVerifier.Contract.UpdateVerifierAddress(&_SlotValueVerifier.TransactOpts, _chainId, _verifierAddress)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_SlotValueVerifier *SlotValueVerifierTransactorSession) UpdateVerifierAddress(_chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _SlotValueVerifier.Contract.UpdateVerifierAddress(&_SlotValueVerifier.TransactOpts, _chainId, _verifierAddress)
}

// SlotValueVerifierOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the SlotValueVerifier contract.
type SlotValueVerifierOwnershipTransferredIterator struct {
	Event *SlotValueVerifierOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SlotValueVerifierOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SlotValueVerifierOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SlotValueVerifierOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SlotValueVerifierOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SlotValueVerifierOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SlotValueVerifierOwnershipTransferred represents a OwnershipTransferred event raised by the SlotValueVerifier contract.
type SlotValueVerifierOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_SlotValueVerifier *SlotValueVerifierFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*SlotValueVerifierOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _SlotValueVerifier.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &SlotValueVerifierOwnershipTransferredIterator{contract: _SlotValueVerifier.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_SlotValueVerifier *SlotValueVerifierFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *SlotValueVerifierOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _SlotValueVerifier.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SlotValueVerifierOwnershipTransferred)
				if err := _SlotValueVerifier.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_SlotValueVerifier *SlotValueVerifierFilterer) ParseOwnershipTransferred(log types.Log) (*SlotValueVerifierOwnershipTransferred, error) {
	event := new(SlotValueVerifierOwnershipTransferred)
	if err := _SlotValueVerifier.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SlotValueVerifierUpdateBlockChunksIterator is returned from FilterUpdateBlockChunks and is used to iterate over the raw logs and unpacked data for UpdateBlockChunks events raised by the SlotValueVerifier contract.
type SlotValueVerifierUpdateBlockChunksIterator struct {
	Event *SlotValueVerifierUpdateBlockChunks // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SlotValueVerifierUpdateBlockChunksIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SlotValueVerifierUpdateBlockChunks)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SlotValueVerifierUpdateBlockChunks)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SlotValueVerifierUpdateBlockChunksIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SlotValueVerifierUpdateBlockChunksIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SlotValueVerifierUpdateBlockChunks represents a UpdateBlockChunks event raised by the SlotValueVerifier contract.
type SlotValueVerifierUpdateBlockChunks struct {
	NewAddress common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterUpdateBlockChunks is a free log retrieval operation binding the contract event 0x0addee9cb6aa9328bbfbe8282179a6737af344619320736b6918af70b6a94a98.
//
// Solidity: event UpdateBlockChunks(address newAddress)
func (_SlotValueVerifier *SlotValueVerifierFilterer) FilterUpdateBlockChunks(opts *bind.FilterOpts) (*SlotValueVerifierUpdateBlockChunksIterator, error) {

	logs, sub, err := _SlotValueVerifier.contract.FilterLogs(opts, "UpdateBlockChunks")
	if err != nil {
		return nil, err
	}
	return &SlotValueVerifierUpdateBlockChunksIterator{contract: _SlotValueVerifier.contract, event: "UpdateBlockChunks", logs: logs, sub: sub}, nil
}

// WatchUpdateBlockChunks is a free log subscription operation binding the contract event 0x0addee9cb6aa9328bbfbe8282179a6737af344619320736b6918af70b6a94a98.
//
// Solidity: event UpdateBlockChunks(address newAddress)
func (_SlotValueVerifier *SlotValueVerifierFilterer) WatchUpdateBlockChunks(opts *bind.WatchOpts, sink chan<- *SlotValueVerifierUpdateBlockChunks) (event.Subscription, error) {

	logs, sub, err := _SlotValueVerifier.contract.WatchLogs(opts, "UpdateBlockChunks")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SlotValueVerifierUpdateBlockChunks)
				if err := _SlotValueVerifier.contract.UnpackLog(event, "UpdateBlockChunks", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdateBlockChunks is a log parse operation binding the contract event 0x0addee9cb6aa9328bbfbe8282179a6737af344619320736b6918af70b6a94a98.
//
// Solidity: event UpdateBlockChunks(address newAddress)
func (_SlotValueVerifier *SlotValueVerifierFilterer) ParseUpdateBlockChunks(log types.Log) (*SlotValueVerifierUpdateBlockChunks, error) {
	event := new(SlotValueVerifierUpdateBlockChunks)
	if err := _SlotValueVerifier.contract.UnpackLog(event, "UpdateBlockChunks", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SlotValueVerifierUpdateVerifierAddressIterator is returned from FilterUpdateVerifierAddress and is used to iterate over the raw logs and unpacked data for UpdateVerifierAddress events raised by the SlotValueVerifier contract.
type SlotValueVerifierUpdateVerifierAddressIterator struct {
	Event *SlotValueVerifierUpdateVerifierAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SlotValueVerifierUpdateVerifierAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SlotValueVerifierUpdateVerifierAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SlotValueVerifierUpdateVerifierAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SlotValueVerifierUpdateVerifierAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SlotValueVerifierUpdateVerifierAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SlotValueVerifierUpdateVerifierAddress represents a UpdateVerifierAddress event raised by the SlotValueVerifier contract.
type SlotValueVerifierUpdateVerifierAddress struct {
	ChainId    uint64
	NewAddress common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterUpdateVerifierAddress is a free log retrieval operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_SlotValueVerifier *SlotValueVerifierFilterer) FilterUpdateVerifierAddress(opts *bind.FilterOpts) (*SlotValueVerifierUpdateVerifierAddressIterator, error) {

	logs, sub, err := _SlotValueVerifier.contract.FilterLogs(opts, "UpdateVerifierAddress")
	if err != nil {
		return nil, err
	}
	return &SlotValueVerifierUpdateVerifierAddressIterator{contract: _SlotValueVerifier.contract, event: "UpdateVerifierAddress", logs: logs, sub: sub}, nil
}

// WatchUpdateVerifierAddress is a free log subscription operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_SlotValueVerifier *SlotValueVerifierFilterer) WatchUpdateVerifierAddress(opts *bind.WatchOpts, sink chan<- *SlotValueVerifierUpdateVerifierAddress) (event.Subscription, error) {

	logs, sub, err := _SlotValueVerifier.contract.WatchLogs(opts, "UpdateVerifierAddress")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SlotValueVerifierUpdateVerifierAddress)
				if err := _SlotValueVerifier.contract.UnpackLog(event, "UpdateVerifierAddress", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdateVerifierAddress is a log parse operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_SlotValueVerifier *SlotValueVerifierFilterer) ParseUpdateVerifierAddress(log types.Log) (*SlotValueVerifierUpdateVerifierAddress, error) {
	event := new(SlotValueVerifierUpdateVerifierAddress)
	if err := _SlotValueVerifier.contract.UnpackLog(event, "UpdateVerifierAddress", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SqrtPriceMathMetaData contains all meta data concerning the SqrtPriceMath contract.
var SqrtPriceMathMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212205959e7cdbf4caea353261654724f6336174cb8bdfcfb6d34bd658287549b098d64736f6c63430008140033",
}

// SqrtPriceMathABI is the input ABI used to generate the binding from.
// Deprecated: Use SqrtPriceMathMetaData.ABI instead.
var SqrtPriceMathABI = SqrtPriceMathMetaData.ABI

// SqrtPriceMathBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use SqrtPriceMathMetaData.Bin instead.
var SqrtPriceMathBin = SqrtPriceMathMetaData.Bin

// DeploySqrtPriceMath deploys a new Ethereum contract, binding an instance of SqrtPriceMath to it.
func DeploySqrtPriceMath(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *SqrtPriceMath, error) {
	parsed, err := SqrtPriceMathMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(SqrtPriceMathBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SqrtPriceMath{SqrtPriceMathCaller: SqrtPriceMathCaller{contract: contract}, SqrtPriceMathTransactor: SqrtPriceMathTransactor{contract: contract}, SqrtPriceMathFilterer: SqrtPriceMathFilterer{contract: contract}}, nil
}

// SqrtPriceMath is an auto generated Go binding around an Ethereum contract.
type SqrtPriceMath struct {
	SqrtPriceMathCaller     // Read-only binding to the contract
	SqrtPriceMathTransactor // Write-only binding to the contract
	SqrtPriceMathFilterer   // Log filterer for contract events
}

// SqrtPriceMathCaller is an auto generated read-only Go binding around an Ethereum contract.
type SqrtPriceMathCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SqrtPriceMathTransactor is an auto generated write-only Go binding around an Ethereum contract.
type SqrtPriceMathTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SqrtPriceMathFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SqrtPriceMathFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SqrtPriceMathSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SqrtPriceMathSession struct {
	Contract     *SqrtPriceMath    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// SqrtPriceMathCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SqrtPriceMathCallerSession struct {
	Contract *SqrtPriceMathCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// SqrtPriceMathTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SqrtPriceMathTransactorSession struct {
	Contract     *SqrtPriceMathTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// SqrtPriceMathRaw is an auto generated low-level Go binding around an Ethereum contract.
type SqrtPriceMathRaw struct {
	Contract *SqrtPriceMath // Generic contract binding to access the raw methods on
}

// SqrtPriceMathCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SqrtPriceMathCallerRaw struct {
	Contract *SqrtPriceMathCaller // Generic read-only contract binding to access the raw methods on
}

// SqrtPriceMathTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SqrtPriceMathTransactorRaw struct {
	Contract *SqrtPriceMathTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSqrtPriceMath creates a new instance of SqrtPriceMath, bound to a specific deployed contract.
func NewSqrtPriceMath(address common.Address, backend bind.ContractBackend) (*SqrtPriceMath, error) {
	contract, err := bindSqrtPriceMath(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SqrtPriceMath{SqrtPriceMathCaller: SqrtPriceMathCaller{contract: contract}, SqrtPriceMathTransactor: SqrtPriceMathTransactor{contract: contract}, SqrtPriceMathFilterer: SqrtPriceMathFilterer{contract: contract}}, nil
}

// NewSqrtPriceMathCaller creates a new read-only instance of SqrtPriceMath, bound to a specific deployed contract.
func NewSqrtPriceMathCaller(address common.Address, caller bind.ContractCaller) (*SqrtPriceMathCaller, error) {
	contract, err := bindSqrtPriceMath(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SqrtPriceMathCaller{contract: contract}, nil
}

// NewSqrtPriceMathTransactor creates a new write-only instance of SqrtPriceMath, bound to a specific deployed contract.
func NewSqrtPriceMathTransactor(address common.Address, transactor bind.ContractTransactor) (*SqrtPriceMathTransactor, error) {
	contract, err := bindSqrtPriceMath(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SqrtPriceMathTransactor{contract: contract}, nil
}

// NewSqrtPriceMathFilterer creates a new log filterer instance of SqrtPriceMath, bound to a specific deployed contract.
func NewSqrtPriceMathFilterer(address common.Address, filterer bind.ContractFilterer) (*SqrtPriceMathFilterer, error) {
	contract, err := bindSqrtPriceMath(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SqrtPriceMathFilterer{contract: contract}, nil
}

// bindSqrtPriceMath binds a generic wrapper to an already deployed contract.
func bindSqrtPriceMath(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := SqrtPriceMathMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SqrtPriceMath *SqrtPriceMathRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SqrtPriceMath.Contract.SqrtPriceMathCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SqrtPriceMath *SqrtPriceMathRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SqrtPriceMath.Contract.SqrtPriceMathTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SqrtPriceMath *SqrtPriceMathRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SqrtPriceMath.Contract.SqrtPriceMathTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SqrtPriceMath *SqrtPriceMathCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SqrtPriceMath.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SqrtPriceMath *SqrtPriceMathTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SqrtPriceMath.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SqrtPriceMath *SqrtPriceMathTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SqrtPriceMath.Contract.contract.Transact(opts, method, params...)
}

// StringsMetaData contains all meta data concerning the Strings contract.
var StringsMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea264697066735822122019fc3cc1e39006ddd1cceed6f4ddeca31842e419d9501858154147cc7095c4b764736f6c63430008140033",
}

// StringsABI is the input ABI used to generate the binding from.
// Deprecated: Use StringsMetaData.ABI instead.
var StringsABI = StringsMetaData.ABI

// StringsBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use StringsMetaData.Bin instead.
var StringsBin = StringsMetaData.Bin

// DeployStrings deploys a new Ethereum contract, binding an instance of Strings to it.
func DeployStrings(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Strings, error) {
	parsed, err := StringsMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(StringsBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Strings{StringsCaller: StringsCaller{contract: contract}, StringsTransactor: StringsTransactor{contract: contract}, StringsFilterer: StringsFilterer{contract: contract}}, nil
}

// Strings is an auto generated Go binding around an Ethereum contract.
type Strings struct {
	StringsCaller     // Read-only binding to the contract
	StringsTransactor // Write-only binding to the contract
	StringsFilterer   // Log filterer for contract events
}

// StringsCaller is an auto generated read-only Go binding around an Ethereum contract.
type StringsCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StringsTransactor is an auto generated write-only Go binding around an Ethereum contract.
type StringsTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StringsFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type StringsFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StringsSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type StringsSession struct {
	Contract     *Strings          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// StringsCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type StringsCallerSession struct {
	Contract *StringsCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// StringsTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type StringsTransactorSession struct {
	Contract     *StringsTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// StringsRaw is an auto generated low-level Go binding around an Ethereum contract.
type StringsRaw struct {
	Contract *Strings // Generic contract binding to access the raw methods on
}

// StringsCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type StringsCallerRaw struct {
	Contract *StringsCaller // Generic read-only contract binding to access the raw methods on
}

// StringsTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type StringsTransactorRaw struct {
	Contract *StringsTransactor // Generic write-only contract binding to access the raw methods on
}

// NewStrings creates a new instance of Strings, bound to a specific deployed contract.
func NewStrings(address common.Address, backend bind.ContractBackend) (*Strings, error) {
	contract, err := bindStrings(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Strings{StringsCaller: StringsCaller{contract: contract}, StringsTransactor: StringsTransactor{contract: contract}, StringsFilterer: StringsFilterer{contract: contract}}, nil
}

// NewStringsCaller creates a new read-only instance of Strings, bound to a specific deployed contract.
func NewStringsCaller(address common.Address, caller bind.ContractCaller) (*StringsCaller, error) {
	contract, err := bindStrings(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &StringsCaller{contract: contract}, nil
}

// NewStringsTransactor creates a new write-only instance of Strings, bound to a specific deployed contract.
func NewStringsTransactor(address common.Address, transactor bind.ContractTransactor) (*StringsTransactor, error) {
	contract, err := bindStrings(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &StringsTransactor{contract: contract}, nil
}

// NewStringsFilterer creates a new log filterer instance of Strings, bound to a specific deployed contract.
func NewStringsFilterer(address common.Address, filterer bind.ContractFilterer) (*StringsFilterer, error) {
	contract, err := bindStrings(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &StringsFilterer{contract: contract}, nil
}

// bindStrings binds a generic wrapper to an already deployed contract.
func bindStrings(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := StringsMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Strings *StringsRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Strings.Contract.StringsCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Strings *StringsRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Strings.Contract.StringsTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Strings *StringsRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Strings.Contract.StringsTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Strings *StringsCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Strings.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Strings *StringsTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Strings.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Strings *StringsTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Strings.Contract.contract.Transact(opts, method, params...)
}

// SwapMathMetaData contains all meta data concerning the SwapMath contract.
var SwapMathMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea2646970667358221220db6fc69538043d203f78224bf51355e754e11b04715eeeaabe29c93b3c8df61064736f6c63430008140033",
}

// SwapMathABI is the input ABI used to generate the binding from.
// Deprecated: Use SwapMathMetaData.ABI instead.
var SwapMathABI = SwapMathMetaData.ABI

// SwapMathBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use SwapMathMetaData.Bin instead.
var SwapMathBin = SwapMathMetaData.Bin

// DeploySwapMath deploys a new Ethereum contract, binding an instance of SwapMath to it.
func DeploySwapMath(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *SwapMath, error) {
	parsed, err := SwapMathMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(SwapMathBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SwapMath{SwapMathCaller: SwapMathCaller{contract: contract}, SwapMathTransactor: SwapMathTransactor{contract: contract}, SwapMathFilterer: SwapMathFilterer{contract: contract}}, nil
}

// SwapMath is an auto generated Go binding around an Ethereum contract.
type SwapMath struct {
	SwapMathCaller     // Read-only binding to the contract
	SwapMathTransactor // Write-only binding to the contract
	SwapMathFilterer   // Log filterer for contract events
}

// SwapMathCaller is an auto generated read-only Go binding around an Ethereum contract.
type SwapMathCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SwapMathTransactor is an auto generated write-only Go binding around an Ethereum contract.
type SwapMathTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SwapMathFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SwapMathFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SwapMathSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SwapMathSession struct {
	Contract     *SwapMath         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// SwapMathCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SwapMathCallerSession struct {
	Contract *SwapMathCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// SwapMathTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SwapMathTransactorSession struct {
	Contract     *SwapMathTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// SwapMathRaw is an auto generated low-level Go binding around an Ethereum contract.
type SwapMathRaw struct {
	Contract *SwapMath // Generic contract binding to access the raw methods on
}

// SwapMathCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SwapMathCallerRaw struct {
	Contract *SwapMathCaller // Generic read-only contract binding to access the raw methods on
}

// SwapMathTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SwapMathTransactorRaw struct {
	Contract *SwapMathTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSwapMath creates a new instance of SwapMath, bound to a specific deployed contract.
func NewSwapMath(address common.Address, backend bind.ContractBackend) (*SwapMath, error) {
	contract, err := bindSwapMath(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SwapMath{SwapMathCaller: SwapMathCaller{contract: contract}, SwapMathTransactor: SwapMathTransactor{contract: contract}, SwapMathFilterer: SwapMathFilterer{contract: contract}}, nil
}

// NewSwapMathCaller creates a new read-only instance of SwapMath, bound to a specific deployed contract.
func NewSwapMathCaller(address common.Address, caller bind.ContractCaller) (*SwapMathCaller, error) {
	contract, err := bindSwapMath(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SwapMathCaller{contract: contract}, nil
}

// NewSwapMathTransactor creates a new write-only instance of SwapMath, bound to a specific deployed contract.
func NewSwapMathTransactor(address common.Address, transactor bind.ContractTransactor) (*SwapMathTransactor, error) {
	contract, err := bindSwapMath(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SwapMathTransactor{contract: contract}, nil
}

// NewSwapMathFilterer creates a new log filterer instance of SwapMath, bound to a specific deployed contract.
func NewSwapMathFilterer(address common.Address, filterer bind.ContractFilterer) (*SwapMathFilterer, error) {
	contract, err := bindSwapMath(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SwapMathFilterer{contract: contract}, nil
}

// bindSwapMath binds a generic wrapper to an already deployed contract.
func bindSwapMath(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := SwapMathMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SwapMath *SwapMathRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SwapMath.Contract.SwapMathCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SwapMath *SwapMathRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SwapMath.Contract.SwapMathTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SwapMath *SwapMathRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SwapMath.Contract.SwapMathTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SwapMath *SwapMathCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SwapMath.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SwapMath *SwapMathTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SwapMath.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SwapMath *SwapMathTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SwapMath.Contract.contract.Transact(opts, method, params...)
}

// TestSMTMetaData contains all meta data concerning the TestSMT contract.
var TestSMTMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint64[]\",\"name\":\"_chainIds\",\"type\":\"uint64[]\"},{\"internalType\":\"address[]\",\"name\":\"_anchorProviders\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_verifiers\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_initRoots\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"anchorProvider\",\"type\":\"address\"}],\"name\":\"AnchorProviderUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ProverRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"smtRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"endBlockNum\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"SmtRootUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"verifier\",\"type\":\"address\"}],\"name\":\"VerifierUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addPausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"addProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"newRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"endBlockNum\",\"type\":\"uint64\"}],\"name\":\"addRootForTesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"anchorProviders\",\"outputs\":[{\"internalType\":\"contractIAnchorBlocks\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"getLatestRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isActiveProver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"smtRoot\",\"type\":\"bytes32\"}],\"name\":\"isSmtRootValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"latestRoots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numPausers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numProvers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pauserList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proverStates\",\"outputs\":[{\"internalType\":\"enumBrevisAccess.ProverState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"provers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removePausers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"removeProvers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"anchorProvider\",\"type\":\"address\"}],\"name\":\"setAnchorProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"verifier\",\"type\":\"address\"}],\"name\":\"setVerifier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"smtRoots\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"newSmtRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"endBlockNum\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"endBlockHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"nextChunkMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[8]\",\"name\":\"proof\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[2]\",\"name\":\"commit\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"knowledgeProof\",\"type\":\"uint256[2]\"}],\"internalType\":\"structISMT.SmtUpdate\",\"name\":\"u\",\"type\":\"tuple\"}],\"name\":\"updateRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"verifiers\",\"outputs\":[{\"internalType\":\"contractIVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x604060808152346200039b5762001e8890813803806200001f81620003b9565b93843982016080838203126200039b5782516001600160401b0391908281116200039b5784019381601f860112156200039b578451916200006a6200006484620003f3565b620003b9565b908196848352602080930183600596871b830101918383116200039b578401905b8282106200039f57505050818301518581116200039b5781620000b09185016200040b565b96868401518681116200039b5782620000cb9186016200040b565b936060810151908782116200039b57019180601f840112156200039b578251620000f96200006482620003f3565b938580868481520192891b8201019283116200039b5785809101915b8383106200038a5750505f80548a519891976001600160a01b0394509250338482167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08a80a36001600160a81b0319163360ff60a01b198116919091178855875260018087528a88205490989060ff166200034857506002549a680100000000000000008c10156200033457888c01806002558c101562000320578a99899c957f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8898c9860028d52818d20019d60018060a01b03199e8f3390825416179055338d52898252808d2060ff199a8b82541617905551338152a16200021c815184511462000479565b6200022b815186511462000479565b6200023a815189511462000479565b899d5b62000252575b8c516119a99081620004df8239f35b8d815111156200031a578d808e8e8c828f8c8c878d838e8e620002778f8690620004b5565b51169c6200028591620004b5565b5116908b865287528585209088825416179055620002a391620004b5565b51169287825260069052209182541617905560078c52818d8c83822092620002cb91620004b5565b5190528c528c208d8a825416179055620002e6908a620004b5565b51908b5260088a528d8b20555f198e1462000306579c8a019c8a6200023d565b634e487b7160e01b8a52601160045260248afd5b62000243565b634e487b7160e01b88526032600452602488fd5b634e487b7160e01b88526041600452602488fd5b62461bcd60e51b815260048101879052601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152606490fd5b825181529181019186910162000115565b5f80fd5b815188811681036200039b5781529084019084016200008b565b6040519190601f01601f191682016001600160401b03811183821017620003df57604052565b634e487b7160e01b5f52604160045260245ffd5b6001600160401b038111620003df5760051b60200190565b9080601f830112156200039b578151906200042a6200006483620003f3565b9182938184526020808095019260051b8201019283116200039b578301905b82821062000458575050505090565b81516001600160a01b03811681036200039b57815290830190830162000449565b156200048157565b60405162461bcd60e51b815260206004820152600c60248201526b0d8cadc40dad2e6dac2e8c6d60a31b6044820152606490fd5b8051821015620004ca5760209160051b010190565b634e487b7160e01b5f52603260045260245ffdfe6080806040526004361015610012575f80fd5b5f3560e01c9081631019b6161461121c57508063158535ff146111eb57806338702532146111a15780633f4ba83a146110a157806346fbf68e14610d6a578063479aa6da14610df65780634f4fef181461108457806358a16b44146110675780635c975abb146110435780635ca32bd814610f86578063677625f214610e2f5780636ae3e08014610df65780636b2c0f5514610dc05780636ef8d66d14610da757806380f51c1214610d6a5780638195408d14610d2857806382dc1ec414610cf25780638456cb5914610bdb5780638da5cb5b14610bb657806397c7c309146105ea5780639c8413c51461052d578063a036e799146104df578063afe8154b1461049d578063e31476da146103d6578063e6c6fcec14610388578063e79b7a5114610333578063ec64842e146102eb578063f2fde38b14610203578063fabc74f5146101ab5763fd1190ea14610166575f80fd5b346101a75760203660031901126101a7576004356004548110156101a7576001600160a01b036101976020926112d8565b9190546040519260031b1c168152f35b5f80fd5b346101a75760203660031901126101a7576001600160a01b036101cc61130d565b165f52600360205260ff60405f20541660405160038210156101ef576020918152f35b634e487b7160e01b5f52602160045260245ffd5b346101a75760203660031901126101a75761021c61130d565b5f54906001600160a01b038083169161023633841461142f565b169182156102805773ffffffffffffffffffffffffffffffffffffffff19839116175f557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3005b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608490fd5b346101a75760203660031901126101a7576001600160a01b0361030c61130d565b165f52600360205260ff60405f20541660038110156101ef57602090600160405191148152f35b346101a75761034136611377565b6001600160a01b0390610358825f5416331461142f565b5f5b8151811015610386578061037c84610375610381948661149c565b51166116d2565b61147a565b61035a565b005b346101a75761039636611377565b6001600160a01b03906103ad825f5416331461142f565b5f5b8151811015610386578061037c846103ca6103d1948661149c565b51166114fc565b6103af565b346101a75760603660031901126101a7577fe8e2da79405f6328030a49e89981740387fc8c731042ec804a6461e796ec6f0b610410611261565b60243561049861041e611278565b926104346001600160a01b035f5416331461142f565b67ffffffffffffffff8116805f52600760205260405f20845f5260205260405f20600160ff198254161790555f5260086020528260405f2055604051938493849160409194936060840195845267ffffffffffffffff809216602085015216910152565b0390a1005b346101a75760203660031901126101a75767ffffffffffffffff6104bf611261565b165f52600560205260206001600160a01b0360405f205416604051908152f35b346101a7576104ed36611377565b6001600160a01b0390610504825f5416331461142f565b5f5b8151811015610386578061037c84610521610528948661149c565b51166117b7565b610506565b346101a75760403660031901126101a7577fb78ea0eaf11776732556ef6189312ceb60eab6b3177526b3a12d966e37be8162610567611261565b61056f611323565b906001600160a01b03610586815f5416331461142f565b67ffffffffffffffff82165f52600660205260405f2090831673ffffffffffffffffffffffffffffffffffffffff19825416179055610498604051928392839092916001600160a01b0360209167ffffffffffffffff604085019616845216910152565b346101a7576102203660031901126101a757610604611261565b6102003660231901126101a7576040519060e0820182811067ffffffffffffffff8211176109c357604052602435825261063c611278565b6020830152606435604083015260843560608301523660c312156101a757604051610100810181811067ffffffffffffffff8211176109c357604052806101a4913683116101a75760a4905b838210610ba65750506080840152366101c312156101a757604051906106ad82611339565b8190366101e4116101a757905b6101e48210610b9657505060a08301523661020312156101a7576040516106e081611339565b8036610224116101a7576101e4905b6102248210610b8657505060c0830152335f52600360205260ff60405f20541660038110156101ef57600103610b4157606082015115610a1c575b67ffffffffffffffff81165f52600860205260405f205460066020526001600160a01b0360405f20541680156109d757604051918261012081011067ffffffffffffffff610120850111176109c35761012083016040526101203684378060801c83526fffffffffffffffffffffffffffffffff8091166020840152845160801c6040840152808551166060840152604085015160801c60808401528060408601511660a084015267ffffffffffffffff60208601511660c0840152606085015160801c60e0840152606085015116610100830152608084015160a08501519260c0860151604051948593633072c1a360e11b8552600485015f905b600882106109a9575050509061084461084f92610104860190611408565b610144840190611408565b5f61018483015b6009821061098f575050506102a4816020935afa908115610984575f91610949575b50156109045767ffffffffffffffff9081165f818152600760209081526040808320865184528252808320805460ff191660011790558551848452600883529281902092909255845194810151825195865290931692840192909252908201527fe8e2da79405f6328030a49e89981740387fc8c731042ec804a6461e796ec6f0b908060608101610498565b60405162461bcd60e51b815260206004820152601060248201527f696e76616c6964207a6b2070726f6f66000000000000000000000000000000006044820152606490fd5b90506020813d60201161097c575b8161096460209383611355565b810103126101a7575180151581036101a75783610878565b3d9150610957565b6040513d5f823e3d90fd5b829350602080916001939451815201930191018492610856565b825181528896506020928301926001929092019101610826565b634e487b7160e01b5f52604160045260245ffd5b60405162461bcd60e51b815260206004820152601760248201527f6e6f20766572696669657220666f7220636861696e49640000000000000000006044820152606490fd5b67ffffffffffffffff81165f5260056020526001600160a01b0360405f2054168015610afc57602067ffffffffffffffff818501511660246040518094819363f25b3f9960e01b835260048301525afa908115610984575f91610aca575b5060408301511461072a5760405162461bcd60e51b815260206004820152601360248201527f616e63686f7220636865636b206661696c6564000000000000000000000000006044820152606490fd5b90506020813d602011610af4575b81610ae560209383611355565b810103126101a7575183610a7a565b3d9150610ad8565b60405162461bcd60e51b815260206004820152601760248201527f756e6b6e6f776e20616e63686f722070726f76696465720000000000000000006044820152606490fd5b60405162461bcd60e51b815260206004820152601260248201527f6e6f7420696e76616c69642070726f76657200000000000000000000000000006044820152606490fd5b81358152602091820191016106ef565b81358152602091820191016106ba565b8135815260209182019101610688565b346101a7575f3660031901126101a75760206001600160a01b035f5416604051908152f35b346101a7575f3660031901126101a757335f526001602090808252610c0660ff60405f2054166114b0565b5f5460ff8160a01c16610cad5760ff60a01b19740100000000000000000000000000000000000000009116175f557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a25882604051338152a15f815b610c6657005b60045481101561038657806001600160a01b03610c85610ca7936112d8565b919054600392831b1c165f52845260405f20600260ff1982541617905561147a565b81610c60565b60405162461bcd60e51b815260048101849052601060248201527f5061757361626c653a20706175736564000000000000000000000000000000006044820152606490fd5b346101a75760203660031901126101a757610386610d0e61130d565b610d236001600160a01b035f5416331461142f565b6116d2565b346101a75760203660031901126101a75767ffffffffffffffff610d4a611261565b165f52600660205260206001600160a01b0360405f205416604051908152f35b346101a75760203660031901126101a7576001600160a01b03610d8b61130d565b165f526001602052602060ff60405f2054166040519015158152f35b346101a7575f3660031901126101a757610386336117b7565b346101a75760203660031901126101a757610386610ddc61130d565b610df16001600160a01b035f5416331461142f565b6117b7565b346101a75760203660031901126101a75767ffffffffffffffff610e18611261565b165f526008602052602060405f2054604051908152f35b346101a757610e3d36611377565b5f54906001600160a01b0391610e56338483161461142f565b60ff9060a01c811615610f7e576002925b5f5b83518110156103865781610e7d828661149c565b511690815f52600360208181528560405f205416828110156101ef57610f3a57600454680100000000000000008110156109c35784610ec5826001610ee594016004556112d8565b90919082549060031b916001600160a01b03809116831b921b1916179055565b835f5281815260405f20918810156101ef57610f35937fef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd0396849260ff19815416888b16179055604051908152a161147a565b610e69565b6064906040519062461bcd60e51b82526004820152601160248201527f6163636f756e742069732070726f7665720000000000000000000000000000006044820152fd5b600192610e67565b346101a75760403660031901126101a7577fd621c244f07f12e1f37bb9c40d61e278041fc4f2859a6736794b26f4297c8090610fc0611261565b610fc8611323565b906001600160a01b03610fdf815f5416331461142f565b67ffffffffffffffff82165f52600560205260405f2090831673ffffffffffffffffffffffffffffffffffffffff19825416179055610498604051928392839092916001600160a01b0360209167ffffffffffffffff604085019616845216910152565b346101a7575f3660031901126101a757602060ff5f5460a01c166040519015158152f35b346101a7575f3660031901126101a7576020600254604051908152f35b346101a7575f3660031901126101a7576020600454604051908152f35b346101a7575f3660031901126101a757335f5260016020908082526110cc60ff60405f2054166114b0565b5f5460ff8160a01c161561115c5760ff60a01b19165f557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa82604051338152a15f815b61111557005b60045481101561038657611156816001600160a01b0361113585946112d8565b919054600392831b1c165f52855260405f208360ff1982541617905561147a565b9061110f565b60405162461bcd60e51b815260048101849052601460248201527f5061757361626c653a206e6f74207061757365640000000000000000000000006044820152606490fd5b346101a75760403660031901126101a75767ffffffffffffffff6111c3611261565b165f52600760205260405f206024355f52602052602060ff60405f2054166040519015158152f35b346101a75760203660031901126101a7576004356002548110156101a7576001600160a01b0361019760209261128f565b346101a75760403660031901126101a75760209067ffffffffffffffff611241611261565b165f526007825260405f206024355f52825260ff60405f20541615158152f35b6004359067ffffffffffffffff821682036101a757565b6044359067ffffffffffffffff821682036101a757565b6002548110156112c45760025f527f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace01905f90565b634e487b7160e01b5f52603260045260245ffd5b6004548110156112c45760045f527f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b01905f90565b600435906001600160a01b03821682036101a757565b602435906001600160a01b03821682036101a757565b6040810190811067ffffffffffffffff8211176109c357604052565b90601f8019910116810190811067ffffffffffffffff8211176109c357604052565b6020806003198301126101a75767ffffffffffffffff916004358381116101a757816023820112156101a75780600401359384116109c3578360051b90604051946113c485840187611355565b85526024848601928201019283116101a757602401905b8282106113e9575050505090565b81356001600160a01b03811681036101a75781529083019083016113db565b5f915b6002831061141857505050565b60019082518152602080910192019201919061140b565b1561143657565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b5f1981146114885760010190565b634e487b7160e01b5f52601160045260245ffd5b80518210156112c45760209160051b010190565b156114b757565b60405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f74207061757365720000000000000000000000006044820152606490fd5b6001600160a01b03809116915f83815260039360209185835260409060ff8282205416878110156116be571561167a576004968754965f199081890198891161166757835b8a54811015611624578682611555836112d8565b905490871b1c161461156f5761156a9061147a565b611541565b9091929394959697988082106115ff575b505050875480156115ec5797849392917fd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985989901906115d66115c1836112d8565b6001600160a01b0382549160031b1b19169055565b55848252855220805460ff1916905551908152a1565b634e487b7160e01b845260318952602484fd5b61161c9261160f610ec5926112d8565b905490871b1c16916112d8565b5f8080611580565b855162461bcd60e51b8152808c01899052601060248201527f70726f766572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b634e487b7160e01b845260118a52602484fd5b815162461bcd60e51b815260048101859052601560248201527f6163636f756e74206973206e6f742070726f76657200000000000000000000006044820152606490fd5b634e487b7160e01b82526021600452602482fd5b6001600160a01b038116905f90828252600160205260ff604083205416611772576002546801000000000000000081101561175e576020926117427f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f89593610ec58460016040960160025561128f565b8281526001845220600160ff19825416179055604051908152a1565b634e487b7160e01b83526041600452602483fd5b60405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c726561647920706175736572000000000000006044820152606490fd5b6001600160a01b03809116905f9282845260019060209382855260409360ff85882054161561192f576002805490915f199182810190811161191b57908695949392918a975b611846575b885162461bcd60e51b8152600481018b9052601060248201527f706175736572206e6f7420666f756e64000000000000000000000000000000006044820152606490fd5b8399989799548a101561191257818561185e8c61128f565b929054600393841b1c1614611887575061187e8798999a9795969761147a565b979695946117fd565b92939497969599918183106118ed575b50505050815480156118d957918493917fcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e98999301906115d66115c18361128f565b634e487b7160e01b89526031600452602489fd5b611909936118fd610ec59361128f565b9054911b1c169161128f565b5f808080611897565b87989950611802565b634e487b7160e01b8a52601160045260248afd5b845162461bcd60e51b815260048101879052601560248201527f4163636f756e74206973206e6f742070617573657200000000000000000000006044820152606490fdfea26469706673582212207fa8d374371aa4dd226f552ea5a5ee38be49d67c2512f51d6fde4d780c4380ec64736f6c63430008140033",
}

// TestSMTABI is the input ABI used to generate the binding from.
// Deprecated: Use TestSMTMetaData.ABI instead.
var TestSMTABI = TestSMTMetaData.ABI

// TestSMTBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use TestSMTMetaData.Bin instead.
var TestSMTBin = TestSMTMetaData.Bin

// DeployTestSMT deploys a new Ethereum contract, binding an instance of TestSMT to it.
func DeployTestSMT(auth *bind.TransactOpts, backend bind.ContractBackend, _chainIds []uint64, _anchorProviders []common.Address, _verifiers []common.Address, _initRoots [][32]byte) (common.Address, *types.Transaction, *TestSMT, error) {
	parsed, err := TestSMTMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(TestSMTBin), backend, _chainIds, _anchorProviders, _verifiers, _initRoots)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &TestSMT{TestSMTCaller: TestSMTCaller{contract: contract}, TestSMTTransactor: TestSMTTransactor{contract: contract}, TestSMTFilterer: TestSMTFilterer{contract: contract}}, nil
}

// TestSMT is an auto generated Go binding around an Ethereum contract.
type TestSMT struct {
	TestSMTCaller     // Read-only binding to the contract
	TestSMTTransactor // Write-only binding to the contract
	TestSMTFilterer   // Log filterer for contract events
}

// TestSMTCaller is an auto generated read-only Go binding around an Ethereum contract.
type TestSMTCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TestSMTTransactor is an auto generated write-only Go binding around an Ethereum contract.
type TestSMTTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TestSMTFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type TestSMTFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TestSMTSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type TestSMTSession struct {
	Contract     *TestSMT          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// TestSMTCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type TestSMTCallerSession struct {
	Contract *TestSMTCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// TestSMTTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type TestSMTTransactorSession struct {
	Contract     *TestSMTTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// TestSMTRaw is an auto generated low-level Go binding around an Ethereum contract.
type TestSMTRaw struct {
	Contract *TestSMT // Generic contract binding to access the raw methods on
}

// TestSMTCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type TestSMTCallerRaw struct {
	Contract *TestSMTCaller // Generic read-only contract binding to access the raw methods on
}

// TestSMTTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type TestSMTTransactorRaw struct {
	Contract *TestSMTTransactor // Generic write-only contract binding to access the raw methods on
}

// NewTestSMT creates a new instance of TestSMT, bound to a specific deployed contract.
func NewTestSMT(address common.Address, backend bind.ContractBackend) (*TestSMT, error) {
	contract, err := bindTestSMT(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &TestSMT{TestSMTCaller: TestSMTCaller{contract: contract}, TestSMTTransactor: TestSMTTransactor{contract: contract}, TestSMTFilterer: TestSMTFilterer{contract: contract}}, nil
}

// NewTestSMTCaller creates a new read-only instance of TestSMT, bound to a specific deployed contract.
func NewTestSMTCaller(address common.Address, caller bind.ContractCaller) (*TestSMTCaller, error) {
	contract, err := bindTestSMT(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &TestSMTCaller{contract: contract}, nil
}

// NewTestSMTTransactor creates a new write-only instance of TestSMT, bound to a specific deployed contract.
func NewTestSMTTransactor(address common.Address, transactor bind.ContractTransactor) (*TestSMTTransactor, error) {
	contract, err := bindTestSMT(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &TestSMTTransactor{contract: contract}, nil
}

// NewTestSMTFilterer creates a new log filterer instance of TestSMT, bound to a specific deployed contract.
func NewTestSMTFilterer(address common.Address, filterer bind.ContractFilterer) (*TestSMTFilterer, error) {
	contract, err := bindTestSMT(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &TestSMTFilterer{contract: contract}, nil
}

// bindTestSMT binds a generic wrapper to an already deployed contract.
func bindTestSMT(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := TestSMTMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TestSMT *TestSMTRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TestSMT.Contract.TestSMTCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TestSMT *TestSMTRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TestSMT.Contract.TestSMTTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TestSMT *TestSMTRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TestSMT.Contract.TestSMTTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TestSMT *TestSMTCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TestSMT.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TestSMT *TestSMTTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TestSMT.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TestSMT *TestSMTTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TestSMT.Contract.contract.Transact(opts, method, params...)
}

// AnchorProviders is a free data retrieval call binding the contract method 0xafe8154b.
//
// Solidity: function anchorProviders(uint64 ) view returns(address)
func (_TestSMT *TestSMTCaller) AnchorProviders(opts *bind.CallOpts, arg0 uint64) (common.Address, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "anchorProviders", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// AnchorProviders is a free data retrieval call binding the contract method 0xafe8154b.
//
// Solidity: function anchorProviders(uint64 ) view returns(address)
func (_TestSMT *TestSMTSession) AnchorProviders(arg0 uint64) (common.Address, error) {
	return _TestSMT.Contract.AnchorProviders(&_TestSMT.CallOpts, arg0)
}

// AnchorProviders is a free data retrieval call binding the contract method 0xafe8154b.
//
// Solidity: function anchorProviders(uint64 ) view returns(address)
func (_TestSMT *TestSMTCallerSession) AnchorProviders(arg0 uint64) (common.Address, error) {
	return _TestSMT.Contract.AnchorProviders(&_TestSMT.CallOpts, arg0)
}

// GetLatestRoot is a free data retrieval call binding the contract method 0x479aa6da.
//
// Solidity: function getLatestRoot(uint64 chainId) view returns(bytes32)
func (_TestSMT *TestSMTCaller) GetLatestRoot(opts *bind.CallOpts, chainId uint64) ([32]byte, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "getLatestRoot", chainId)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// GetLatestRoot is a free data retrieval call binding the contract method 0x479aa6da.
//
// Solidity: function getLatestRoot(uint64 chainId) view returns(bytes32)
func (_TestSMT *TestSMTSession) GetLatestRoot(chainId uint64) ([32]byte, error) {
	return _TestSMT.Contract.GetLatestRoot(&_TestSMT.CallOpts, chainId)
}

// GetLatestRoot is a free data retrieval call binding the contract method 0x479aa6da.
//
// Solidity: function getLatestRoot(uint64 chainId) view returns(bytes32)
func (_TestSMT *TestSMTCallerSession) GetLatestRoot(chainId uint64) ([32]byte, error) {
	return _TestSMT.Contract.GetLatestRoot(&_TestSMT.CallOpts, chainId)
}

// IsActiveProver is a free data retrieval call binding the contract method 0xec64842e.
//
// Solidity: function isActiveProver(address _account) view returns(bool)
func (_TestSMT *TestSMTCaller) IsActiveProver(opts *bind.CallOpts, _account common.Address) (bool, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "isActiveProver", _account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsActiveProver is a free data retrieval call binding the contract method 0xec64842e.
//
// Solidity: function isActiveProver(address _account) view returns(bool)
func (_TestSMT *TestSMTSession) IsActiveProver(_account common.Address) (bool, error) {
	return _TestSMT.Contract.IsActiveProver(&_TestSMT.CallOpts, _account)
}

// IsActiveProver is a free data retrieval call binding the contract method 0xec64842e.
//
// Solidity: function isActiveProver(address _account) view returns(bool)
func (_TestSMT *TestSMTCallerSession) IsActiveProver(_account common.Address) (bool, error) {
	return _TestSMT.Contract.IsActiveProver(&_TestSMT.CallOpts, _account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_TestSMT *TestSMTCaller) IsPauser(opts *bind.CallOpts, account common.Address) (bool, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "isPauser", account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_TestSMT *TestSMTSession) IsPauser(account common.Address) (bool, error) {
	return _TestSMT.Contract.IsPauser(&_TestSMT.CallOpts, account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_TestSMT *TestSMTCallerSession) IsPauser(account common.Address) (bool, error) {
	return _TestSMT.Contract.IsPauser(&_TestSMT.CallOpts, account)
}

// IsSmtRootValid is a free data retrieval call binding the contract method 0x1019b616.
//
// Solidity: function isSmtRootValid(uint64 chainId, bytes32 smtRoot) view returns(bool)
func (_TestSMT *TestSMTCaller) IsSmtRootValid(opts *bind.CallOpts, chainId uint64, smtRoot [32]byte) (bool, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "isSmtRootValid", chainId, smtRoot)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsSmtRootValid is a free data retrieval call binding the contract method 0x1019b616.
//
// Solidity: function isSmtRootValid(uint64 chainId, bytes32 smtRoot) view returns(bool)
func (_TestSMT *TestSMTSession) IsSmtRootValid(chainId uint64, smtRoot [32]byte) (bool, error) {
	return _TestSMT.Contract.IsSmtRootValid(&_TestSMT.CallOpts, chainId, smtRoot)
}

// IsSmtRootValid is a free data retrieval call binding the contract method 0x1019b616.
//
// Solidity: function isSmtRootValid(uint64 chainId, bytes32 smtRoot) view returns(bool)
func (_TestSMT *TestSMTCallerSession) IsSmtRootValid(chainId uint64, smtRoot [32]byte) (bool, error) {
	return _TestSMT.Contract.IsSmtRootValid(&_TestSMT.CallOpts, chainId, smtRoot)
}

// LatestRoots is a free data retrieval call binding the contract method 0x6ae3e080.
//
// Solidity: function latestRoots(uint64 ) view returns(bytes32)
func (_TestSMT *TestSMTCaller) LatestRoots(opts *bind.CallOpts, arg0 uint64) ([32]byte, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "latestRoots", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// LatestRoots is a free data retrieval call binding the contract method 0x6ae3e080.
//
// Solidity: function latestRoots(uint64 ) view returns(bytes32)
func (_TestSMT *TestSMTSession) LatestRoots(arg0 uint64) ([32]byte, error) {
	return _TestSMT.Contract.LatestRoots(&_TestSMT.CallOpts, arg0)
}

// LatestRoots is a free data retrieval call binding the contract method 0x6ae3e080.
//
// Solidity: function latestRoots(uint64 ) view returns(bytes32)
func (_TestSMT *TestSMTCallerSession) LatestRoots(arg0 uint64) ([32]byte, error) {
	return _TestSMT.Contract.LatestRoots(&_TestSMT.CallOpts, arg0)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_TestSMT *TestSMTCaller) NumPausers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "numPausers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_TestSMT *TestSMTSession) NumPausers() (*big.Int, error) {
	return _TestSMT.Contract.NumPausers(&_TestSMT.CallOpts)
}

// NumPausers is a free data retrieval call binding the contract method 0x58a16b44.
//
// Solidity: function numPausers() view returns(uint256)
func (_TestSMT *TestSMTCallerSession) NumPausers() (*big.Int, error) {
	return _TestSMT.Contract.NumPausers(&_TestSMT.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_TestSMT *TestSMTCaller) NumProvers(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "numProvers")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_TestSMT *TestSMTSession) NumProvers() (*big.Int, error) {
	return _TestSMT.Contract.NumProvers(&_TestSMT.CallOpts)
}

// NumProvers is a free data retrieval call binding the contract method 0x4f4fef18.
//
// Solidity: function numProvers() view returns(uint256)
func (_TestSMT *TestSMTCallerSession) NumProvers() (*big.Int, error) {
	return _TestSMT.Contract.NumProvers(&_TestSMT.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TestSMT *TestSMTCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TestSMT *TestSMTSession) Owner() (common.Address, error) {
	return _TestSMT.Contract.Owner(&_TestSMT.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TestSMT *TestSMTCallerSession) Owner() (common.Address, error) {
	return _TestSMT.Contract.Owner(&_TestSMT.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_TestSMT *TestSMTCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_TestSMT *TestSMTSession) Paused() (bool, error) {
	return _TestSMT.Contract.Paused(&_TestSMT.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_TestSMT *TestSMTCallerSession) Paused() (bool, error) {
	return _TestSMT.Contract.Paused(&_TestSMT.CallOpts)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_TestSMT *TestSMTCaller) PauserList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "pauserList", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_TestSMT *TestSMTSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _TestSMT.Contract.PauserList(&_TestSMT.CallOpts, arg0)
}

// PauserList is a free data retrieval call binding the contract method 0x158535ff.
//
// Solidity: function pauserList(uint256 ) view returns(address)
func (_TestSMT *TestSMTCallerSession) PauserList(arg0 *big.Int) (common.Address, error) {
	return _TestSMT.Contract.PauserList(&_TestSMT.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_TestSMT *TestSMTCaller) Pausers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "pausers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_TestSMT *TestSMTSession) Pausers(arg0 common.Address) (bool, error) {
	return _TestSMT.Contract.Pausers(&_TestSMT.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_TestSMT *TestSMTCallerSession) Pausers(arg0 common.Address) (bool, error) {
	return _TestSMT.Contract.Pausers(&_TestSMT.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_TestSMT *TestSMTCaller) ProverStates(opts *bind.CallOpts, arg0 common.Address) (uint8, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "proverStates", arg0)

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_TestSMT *TestSMTSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _TestSMT.Contract.ProverStates(&_TestSMT.CallOpts, arg0)
}

// ProverStates is a free data retrieval call binding the contract method 0xfabc74f5.
//
// Solidity: function proverStates(address ) view returns(uint8)
func (_TestSMT *TestSMTCallerSession) ProverStates(arg0 common.Address) (uint8, error) {
	return _TestSMT.Contract.ProverStates(&_TestSMT.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_TestSMT *TestSMTCaller) Provers(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "provers", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_TestSMT *TestSMTSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _TestSMT.Contract.Provers(&_TestSMT.CallOpts, arg0)
}

// Provers is a free data retrieval call binding the contract method 0xfd1190ea.
//
// Solidity: function provers(uint256 ) view returns(address)
func (_TestSMT *TestSMTCallerSession) Provers(arg0 *big.Int) (common.Address, error) {
	return _TestSMT.Contract.Provers(&_TestSMT.CallOpts, arg0)
}

// SmtRoots is a free data retrieval call binding the contract method 0x38702532.
//
// Solidity: function smtRoots(uint64 , bytes32 ) view returns(bool)
func (_TestSMT *TestSMTCaller) SmtRoots(opts *bind.CallOpts, arg0 uint64, arg1 [32]byte) (bool, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "smtRoots", arg0, arg1)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SmtRoots is a free data retrieval call binding the contract method 0x38702532.
//
// Solidity: function smtRoots(uint64 , bytes32 ) view returns(bool)
func (_TestSMT *TestSMTSession) SmtRoots(arg0 uint64, arg1 [32]byte) (bool, error) {
	return _TestSMT.Contract.SmtRoots(&_TestSMT.CallOpts, arg0, arg1)
}

// SmtRoots is a free data retrieval call binding the contract method 0x38702532.
//
// Solidity: function smtRoots(uint64 , bytes32 ) view returns(bool)
func (_TestSMT *TestSMTCallerSession) SmtRoots(arg0 uint64, arg1 [32]byte) (bool, error) {
	return _TestSMT.Contract.SmtRoots(&_TestSMT.CallOpts, arg0, arg1)
}

// Verifiers is a free data retrieval call binding the contract method 0x8195408d.
//
// Solidity: function verifiers(uint64 ) view returns(address)
func (_TestSMT *TestSMTCaller) Verifiers(opts *bind.CallOpts, arg0 uint64) (common.Address, error) {
	var out []interface{}
	err := _TestSMT.contract.Call(opts, &out, "verifiers", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Verifiers is a free data retrieval call binding the contract method 0x8195408d.
//
// Solidity: function verifiers(uint64 ) view returns(address)
func (_TestSMT *TestSMTSession) Verifiers(arg0 uint64) (common.Address, error) {
	return _TestSMT.Contract.Verifiers(&_TestSMT.CallOpts, arg0)
}

// Verifiers is a free data retrieval call binding the contract method 0x8195408d.
//
// Solidity: function verifiers(uint64 ) view returns(address)
func (_TestSMT *TestSMTCallerSession) Verifiers(arg0 uint64) (common.Address, error) {
	return _TestSMT.Contract.Verifiers(&_TestSMT.CallOpts, arg0)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_TestSMT *TestSMTTransactor) AddPauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _TestSMT.contract.Transact(opts, "addPauser", account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_TestSMT *TestSMTSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.AddPauser(&_TestSMT.TransactOpts, account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_TestSMT *TestSMTTransactorSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.AddPauser(&_TestSMT.TransactOpts, account)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_TestSMT *TestSMTTransactor) AddPausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _TestSMT.contract.Transact(opts, "addPausers", accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_TestSMT *TestSMTSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.AddPausers(&_TestSMT.TransactOpts, accounts)
}

// AddPausers is a paid mutator transaction binding the contract method 0xe79b7a51.
//
// Solidity: function addPausers(address[] accounts) returns()
func (_TestSMT *TestSMTTransactorSession) AddPausers(accounts []common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.AddPausers(&_TestSMT.TransactOpts, accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_TestSMT *TestSMTTransactor) AddProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _TestSMT.contract.Transact(opts, "addProvers", _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_TestSMT *TestSMTSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.AddProvers(&_TestSMT.TransactOpts, _accounts)
}

// AddProvers is a paid mutator transaction binding the contract method 0x677625f2.
//
// Solidity: function addProvers(address[] _accounts) returns()
func (_TestSMT *TestSMTTransactorSession) AddProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.AddProvers(&_TestSMT.TransactOpts, _accounts)
}

// AddRootForTesting is a paid mutator transaction binding the contract method 0xe31476da.
//
// Solidity: function addRootForTesting(uint64 chainId, bytes32 newRoot, uint64 endBlockNum) returns()
func (_TestSMT *TestSMTTransactor) AddRootForTesting(opts *bind.TransactOpts, chainId uint64, newRoot [32]byte, endBlockNum uint64) (*types.Transaction, error) {
	return _TestSMT.contract.Transact(opts, "addRootForTesting", chainId, newRoot, endBlockNum)
}

// AddRootForTesting is a paid mutator transaction binding the contract method 0xe31476da.
//
// Solidity: function addRootForTesting(uint64 chainId, bytes32 newRoot, uint64 endBlockNum) returns()
func (_TestSMT *TestSMTSession) AddRootForTesting(chainId uint64, newRoot [32]byte, endBlockNum uint64) (*types.Transaction, error) {
	return _TestSMT.Contract.AddRootForTesting(&_TestSMT.TransactOpts, chainId, newRoot, endBlockNum)
}

// AddRootForTesting is a paid mutator transaction binding the contract method 0xe31476da.
//
// Solidity: function addRootForTesting(uint64 chainId, bytes32 newRoot, uint64 endBlockNum) returns()
func (_TestSMT *TestSMTTransactorSession) AddRootForTesting(chainId uint64, newRoot [32]byte, endBlockNum uint64) (*types.Transaction, error) {
	return _TestSMT.Contract.AddRootForTesting(&_TestSMT.TransactOpts, chainId, newRoot, endBlockNum)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_TestSMT *TestSMTTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TestSMT.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_TestSMT *TestSMTSession) Pause() (*types.Transaction, error) {
	return _TestSMT.Contract.Pause(&_TestSMT.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_TestSMT *TestSMTTransactorSession) Pause() (*types.Transaction, error) {
	return _TestSMT.Contract.Pause(&_TestSMT.TransactOpts)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_TestSMT *TestSMTTransactor) RemovePauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _TestSMT.contract.Transact(opts, "removePauser", account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_TestSMT *TestSMTSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.RemovePauser(&_TestSMT.TransactOpts, account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_TestSMT *TestSMTTransactorSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.RemovePauser(&_TestSMT.TransactOpts, account)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_TestSMT *TestSMTTransactor) RemovePausers(opts *bind.TransactOpts, accounts []common.Address) (*types.Transaction, error) {
	return _TestSMT.contract.Transact(opts, "removePausers", accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_TestSMT *TestSMTSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.RemovePausers(&_TestSMT.TransactOpts, accounts)
}

// RemovePausers is a paid mutator transaction binding the contract method 0xa036e799.
//
// Solidity: function removePausers(address[] accounts) returns()
func (_TestSMT *TestSMTTransactorSession) RemovePausers(accounts []common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.RemovePausers(&_TestSMT.TransactOpts, accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_TestSMT *TestSMTTransactor) RemoveProvers(opts *bind.TransactOpts, _accounts []common.Address) (*types.Transaction, error) {
	return _TestSMT.contract.Transact(opts, "removeProvers", _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_TestSMT *TestSMTSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.RemoveProvers(&_TestSMT.TransactOpts, _accounts)
}

// RemoveProvers is a paid mutator transaction binding the contract method 0xe6c6fcec.
//
// Solidity: function removeProvers(address[] _accounts) returns()
func (_TestSMT *TestSMTTransactorSession) RemoveProvers(_accounts []common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.RemoveProvers(&_TestSMT.TransactOpts, _accounts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_TestSMT *TestSMTTransactor) RenouncePauser(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TestSMT.contract.Transact(opts, "renouncePauser")
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_TestSMT *TestSMTSession) RenouncePauser() (*types.Transaction, error) {
	return _TestSMT.Contract.RenouncePauser(&_TestSMT.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_TestSMT *TestSMTTransactorSession) RenouncePauser() (*types.Transaction, error) {
	return _TestSMT.Contract.RenouncePauser(&_TestSMT.TransactOpts)
}

// SetAnchorProvider is a paid mutator transaction binding the contract method 0x5ca32bd8.
//
// Solidity: function setAnchorProvider(uint64 chainId, address anchorProvider) returns()
func (_TestSMT *TestSMTTransactor) SetAnchorProvider(opts *bind.TransactOpts, chainId uint64, anchorProvider common.Address) (*types.Transaction, error) {
	return _TestSMT.contract.Transact(opts, "setAnchorProvider", chainId, anchorProvider)
}

// SetAnchorProvider is a paid mutator transaction binding the contract method 0x5ca32bd8.
//
// Solidity: function setAnchorProvider(uint64 chainId, address anchorProvider) returns()
func (_TestSMT *TestSMTSession) SetAnchorProvider(chainId uint64, anchorProvider common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.SetAnchorProvider(&_TestSMT.TransactOpts, chainId, anchorProvider)
}

// SetAnchorProvider is a paid mutator transaction binding the contract method 0x5ca32bd8.
//
// Solidity: function setAnchorProvider(uint64 chainId, address anchorProvider) returns()
func (_TestSMT *TestSMTTransactorSession) SetAnchorProvider(chainId uint64, anchorProvider common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.SetAnchorProvider(&_TestSMT.TransactOpts, chainId, anchorProvider)
}

// SetVerifier is a paid mutator transaction binding the contract method 0x9c8413c5.
//
// Solidity: function setVerifier(uint64 chainId, address verifier) returns()
func (_TestSMT *TestSMTTransactor) SetVerifier(opts *bind.TransactOpts, chainId uint64, verifier common.Address) (*types.Transaction, error) {
	return _TestSMT.contract.Transact(opts, "setVerifier", chainId, verifier)
}

// SetVerifier is a paid mutator transaction binding the contract method 0x9c8413c5.
//
// Solidity: function setVerifier(uint64 chainId, address verifier) returns()
func (_TestSMT *TestSMTSession) SetVerifier(chainId uint64, verifier common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.SetVerifier(&_TestSMT.TransactOpts, chainId, verifier)
}

// SetVerifier is a paid mutator transaction binding the contract method 0x9c8413c5.
//
// Solidity: function setVerifier(uint64 chainId, address verifier) returns()
func (_TestSMT *TestSMTTransactorSession) SetVerifier(chainId uint64, verifier common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.SetVerifier(&_TestSMT.TransactOpts, chainId, verifier)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TestSMT *TestSMTTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _TestSMT.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TestSMT *TestSMTSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.TransferOwnership(&_TestSMT.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TestSMT *TestSMTTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _TestSMT.Contract.TransferOwnership(&_TestSMT.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_TestSMT *TestSMTTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TestSMT.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_TestSMT *TestSMTSession) Unpause() (*types.Transaction, error) {
	return _TestSMT.Contract.Unpause(&_TestSMT.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_TestSMT *TestSMTTransactorSession) Unpause() (*types.Transaction, error) {
	return _TestSMT.Contract.Unpause(&_TestSMT.TransactOpts)
}

// UpdateRoot is a paid mutator transaction binding the contract method 0x97c7c309.
//
// Solidity: function updateRoot(uint64 chainId, (bytes32,uint64,bytes32,bytes32,uint256[8],uint256[2],uint256[2]) u) returns()
func (_TestSMT *TestSMTTransactor) UpdateRoot(opts *bind.TransactOpts, chainId uint64, u ISMTSmtUpdate) (*types.Transaction, error) {
	return _TestSMT.contract.Transact(opts, "updateRoot", chainId, u)
}

// UpdateRoot is a paid mutator transaction binding the contract method 0x97c7c309.
//
// Solidity: function updateRoot(uint64 chainId, (bytes32,uint64,bytes32,bytes32,uint256[8],uint256[2],uint256[2]) u) returns()
func (_TestSMT *TestSMTSession) UpdateRoot(chainId uint64, u ISMTSmtUpdate) (*types.Transaction, error) {
	return _TestSMT.Contract.UpdateRoot(&_TestSMT.TransactOpts, chainId, u)
}

// UpdateRoot is a paid mutator transaction binding the contract method 0x97c7c309.
//
// Solidity: function updateRoot(uint64 chainId, (bytes32,uint64,bytes32,bytes32,uint256[8],uint256[2],uint256[2]) u) returns()
func (_TestSMT *TestSMTTransactorSession) UpdateRoot(chainId uint64, u ISMTSmtUpdate) (*types.Transaction, error) {
	return _TestSMT.Contract.UpdateRoot(&_TestSMT.TransactOpts, chainId, u)
}

// TestSMTAnchorProviderUpdatedIterator is returned from FilterAnchorProviderUpdated and is used to iterate over the raw logs and unpacked data for AnchorProviderUpdated events raised by the TestSMT contract.
type TestSMTAnchorProviderUpdatedIterator struct {
	Event *TestSMTAnchorProviderUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TestSMTAnchorProviderUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TestSMTAnchorProviderUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TestSMTAnchorProviderUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TestSMTAnchorProviderUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TestSMTAnchorProviderUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TestSMTAnchorProviderUpdated represents a AnchorProviderUpdated event raised by the TestSMT contract.
type TestSMTAnchorProviderUpdated struct {
	ChainId        uint64
	AnchorProvider common.Address
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterAnchorProviderUpdated is a free log retrieval operation binding the contract event 0xd621c244f07f12e1f37bb9c40d61e278041fc4f2859a6736794b26f4297c8090.
//
// Solidity: event AnchorProviderUpdated(uint64 chainId, address anchorProvider)
func (_TestSMT *TestSMTFilterer) FilterAnchorProviderUpdated(opts *bind.FilterOpts) (*TestSMTAnchorProviderUpdatedIterator, error) {

	logs, sub, err := _TestSMT.contract.FilterLogs(opts, "AnchorProviderUpdated")
	if err != nil {
		return nil, err
	}
	return &TestSMTAnchorProviderUpdatedIterator{contract: _TestSMT.contract, event: "AnchorProviderUpdated", logs: logs, sub: sub}, nil
}

// WatchAnchorProviderUpdated is a free log subscription operation binding the contract event 0xd621c244f07f12e1f37bb9c40d61e278041fc4f2859a6736794b26f4297c8090.
//
// Solidity: event AnchorProviderUpdated(uint64 chainId, address anchorProvider)
func (_TestSMT *TestSMTFilterer) WatchAnchorProviderUpdated(opts *bind.WatchOpts, sink chan<- *TestSMTAnchorProviderUpdated) (event.Subscription, error) {

	logs, sub, err := _TestSMT.contract.WatchLogs(opts, "AnchorProviderUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TestSMTAnchorProviderUpdated)
				if err := _TestSMT.contract.UnpackLog(event, "AnchorProviderUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAnchorProviderUpdated is a log parse operation binding the contract event 0xd621c244f07f12e1f37bb9c40d61e278041fc4f2859a6736794b26f4297c8090.
//
// Solidity: event AnchorProviderUpdated(uint64 chainId, address anchorProvider)
func (_TestSMT *TestSMTFilterer) ParseAnchorProviderUpdated(log types.Log) (*TestSMTAnchorProviderUpdated, error) {
	event := new(TestSMTAnchorProviderUpdated)
	if err := _TestSMT.contract.UnpackLog(event, "AnchorProviderUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TestSMTOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the TestSMT contract.
type TestSMTOwnershipTransferredIterator struct {
	Event *TestSMTOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TestSMTOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TestSMTOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TestSMTOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TestSMTOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TestSMTOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TestSMTOwnershipTransferred represents a OwnershipTransferred event raised by the TestSMT contract.
type TestSMTOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TestSMT *TestSMTFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*TestSMTOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _TestSMT.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &TestSMTOwnershipTransferredIterator{contract: _TestSMT.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TestSMT *TestSMTFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *TestSMTOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _TestSMT.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TestSMTOwnershipTransferred)
				if err := _TestSMT.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TestSMT *TestSMTFilterer) ParseOwnershipTransferred(log types.Log) (*TestSMTOwnershipTransferred, error) {
	event := new(TestSMTOwnershipTransferred)
	if err := _TestSMT.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TestSMTPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the TestSMT contract.
type TestSMTPausedIterator struct {
	Event *TestSMTPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TestSMTPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TestSMTPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TestSMTPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TestSMTPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TestSMTPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TestSMTPaused represents a Paused event raised by the TestSMT contract.
type TestSMTPaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_TestSMT *TestSMTFilterer) FilterPaused(opts *bind.FilterOpts) (*TestSMTPausedIterator, error) {

	logs, sub, err := _TestSMT.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &TestSMTPausedIterator{contract: _TestSMT.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_TestSMT *TestSMTFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *TestSMTPaused) (event.Subscription, error) {

	logs, sub, err := _TestSMT.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TestSMTPaused)
				if err := _TestSMT.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_TestSMT *TestSMTFilterer) ParsePaused(log types.Log) (*TestSMTPaused, error) {
	event := new(TestSMTPaused)
	if err := _TestSMT.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TestSMTPauserAddedIterator is returned from FilterPauserAdded and is used to iterate over the raw logs and unpacked data for PauserAdded events raised by the TestSMT contract.
type TestSMTPauserAddedIterator struct {
	Event *TestSMTPauserAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TestSMTPauserAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TestSMTPauserAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TestSMTPauserAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TestSMTPauserAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TestSMTPauserAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TestSMTPauserAdded represents a PauserAdded event raised by the TestSMT contract.
type TestSMTPauserAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserAdded is a free log retrieval operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_TestSMT *TestSMTFilterer) FilterPauserAdded(opts *bind.FilterOpts) (*TestSMTPauserAddedIterator, error) {

	logs, sub, err := _TestSMT.contract.FilterLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return &TestSMTPauserAddedIterator{contract: _TestSMT.contract, event: "PauserAdded", logs: logs, sub: sub}, nil
}

// WatchPauserAdded is a free log subscription operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_TestSMT *TestSMTFilterer) WatchPauserAdded(opts *bind.WatchOpts, sink chan<- *TestSMTPauserAdded) (event.Subscription, error) {

	logs, sub, err := _TestSMT.contract.WatchLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TestSMTPauserAdded)
				if err := _TestSMT.contract.UnpackLog(event, "PauserAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserAdded is a log parse operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_TestSMT *TestSMTFilterer) ParsePauserAdded(log types.Log) (*TestSMTPauserAdded, error) {
	event := new(TestSMTPauserAdded)
	if err := _TestSMT.contract.UnpackLog(event, "PauserAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TestSMTPauserRemovedIterator is returned from FilterPauserRemoved and is used to iterate over the raw logs and unpacked data for PauserRemoved events raised by the TestSMT contract.
type TestSMTPauserRemovedIterator struct {
	Event *TestSMTPauserRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TestSMTPauserRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TestSMTPauserRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TestSMTPauserRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TestSMTPauserRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TestSMTPauserRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TestSMTPauserRemoved represents a PauserRemoved event raised by the TestSMT contract.
type TestSMTPauserRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserRemoved is a free log retrieval operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_TestSMT *TestSMTFilterer) FilterPauserRemoved(opts *bind.FilterOpts) (*TestSMTPauserRemovedIterator, error) {

	logs, sub, err := _TestSMT.contract.FilterLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return &TestSMTPauserRemovedIterator{contract: _TestSMT.contract, event: "PauserRemoved", logs: logs, sub: sub}, nil
}

// WatchPauserRemoved is a free log subscription operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_TestSMT *TestSMTFilterer) WatchPauserRemoved(opts *bind.WatchOpts, sink chan<- *TestSMTPauserRemoved) (event.Subscription, error) {

	logs, sub, err := _TestSMT.contract.WatchLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TestSMTPauserRemoved)
				if err := _TestSMT.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserRemoved is a log parse operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_TestSMT *TestSMTFilterer) ParsePauserRemoved(log types.Log) (*TestSMTPauserRemoved, error) {
	event := new(TestSMTPauserRemoved)
	if err := _TestSMT.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TestSMTProverAddedIterator is returned from FilterProverAdded and is used to iterate over the raw logs and unpacked data for ProverAdded events raised by the TestSMT contract.
type TestSMTProverAddedIterator struct {
	Event *TestSMTProverAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TestSMTProverAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TestSMTProverAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TestSMTProverAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TestSMTProverAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TestSMTProverAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TestSMTProverAdded represents a ProverAdded event raised by the TestSMT contract.
type TestSMTProverAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverAdded is a free log retrieval operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_TestSMT *TestSMTFilterer) FilterProverAdded(opts *bind.FilterOpts) (*TestSMTProverAddedIterator, error) {

	logs, sub, err := _TestSMT.contract.FilterLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return &TestSMTProverAddedIterator{contract: _TestSMT.contract, event: "ProverAdded", logs: logs, sub: sub}, nil
}

// WatchProverAdded is a free log subscription operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_TestSMT *TestSMTFilterer) WatchProverAdded(opts *bind.WatchOpts, sink chan<- *TestSMTProverAdded) (event.Subscription, error) {

	logs, sub, err := _TestSMT.contract.WatchLogs(opts, "ProverAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TestSMTProverAdded)
				if err := _TestSMT.contract.UnpackLog(event, "ProverAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverAdded is a log parse operation binding the contract event 0xef1fa0a4d797341645c201a742cf59be633da0589e0e3cda511cfc90cd039684.
//
// Solidity: event ProverAdded(address account)
func (_TestSMT *TestSMTFilterer) ParseProverAdded(log types.Log) (*TestSMTProverAdded, error) {
	event := new(TestSMTProverAdded)
	if err := _TestSMT.contract.UnpackLog(event, "ProverAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TestSMTProverRemovedIterator is returned from FilterProverRemoved and is used to iterate over the raw logs and unpacked data for ProverRemoved events raised by the TestSMT contract.
type TestSMTProverRemovedIterator struct {
	Event *TestSMTProverRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TestSMTProverRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TestSMTProverRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TestSMTProverRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TestSMTProverRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TestSMTProverRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TestSMTProverRemoved represents a ProverRemoved event raised by the TestSMT contract.
type TestSMTProverRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProverRemoved is a free log retrieval operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_TestSMT *TestSMTFilterer) FilterProverRemoved(opts *bind.FilterOpts) (*TestSMTProverRemovedIterator, error) {

	logs, sub, err := _TestSMT.contract.FilterLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return &TestSMTProverRemovedIterator{contract: _TestSMT.contract, event: "ProverRemoved", logs: logs, sub: sub}, nil
}

// WatchProverRemoved is a free log subscription operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_TestSMT *TestSMTFilterer) WatchProverRemoved(opts *bind.WatchOpts, sink chan<- *TestSMTProverRemoved) (event.Subscription, error) {

	logs, sub, err := _TestSMT.contract.WatchLogs(opts, "ProverRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TestSMTProverRemoved)
				if err := _TestSMT.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProverRemoved is a log parse operation binding the contract event 0xd64d11086d859b73cf85a91ca06cbc484398acabe3d9a1b26d4366dff377d985.
//
// Solidity: event ProverRemoved(address account)
func (_TestSMT *TestSMTFilterer) ParseProverRemoved(log types.Log) (*TestSMTProverRemoved, error) {
	event := new(TestSMTProverRemoved)
	if err := _TestSMT.contract.UnpackLog(event, "ProverRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TestSMTSmtRootUpdatedIterator is returned from FilterSmtRootUpdated and is used to iterate over the raw logs and unpacked data for SmtRootUpdated events raised by the TestSMT contract.
type TestSMTSmtRootUpdatedIterator struct {
	Event *TestSMTSmtRootUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TestSMTSmtRootUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TestSMTSmtRootUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TestSMTSmtRootUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TestSMTSmtRootUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TestSMTSmtRootUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TestSMTSmtRootUpdated represents a SmtRootUpdated event raised by the TestSMT contract.
type TestSMTSmtRootUpdated struct {
	SmtRoot     [32]byte
	EndBlockNum uint64
	ChainId     uint64
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterSmtRootUpdated is a free log retrieval operation binding the contract event 0xe8e2da79405f6328030a49e89981740387fc8c731042ec804a6461e796ec6f0b.
//
// Solidity: event SmtRootUpdated(bytes32 smtRoot, uint64 endBlockNum, uint64 chainId)
func (_TestSMT *TestSMTFilterer) FilterSmtRootUpdated(opts *bind.FilterOpts) (*TestSMTSmtRootUpdatedIterator, error) {

	logs, sub, err := _TestSMT.contract.FilterLogs(opts, "SmtRootUpdated")
	if err != nil {
		return nil, err
	}
	return &TestSMTSmtRootUpdatedIterator{contract: _TestSMT.contract, event: "SmtRootUpdated", logs: logs, sub: sub}, nil
}

// WatchSmtRootUpdated is a free log subscription operation binding the contract event 0xe8e2da79405f6328030a49e89981740387fc8c731042ec804a6461e796ec6f0b.
//
// Solidity: event SmtRootUpdated(bytes32 smtRoot, uint64 endBlockNum, uint64 chainId)
func (_TestSMT *TestSMTFilterer) WatchSmtRootUpdated(opts *bind.WatchOpts, sink chan<- *TestSMTSmtRootUpdated) (event.Subscription, error) {

	logs, sub, err := _TestSMT.contract.WatchLogs(opts, "SmtRootUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TestSMTSmtRootUpdated)
				if err := _TestSMT.contract.UnpackLog(event, "SmtRootUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSmtRootUpdated is a log parse operation binding the contract event 0xe8e2da79405f6328030a49e89981740387fc8c731042ec804a6461e796ec6f0b.
//
// Solidity: event SmtRootUpdated(bytes32 smtRoot, uint64 endBlockNum, uint64 chainId)
func (_TestSMT *TestSMTFilterer) ParseSmtRootUpdated(log types.Log) (*TestSMTSmtRootUpdated, error) {
	event := new(TestSMTSmtRootUpdated)
	if err := _TestSMT.contract.UnpackLog(event, "SmtRootUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TestSMTUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the TestSMT contract.
type TestSMTUnpausedIterator struct {
	Event *TestSMTUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TestSMTUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TestSMTUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TestSMTUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TestSMTUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TestSMTUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TestSMTUnpaused represents a Unpaused event raised by the TestSMT contract.
type TestSMTUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_TestSMT *TestSMTFilterer) FilterUnpaused(opts *bind.FilterOpts) (*TestSMTUnpausedIterator, error) {

	logs, sub, err := _TestSMT.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &TestSMTUnpausedIterator{contract: _TestSMT.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_TestSMT *TestSMTFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *TestSMTUnpaused) (event.Subscription, error) {

	logs, sub, err := _TestSMT.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TestSMTUnpaused)
				if err := _TestSMT.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_TestSMT *TestSMTFilterer) ParseUnpaused(log types.Log) (*TestSMTUnpaused, error) {
	event := new(TestSMTUnpaused)
	if err := _TestSMT.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TestSMTVerifierUpdatedIterator is returned from FilterVerifierUpdated and is used to iterate over the raw logs and unpacked data for VerifierUpdated events raised by the TestSMT contract.
type TestSMTVerifierUpdatedIterator struct {
	Event *TestSMTVerifierUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TestSMTVerifierUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TestSMTVerifierUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TestSMTVerifierUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TestSMTVerifierUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TestSMTVerifierUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TestSMTVerifierUpdated represents a VerifierUpdated event raised by the TestSMT contract.
type TestSMTVerifierUpdated struct {
	ChainId  uint64
	Verifier common.Address
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterVerifierUpdated is a free log retrieval operation binding the contract event 0xb78ea0eaf11776732556ef6189312ceb60eab6b3177526b3a12d966e37be8162.
//
// Solidity: event VerifierUpdated(uint64 chainId, address verifier)
func (_TestSMT *TestSMTFilterer) FilterVerifierUpdated(opts *bind.FilterOpts) (*TestSMTVerifierUpdatedIterator, error) {

	logs, sub, err := _TestSMT.contract.FilterLogs(opts, "VerifierUpdated")
	if err != nil {
		return nil, err
	}
	return &TestSMTVerifierUpdatedIterator{contract: _TestSMT.contract, event: "VerifierUpdated", logs: logs, sub: sub}, nil
}

// WatchVerifierUpdated is a free log subscription operation binding the contract event 0xb78ea0eaf11776732556ef6189312ceb60eab6b3177526b3a12d966e37be8162.
//
// Solidity: event VerifierUpdated(uint64 chainId, address verifier)
func (_TestSMT *TestSMTFilterer) WatchVerifierUpdated(opts *bind.WatchOpts, sink chan<- *TestSMTVerifierUpdated) (event.Subscription, error) {

	logs, sub, err := _TestSMT.contract.WatchLogs(opts, "VerifierUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TestSMTVerifierUpdated)
				if err := _TestSMT.contract.UnpackLog(event, "VerifierUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseVerifierUpdated is a log parse operation binding the contract event 0xb78ea0eaf11776732556ef6189312ceb60eab6b3177526b3a12d966e37be8162.
//
// Solidity: event VerifierUpdated(uint64 chainId, address verifier)
func (_TestSMT *TestSMTFilterer) ParseVerifierUpdated(log types.Log) (*TestSMTVerifierUpdated, error) {
	event := new(TestSMTVerifierUpdated)
	if err := _TestSMT.contract.UnpackLog(event, "VerifierUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TickBitmapMetaData contains all meta data concerning the TickBitmap contract.
var TickBitmapMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"}],\"name\":\"TickMisaligned\",\"type\":\"error\"}]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212208fbdf76d95acb28bf06a018ce600d7687585fd7839436ed10e31224f33b4466c64736f6c63430008140033",
}

// TickBitmapABI is the input ABI used to generate the binding from.
// Deprecated: Use TickBitmapMetaData.ABI instead.
var TickBitmapABI = TickBitmapMetaData.ABI

// TickBitmapBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use TickBitmapMetaData.Bin instead.
var TickBitmapBin = TickBitmapMetaData.Bin

// DeployTickBitmap deploys a new Ethereum contract, binding an instance of TickBitmap to it.
func DeployTickBitmap(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *TickBitmap, error) {
	parsed, err := TickBitmapMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(TickBitmapBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &TickBitmap{TickBitmapCaller: TickBitmapCaller{contract: contract}, TickBitmapTransactor: TickBitmapTransactor{contract: contract}, TickBitmapFilterer: TickBitmapFilterer{contract: contract}}, nil
}

// TickBitmap is an auto generated Go binding around an Ethereum contract.
type TickBitmap struct {
	TickBitmapCaller     // Read-only binding to the contract
	TickBitmapTransactor // Write-only binding to the contract
	TickBitmapFilterer   // Log filterer for contract events
}

// TickBitmapCaller is an auto generated read-only Go binding around an Ethereum contract.
type TickBitmapCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TickBitmapTransactor is an auto generated write-only Go binding around an Ethereum contract.
type TickBitmapTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TickBitmapFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type TickBitmapFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TickBitmapSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type TickBitmapSession struct {
	Contract     *TickBitmap       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// TickBitmapCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type TickBitmapCallerSession struct {
	Contract *TickBitmapCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// TickBitmapTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type TickBitmapTransactorSession struct {
	Contract     *TickBitmapTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// TickBitmapRaw is an auto generated low-level Go binding around an Ethereum contract.
type TickBitmapRaw struct {
	Contract *TickBitmap // Generic contract binding to access the raw methods on
}

// TickBitmapCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type TickBitmapCallerRaw struct {
	Contract *TickBitmapCaller // Generic read-only contract binding to access the raw methods on
}

// TickBitmapTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type TickBitmapTransactorRaw struct {
	Contract *TickBitmapTransactor // Generic write-only contract binding to access the raw methods on
}

// NewTickBitmap creates a new instance of TickBitmap, bound to a specific deployed contract.
func NewTickBitmap(address common.Address, backend bind.ContractBackend) (*TickBitmap, error) {
	contract, err := bindTickBitmap(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &TickBitmap{TickBitmapCaller: TickBitmapCaller{contract: contract}, TickBitmapTransactor: TickBitmapTransactor{contract: contract}, TickBitmapFilterer: TickBitmapFilterer{contract: contract}}, nil
}

// NewTickBitmapCaller creates a new read-only instance of TickBitmap, bound to a specific deployed contract.
func NewTickBitmapCaller(address common.Address, caller bind.ContractCaller) (*TickBitmapCaller, error) {
	contract, err := bindTickBitmap(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &TickBitmapCaller{contract: contract}, nil
}

// NewTickBitmapTransactor creates a new write-only instance of TickBitmap, bound to a specific deployed contract.
func NewTickBitmapTransactor(address common.Address, transactor bind.ContractTransactor) (*TickBitmapTransactor, error) {
	contract, err := bindTickBitmap(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &TickBitmapTransactor{contract: contract}, nil
}

// NewTickBitmapFilterer creates a new log filterer instance of TickBitmap, bound to a specific deployed contract.
func NewTickBitmapFilterer(address common.Address, filterer bind.ContractFilterer) (*TickBitmapFilterer, error) {
	contract, err := bindTickBitmap(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &TickBitmapFilterer{contract: contract}, nil
}

// bindTickBitmap binds a generic wrapper to an already deployed contract.
func bindTickBitmap(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := TickBitmapMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TickBitmap *TickBitmapRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TickBitmap.Contract.TickBitmapCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TickBitmap *TickBitmapRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TickBitmap.Contract.TickBitmapTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TickBitmap *TickBitmapRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TickBitmap.Contract.TickBitmapTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TickBitmap *TickBitmapCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TickBitmap.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TickBitmap *TickBitmapTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TickBitmap.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TickBitmap *TickBitmapTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TickBitmap.Contract.contract.Transact(opts, method, params...)
}

// TickMathMetaData contains all meta data concerning the TickMath contract.
var TickMathMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"InvalidSqrtRatio\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTick\",\"type\":\"error\"}]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212205772a8b338a83359a3f28220a5ee3b420f99c706f658d1ecd9777e86a692d54764736f6c63430008140033",
}

// TickMathABI is the input ABI used to generate the binding from.
// Deprecated: Use TickMathMetaData.ABI instead.
var TickMathABI = TickMathMetaData.ABI

// TickMathBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use TickMathMetaData.Bin instead.
var TickMathBin = TickMathMetaData.Bin

// DeployTickMath deploys a new Ethereum contract, binding an instance of TickMath to it.
func DeployTickMath(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *TickMath, error) {
	parsed, err := TickMathMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(TickMathBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &TickMath{TickMathCaller: TickMathCaller{contract: contract}, TickMathTransactor: TickMathTransactor{contract: contract}, TickMathFilterer: TickMathFilterer{contract: contract}}, nil
}

// TickMath is an auto generated Go binding around an Ethereum contract.
type TickMath struct {
	TickMathCaller     // Read-only binding to the contract
	TickMathTransactor // Write-only binding to the contract
	TickMathFilterer   // Log filterer for contract events
}

// TickMathCaller is an auto generated read-only Go binding around an Ethereum contract.
type TickMathCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TickMathTransactor is an auto generated write-only Go binding around an Ethereum contract.
type TickMathTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TickMathFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type TickMathFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TickMathSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type TickMathSession struct {
	Contract     *TickMath         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// TickMathCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type TickMathCallerSession struct {
	Contract *TickMathCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// TickMathTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type TickMathTransactorSession struct {
	Contract     *TickMathTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// TickMathRaw is an auto generated low-level Go binding around an Ethereum contract.
type TickMathRaw struct {
	Contract *TickMath // Generic contract binding to access the raw methods on
}

// TickMathCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type TickMathCallerRaw struct {
	Contract *TickMathCaller // Generic read-only contract binding to access the raw methods on
}

// TickMathTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type TickMathTransactorRaw struct {
	Contract *TickMathTransactor // Generic write-only contract binding to access the raw methods on
}

// NewTickMath creates a new instance of TickMath, bound to a specific deployed contract.
func NewTickMath(address common.Address, backend bind.ContractBackend) (*TickMath, error) {
	contract, err := bindTickMath(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &TickMath{TickMathCaller: TickMathCaller{contract: contract}, TickMathTransactor: TickMathTransactor{contract: contract}, TickMathFilterer: TickMathFilterer{contract: contract}}, nil
}

// NewTickMathCaller creates a new read-only instance of TickMath, bound to a specific deployed contract.
func NewTickMathCaller(address common.Address, caller bind.ContractCaller) (*TickMathCaller, error) {
	contract, err := bindTickMath(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &TickMathCaller{contract: contract}, nil
}

// NewTickMathTransactor creates a new write-only instance of TickMath, bound to a specific deployed contract.
func NewTickMathTransactor(address common.Address, transactor bind.ContractTransactor) (*TickMathTransactor, error) {
	contract, err := bindTickMath(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &TickMathTransactor{contract: contract}, nil
}

// NewTickMathFilterer creates a new log filterer instance of TickMath, bound to a specific deployed contract.
func NewTickMathFilterer(address common.Address, filterer bind.ContractFilterer) (*TickMathFilterer, error) {
	contract, err := bindTickMath(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &TickMathFilterer{contract: contract}, nil
}

// bindTickMath binds a generic wrapper to an already deployed contract.
func bindTickMath(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := TickMathMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TickMath *TickMathRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TickMath.Contract.TickMathCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TickMath *TickMathRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TickMath.Contract.TickMathTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TickMath *TickMathRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TickMath.Contract.TickMathTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TickMath *TickMathCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TickMath.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TickMath *TickMathTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TickMath.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TickMath *TickMathTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TickMath.Contract.contract.Transact(opts, method, params...)
}

// TierFactoryMetaData contains all meta data concerning the TierFactory contract.
var TierFactoryMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"TargetPrefix\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_FLAG_MASK\",\"outputs\":[{\"internalType\":\"uint160\",\"name\":\"\",\"type\":\"uint160\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIPoolManager\",\"name\":\"poolManager\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIPoolManager\",\"name\":\"poolManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startSalt\",\"type\":\"uint256\"}],\"name\":\"mineDeploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIPoolManager\",\"name\":\"poolManager\",\"type\":\"address\"}],\"name\":\"mineDeploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIPoolManager\",\"name\":\"poolManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startSalt\",\"type\":\"uint256\"}],\"name\":\"mineSalt\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractTierHook\",\"name\":\"_tierHook\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sumVolumeAddress\",\"type\":\"address\"}],\"name\":\"updateHookSumVolumeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x60a08060405234610079576021609a1b6080525f8054336001600160a01b0319821681178355916001600160a01b03909116907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09080a3611630908161007e823960805181818161026b0152818161042b01526105720152f35b5f80fdfe6040608081526004361015610012575f80fd5b5f90813560e01c806321cde3ec146103bf5780632e026a671461038857806332c02a1414610350578063635d401714610321578063715018a6146102b45780638da5cb5b1461028f578063a707b18a1461024c578063c6f614631461022e57828163d8f4720114610179575063f2fde38b1461008c575f80fd5b34610175576020366003190112610175576100a56103f2565b6001600160a01b0380916100bd828654163314610763565b1691821561010c57505f548273ffffffffffffffffffffffffffffffffffffffff198216175f55167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a380f35b5162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608490fd5b5080fd5b80833461022b578060031936011261022b576004356001600160a01b03908181168091036102225760243591808316809303610227576101bd908554163314610763565b803b15610222576024849284519586938492630221016d60e31b845260048401525af18015610218576101ee578280f35b67ffffffffffffffff8211610204575281808280f35b634e487b7160e01b83526041600452602483fd5b81513d85823e3d90fd5b505050fd5b8480fd5b50fd5b50346101755781600319360112610175576020905160ff60981b8152f35b5034610175578160031936011261017557602090516001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000168152f35b50346101755781600319360112610175576001600160a01b0360209254169051908152f35b823461031e578060031936011261031e5780805473ffffffffffffffffffffffffffffffffffffffff196001600160a01b038216916102f4338414610763565b1682557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b80fd5b50346101755780600319360112610175576020906103496103406103f2565b60243590610546565b9051908152f35b50346101755780600319360112610175576020906001600160a01b036103806103776103f2565b602435906106eb565b915191168152f35b5034610175576020366003190112610175576020906001600160a01b036103806103b06103f2565b6103b98161040c565b906106eb565b50346101755780600319360112610175576020906001600160a01b036103806103e66103f2565b6103b960243582610546565b600435906001600160a01b038216820361040857565b5f80fd5b5f610e4c906020928383016107af903060601b926001600160a01b03807f000000000000000000000000000000000000000000000000000000000000000016955b6103e8811061049b5760405162461bcd60e51b8152600481018a9052601560248201527f4661696c656420746f2066696e6420612073616c7400000000000000000000006044820152606490fd5b8660ff60981b8a8a6104e76104fb6040938451936104b98c866106c9565b8085528c828601396104ed85518a8c16838201528281526104d98161067d565b86519485938401809761073a565b9061073a565b03601f1981018352826106c9565b51902090518c81019160ff60f81b83528a6021830152856035830152605590818301528152610529816106ad565b519020161461053a5760010161044d565b97505050505050505090565b906103e881019081811161066957610e4c6020938482016107af913060601b936001600160a01b0390817f000000000000000000000000000000000000000000000000000000000000000016965b8881106105e05760405162461bcd60e51b8152600481018b9052601560248201527f4661696c656420746f2066696e6420612073616c7400000000000000000000006044820152606490fd5b8760ff60981b60408c6104e761061d8351926105fc8c856106c9565b888452888d828601396104ed85518b8d16838201528281526104d98161067d565b51902090518d81019160ff60f81b83528b602183015285603583015260559081830152815261064b816106ad565b519020161461065c57600101610594565b9850505050505050505090565b634e487b7160e01b5f52601160045260245ffd5b6040810190811067ffffffffffffffff82111761069957604052565b634e487b7160e01b5f52604160045260245ffd5b6080810190811067ffffffffffffffff82111761069957604052565b90601f8019910116810190811067ffffffffffffffff82111761069957604052565b90604051610e4c8082019082821067ffffffffffffffff8311176106995760209183916107af83396001600160a01b0380961681520301905ff5801561072f571690565b6040513d5f823e3d90fd5b908151915f5b838110610750575050015f815290565b8060208092840101518185015201610740565b1561076a57565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fdfe60a034620001f657601f62000e4c38819003918201601f19168301916001600160401b03831184841017620001fa57808492602094604052833981010312620001f657516001600160a01b03908181168103620001f6575f8054336001600160a01b03198216811783559193167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08480a36080528060e0620000a06200020e565b8281528260208201528260408201528260608201528260808201528260a08201528260c0820152015260e0620000d56200020e565b60018152826020820152826040820152826060820152826080820152600160a08201528260c082015201526001609f1b30161515600114801590620001e6575b8015620001d6575b8015620001c6575b8015620001b6575b8015620001a2575b801562000192575b801562000182575b6200016a57604051610c1c908162000230823960805181818161023101526103fd0152f35b604051630732d7b560e51b8152306004820152602490fd5b5030600160981b16151562000145565b5030600160991b1615156200013d565b50306001609a1b1615156001141562000135565b50306001609b1b1615156200012d565b50306001609c1b16151562000125565b50306001609d1b1615156200011d565b50306001609e1b16151562000115565b5f80fd5b634e487b7160e01b5f52604160045260245ffd5b6040519061010082016001600160401b03811183821017620001fa5760405256fe60406080815260049081361015610014575f80fd5b5f803560e01c806311080b68146107c8578063229c7d8b146107a05780632ab7a3e21461077b57806330b7cdef146107585780633440d820146106ce57806339dfff16146106b2578063575e24b4146106a25780635ae4ce5814610684578063612c39b7146105b4578063715018a61461054a5780638da5cb5b1461052457806390f57fc1146104f2578063a910f80f14610484578063ab6291fe146103c0578063b47b2fb114610259578063b6a8b0fa1461020c578063dc4c90d314610211578063e1b4af691461020c578063f2fde38b1461011d5763fe9a6f45146100f9575f80fd5b3461011a5750610108366108a3565b505050505051630a85dc2960e01b8152fd5b80fd5b50913461020857602036600319011261020857610138610847565b908354906001600160a01b0380831693610153338614610ad3565b1693841561019f57505073ffffffffffffffffffffffffffffffffffffffff1916821783557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b906020608492519162461bcd60e51b8352820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152fd5b8280fd5b610981565b509034610255578160031936011261025557602090516001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000168152f35b5080fd5b503461011a5761026836610907565b505092505060a08136031261020857835167ffffffffffffffff9360a08201858111838210176103ad57865261029d83610861565b918281526102ad60208501610861565b9360208201948552878101359062ffffff80831683036103a9578984019283526060820135918260020b83036103a557608090606086019384520135926001600160a01b039485851685036103a157608001938452848b51988160208b019916895251168b890152511660608701525160020b6080860152511660a084015260a0835260c08301948386109086111761038e57506020955060e09084865282519020928060801d8552600f0b9101527f6e78eb77321ff667248e786162a80dcc8c37e03953a73757e24aeba9ba881bee833293a35163b47b2fb160e01b8152f35b634e487b7160e01b815260418752602490fd5b8680fd5b8580fd5b8480fd5b634e487b7160e01b825260418852602482fd5b503461011a576020928360031936011261025557803567ffffffffffffffff8111610208576103f29036908301610875565b916001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163303610476575061043084928692610a39565b82519382859384528251928382860152825b84811061046057505050828201840152601f01601f19168101030190f35b8181018301518882018801528795508201610442565b845163570c108560e11b8152fd5b503461011a5761012036600319011261011a5761049f610847565b5060a036602319011261011a576104b461096b565b5060e4358060020b0361011a57610104359067ffffffffffffffff821161011a57506104e39036908401610875565b505051630a85dc2960e01b8152fd5b5090346102555760203660031901126102555760209062ffffff61051c610517610847565b610b1e565b915191168152f35b5090346102555781600319360112610255576001600160a01b0360209254169051908152f35b503461011a578060031936011261011a5780805473ffffffffffffffffffffffffffffffffffffffff196001600160a01b0382169161058a338414610ad3565b1682557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b509034610255578160031936011261025557816101009260e083516105d8816109e6565b82815282602082015282858201528260608201528260808201528260a08201528260c08201520152815161060b816109e6565b6001815260208101928284528082019083825260608301848152608084019185835260a08501936001855260e060c087019688885201968752815197600189525115156020890152511515908701525115156060860152511515608085015251151560a084015251151560c083015251151560e0820152f35b5090346102555760a036600319011261025557602090516155338152f35b503461011a5750610108366108a3565b5090346102555760a03660031901126102555751908152602090f35b503461011a5761010036600319011261011a576106e9610847565b5060a036602319011261011a576106fe61096b565b5060e43567ffffffffffffffff81116102555761071e9036908501610875565b50506064359062ffffff8216820361011a575062800000161561074b57516301a206c160e51b8152602090f35b516315b3d69f60e31b8152fd5b503461011a575061076836610907565b50505050505051630a85dc2960e01b8152fd5b5090346102555760209061078e366108a3565b505050505062ffffff61051c32610b1e565b5090346102555781600319360112610255576020906001600160a01b03600154169051908152f35b5090346102555760203660031901126102555760207fa7f1d21617374882d6d2a29f886042bc73207e68d82e84a98231e74fcf6c111a91610807610847565b6001600160a01b039061081e828754163314610ad3565b16908173ffffffffffffffffffffffffffffffffffffffff19600154161760015551908152a180f35b600435906001600160a01b038216820361085d57565b5f80fd5b35906001600160a01b038216820361085d57565b9181601f8401121561085d5782359167ffffffffffffffff831161085d576020838186019501011161085d57565b9061014060031983011261085d576004356001600160a01b038116810361085d579160a060231982011261085d57602491606060c31983011261085d5760c491610124359067ffffffffffffffff821161085d5761090391600401610875565b9091565b61016060031982011261085d576004356001600160a01b038116810361085d579160a060231983011261085d57602491606060c31982011261085d5760c4916101243591610144359067ffffffffffffffff821161085d5761090391600401610875565b60c435906001600160a01b038216820361085d57565b3461085d5761012036600319011261085d576004356001600160a01b0381160361085d5760a036602319011261085d576101043567ffffffffffffffff811161085d576109d2903690600401610875565b5050604051630a85dc2960e01b8152600490fd5b610100810190811067ffffffffffffffff821117610a0357604052565b634e487b7160e01b5f52604160045260245ffd5b90601f8019910116810190811067ffffffffffffffff821117610a0357604052565b604051929183918190833781015f9384928284809452039082305af13d15610aca573d67ffffffffffffffff8111610ab65760405190610a83601f8201601f191660200183610a17565b8152809360203d92013e5b610ab45750805115610aa257602081519101fd5b6040516314815f4760e31b8152600490fd5b565b634e487b7160e01b84526041600452602484fd5b60609250610a8e565b15610ada57565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b610b2790610b50565b6127109060028103610b3f575060011c627fffff1690565b600114610b495790565b50611f4090565b60206001600160a01b036024816001541693604051948593849263950650c160e01b84521660048301525afa908115610bdb575f91610baa575b50633b9aca00811115610b9d5750600290565b610ba5575f90565b600190565b906020823d8211610bd3575b81610bc360209383610a17565b8101031261011a5750515f610b8a565b3d9150610bb6565b6040513d5f823e3d90fdfea2646970667358221220673bf1524ffc00f66529d5dd7f43405b436ec5b637069ebc4b748729dc3fda6564736f6c63430008140033a2646970667358221220fdf47fdbe6077efdd49c6199e3ed5555ccd1539a383d1995e69b2713dadfe72864736f6c63430008140033",
}

// TierFactoryABI is the input ABI used to generate the binding from.
// Deprecated: Use TierFactoryMetaData.ABI instead.
var TierFactoryABI = TierFactoryMetaData.ABI

// TierFactoryBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use TierFactoryMetaData.Bin instead.
var TierFactoryBin = TierFactoryMetaData.Bin

// DeployTierFactory deploys a new Ethereum contract, binding an instance of TierFactory to it.
func DeployTierFactory(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *TierFactory, error) {
	parsed, err := TierFactoryMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(TierFactoryBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &TierFactory{TierFactoryCaller: TierFactoryCaller{contract: contract}, TierFactoryTransactor: TierFactoryTransactor{contract: contract}, TierFactoryFilterer: TierFactoryFilterer{contract: contract}}, nil
}

// TierFactory is an auto generated Go binding around an Ethereum contract.
type TierFactory struct {
	TierFactoryCaller     // Read-only binding to the contract
	TierFactoryTransactor // Write-only binding to the contract
	TierFactoryFilterer   // Log filterer for contract events
}

// TierFactoryCaller is an auto generated read-only Go binding around an Ethereum contract.
type TierFactoryCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TierFactoryTransactor is an auto generated write-only Go binding around an Ethereum contract.
type TierFactoryTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TierFactoryFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type TierFactoryFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TierFactorySession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type TierFactorySession struct {
	Contract     *TierFactory      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// TierFactoryCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type TierFactoryCallerSession struct {
	Contract *TierFactoryCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// TierFactoryTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type TierFactoryTransactorSession struct {
	Contract     *TierFactoryTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// TierFactoryRaw is an auto generated low-level Go binding around an Ethereum contract.
type TierFactoryRaw struct {
	Contract *TierFactory // Generic contract binding to access the raw methods on
}

// TierFactoryCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type TierFactoryCallerRaw struct {
	Contract *TierFactoryCaller // Generic read-only contract binding to access the raw methods on
}

// TierFactoryTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type TierFactoryTransactorRaw struct {
	Contract *TierFactoryTransactor // Generic write-only contract binding to access the raw methods on
}

// NewTierFactory creates a new instance of TierFactory, bound to a specific deployed contract.
func NewTierFactory(address common.Address, backend bind.ContractBackend) (*TierFactory, error) {
	contract, err := bindTierFactory(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &TierFactory{TierFactoryCaller: TierFactoryCaller{contract: contract}, TierFactoryTransactor: TierFactoryTransactor{contract: contract}, TierFactoryFilterer: TierFactoryFilterer{contract: contract}}, nil
}

// NewTierFactoryCaller creates a new read-only instance of TierFactory, bound to a specific deployed contract.
func NewTierFactoryCaller(address common.Address, caller bind.ContractCaller) (*TierFactoryCaller, error) {
	contract, err := bindTierFactory(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &TierFactoryCaller{contract: contract}, nil
}

// NewTierFactoryTransactor creates a new write-only instance of TierFactory, bound to a specific deployed contract.
func NewTierFactoryTransactor(address common.Address, transactor bind.ContractTransactor) (*TierFactoryTransactor, error) {
	contract, err := bindTierFactory(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &TierFactoryTransactor{contract: contract}, nil
}

// NewTierFactoryFilterer creates a new log filterer instance of TierFactory, bound to a specific deployed contract.
func NewTierFactoryFilterer(address common.Address, filterer bind.ContractFilterer) (*TierFactoryFilterer, error) {
	contract, err := bindTierFactory(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &TierFactoryFilterer{contract: contract}, nil
}

// bindTierFactory binds a generic wrapper to an already deployed contract.
func bindTierFactory(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := TierFactoryMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TierFactory *TierFactoryRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TierFactory.Contract.TierFactoryCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TierFactory *TierFactoryRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TierFactory.Contract.TierFactoryTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TierFactory *TierFactoryRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TierFactory.Contract.TierFactoryTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TierFactory *TierFactoryCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TierFactory.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TierFactory *TierFactoryTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TierFactory.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TierFactory *TierFactoryTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TierFactory.Contract.contract.Transact(opts, method, params...)
}

// TargetPrefix is a free data retrieval call binding the contract method 0xa707b18a.
//
// Solidity: function TargetPrefix() view returns(address)
func (_TierFactory *TierFactoryCaller) TargetPrefix(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _TierFactory.contract.Call(opts, &out, "TargetPrefix")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// TargetPrefix is a free data retrieval call binding the contract method 0xa707b18a.
//
// Solidity: function TargetPrefix() view returns(address)
func (_TierFactory *TierFactorySession) TargetPrefix() (common.Address, error) {
	return _TierFactory.Contract.TargetPrefix(&_TierFactory.CallOpts)
}

// TargetPrefix is a free data retrieval call binding the contract method 0xa707b18a.
//
// Solidity: function TargetPrefix() view returns(address)
func (_TierFactory *TierFactoryCallerSession) TargetPrefix() (common.Address, error) {
	return _TierFactory.Contract.TargetPrefix(&_TierFactory.CallOpts)
}

// UNISWAPFLAGMASK is a free data retrieval call binding the contract method 0xc6f61463.
//
// Solidity: function UNISWAP_FLAG_MASK() view returns(uint160)
func (_TierFactory *TierFactoryCaller) UNISWAPFLAGMASK(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _TierFactory.contract.Call(opts, &out, "UNISWAP_FLAG_MASK")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// UNISWAPFLAGMASK is a free data retrieval call binding the contract method 0xc6f61463.
//
// Solidity: function UNISWAP_FLAG_MASK() view returns(uint160)
func (_TierFactory *TierFactorySession) UNISWAPFLAGMASK() (*big.Int, error) {
	return _TierFactory.Contract.UNISWAPFLAGMASK(&_TierFactory.CallOpts)
}

// UNISWAPFLAGMASK is a free data retrieval call binding the contract method 0xc6f61463.
//
// Solidity: function UNISWAP_FLAG_MASK() view returns(uint160)
func (_TierFactory *TierFactoryCallerSession) UNISWAPFLAGMASK() (*big.Int, error) {
	return _TierFactory.Contract.UNISWAPFLAGMASK(&_TierFactory.CallOpts)
}

// MineSalt is a free data retrieval call binding the contract method 0x635d4017.
//
// Solidity: function mineSalt(address poolManager, uint256 startSalt) view returns(bytes32 salt)
func (_TierFactory *TierFactoryCaller) MineSalt(opts *bind.CallOpts, poolManager common.Address, startSalt *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _TierFactory.contract.Call(opts, &out, "mineSalt", poolManager, startSalt)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// MineSalt is a free data retrieval call binding the contract method 0x635d4017.
//
// Solidity: function mineSalt(address poolManager, uint256 startSalt) view returns(bytes32 salt)
func (_TierFactory *TierFactorySession) MineSalt(poolManager common.Address, startSalt *big.Int) ([32]byte, error) {
	return _TierFactory.Contract.MineSalt(&_TierFactory.CallOpts, poolManager, startSalt)
}

// MineSalt is a free data retrieval call binding the contract method 0x635d4017.
//
// Solidity: function mineSalt(address poolManager, uint256 startSalt) view returns(bytes32 salt)
func (_TierFactory *TierFactoryCallerSession) MineSalt(poolManager common.Address, startSalt *big.Int) ([32]byte, error) {
	return _TierFactory.Contract.MineSalt(&_TierFactory.CallOpts, poolManager, startSalt)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TierFactory *TierFactoryCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _TierFactory.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TierFactory *TierFactorySession) Owner() (common.Address, error) {
	return _TierFactory.Contract.Owner(&_TierFactory.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TierFactory *TierFactoryCallerSession) Owner() (common.Address, error) {
	return _TierFactory.Contract.Owner(&_TierFactory.CallOpts)
}

// Deploy is a paid mutator transaction binding the contract method 0x32c02a14.
//
// Solidity: function deploy(address poolManager, bytes32 salt) returns(address)
func (_TierFactory *TierFactoryTransactor) Deploy(opts *bind.TransactOpts, poolManager common.Address, salt [32]byte) (*types.Transaction, error) {
	return _TierFactory.contract.Transact(opts, "deploy", poolManager, salt)
}

// Deploy is a paid mutator transaction binding the contract method 0x32c02a14.
//
// Solidity: function deploy(address poolManager, bytes32 salt) returns(address)
func (_TierFactory *TierFactorySession) Deploy(poolManager common.Address, salt [32]byte) (*types.Transaction, error) {
	return _TierFactory.Contract.Deploy(&_TierFactory.TransactOpts, poolManager, salt)
}

// Deploy is a paid mutator transaction binding the contract method 0x32c02a14.
//
// Solidity: function deploy(address poolManager, bytes32 salt) returns(address)
func (_TierFactory *TierFactoryTransactorSession) Deploy(poolManager common.Address, salt [32]byte) (*types.Transaction, error) {
	return _TierFactory.Contract.Deploy(&_TierFactory.TransactOpts, poolManager, salt)
}

// MineDeploy is a paid mutator transaction binding the contract method 0x21cde3ec.
//
// Solidity: function mineDeploy(address poolManager, uint256 startSalt) returns(address)
func (_TierFactory *TierFactoryTransactor) MineDeploy(opts *bind.TransactOpts, poolManager common.Address, startSalt *big.Int) (*types.Transaction, error) {
	return _TierFactory.contract.Transact(opts, "mineDeploy", poolManager, startSalt)
}

// MineDeploy is a paid mutator transaction binding the contract method 0x21cde3ec.
//
// Solidity: function mineDeploy(address poolManager, uint256 startSalt) returns(address)
func (_TierFactory *TierFactorySession) MineDeploy(poolManager common.Address, startSalt *big.Int) (*types.Transaction, error) {
	return _TierFactory.Contract.MineDeploy(&_TierFactory.TransactOpts, poolManager, startSalt)
}

// MineDeploy is a paid mutator transaction binding the contract method 0x21cde3ec.
//
// Solidity: function mineDeploy(address poolManager, uint256 startSalt) returns(address)
func (_TierFactory *TierFactoryTransactorSession) MineDeploy(poolManager common.Address, startSalt *big.Int) (*types.Transaction, error) {
	return _TierFactory.Contract.MineDeploy(&_TierFactory.TransactOpts, poolManager, startSalt)
}

// MineDeploy0 is a paid mutator transaction binding the contract method 0x2e026a67.
//
// Solidity: function mineDeploy(address poolManager) returns(address)
func (_TierFactory *TierFactoryTransactor) MineDeploy0(opts *bind.TransactOpts, poolManager common.Address) (*types.Transaction, error) {
	return _TierFactory.contract.Transact(opts, "mineDeploy0", poolManager)
}

// MineDeploy0 is a paid mutator transaction binding the contract method 0x2e026a67.
//
// Solidity: function mineDeploy(address poolManager) returns(address)
func (_TierFactory *TierFactorySession) MineDeploy0(poolManager common.Address) (*types.Transaction, error) {
	return _TierFactory.Contract.MineDeploy0(&_TierFactory.TransactOpts, poolManager)
}

// MineDeploy0 is a paid mutator transaction binding the contract method 0x2e026a67.
//
// Solidity: function mineDeploy(address poolManager) returns(address)
func (_TierFactory *TierFactoryTransactorSession) MineDeploy0(poolManager common.Address) (*types.Transaction, error) {
	return _TierFactory.Contract.MineDeploy0(&_TierFactory.TransactOpts, poolManager)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_TierFactory *TierFactoryTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TierFactory.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_TierFactory *TierFactorySession) RenounceOwnership() (*types.Transaction, error) {
	return _TierFactory.Contract.RenounceOwnership(&_TierFactory.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_TierFactory *TierFactoryTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _TierFactory.Contract.RenounceOwnership(&_TierFactory.TransactOpts)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TierFactory *TierFactoryTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _TierFactory.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TierFactory *TierFactorySession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _TierFactory.Contract.TransferOwnership(&_TierFactory.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TierFactory *TierFactoryTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _TierFactory.Contract.TransferOwnership(&_TierFactory.TransactOpts, newOwner)
}

// UpdateHookSumVolumeAddress is a paid mutator transaction binding the contract method 0xd8f47201.
//
// Solidity: function updateHookSumVolumeAddress(address _tierHook, address _sumVolumeAddress) returns()
func (_TierFactory *TierFactoryTransactor) UpdateHookSumVolumeAddress(opts *bind.TransactOpts, _tierHook common.Address, _sumVolumeAddress common.Address) (*types.Transaction, error) {
	return _TierFactory.contract.Transact(opts, "updateHookSumVolumeAddress", _tierHook, _sumVolumeAddress)
}

// UpdateHookSumVolumeAddress is a paid mutator transaction binding the contract method 0xd8f47201.
//
// Solidity: function updateHookSumVolumeAddress(address _tierHook, address _sumVolumeAddress) returns()
func (_TierFactory *TierFactorySession) UpdateHookSumVolumeAddress(_tierHook common.Address, _sumVolumeAddress common.Address) (*types.Transaction, error) {
	return _TierFactory.Contract.UpdateHookSumVolumeAddress(&_TierFactory.TransactOpts, _tierHook, _sumVolumeAddress)
}

// UpdateHookSumVolumeAddress is a paid mutator transaction binding the contract method 0xd8f47201.
//
// Solidity: function updateHookSumVolumeAddress(address _tierHook, address _sumVolumeAddress) returns()
func (_TierFactory *TierFactoryTransactorSession) UpdateHookSumVolumeAddress(_tierHook common.Address, _sumVolumeAddress common.Address) (*types.Transaction, error) {
	return _TierFactory.Contract.UpdateHookSumVolumeAddress(&_TierFactory.TransactOpts, _tierHook, _sumVolumeAddress)
}

// TierFactoryOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the TierFactory contract.
type TierFactoryOwnershipTransferredIterator struct {
	Event *TierFactoryOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TierFactoryOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TierFactoryOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TierFactoryOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TierFactoryOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TierFactoryOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TierFactoryOwnershipTransferred represents a OwnershipTransferred event raised by the TierFactory contract.
type TierFactoryOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TierFactory *TierFactoryFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*TierFactoryOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _TierFactory.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &TierFactoryOwnershipTransferredIterator{contract: _TierFactory.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TierFactory *TierFactoryFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *TierFactoryOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _TierFactory.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TierFactoryOwnershipTransferred)
				if err := _TierFactory.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TierFactory *TierFactoryFilterer) ParseOwnershipTransferred(log types.Log) (*TierFactoryOwnershipTransferred, error) {
	event := new(TierFactoryOwnershipTransferred)
	if err := _TierFactory.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TierHookMetaData contains all meta data concerning the TierHook contract.
var TierHookMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"contractIPoolManager\",\"name\":\"_poolManager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hooks\",\"type\":\"address\"}],\"name\":\"HookAddressNotValid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HookNotImplemented\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPool\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LockFailure\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MustUseDynamicFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotPoolManager\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotSelf\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"PoolId\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int128\",\"name\":\"amount0\",\"type\":\"int128\"},{\"indexed\":false,\"internalType\":\"int128\",\"name\":\"amount1\",\"type\":\"int128\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"UpdateSumVolumeAddress\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"afterDonate\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint160\",\"name\":\"\",\"type\":\"uint160\"},{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"afterInitialize\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"int256\",\"name\":\"liquidityDelta\",\"type\":\"int256\"}],\"internalType\":\"structIPoolManager.ModifyPositionParams\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"BalanceDelta\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"afterModifyPosition\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"zeroForOne\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"amountSpecified\",\"type\":\"int256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"structIPoolManager.SwapParams\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"BalanceDelta\",\"name\":\"delta\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"afterSwap\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"beforeDonate\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"internalType\":\"uint160\",\"name\":\"\",\"type\":\"uint160\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"beforeInitialize\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"int256\",\"name\":\"liquidityDelta\",\"type\":\"int256\"}],\"internalType\":\"structIPoolManager.ModifyPositionParams\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"beforeModifyPosition\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"zeroForOne\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"amountSpecified\",\"type\":\"int256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"structIPoolManager.SwapParams\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"beforeSwap\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"zeroForOne\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"amountSpecified\",\"type\":\"int256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"structIPoolManager.SwapParams\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"getFee\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"swapper\",\"type\":\"address\"}],\"name\":\"getFeeBySwapper\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"\",\"type\":\"tuple\"}],\"name\":\"getHookFees\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"Currency\",\"name\":\"currency0\",\"type\":\"address\"},{\"internalType\":\"Currency\",\"name\":\"currency1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"internalType\":\"contractIHooks\",\"name\":\"hooks\",\"type\":\"address\"}],\"internalType\":\"structPoolKey\",\"name\":\"key\",\"type\":\"tuple\"}],\"name\":\"getHookWithdrawFee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"fee\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHooksCalls\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"beforeInitialize\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"afterInitialize\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"beforeModifyPosition\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"afterModifyPosition\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"beforeSwap\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"afterSwap\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"beforeDonate\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"afterDonate\",\"type\":\"bool\"}],\"internalType\":\"structHooks.Calls\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"lockAcquired\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolManager\",\"outputs\":[{\"internalType\":\"contractIPoolManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sumVolumeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sumVolumeAddress\",\"type\":\"address\"}],\"name\":\"updateSumVolumeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x60a034620001f657601f62000e4c38819003918201601f19168301916001600160401b03831184841017620001fa57808492602094604052833981010312620001f657516001600160a01b03908181168103620001f6575f8054336001600160a01b03198216811783559193167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08480a36080528060e0620000a06200020e565b8281528260208201528260408201528260608201528260808201528260a08201528260c0820152015260e0620000d56200020e565b60018152826020820152826040820152826060820152826080820152600160a08201528260c082015201526001609f1b30161515600114801590620001e6575b8015620001d6575b8015620001c6575b8015620001b6575b8015620001a2575b801562000192575b801562000182575b6200016a57604051610c1c908162000230823960805181818161023101526103fd0152f35b604051630732d7b560e51b8152306004820152602490fd5b5030600160981b16151562000145565b5030600160991b1615156200013d565b50306001609a1b1615156001141562000135565b50306001609b1b1615156200012d565b50306001609c1b16151562000125565b50306001609d1b1615156200011d565b50306001609e1b16151562000115565b5f80fd5b634e487b7160e01b5f52604160045260245ffd5b6040519061010082016001600160401b03811183821017620001fa5760405256fe60406080815260049081361015610014575f80fd5b5f803560e01c806311080b68146107c8578063229c7d8b146107a05780632ab7a3e21461077b57806330b7cdef146107585780633440d820146106ce57806339dfff16146106b2578063575e24b4146106a25780635ae4ce5814610684578063612c39b7146105b4578063715018a61461054a5780638da5cb5b1461052457806390f57fc1146104f2578063a910f80f14610484578063ab6291fe146103c0578063b47b2fb114610259578063b6a8b0fa1461020c578063dc4c90d314610211578063e1b4af691461020c578063f2fde38b1461011d5763fe9a6f45146100f9575f80fd5b3461011a5750610108366108a3565b505050505051630a85dc2960e01b8152fd5b80fd5b50913461020857602036600319011261020857610138610847565b908354906001600160a01b0380831693610153338614610ad3565b1693841561019f57505073ffffffffffffffffffffffffffffffffffffffff1916821783557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b906020608492519162461bcd60e51b8352820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152fd5b8280fd5b610981565b509034610255578160031936011261025557602090516001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000168152f35b5080fd5b503461011a5761026836610907565b505092505060a08136031261020857835167ffffffffffffffff9360a08201858111838210176103ad57865261029d83610861565b918281526102ad60208501610861565b9360208201948552878101359062ffffff80831683036103a9578984019283526060820135918260020b83036103a557608090606086019384520135926001600160a01b039485851685036103a157608001938452848b51988160208b019916895251168b890152511660608701525160020b6080860152511660a084015260a0835260c08301948386109086111761038e57506020955060e09084865282519020928060801d8552600f0b9101527f6e78eb77321ff667248e786162a80dcc8c37e03953a73757e24aeba9ba881bee833293a35163b47b2fb160e01b8152f35b634e487b7160e01b815260418752602490fd5b8680fd5b8580fd5b8480fd5b634e487b7160e01b825260418852602482fd5b503461011a576020928360031936011261025557803567ffffffffffffffff8111610208576103f29036908301610875565b916001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163303610476575061043084928692610a39565b82519382859384528251928382860152825b84811061046057505050828201840152601f01601f19168101030190f35b8181018301518882018801528795508201610442565b845163570c108560e11b8152fd5b503461011a5761012036600319011261011a5761049f610847565b5060a036602319011261011a576104b461096b565b5060e4358060020b0361011a57610104359067ffffffffffffffff821161011a57506104e39036908401610875565b505051630a85dc2960e01b8152fd5b5090346102555760203660031901126102555760209062ffffff61051c610517610847565b610b1e565b915191168152f35b5090346102555781600319360112610255576001600160a01b0360209254169051908152f35b503461011a578060031936011261011a5780805473ffffffffffffffffffffffffffffffffffffffff196001600160a01b0382169161058a338414610ad3565b1682557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b509034610255578160031936011261025557816101009260e083516105d8816109e6565b82815282602082015282858201528260608201528260808201528260a08201528260c08201520152815161060b816109e6565b6001815260208101928284528082019083825260608301848152608084019185835260a08501936001855260e060c087019688885201968752815197600189525115156020890152511515908701525115156060860152511515608085015251151560a084015251151560c083015251151560e0820152f35b5090346102555760a036600319011261025557602090516155338152f35b503461011a5750610108366108a3565b5090346102555760a03660031901126102555751908152602090f35b503461011a5761010036600319011261011a576106e9610847565b5060a036602319011261011a576106fe61096b565b5060e43567ffffffffffffffff81116102555761071e9036908501610875565b50506064359062ffffff8216820361011a575062800000161561074b57516301a206c160e51b8152602090f35b516315b3d69f60e31b8152fd5b503461011a575061076836610907565b50505050505051630a85dc2960e01b8152fd5b5090346102555760209061078e366108a3565b505050505062ffffff61051c32610b1e565b5090346102555781600319360112610255576020906001600160a01b03600154169051908152f35b5090346102555760203660031901126102555760207fa7f1d21617374882d6d2a29f886042bc73207e68d82e84a98231e74fcf6c111a91610807610847565b6001600160a01b039061081e828754163314610ad3565b16908173ffffffffffffffffffffffffffffffffffffffff19600154161760015551908152a180f35b600435906001600160a01b038216820361085d57565b5f80fd5b35906001600160a01b038216820361085d57565b9181601f8401121561085d5782359167ffffffffffffffff831161085d576020838186019501011161085d57565b9061014060031983011261085d576004356001600160a01b038116810361085d579160a060231982011261085d57602491606060c31983011261085d5760c491610124359067ffffffffffffffff821161085d5761090391600401610875565b9091565b61016060031982011261085d576004356001600160a01b038116810361085d579160a060231983011261085d57602491606060c31982011261085d5760c4916101243591610144359067ffffffffffffffff821161085d5761090391600401610875565b60c435906001600160a01b038216820361085d57565b3461085d5761012036600319011261085d576004356001600160a01b0381160361085d5760a036602319011261085d576101043567ffffffffffffffff811161085d576109d2903690600401610875565b5050604051630a85dc2960e01b8152600490fd5b610100810190811067ffffffffffffffff821117610a0357604052565b634e487b7160e01b5f52604160045260245ffd5b90601f8019910116810190811067ffffffffffffffff821117610a0357604052565b604051929183918190833781015f9384928284809452039082305af13d15610aca573d67ffffffffffffffff8111610ab65760405190610a83601f8201601f191660200183610a17565b8152809360203d92013e5b610ab45750805115610aa257602081519101fd5b6040516314815f4760e31b8152600490fd5b565b634e487b7160e01b84526041600452602484fd5b60609250610a8e565b15610ada57565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b610b2790610b50565b6127109060028103610b3f575060011c627fffff1690565b600114610b495790565b50611f4090565b60206001600160a01b036024816001541693604051948593849263950650c160e01b84521660048301525afa908115610bdb575f91610baa575b50633b9aca00811115610b9d5750600290565b610ba5575f90565b600190565b906020823d8211610bd3575b81610bc360209383610a17565b8101031261011a5750515f610b8a565b3d9150610bb6565b6040513d5f823e3d90fdfea2646970667358221220673bf1524ffc00f66529d5dd7f43405b436ec5b637069ebc4b748729dc3fda6564736f6c63430008140033",
}

// TierHookABI is the input ABI used to generate the binding from.
// Deprecated: Use TierHookMetaData.ABI instead.
var TierHookABI = TierHookMetaData.ABI

// TierHookBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use TierHookMetaData.Bin instead.
var TierHookBin = TierHookMetaData.Bin

// DeployTierHook deploys a new Ethereum contract, binding an instance of TierHook to it.
func DeployTierHook(auth *bind.TransactOpts, backend bind.ContractBackend, _poolManager common.Address) (common.Address, *types.Transaction, *TierHook, error) {
	parsed, err := TierHookMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(TierHookBin), backend, _poolManager)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &TierHook{TierHookCaller: TierHookCaller{contract: contract}, TierHookTransactor: TierHookTransactor{contract: contract}, TierHookFilterer: TierHookFilterer{contract: contract}}, nil
}

// TierHook is an auto generated Go binding around an Ethereum contract.
type TierHook struct {
	TierHookCaller     // Read-only binding to the contract
	TierHookTransactor // Write-only binding to the contract
	TierHookFilterer   // Log filterer for contract events
}

// TierHookCaller is an auto generated read-only Go binding around an Ethereum contract.
type TierHookCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TierHookTransactor is an auto generated write-only Go binding around an Ethereum contract.
type TierHookTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TierHookFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type TierHookFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TierHookSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type TierHookSession struct {
	Contract     *TierHook         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// TierHookCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type TierHookCallerSession struct {
	Contract *TierHookCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// TierHookTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type TierHookTransactorSession struct {
	Contract     *TierHookTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// TierHookRaw is an auto generated low-level Go binding around an Ethereum contract.
type TierHookRaw struct {
	Contract *TierHook // Generic contract binding to access the raw methods on
}

// TierHookCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type TierHookCallerRaw struct {
	Contract *TierHookCaller // Generic read-only contract binding to access the raw methods on
}

// TierHookTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type TierHookTransactorRaw struct {
	Contract *TierHookTransactor // Generic write-only contract binding to access the raw methods on
}

// NewTierHook creates a new instance of TierHook, bound to a specific deployed contract.
func NewTierHook(address common.Address, backend bind.ContractBackend) (*TierHook, error) {
	contract, err := bindTierHook(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &TierHook{TierHookCaller: TierHookCaller{contract: contract}, TierHookTransactor: TierHookTransactor{contract: contract}, TierHookFilterer: TierHookFilterer{contract: contract}}, nil
}

// NewTierHookCaller creates a new read-only instance of TierHook, bound to a specific deployed contract.
func NewTierHookCaller(address common.Address, caller bind.ContractCaller) (*TierHookCaller, error) {
	contract, err := bindTierHook(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &TierHookCaller{contract: contract}, nil
}

// NewTierHookTransactor creates a new write-only instance of TierHook, bound to a specific deployed contract.
func NewTierHookTransactor(address common.Address, transactor bind.ContractTransactor) (*TierHookTransactor, error) {
	contract, err := bindTierHook(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &TierHookTransactor{contract: contract}, nil
}

// NewTierHookFilterer creates a new log filterer instance of TierHook, bound to a specific deployed contract.
func NewTierHookFilterer(address common.Address, filterer bind.ContractFilterer) (*TierHookFilterer, error) {
	contract, err := bindTierHook(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &TierHookFilterer{contract: contract}, nil
}

// bindTierHook binds a generic wrapper to an already deployed contract.
func bindTierHook(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := TierHookMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TierHook *TierHookRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TierHook.Contract.TierHookCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TierHook *TierHookRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TierHook.Contract.TierHookTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TierHook *TierHookRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TierHook.Contract.TierHookTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TierHook *TierHookCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TierHook.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TierHook *TierHookTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TierHook.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TierHook *TierHookTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TierHook.Contract.contract.Transact(opts, method, params...)
}

// BeforeInitialize is a free data retrieval call binding the contract method 0x3440d820.
//
// Solidity: function beforeInitialize(address , (address,address,uint24,int24,address) key, uint160 , bytes ) pure returns(bytes4)
func (_TierHook *TierHookCaller) BeforeInitialize(opts *bind.CallOpts, arg0 common.Address, key PoolKey, arg2 *big.Int, arg3 []byte) ([4]byte, error) {
	var out []interface{}
	err := _TierHook.contract.Call(opts, &out, "beforeInitialize", arg0, key, arg2, arg3)

	if err != nil {
		return *new([4]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([4]byte)).(*[4]byte)

	return out0, err

}

// BeforeInitialize is a free data retrieval call binding the contract method 0x3440d820.
//
// Solidity: function beforeInitialize(address , (address,address,uint24,int24,address) key, uint160 , bytes ) pure returns(bytes4)
func (_TierHook *TierHookSession) BeforeInitialize(arg0 common.Address, key PoolKey, arg2 *big.Int, arg3 []byte) ([4]byte, error) {
	return _TierHook.Contract.BeforeInitialize(&_TierHook.CallOpts, arg0, key, arg2, arg3)
}

// BeforeInitialize is a free data retrieval call binding the contract method 0x3440d820.
//
// Solidity: function beforeInitialize(address , (address,address,uint24,int24,address) key, uint160 , bytes ) pure returns(bytes4)
func (_TierHook *TierHookCallerSession) BeforeInitialize(arg0 common.Address, key PoolKey, arg2 *big.Int, arg3 []byte) ([4]byte, error) {
	return _TierHook.Contract.BeforeInitialize(&_TierHook.CallOpts, arg0, key, arg2, arg3)
}

// GetFee is a free data retrieval call binding the contract method 0x2ab7a3e2.
//
// Solidity: function getFee(address , (address,address,uint24,int24,address) , (bool,int256,uint160) , bytes ) view returns(uint24)
func (_TierHook *TierHookCaller) GetFee(opts *bind.CallOpts, arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerSwapParams, arg3 []byte) (*big.Int, error) {
	var out []interface{}
	err := _TierHook.contract.Call(opts, &out, "getFee", arg0, arg1, arg2, arg3)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetFee is a free data retrieval call binding the contract method 0x2ab7a3e2.
//
// Solidity: function getFee(address , (address,address,uint24,int24,address) , (bool,int256,uint160) , bytes ) view returns(uint24)
func (_TierHook *TierHookSession) GetFee(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerSwapParams, arg3 []byte) (*big.Int, error) {
	return _TierHook.Contract.GetFee(&_TierHook.CallOpts, arg0, arg1, arg2, arg3)
}

// GetFee is a free data retrieval call binding the contract method 0x2ab7a3e2.
//
// Solidity: function getFee(address , (address,address,uint24,int24,address) , (bool,int256,uint160) , bytes ) view returns(uint24)
func (_TierHook *TierHookCallerSession) GetFee(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerSwapParams, arg3 []byte) (*big.Int, error) {
	return _TierHook.Contract.GetFee(&_TierHook.CallOpts, arg0, arg1, arg2, arg3)
}

// GetFeeBySwapper is a free data retrieval call binding the contract method 0x90f57fc1.
//
// Solidity: function getFeeBySwapper(address swapper) view returns(uint24)
func (_TierHook *TierHookCaller) GetFeeBySwapper(opts *bind.CallOpts, swapper common.Address) (*big.Int, error) {
	var out []interface{}
	err := _TierHook.contract.Call(opts, &out, "getFeeBySwapper", swapper)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetFeeBySwapper is a free data retrieval call binding the contract method 0x90f57fc1.
//
// Solidity: function getFeeBySwapper(address swapper) view returns(uint24)
func (_TierHook *TierHookSession) GetFeeBySwapper(swapper common.Address) (*big.Int, error) {
	return _TierHook.Contract.GetFeeBySwapper(&_TierHook.CallOpts, swapper)
}

// GetFeeBySwapper is a free data retrieval call binding the contract method 0x90f57fc1.
//
// Solidity: function getFeeBySwapper(address swapper) view returns(uint24)
func (_TierHook *TierHookCallerSession) GetFeeBySwapper(swapper common.Address) (*big.Int, error) {
	return _TierHook.Contract.GetFeeBySwapper(&_TierHook.CallOpts, swapper)
}

// GetHookFees is a free data retrieval call binding the contract method 0x5ae4ce58.
//
// Solidity: function getHookFees((address,address,uint24,int24,address) ) pure returns(uint24 fee)
func (_TierHook *TierHookCaller) GetHookFees(opts *bind.CallOpts, arg0 PoolKey) (*big.Int, error) {
	var out []interface{}
	err := _TierHook.contract.Call(opts, &out, "getHookFees", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetHookFees is a free data retrieval call binding the contract method 0x5ae4ce58.
//
// Solidity: function getHookFees((address,address,uint24,int24,address) ) pure returns(uint24 fee)
func (_TierHook *TierHookSession) GetHookFees(arg0 PoolKey) (*big.Int, error) {
	return _TierHook.Contract.GetHookFees(&_TierHook.CallOpts, arg0)
}

// GetHookFees is a free data retrieval call binding the contract method 0x5ae4ce58.
//
// Solidity: function getHookFees((address,address,uint24,int24,address) ) pure returns(uint24 fee)
func (_TierHook *TierHookCallerSession) GetHookFees(arg0 PoolKey) (*big.Int, error) {
	return _TierHook.Contract.GetHookFees(&_TierHook.CallOpts, arg0)
}

// GetHookWithdrawFee is a free data retrieval call binding the contract method 0x39dfff16.
//
// Solidity: function getHookWithdrawFee((address,address,uint24,int24,address) key) view returns(uint8 fee)
func (_TierHook *TierHookCaller) GetHookWithdrawFee(opts *bind.CallOpts, key PoolKey) (uint8, error) {
	var out []interface{}
	err := _TierHook.contract.Call(opts, &out, "getHookWithdrawFee", key)

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// GetHookWithdrawFee is a free data retrieval call binding the contract method 0x39dfff16.
//
// Solidity: function getHookWithdrawFee((address,address,uint24,int24,address) key) view returns(uint8 fee)
func (_TierHook *TierHookSession) GetHookWithdrawFee(key PoolKey) (uint8, error) {
	return _TierHook.Contract.GetHookWithdrawFee(&_TierHook.CallOpts, key)
}

// GetHookWithdrawFee is a free data retrieval call binding the contract method 0x39dfff16.
//
// Solidity: function getHookWithdrawFee((address,address,uint24,int24,address) key) view returns(uint8 fee)
func (_TierHook *TierHookCallerSession) GetHookWithdrawFee(key PoolKey) (uint8, error) {
	return _TierHook.Contract.GetHookWithdrawFee(&_TierHook.CallOpts, key)
}

// GetHooksCalls is a free data retrieval call binding the contract method 0x612c39b7.
//
// Solidity: function getHooksCalls() pure returns((bool,bool,bool,bool,bool,bool,bool,bool))
func (_TierHook *TierHookCaller) GetHooksCalls(opts *bind.CallOpts) (HooksCalls, error) {
	var out []interface{}
	err := _TierHook.contract.Call(opts, &out, "getHooksCalls")

	if err != nil {
		return *new(HooksCalls), err
	}

	out0 := *abi.ConvertType(out[0], new(HooksCalls)).(*HooksCalls)

	return out0, err

}

// GetHooksCalls is a free data retrieval call binding the contract method 0x612c39b7.
//
// Solidity: function getHooksCalls() pure returns((bool,bool,bool,bool,bool,bool,bool,bool))
func (_TierHook *TierHookSession) GetHooksCalls() (HooksCalls, error) {
	return _TierHook.Contract.GetHooksCalls(&_TierHook.CallOpts)
}

// GetHooksCalls is a free data retrieval call binding the contract method 0x612c39b7.
//
// Solidity: function getHooksCalls() pure returns((bool,bool,bool,bool,bool,bool,bool,bool))
func (_TierHook *TierHookCallerSession) GetHooksCalls() (HooksCalls, error) {
	return _TierHook.Contract.GetHooksCalls(&_TierHook.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TierHook *TierHookCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _TierHook.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TierHook *TierHookSession) Owner() (common.Address, error) {
	return _TierHook.Contract.Owner(&_TierHook.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TierHook *TierHookCallerSession) Owner() (common.Address, error) {
	return _TierHook.Contract.Owner(&_TierHook.CallOpts)
}

// PoolManager is a free data retrieval call binding the contract method 0xdc4c90d3.
//
// Solidity: function poolManager() view returns(address)
func (_TierHook *TierHookCaller) PoolManager(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _TierHook.contract.Call(opts, &out, "poolManager")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PoolManager is a free data retrieval call binding the contract method 0xdc4c90d3.
//
// Solidity: function poolManager() view returns(address)
func (_TierHook *TierHookSession) PoolManager() (common.Address, error) {
	return _TierHook.Contract.PoolManager(&_TierHook.CallOpts)
}

// PoolManager is a free data retrieval call binding the contract method 0xdc4c90d3.
//
// Solidity: function poolManager() view returns(address)
func (_TierHook *TierHookCallerSession) PoolManager() (common.Address, error) {
	return _TierHook.Contract.PoolManager(&_TierHook.CallOpts)
}

// SumVolumeAddress is a free data retrieval call binding the contract method 0x229c7d8b.
//
// Solidity: function sumVolumeAddress() view returns(address)
func (_TierHook *TierHookCaller) SumVolumeAddress(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _TierHook.contract.Call(opts, &out, "sumVolumeAddress")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SumVolumeAddress is a free data retrieval call binding the contract method 0x229c7d8b.
//
// Solidity: function sumVolumeAddress() view returns(address)
func (_TierHook *TierHookSession) SumVolumeAddress() (common.Address, error) {
	return _TierHook.Contract.SumVolumeAddress(&_TierHook.CallOpts)
}

// SumVolumeAddress is a free data retrieval call binding the contract method 0x229c7d8b.
//
// Solidity: function sumVolumeAddress() view returns(address)
func (_TierHook *TierHookCallerSession) SumVolumeAddress() (common.Address, error) {
	return _TierHook.Contract.SumVolumeAddress(&_TierHook.CallOpts)
}

// AfterDonate is a paid mutator transaction binding the contract method 0xe1b4af69.
//
// Solidity: function afterDonate(address , (address,address,uint24,int24,address) , uint256 , uint256 , bytes ) returns(bytes4)
func (_TierHook *TierHookTransactor) AfterDonate(opts *bind.TransactOpts, arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.contract.Transact(opts, "afterDonate", arg0, arg1, arg2, arg3, arg4)
}

// AfterDonate is a paid mutator transaction binding the contract method 0xe1b4af69.
//
// Solidity: function afterDonate(address , (address,address,uint24,int24,address) , uint256 , uint256 , bytes ) returns(bytes4)
func (_TierHook *TierHookSession) AfterDonate(arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.Contract.AfterDonate(&_TierHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// AfterDonate is a paid mutator transaction binding the contract method 0xe1b4af69.
//
// Solidity: function afterDonate(address , (address,address,uint24,int24,address) , uint256 , uint256 , bytes ) returns(bytes4)
func (_TierHook *TierHookTransactorSession) AfterDonate(arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.Contract.AfterDonate(&_TierHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// AfterInitialize is a paid mutator transaction binding the contract method 0xa910f80f.
//
// Solidity: function afterInitialize(address , (address,address,uint24,int24,address) , uint160 , int24 , bytes ) returns(bytes4)
func (_TierHook *TierHookTransactor) AfterInitialize(opts *bind.TransactOpts, arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.contract.Transact(opts, "afterInitialize", arg0, arg1, arg2, arg3, arg4)
}

// AfterInitialize is a paid mutator transaction binding the contract method 0xa910f80f.
//
// Solidity: function afterInitialize(address , (address,address,uint24,int24,address) , uint160 , int24 , bytes ) returns(bytes4)
func (_TierHook *TierHookSession) AfterInitialize(arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.Contract.AfterInitialize(&_TierHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// AfterInitialize is a paid mutator transaction binding the contract method 0xa910f80f.
//
// Solidity: function afterInitialize(address , (address,address,uint24,int24,address) , uint160 , int24 , bytes ) returns(bytes4)
func (_TierHook *TierHookTransactorSession) AfterInitialize(arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.Contract.AfterInitialize(&_TierHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// AfterModifyPosition is a paid mutator transaction binding the contract method 0x30b7cdef.
//
// Solidity: function afterModifyPosition(address , (address,address,uint24,int24,address) , (int24,int24,int256) , int256 , bytes ) returns(bytes4)
func (_TierHook *TierHookTransactor) AfterModifyPosition(opts *bind.TransactOpts, arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerModifyPositionParams, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.contract.Transact(opts, "afterModifyPosition", arg0, arg1, arg2, arg3, arg4)
}

// AfterModifyPosition is a paid mutator transaction binding the contract method 0x30b7cdef.
//
// Solidity: function afterModifyPosition(address , (address,address,uint24,int24,address) , (int24,int24,int256) , int256 , bytes ) returns(bytes4)
func (_TierHook *TierHookSession) AfterModifyPosition(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerModifyPositionParams, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.Contract.AfterModifyPosition(&_TierHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// AfterModifyPosition is a paid mutator transaction binding the contract method 0x30b7cdef.
//
// Solidity: function afterModifyPosition(address , (address,address,uint24,int24,address) , (int24,int24,int256) , int256 , bytes ) returns(bytes4)
func (_TierHook *TierHookTransactorSession) AfterModifyPosition(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerModifyPositionParams, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.Contract.AfterModifyPosition(&_TierHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// AfterSwap is a paid mutator transaction binding the contract method 0xb47b2fb1.
//
// Solidity: function afterSwap(address , (address,address,uint24,int24,address) key, (bool,int256,uint160) , int256 delta, bytes ) returns(bytes4 selector)
func (_TierHook *TierHookTransactor) AfterSwap(opts *bind.TransactOpts, arg0 common.Address, key PoolKey, arg2 IPoolManagerSwapParams, delta *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.contract.Transact(opts, "afterSwap", arg0, key, arg2, delta, arg4)
}

// AfterSwap is a paid mutator transaction binding the contract method 0xb47b2fb1.
//
// Solidity: function afterSwap(address , (address,address,uint24,int24,address) key, (bool,int256,uint160) , int256 delta, bytes ) returns(bytes4 selector)
func (_TierHook *TierHookSession) AfterSwap(arg0 common.Address, key PoolKey, arg2 IPoolManagerSwapParams, delta *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.Contract.AfterSwap(&_TierHook.TransactOpts, arg0, key, arg2, delta, arg4)
}

// AfterSwap is a paid mutator transaction binding the contract method 0xb47b2fb1.
//
// Solidity: function afterSwap(address , (address,address,uint24,int24,address) key, (bool,int256,uint160) , int256 delta, bytes ) returns(bytes4 selector)
func (_TierHook *TierHookTransactorSession) AfterSwap(arg0 common.Address, key PoolKey, arg2 IPoolManagerSwapParams, delta *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.Contract.AfterSwap(&_TierHook.TransactOpts, arg0, key, arg2, delta, arg4)
}

// BeforeDonate is a paid mutator transaction binding the contract method 0xb6a8b0fa.
//
// Solidity: function beforeDonate(address , (address,address,uint24,int24,address) , uint256 , uint256 , bytes ) returns(bytes4)
func (_TierHook *TierHookTransactor) BeforeDonate(opts *bind.TransactOpts, arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.contract.Transact(opts, "beforeDonate", arg0, arg1, arg2, arg3, arg4)
}

// BeforeDonate is a paid mutator transaction binding the contract method 0xb6a8b0fa.
//
// Solidity: function beforeDonate(address , (address,address,uint24,int24,address) , uint256 , uint256 , bytes ) returns(bytes4)
func (_TierHook *TierHookSession) BeforeDonate(arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.Contract.BeforeDonate(&_TierHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// BeforeDonate is a paid mutator transaction binding the contract method 0xb6a8b0fa.
//
// Solidity: function beforeDonate(address , (address,address,uint24,int24,address) , uint256 , uint256 , bytes ) returns(bytes4)
func (_TierHook *TierHookTransactorSession) BeforeDonate(arg0 common.Address, arg1 PoolKey, arg2 *big.Int, arg3 *big.Int, arg4 []byte) (*types.Transaction, error) {
	return _TierHook.Contract.BeforeDonate(&_TierHook.TransactOpts, arg0, arg1, arg2, arg3, arg4)
}

// BeforeModifyPosition is a paid mutator transaction binding the contract method 0xfe9a6f45.
//
// Solidity: function beforeModifyPosition(address , (address,address,uint24,int24,address) , (int24,int24,int256) , bytes ) returns(bytes4)
func (_TierHook *TierHookTransactor) BeforeModifyPosition(opts *bind.TransactOpts, arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerModifyPositionParams, arg3 []byte) (*types.Transaction, error) {
	return _TierHook.contract.Transact(opts, "beforeModifyPosition", arg0, arg1, arg2, arg3)
}

// BeforeModifyPosition is a paid mutator transaction binding the contract method 0xfe9a6f45.
//
// Solidity: function beforeModifyPosition(address , (address,address,uint24,int24,address) , (int24,int24,int256) , bytes ) returns(bytes4)
func (_TierHook *TierHookSession) BeforeModifyPosition(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerModifyPositionParams, arg3 []byte) (*types.Transaction, error) {
	return _TierHook.Contract.BeforeModifyPosition(&_TierHook.TransactOpts, arg0, arg1, arg2, arg3)
}

// BeforeModifyPosition is a paid mutator transaction binding the contract method 0xfe9a6f45.
//
// Solidity: function beforeModifyPosition(address , (address,address,uint24,int24,address) , (int24,int24,int256) , bytes ) returns(bytes4)
func (_TierHook *TierHookTransactorSession) BeforeModifyPosition(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerModifyPositionParams, arg3 []byte) (*types.Transaction, error) {
	return _TierHook.Contract.BeforeModifyPosition(&_TierHook.TransactOpts, arg0, arg1, arg2, arg3)
}

// BeforeSwap is a paid mutator transaction binding the contract method 0x575e24b4.
//
// Solidity: function beforeSwap(address , (address,address,uint24,int24,address) , (bool,int256,uint160) , bytes ) returns(bytes4)
func (_TierHook *TierHookTransactor) BeforeSwap(opts *bind.TransactOpts, arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerSwapParams, arg3 []byte) (*types.Transaction, error) {
	return _TierHook.contract.Transact(opts, "beforeSwap", arg0, arg1, arg2, arg3)
}

// BeforeSwap is a paid mutator transaction binding the contract method 0x575e24b4.
//
// Solidity: function beforeSwap(address , (address,address,uint24,int24,address) , (bool,int256,uint160) , bytes ) returns(bytes4)
func (_TierHook *TierHookSession) BeforeSwap(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerSwapParams, arg3 []byte) (*types.Transaction, error) {
	return _TierHook.Contract.BeforeSwap(&_TierHook.TransactOpts, arg0, arg1, arg2, arg3)
}

// BeforeSwap is a paid mutator transaction binding the contract method 0x575e24b4.
//
// Solidity: function beforeSwap(address , (address,address,uint24,int24,address) , (bool,int256,uint160) , bytes ) returns(bytes4)
func (_TierHook *TierHookTransactorSession) BeforeSwap(arg0 common.Address, arg1 PoolKey, arg2 IPoolManagerSwapParams, arg3 []byte) (*types.Transaction, error) {
	return _TierHook.Contract.BeforeSwap(&_TierHook.TransactOpts, arg0, arg1, arg2, arg3)
}

// LockAcquired is a paid mutator transaction binding the contract method 0xab6291fe.
//
// Solidity: function lockAcquired(bytes data) returns(bytes)
func (_TierHook *TierHookTransactor) LockAcquired(opts *bind.TransactOpts, data []byte) (*types.Transaction, error) {
	return _TierHook.contract.Transact(opts, "lockAcquired", data)
}

// LockAcquired is a paid mutator transaction binding the contract method 0xab6291fe.
//
// Solidity: function lockAcquired(bytes data) returns(bytes)
func (_TierHook *TierHookSession) LockAcquired(data []byte) (*types.Transaction, error) {
	return _TierHook.Contract.LockAcquired(&_TierHook.TransactOpts, data)
}

// LockAcquired is a paid mutator transaction binding the contract method 0xab6291fe.
//
// Solidity: function lockAcquired(bytes data) returns(bytes)
func (_TierHook *TierHookTransactorSession) LockAcquired(data []byte) (*types.Transaction, error) {
	return _TierHook.Contract.LockAcquired(&_TierHook.TransactOpts, data)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_TierHook *TierHookTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TierHook.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_TierHook *TierHookSession) RenounceOwnership() (*types.Transaction, error) {
	return _TierHook.Contract.RenounceOwnership(&_TierHook.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_TierHook *TierHookTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _TierHook.Contract.RenounceOwnership(&_TierHook.TransactOpts)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TierHook *TierHookTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _TierHook.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TierHook *TierHookSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _TierHook.Contract.TransferOwnership(&_TierHook.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TierHook *TierHookTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _TierHook.Contract.TransferOwnership(&_TierHook.TransactOpts, newOwner)
}

// UpdateSumVolumeAddress is a paid mutator transaction binding the contract method 0x11080b68.
//
// Solidity: function updateSumVolumeAddress(address _sumVolumeAddress) returns()
func (_TierHook *TierHookTransactor) UpdateSumVolumeAddress(opts *bind.TransactOpts, _sumVolumeAddress common.Address) (*types.Transaction, error) {
	return _TierHook.contract.Transact(opts, "updateSumVolumeAddress", _sumVolumeAddress)
}

// UpdateSumVolumeAddress is a paid mutator transaction binding the contract method 0x11080b68.
//
// Solidity: function updateSumVolumeAddress(address _sumVolumeAddress) returns()
func (_TierHook *TierHookSession) UpdateSumVolumeAddress(_sumVolumeAddress common.Address) (*types.Transaction, error) {
	return _TierHook.Contract.UpdateSumVolumeAddress(&_TierHook.TransactOpts, _sumVolumeAddress)
}

// UpdateSumVolumeAddress is a paid mutator transaction binding the contract method 0x11080b68.
//
// Solidity: function updateSumVolumeAddress(address _sumVolumeAddress) returns()
func (_TierHook *TierHookTransactorSession) UpdateSumVolumeAddress(_sumVolumeAddress common.Address) (*types.Transaction, error) {
	return _TierHook.Contract.UpdateSumVolumeAddress(&_TierHook.TransactOpts, _sumVolumeAddress)
}

// TierHookOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the TierHook contract.
type TierHookOwnershipTransferredIterator struct {
	Event *TierHookOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TierHookOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TierHookOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TierHookOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TierHookOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TierHookOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TierHookOwnershipTransferred represents a OwnershipTransferred event raised by the TierHook contract.
type TierHookOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TierHook *TierHookFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*TierHookOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _TierHook.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &TierHookOwnershipTransferredIterator{contract: _TierHook.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TierHook *TierHookFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *TierHookOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _TierHook.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TierHookOwnershipTransferred)
				if err := _TierHook.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TierHook *TierHookFilterer) ParseOwnershipTransferred(log types.Log) (*TierHookOwnershipTransferred, error) {
	event := new(TierHookOwnershipTransferred)
	if err := _TierHook.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TierHookSwapIterator is returned from FilterSwap and is used to iterate over the raw logs and unpacked data for Swap events raised by the TierHook contract.
type TierHookSwapIterator struct {
	Event *TierHookSwap // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TierHookSwapIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TierHookSwap)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TierHookSwap)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TierHookSwapIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TierHookSwapIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TierHookSwap represents a Swap event raised by the TierHook contract.
type TierHookSwap struct {
	Id      [32]byte
	Sender  common.Address
	Amount0 *big.Int
	Amount1 *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterSwap is a free log retrieval operation binding the contract event 0x6e78eb77321ff667248e786162a80dcc8c37e03953a73757e24aeba9ba881bee.
//
// Solidity: event Swap(bytes32 indexed id, address indexed sender, int128 amount0, int128 amount1)
func (_TierHook *TierHookFilterer) FilterSwap(opts *bind.FilterOpts, id [][32]byte, sender []common.Address) (*TierHookSwapIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _TierHook.contract.FilterLogs(opts, "Swap", idRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &TierHookSwapIterator{contract: _TierHook.contract, event: "Swap", logs: logs, sub: sub}, nil
}

// WatchSwap is a free log subscription operation binding the contract event 0x6e78eb77321ff667248e786162a80dcc8c37e03953a73757e24aeba9ba881bee.
//
// Solidity: event Swap(bytes32 indexed id, address indexed sender, int128 amount0, int128 amount1)
func (_TierHook *TierHookFilterer) WatchSwap(opts *bind.WatchOpts, sink chan<- *TierHookSwap, id [][32]byte, sender []common.Address) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _TierHook.contract.WatchLogs(opts, "Swap", idRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TierHookSwap)
				if err := _TierHook.contract.UnpackLog(event, "Swap", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSwap is a log parse operation binding the contract event 0x6e78eb77321ff667248e786162a80dcc8c37e03953a73757e24aeba9ba881bee.
//
// Solidity: event Swap(bytes32 indexed id, address indexed sender, int128 amount0, int128 amount1)
func (_TierHook *TierHookFilterer) ParseSwap(log types.Log) (*TierHookSwap, error) {
	event := new(TierHookSwap)
	if err := _TierHook.contract.UnpackLog(event, "Swap", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TierHookUpdateSumVolumeAddressIterator is returned from FilterUpdateSumVolumeAddress and is used to iterate over the raw logs and unpacked data for UpdateSumVolumeAddress events raised by the TierHook contract.
type TierHookUpdateSumVolumeAddressIterator struct {
	Event *TierHookUpdateSumVolumeAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TierHookUpdateSumVolumeAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TierHookUpdateSumVolumeAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TierHookUpdateSumVolumeAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TierHookUpdateSumVolumeAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TierHookUpdateSumVolumeAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TierHookUpdateSumVolumeAddress represents a UpdateSumVolumeAddress event raised by the TierHook contract.
type TierHookUpdateSumVolumeAddress struct {
	NewAddress common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterUpdateSumVolumeAddress is a free log retrieval operation binding the contract event 0xa7f1d21617374882d6d2a29f886042bc73207e68d82e84a98231e74fcf6c111a.
//
// Solidity: event UpdateSumVolumeAddress(address newAddress)
func (_TierHook *TierHookFilterer) FilterUpdateSumVolumeAddress(opts *bind.FilterOpts) (*TierHookUpdateSumVolumeAddressIterator, error) {

	logs, sub, err := _TierHook.contract.FilterLogs(opts, "UpdateSumVolumeAddress")
	if err != nil {
		return nil, err
	}
	return &TierHookUpdateSumVolumeAddressIterator{contract: _TierHook.contract, event: "UpdateSumVolumeAddress", logs: logs, sub: sub}, nil
}

// WatchUpdateSumVolumeAddress is a free log subscription operation binding the contract event 0xa7f1d21617374882d6d2a29f886042bc73207e68d82e84a98231e74fcf6c111a.
//
// Solidity: event UpdateSumVolumeAddress(address newAddress)
func (_TierHook *TierHookFilterer) WatchUpdateSumVolumeAddress(opts *bind.WatchOpts, sink chan<- *TierHookUpdateSumVolumeAddress) (event.Subscription, error) {

	logs, sub, err := _TierHook.contract.WatchLogs(opts, "UpdateSumVolumeAddress")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TierHookUpdateSumVolumeAddress)
				if err := _TierHook.contract.UnpackLog(event, "UpdateSumVolumeAddress", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdateSumVolumeAddress is a log parse operation binding the contract event 0xa7f1d21617374882d6d2a29f886042bc73207e68d82e84a98231e74fcf6c111a.
//
// Solidity: event UpdateSumVolumeAddress(address newAddress)
func (_TierHook *TierHookFilterer) ParseUpdateSumVolumeAddress(log types.Log) (*TierHookUpdateSumVolumeAddress, error) {
	event := new(TierHookUpdateSumVolumeAddress)
	if err := _TierHook.contract.UnpackLog(event, "UpdateSumVolumeAddress", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TokenVaultMetaData contains all meta data concerning the TokenVault contract.
var TokenVaultMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"contractIMessageBridge\",\"name\":\"_messageBridge\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"depositId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"mintAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MinDepositUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"withdrawId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"refId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"burnAccount\",\"type\":\"address\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_mintChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_mintAccount\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"executeMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"messageBridge\",\"outputs\":[{\"internalType\":\"contractIMessageBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"records\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"remotePegBridges\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMinDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_remoteChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_remotePegBridge\",\"type\":\"address\"}],\"name\":\"setRemotePegBridge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x6080346100a657601f6110fe38819003918201601f19168301916001600160401b038311848410176100aa578084926020946040528339810103126100a657516001600160a01b0390818116908190036100a65760018060a01b031990815f5416175f55600154903390821617600155604051913391167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a361103f90816100bf8239f35b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe60806040526004361015610011575f80fd5b5f3560e01c806301e64725146100c457806323463624146100bf5780632f5c5fee146100ba57806333a42db1146100b55780633c29f839146100b05780635ec2fa26146100ab578063715018a6146100a65780638da5cb5b146100a1578063aec95a141461009c578063cd49e90b146100975763f2fde38b14610092575f80fd5b6107a6565b610764565b6106da565b6106b4565b610645565b6104ed565b610480565b61045b565b6103e6565b61015c565b346100f35760203660031901126100f3576004355f526002602052602060ff60405f2054166040519015158152f35b5f80fd5b6001600160a01b038116036100f357565b60643590610115826100f7565b565b6044359067ffffffffffffffff821682036100f357565b6084359067ffffffffffffffff821682036100f357565b6004359067ffffffffffffffff821682036100f357565b346100f35760a03660031901126100f3576103e261032b7f3151eb0c52871b9cf9243864e37490145ad0396a42ce45349fdfd20b16a2487f6004356101a0816100f7565b602435906103cf6101af610117565b6064356101bb816100f7565b6101c361012e565b906101ea6101e2866001600160a01b03165f52600460205260405f2090565b548711610857565b61037e866103506001600160a01b03956102328761022a61021d8467ffffffffffffffff165f52600360205260405f2090565b546001600160a01b031690565b1615156108a3565b6040516bffffffffffffffffffffffff1933606090811b8216602084019081528c821b831660348501526048840187905288821b831660688501527fffffffffffffffff00000000000000000000000000000000000000000000000060c08b811b8216607c87015246901b1660848501523090911b909116608c83015260808252601f1992916102c360a082610924565b5190209c8d926102ee6102e86102e1865f52600260205260405f2090565b5460ff1690565b15610946565b604080516001600160a01b038e81166020830152918101889052908916606082015233608082015260a081019490945260c0908101845283610924565b61034a61021d8267ffffffffffffffff165f52600360205260405f2090565b90610f64565b946103736103668c5f52600260205260405f2090565b805460ff19166001179055565b309033908916610a84565b604051958695338a88939460c09567ffffffffffffffff94929998979360e087019a87526001600160a01b039384809216602089015216604087015260608601521660808401521660a08201520152565b0390a16040519081529081906020820190565b0390f35b346100f35760403660031901126100f3576103ff610145565b6024359061040c826100f7565b67ffffffffffffffff6001600160a01b039161042d83600154163314610992565b165f52600360205260405f20911673ffffffffffffffffffffffffffffffffffffffff198254161790555f80f35b346100f3575f3660031901126100f35760206001600160a01b035f5416604051908152f35b346100f35760203660031901126100f3576001600160a01b036004356104a5816100f7565b165f526004602052602060405f2054604051908152f35b9181601f840112156100f35782359167ffffffffffffffff83116100f3576020808501948460051b0101116100f357565b346100f3576040806003193601126100f35767ffffffffffffffff906004358281116100f3576105219036906004016104bc565b90926024359081116100f35761053b9036906004016104bc565b92906105536001600160a01b03600154163314610992565b838303610601575f5b83811061056557005b806105746105fc9287856109ff565b356105a261058b61058684898c6109ff565b610a23565b6001600160a01b03165f52600460205260405f2090565b557f0f48d517989455cd80ed52427e80553e66f9b69fd5cee8e26bd1a1f9c364fba66105d261058683888b6109ff565b6105dd8389876109ff565b86516001600160a01b03929092168252356020820152604090a16109dd565b61055c565b815162461bcd60e51b815260206004820152600f60248201527f6c656e677468206d69736d6174636800000000000000000000000000000000006044820152606490fd5b346100f3575f806003193601126106b1578060015473ffffffffffffffffffffffffffffffffffffffff196001600160a01b03821691610686338414610992565b166001557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b80fd5b346100f3575f3660031901126100f35760206001600160a01b0360015416604051908152f35b346100f35760803660031901126100f3576106f3610145565b60243590610700826100f7565b6044359067ffffffffffffffff908183116100f357366023840112156100f35782600401359182116100f35736602483850101116100f3576103e29360246107529461074a610108565b500191610cf7565b60405190151581529081906020820190565b346100f35760203660031901126100f35767ffffffffffffffff610786610145565b165f52600360205260206001600160a01b0360405f205416604051908152f35b346100f35760203660031901126100f3576004356107c3816100f7565b6001600160a01b036107da81600154163314610992565b8116156107ec576107ea90610a30565b005b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608490fd5b1561085e57565b60405162461bcd60e51b815260206004820152601060248201527f616d6f756e7420746f6f20736d616c6c000000000000000000000000000000006044820152606490fd5b156108aa57565b60405162461bcd60e51b815260206004820152601260248201527f696e76616c6964206d696e7420636861696e00000000000000000000000000006044820152606490fd5b634e487b7160e01b5f52604160045260245ffd5b6040810190811067ffffffffffffffff82111761091f57604052565b6108ef565b90601f8019910116810190811067ffffffffffffffff82111761091f57604052565b1561094d57565b60405162461bcd60e51b815260206004820152600d60248201527f7265636f726420657869737473000000000000000000000000000000000000006044820152606490fd5b1561099957565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b5f1981146109eb5760010190565b634e487b7160e01b5f52601160045260245ffd5b9190811015610a0f5760051b0190565b634e487b7160e01b5f52603260045260245ffd5b35610a2d816100f7565b90565b600154906001600160a01b03809116918273ffffffffffffffffffffffffffffffffffffffff19821617600155167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3565b9290604051926323b872dd60e01b60208501526001600160a01b03809216602485015216604483015260648201526064815260a081019181831067ffffffffffffffff84111761091f5761011592604052610b64565b908160209103126100f3575180151581036100f35790565b15610af957565b60405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f742073756363656564000000000000000000000000000000000000000000006064820152608490fd5b6001600160a01b03169060405190610b7b82610903565b6020928383527f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c656484840152803b15610bf1575f8281928287610bcc9796519301915af1610bc6610c36565b90610cb3565b80519081610bd957505050565b8261011593610bec938301019101610ada565b610af2565b60405162461bcd60e51b815260048101859052601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606490fd5b3d15610c70573d9067ffffffffffffffff821161091f5760405191610c65601f8201601f191660200184610924565b82523d5f602084013e565b606090565b91908251928382525f5b848110610c9f575050825f602080949584010152601f8019910116010190565b602081830181015184830182015201610c7f565b90919015610cbf575090565b815115610ccf5750805190602001fd5b60405162461bcd60e51b815260206004820152908190610cf3906024830190610c75565b0390fd5b9291926001600160a01b0390815f54163303610d7f5767ffffffffffffffff165f5260036020528060405f205416911603610d3a57610d3591610dc4565b600190565b60405162461bcd60e51b815260206004820152601f60248201527f73656e646572206973206e6f742072656d6f74652070656720627269646765006044820152606490fd5b60405162461bcd60e51b815260206004820152601c60248201527f63616c6c6572206973206e6f74206d65737361676520627269646765000000006044820152606490fd5b908160a091810103126100f357807fc20f8288cc0b746ccfa1837a99fcdc5225b43ab191419bf6b43fe3802c4829569135610dfe816100f7565b610f1e6020830135604084013592610e15846100f7565b6080606086013595610e26876100f7565b0135906001600160a01b038080921695169516916040516020810190610ea881610e9a8a8789888d30948a949193609096936bffffffffffffffffffffffff19809681809560601b16895260601b166014880152602887015260601b166048850152605c84015260601b16607c8201520190565b03601f198101835282610924565b51902094610ec46102e86102e1885f52600260205260405f2090565b610ed9610366875f52600260205260405f2090565b610ee4828883610f23565b604080519687526001600160a01b039788166020880152908716908601526060850152608084015290921660a082015290819060c0820190565b0390a1565b60405163a9059cbb60e01b60208201526001600160a01b0392909216602483015260448083019390935291815261011591610f5f606483610924565b610b64565b91906020906001600160a01b039267ffffffffffffffff5f8096610fb7878354169460405198899788968795635c85c1a960e11b8752166004860152166024840152606060448401526064830190610c75565b03925af1918215610ffd578092610fcd57505090565b9091506020823d8211610ff5575b81610fe860209383610924565b810103126106b157505190565b3d9150610fdb565b604051903d90823e3d90fdfea26469706673582212203907d6666e07c262416e7ffc7af8ed83174676aabebb4a743bbe2f9ae718409664736f6c63430008140033",
}

// TokenVaultABI is the input ABI used to generate the binding from.
// Deprecated: Use TokenVaultMetaData.ABI instead.
var TokenVaultABI = TokenVaultMetaData.ABI

// TokenVaultBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use TokenVaultMetaData.Bin instead.
var TokenVaultBin = TokenVaultMetaData.Bin

// DeployTokenVault deploys a new Ethereum contract, binding an instance of TokenVault to it.
func DeployTokenVault(auth *bind.TransactOpts, backend bind.ContractBackend, _messageBridge common.Address) (common.Address, *types.Transaction, *TokenVault, error) {
	parsed, err := TokenVaultMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(TokenVaultBin), backend, _messageBridge)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &TokenVault{TokenVaultCaller: TokenVaultCaller{contract: contract}, TokenVaultTransactor: TokenVaultTransactor{contract: contract}, TokenVaultFilterer: TokenVaultFilterer{contract: contract}}, nil
}

// TokenVault is an auto generated Go binding around an Ethereum contract.
type TokenVault struct {
	TokenVaultCaller     // Read-only binding to the contract
	TokenVaultTransactor // Write-only binding to the contract
	TokenVaultFilterer   // Log filterer for contract events
}

// TokenVaultCaller is an auto generated read-only Go binding around an Ethereum contract.
type TokenVaultCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenVaultTransactor is an auto generated write-only Go binding around an Ethereum contract.
type TokenVaultTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenVaultFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type TokenVaultFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenVaultSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type TokenVaultSession struct {
	Contract     *TokenVault       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// TokenVaultCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type TokenVaultCallerSession struct {
	Contract *TokenVaultCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// TokenVaultTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type TokenVaultTransactorSession struct {
	Contract     *TokenVaultTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// TokenVaultRaw is an auto generated low-level Go binding around an Ethereum contract.
type TokenVaultRaw struct {
	Contract *TokenVault // Generic contract binding to access the raw methods on
}

// TokenVaultCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type TokenVaultCallerRaw struct {
	Contract *TokenVaultCaller // Generic read-only contract binding to access the raw methods on
}

// TokenVaultTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type TokenVaultTransactorRaw struct {
	Contract *TokenVaultTransactor // Generic write-only contract binding to access the raw methods on
}

// NewTokenVault creates a new instance of TokenVault, bound to a specific deployed contract.
func NewTokenVault(address common.Address, backend bind.ContractBackend) (*TokenVault, error) {
	contract, err := bindTokenVault(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &TokenVault{TokenVaultCaller: TokenVaultCaller{contract: contract}, TokenVaultTransactor: TokenVaultTransactor{contract: contract}, TokenVaultFilterer: TokenVaultFilterer{contract: contract}}, nil
}

// NewTokenVaultCaller creates a new read-only instance of TokenVault, bound to a specific deployed contract.
func NewTokenVaultCaller(address common.Address, caller bind.ContractCaller) (*TokenVaultCaller, error) {
	contract, err := bindTokenVault(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &TokenVaultCaller{contract: contract}, nil
}

// NewTokenVaultTransactor creates a new write-only instance of TokenVault, bound to a specific deployed contract.
func NewTokenVaultTransactor(address common.Address, transactor bind.ContractTransactor) (*TokenVaultTransactor, error) {
	contract, err := bindTokenVault(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &TokenVaultTransactor{contract: contract}, nil
}

// NewTokenVaultFilterer creates a new log filterer instance of TokenVault, bound to a specific deployed contract.
func NewTokenVaultFilterer(address common.Address, filterer bind.ContractFilterer) (*TokenVaultFilterer, error) {
	contract, err := bindTokenVault(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &TokenVaultFilterer{contract: contract}, nil
}

// bindTokenVault binds a generic wrapper to an already deployed contract.
func bindTokenVault(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := TokenVaultMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TokenVault *TokenVaultRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TokenVault.Contract.TokenVaultCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TokenVault *TokenVaultRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenVault.Contract.TokenVaultTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TokenVault *TokenVaultRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TokenVault.Contract.TokenVaultTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TokenVault *TokenVaultCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TokenVault.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TokenVault *TokenVaultTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenVault.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TokenVault *TokenVaultTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TokenVault.Contract.contract.Transact(opts, method, params...)
}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_TokenVault *TokenVaultCaller) MessageBridge(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _TokenVault.contract.Call(opts, &out, "messageBridge")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_TokenVault *TokenVaultSession) MessageBridge() (common.Address, error) {
	return _TokenVault.Contract.MessageBridge(&_TokenVault.CallOpts)
}

// MessageBridge is a free data retrieval call binding the contract method 0x33a42db1.
//
// Solidity: function messageBridge() view returns(address)
func (_TokenVault *TokenVaultCallerSession) MessageBridge() (common.Address, error) {
	return _TokenVault.Contract.MessageBridge(&_TokenVault.CallOpts)
}

// MinDeposit is a free data retrieval call binding the contract method 0x3c29f839.
//
// Solidity: function minDeposit(address ) view returns(uint256)
func (_TokenVault *TokenVaultCaller) MinDeposit(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _TokenVault.contract.Call(opts, &out, "minDeposit", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MinDeposit is a free data retrieval call binding the contract method 0x3c29f839.
//
// Solidity: function minDeposit(address ) view returns(uint256)
func (_TokenVault *TokenVaultSession) MinDeposit(arg0 common.Address) (*big.Int, error) {
	return _TokenVault.Contract.MinDeposit(&_TokenVault.CallOpts, arg0)
}

// MinDeposit is a free data retrieval call binding the contract method 0x3c29f839.
//
// Solidity: function minDeposit(address ) view returns(uint256)
func (_TokenVault *TokenVaultCallerSession) MinDeposit(arg0 common.Address) (*big.Int, error) {
	return _TokenVault.Contract.MinDeposit(&_TokenVault.CallOpts, arg0)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TokenVault *TokenVaultCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _TokenVault.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TokenVault *TokenVaultSession) Owner() (common.Address, error) {
	return _TokenVault.Contract.Owner(&_TokenVault.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TokenVault *TokenVaultCallerSession) Owner() (common.Address, error) {
	return _TokenVault.Contract.Owner(&_TokenVault.CallOpts)
}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_TokenVault *TokenVaultCaller) Records(opts *bind.CallOpts, arg0 [32]byte) (bool, error) {
	var out []interface{}
	err := _TokenVault.contract.Call(opts, &out, "records", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_TokenVault *TokenVaultSession) Records(arg0 [32]byte) (bool, error) {
	return _TokenVault.Contract.Records(&_TokenVault.CallOpts, arg0)
}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_TokenVault *TokenVaultCallerSession) Records(arg0 [32]byte) (bool, error) {
	return _TokenVault.Contract.Records(&_TokenVault.CallOpts, arg0)
}

// RemotePegBridges is a free data retrieval call binding the contract method 0xcd49e90b.
//
// Solidity: function remotePegBridges(uint64 ) view returns(address)
func (_TokenVault *TokenVaultCaller) RemotePegBridges(opts *bind.CallOpts, arg0 uint64) (common.Address, error) {
	var out []interface{}
	err := _TokenVault.contract.Call(opts, &out, "remotePegBridges", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// RemotePegBridges is a free data retrieval call binding the contract method 0xcd49e90b.
//
// Solidity: function remotePegBridges(uint64 ) view returns(address)
func (_TokenVault *TokenVaultSession) RemotePegBridges(arg0 uint64) (common.Address, error) {
	return _TokenVault.Contract.RemotePegBridges(&_TokenVault.CallOpts, arg0)
}

// RemotePegBridges is a free data retrieval call binding the contract method 0xcd49e90b.
//
// Solidity: function remotePegBridges(uint64 ) view returns(address)
func (_TokenVault *TokenVaultCallerSession) RemotePegBridges(arg0 uint64) (common.Address, error) {
	return _TokenVault.Contract.RemotePegBridges(&_TokenVault.CallOpts, arg0)
}

// Deposit is a paid mutator transaction binding the contract method 0x23463624.
//
// Solidity: function deposit(address _token, uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) returns(bytes32)
func (_TokenVault *TokenVaultTransactor) Deposit(opts *bind.TransactOpts, _token common.Address, _amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _TokenVault.contract.Transact(opts, "deposit", _token, _amount, _mintChainId, _mintAccount, _nonce)
}

// Deposit is a paid mutator transaction binding the contract method 0x23463624.
//
// Solidity: function deposit(address _token, uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) returns(bytes32)
func (_TokenVault *TokenVaultSession) Deposit(_token common.Address, _amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _TokenVault.Contract.Deposit(&_TokenVault.TransactOpts, _token, _amount, _mintChainId, _mintAccount, _nonce)
}

// Deposit is a paid mutator transaction binding the contract method 0x23463624.
//
// Solidity: function deposit(address _token, uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) returns(bytes32)
func (_TokenVault *TokenVaultTransactorSession) Deposit(_token common.Address, _amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _TokenVault.Contract.Deposit(&_TokenVault.TransactOpts, _token, _amount, _mintChainId, _mintAccount, _nonce)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 srcChainId, address sender, bytes message, address executor) returns(bool)
func (_TokenVault *TokenVaultTransactor) ExecuteMessage(opts *bind.TransactOpts, srcChainId uint64, sender common.Address, message []byte, executor common.Address) (*types.Transaction, error) {
	return _TokenVault.contract.Transact(opts, "executeMessage", srcChainId, sender, message, executor)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 srcChainId, address sender, bytes message, address executor) returns(bool)
func (_TokenVault *TokenVaultSession) ExecuteMessage(srcChainId uint64, sender common.Address, message []byte, executor common.Address) (*types.Transaction, error) {
	return _TokenVault.Contract.ExecuteMessage(&_TokenVault.TransactOpts, srcChainId, sender, message, executor)
}

// ExecuteMessage is a paid mutator transaction binding the contract method 0xaec95a14.
//
// Solidity: function executeMessage(uint64 srcChainId, address sender, bytes message, address executor) returns(bool)
func (_TokenVault *TokenVaultTransactorSession) ExecuteMessage(srcChainId uint64, sender common.Address, message []byte, executor common.Address) (*types.Transaction, error) {
	return _TokenVault.Contract.ExecuteMessage(&_TokenVault.TransactOpts, srcChainId, sender, message, executor)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_TokenVault *TokenVaultTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenVault.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_TokenVault *TokenVaultSession) RenounceOwnership() (*types.Transaction, error) {
	return _TokenVault.Contract.RenounceOwnership(&_TokenVault.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_TokenVault *TokenVaultTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _TokenVault.Contract.RenounceOwnership(&_TokenVault.TransactOpts)
}

// SetMinDeposit is a paid mutator transaction binding the contract method 0x5ec2fa26.
//
// Solidity: function setMinDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_TokenVault *TokenVaultTransactor) SetMinDeposit(opts *bind.TransactOpts, _tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _TokenVault.contract.Transact(opts, "setMinDeposit", _tokens, _amounts)
}

// SetMinDeposit is a paid mutator transaction binding the contract method 0x5ec2fa26.
//
// Solidity: function setMinDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_TokenVault *TokenVaultSession) SetMinDeposit(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _TokenVault.Contract.SetMinDeposit(&_TokenVault.TransactOpts, _tokens, _amounts)
}

// SetMinDeposit is a paid mutator transaction binding the contract method 0x5ec2fa26.
//
// Solidity: function setMinDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_TokenVault *TokenVaultTransactorSession) SetMinDeposit(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _TokenVault.Contract.SetMinDeposit(&_TokenVault.TransactOpts, _tokens, _amounts)
}

// SetRemotePegBridge is a paid mutator transaction binding the contract method 0x2f5c5fee.
//
// Solidity: function setRemotePegBridge(uint64 _remoteChainId, address _remotePegBridge) returns()
func (_TokenVault *TokenVaultTransactor) SetRemotePegBridge(opts *bind.TransactOpts, _remoteChainId uint64, _remotePegBridge common.Address) (*types.Transaction, error) {
	return _TokenVault.contract.Transact(opts, "setRemotePegBridge", _remoteChainId, _remotePegBridge)
}

// SetRemotePegBridge is a paid mutator transaction binding the contract method 0x2f5c5fee.
//
// Solidity: function setRemotePegBridge(uint64 _remoteChainId, address _remotePegBridge) returns()
func (_TokenVault *TokenVaultSession) SetRemotePegBridge(_remoteChainId uint64, _remotePegBridge common.Address) (*types.Transaction, error) {
	return _TokenVault.Contract.SetRemotePegBridge(&_TokenVault.TransactOpts, _remoteChainId, _remotePegBridge)
}

// SetRemotePegBridge is a paid mutator transaction binding the contract method 0x2f5c5fee.
//
// Solidity: function setRemotePegBridge(uint64 _remoteChainId, address _remotePegBridge) returns()
func (_TokenVault *TokenVaultTransactorSession) SetRemotePegBridge(_remoteChainId uint64, _remotePegBridge common.Address) (*types.Transaction, error) {
	return _TokenVault.Contract.SetRemotePegBridge(&_TokenVault.TransactOpts, _remoteChainId, _remotePegBridge)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TokenVault *TokenVaultTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _TokenVault.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TokenVault *TokenVaultSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _TokenVault.Contract.TransferOwnership(&_TokenVault.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TokenVault *TokenVaultTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _TokenVault.Contract.TransferOwnership(&_TokenVault.TransactOpts, newOwner)
}

// TokenVaultDepositedIterator is returned from FilterDeposited and is used to iterate over the raw logs and unpacked data for Deposited events raised by the TokenVault contract.
type TokenVaultDepositedIterator struct {
	Event *TokenVaultDeposited // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenVaultDepositedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenVaultDeposited)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenVaultDeposited)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenVaultDepositedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenVaultDepositedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenVaultDeposited represents a Deposited event raised by the TokenVault contract.
type TokenVaultDeposited struct {
	DepositId   [32]byte
	Depositor   common.Address
	Token       common.Address
	Amount      *big.Int
	MintAccount common.Address
	Nonce       uint64
	MessageId   [32]byte
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterDeposited is a free log retrieval operation binding the contract event 0x3151eb0c52871b9cf9243864e37490145ad0396a42ce45349fdfd20b16a2487f.
//
// Solidity: event Deposited(bytes32 depositId, address depositor, address token, uint256 amount, address mintAccount, uint64 nonce, bytes32 messageId)
func (_TokenVault *TokenVaultFilterer) FilterDeposited(opts *bind.FilterOpts) (*TokenVaultDepositedIterator, error) {

	logs, sub, err := _TokenVault.contract.FilterLogs(opts, "Deposited")
	if err != nil {
		return nil, err
	}
	return &TokenVaultDepositedIterator{contract: _TokenVault.contract, event: "Deposited", logs: logs, sub: sub}, nil
}

// WatchDeposited is a free log subscription operation binding the contract event 0x3151eb0c52871b9cf9243864e37490145ad0396a42ce45349fdfd20b16a2487f.
//
// Solidity: event Deposited(bytes32 depositId, address depositor, address token, uint256 amount, address mintAccount, uint64 nonce, bytes32 messageId)
func (_TokenVault *TokenVaultFilterer) WatchDeposited(opts *bind.WatchOpts, sink chan<- *TokenVaultDeposited) (event.Subscription, error) {

	logs, sub, err := _TokenVault.contract.WatchLogs(opts, "Deposited")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenVaultDeposited)
				if err := _TokenVault.contract.UnpackLog(event, "Deposited", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDeposited is a log parse operation binding the contract event 0x3151eb0c52871b9cf9243864e37490145ad0396a42ce45349fdfd20b16a2487f.
//
// Solidity: event Deposited(bytes32 depositId, address depositor, address token, uint256 amount, address mintAccount, uint64 nonce, bytes32 messageId)
func (_TokenVault *TokenVaultFilterer) ParseDeposited(log types.Log) (*TokenVaultDeposited, error) {
	event := new(TokenVaultDeposited)
	if err := _TokenVault.contract.UnpackLog(event, "Deposited", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TokenVaultMinDepositUpdatedIterator is returned from FilterMinDepositUpdated and is used to iterate over the raw logs and unpacked data for MinDepositUpdated events raised by the TokenVault contract.
type TokenVaultMinDepositUpdatedIterator struct {
	Event *TokenVaultMinDepositUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenVaultMinDepositUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenVaultMinDepositUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenVaultMinDepositUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenVaultMinDepositUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenVaultMinDepositUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenVaultMinDepositUpdated represents a MinDepositUpdated event raised by the TokenVault contract.
type TokenVaultMinDepositUpdated struct {
	Token  common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterMinDepositUpdated is a free log retrieval operation binding the contract event 0x0f48d517989455cd80ed52427e80553e66f9b69fd5cee8e26bd1a1f9c364fba6.
//
// Solidity: event MinDepositUpdated(address token, uint256 amount)
func (_TokenVault *TokenVaultFilterer) FilterMinDepositUpdated(opts *bind.FilterOpts) (*TokenVaultMinDepositUpdatedIterator, error) {

	logs, sub, err := _TokenVault.contract.FilterLogs(opts, "MinDepositUpdated")
	if err != nil {
		return nil, err
	}
	return &TokenVaultMinDepositUpdatedIterator{contract: _TokenVault.contract, event: "MinDepositUpdated", logs: logs, sub: sub}, nil
}

// WatchMinDepositUpdated is a free log subscription operation binding the contract event 0x0f48d517989455cd80ed52427e80553e66f9b69fd5cee8e26bd1a1f9c364fba6.
//
// Solidity: event MinDepositUpdated(address token, uint256 amount)
func (_TokenVault *TokenVaultFilterer) WatchMinDepositUpdated(opts *bind.WatchOpts, sink chan<- *TokenVaultMinDepositUpdated) (event.Subscription, error) {

	logs, sub, err := _TokenVault.contract.WatchLogs(opts, "MinDepositUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenVaultMinDepositUpdated)
				if err := _TokenVault.contract.UnpackLog(event, "MinDepositUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMinDepositUpdated is a log parse operation binding the contract event 0x0f48d517989455cd80ed52427e80553e66f9b69fd5cee8e26bd1a1f9c364fba6.
//
// Solidity: event MinDepositUpdated(address token, uint256 amount)
func (_TokenVault *TokenVaultFilterer) ParseMinDepositUpdated(log types.Log) (*TokenVaultMinDepositUpdated, error) {
	event := new(TokenVaultMinDepositUpdated)
	if err := _TokenVault.contract.UnpackLog(event, "MinDepositUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TokenVaultOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the TokenVault contract.
type TokenVaultOwnershipTransferredIterator struct {
	Event *TokenVaultOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenVaultOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenVaultOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenVaultOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenVaultOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenVaultOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenVaultOwnershipTransferred represents a OwnershipTransferred event raised by the TokenVault contract.
type TokenVaultOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TokenVault *TokenVaultFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*TokenVaultOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _TokenVault.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &TokenVaultOwnershipTransferredIterator{contract: _TokenVault.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TokenVault *TokenVaultFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *TokenVaultOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _TokenVault.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenVaultOwnershipTransferred)
				if err := _TokenVault.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TokenVault *TokenVaultFilterer) ParseOwnershipTransferred(log types.Log) (*TokenVaultOwnershipTransferred, error) {
	event := new(TokenVaultOwnershipTransferred)
	if err := _TokenVault.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TokenVaultWithdrawnIterator is returned from FilterWithdrawn and is used to iterate over the raw logs and unpacked data for Withdrawn events raised by the TokenVault contract.
type TokenVaultWithdrawnIterator struct {
	Event *TokenVaultWithdrawn // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenVaultWithdrawnIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenVaultWithdrawn)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenVaultWithdrawn)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenVaultWithdrawnIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenVaultWithdrawnIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenVaultWithdrawn represents a Withdrawn event raised by the TokenVault contract.
type TokenVaultWithdrawn struct {
	WithdrawId  [32]byte
	Receiver    common.Address
	Token       common.Address
	Amount      *big.Int
	RefId       [32]byte
	BurnAccount common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterWithdrawn is a free log retrieval operation binding the contract event 0xc20f8288cc0b746ccfa1837a99fcdc5225b43ab191419bf6b43fe3802c482956.
//
// Solidity: event Withdrawn(bytes32 withdrawId, address receiver, address token, uint256 amount, bytes32 refId, address burnAccount)
func (_TokenVault *TokenVaultFilterer) FilterWithdrawn(opts *bind.FilterOpts) (*TokenVaultWithdrawnIterator, error) {

	logs, sub, err := _TokenVault.contract.FilterLogs(opts, "Withdrawn")
	if err != nil {
		return nil, err
	}
	return &TokenVaultWithdrawnIterator{contract: _TokenVault.contract, event: "Withdrawn", logs: logs, sub: sub}, nil
}

// WatchWithdrawn is a free log subscription operation binding the contract event 0xc20f8288cc0b746ccfa1837a99fcdc5225b43ab191419bf6b43fe3802c482956.
//
// Solidity: event Withdrawn(bytes32 withdrawId, address receiver, address token, uint256 amount, bytes32 refId, address burnAccount)
func (_TokenVault *TokenVaultFilterer) WatchWithdrawn(opts *bind.WatchOpts, sink chan<- *TokenVaultWithdrawn) (event.Subscription, error) {

	logs, sub, err := _TokenVault.contract.WatchLogs(opts, "Withdrawn")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenVaultWithdrawn)
				if err := _TokenVault.contract.UnpackLog(event, "Withdrawn", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdrawn is a log parse operation binding the contract event 0xc20f8288cc0b746ccfa1837a99fcdc5225b43ab191419bf6b43fe3802c482956.
//
// Solidity: event Withdrawn(bytes32 withdrawId, address receiver, address token, uint256 amount, bytes32 refId, address burnAccount)
func (_TokenVault *TokenVaultFilterer) ParseWithdrawn(log types.Log) (*TokenVaultWithdrawn, error) {
	event := new(TokenVaultWithdrawn)
	if err := _TokenVault.contract.UnpackLog(event, "Withdrawn", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TxMetaData contains all meta data concerning the Tx contract.
var TxMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"txRaw\",\"type\":\"bytes\"}],\"name\":\"decodeTx\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"gasTipCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasFeeCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"internalType\":\"structTx.TxInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]",
	Bin: "0x6080806040523461001a57610e3a908161001f823930815050f35b5f80fdfe6040608081526004361015610012575f80fd5b5f90813560e01c63dae029d314610027575f80fd5b602090816003193601126103d55767ffffffffffffffff916004358381116103d157366023820112156103d15780600401359384116103d157602481019060248536920101116103d1576102e4946102da926102c992610085610526565b9660ff926100ba6002856100b36100ad61009f8789610591565b356001600160f81b03191690565b60f81c90565b16146105ae565b6100df6100da6100d56100ce8580886105fa565b36916106a7565b6109ff565b610a66565b926101136101056100f86100f2876106dd565b51610b79565b67ffffffffffffffff1690565b67ffffffffffffffff168b52565b6101356101256100f86100f2876106ea565b67ffffffffffffffff168b840152565b6101416100f2856106fa565b898b01526101516100f28561070a565b60608b01526101626100f28561071a565b60808b015261018c61017c6101768661072a565b51610b5b565b6001600160a01b031660a08c0152565b6101986100f28561073a565b60c08b01526101af6101a98561074a565b51610be7565b60e08b01526101c96101c36100f28661075b565b60ff1690565b956101ed6101e26101a96101e76101e26101a98a61076c565b6107a2565b9761077d565b958a6102076102026100ad61009f898861059f565b6107d8565b9582871660010361039b576102336101c361022e6100ad610228858a610637565b90610865565b6107f0565b965b61ffff8816603781116102e85750506102bd939261029d8761028f6102b5958561028961027a6102686102a5998e610648565b9d909361027481610891565b91610656565b929093519c8d968701916108f8565b916108f8565b03601f1981018852876104f5565b859716610814565b60f81b6001600160f81b03191690565b901a91610971565b535b8151910120610981565b6001600160a01b0316610100840152565b5191829182610417565b0390f35b909697945083959391925011155f146103615761035b93828261031d61031761009f61032f9661034d98610591565b98610803565b9261032782610891565b931691610673565b8c5195869491929160f81b6001600160f81b03191690888601610940565b03601f1981018352826104f5565b906102bf565b61035b93828261031d61031761009f61037d9661034d98610591565b8c5195869491929160f01b6001600160f01b03191690888601610905565b6103cb6103c66103c06103ba6103b36101c38c610803565b858a61061a565b90610825565b60f01c90565b610851565b96610235565b8480fd5b8280fd5b91908251928382525f5b848110610403575050825f602080949584010152601f8019910116010190565b6020818301810151848301820152016103e3565b6104bd906020815261043660208201845167ffffffffffffffff169052565b602083015167ffffffffffffffff1660408201526040830151606082015260608301516080820152608083015160a082015261048260a084015160c08301906001600160a01b03169052565b60c083015160e082015260e0830151610120906104ac6101009183838601526101408501906103d9565b9401516001600160a01b0316910152565b90565b634e487b7160e01b5f52604160045260245ffd5b6040810190811067ffffffffffffffff8211176104f057604052565b6104c0565b90601f8019910116810190811067ffffffffffffffff8211176104f057604052565b60405190610524826104d4565b565b60405190610120820182811067ffffffffffffffff8211176104f057604052816101005f918281528260208201528260408201528260608201528260808201528260a08201528260c0820152606060e08201520152565b634e487b7160e01b5f52603260045260245ffd5b901561059a5790565b61057d565b906001101561059a5760010190565b156105b557565b60405162461bcd60e51b815260206004820152601660248201527f6e6f7420612044796e616d6963466565547854797065000000000000000000006044820152606490fd5b909291928360011161061657831161061657600101915f190190565b5f80fd5b909291928360021161061657831161061657600201916001190190565b906003116106165760020190600190565b906002116106165790600290565b909291928360031161061657831161061657600301916002190190565b90939293848311610616578411610616578101920390565b67ffffffffffffffff81116104f057601f01601f191660200190565b9291926106b38261068b565b916106c160405193846104f5565b829481845281830111610616578281602093845f960137010152565b80511561059a5760200190565b80516001101561059a5760400190565b80516002101561059a5760600190565b80516003101561059a5760800190565b80516004101561059a5760a00190565b80516005101561059a5760c00190565b80516006101561059a5760e00190565b80516007101561059a576101000190565b80516009101561059a576101400190565b8051600a101561059a576101600190565b8051600b101561059a576101800190565b805182101561059a5760209160051b010190565b6020815191015190602081106107b6575090565b5f199060200360031b1b1690565b634e487b7160e01b5f52601160045260245ffd5b60ff60f6199116019060ff82116107eb57565b6107c4565b60ff6042199116019060ff82116107eb57565b60ff166002019060ff82116107eb57565b60ff1660c0019060ff82116107eb57565b6001600160f01b0319903581811693926002811061084257505050565b60020360031b82901b16169150565b61ffff90811660421901919082116107eb57565b6001600160f81b0319903581811693926001811061088257505050565b60010360031b82901b16169150565b6042198101919082116107eb57565b60bf198101919082116107eb57565b607f198101919082116107eb57565b60200390602082116107eb57565b5f198101919082116107eb57565b60f6198101919082116107eb57565b60b6198101919082116107eb57565b908092918237015f815290565b6001600160f81b0319909116815260f960f81b60018201526001600160f01b031990911660028201526004929182908483013701015f815290565b6001600160f81b03199182168152601f60fb1b6001820152911660028201526003929182908483013701015f815290565b80516001101561059a5760210190565b919260ff8116601b81106109cd575b509160209360809260ff5f9560405194855216868401526040830152606082015282805260015afa156109c2575f5190565b6040513d5f823e3d90fd5b601b9150929192019060ff82116107eb5791906020610990565b604051906109f4826104d4565b5f6020838281520152565b610a076109e7565b50602081519160405192610a1a846104d4565b835201602082015290565b67ffffffffffffffff81116104f05760051b60200190565b90600182018092116107eb57565b919082018092116107eb57565b5f1981146107eb5760010190565b610a6f81610b37565b1561061657610a7d81610c34565b610a8681610a25565b91610a9460405193846104f5565b818352601f19610aa383610a25565b015f5b818110610b20575050610ac7602080920151610ac181610d1a565b90610a4b565b5f905b838210610ad8575050505090565b610b1481610ae8610b1a93610c95565b90610af1610517565b8281528187820152610b03868a61078e565b52610b0e858961078e565b50610a4b565b91610a58565b90610aca565b602090610b2b6109e7565b82828801015201610aa6565b805115610b5657602060c0910151515f1a10610b5257600190565b5f90565b505f90565b601581510361061657610b756001600160a01b0391610b79565b1690565b80518015159081610baf575b501561061657610b9490610bbb565b90519060208110610ba3575090565b6020036101000a900490565b6021915011155f610b85565b906020820191610bcb8351610d1a565b9251908382018092116107eb57519283039283116107eb579190565b80511561061657610bfa6104bd91610bbb565b610c068193929361068b565b92610c1460405194856104f5565b818452601f19610c238361068b565b013660208601378360200190610d87565b805115610b56575f9060208101908151610c4d81610d1a565b81018091116107eb579151905181018091116107eb5791905b828110610c735750905090565b610c7c81610c95565b81018091116107eb57610c8f9091610a58565b90610c66565b80515f1a906080821015610caa575050600190565b60b8821015610cc55750610cc06104bd916108af565b610a3d565b9060c0811015610ce95760b51991600160b783602003016101000a91015104010190565b9060f8821015610d005750610cc06104bd916108a0565b60010151602082900360f7016101000a90040160f5190190565b515f1a6080811015610d2b57505f90565b60b881108015610d62575b15610d415750600190565b60c0811015610d5657610cc06104bd916108e9565b610cc06104bd916108da565b5060c08110158015610d36575060f88110610d36565b601f81116107eb576101000a90565b929091928315610dfe5792915b602093848410610dc957805182528481018091116107eb579381018091116107eb5791601f1981019081116107eb5791610d94565b9193509180610dd757505050565b610deb610de6610df0926108be565b610d78565b6108cc565b905182518216911916179052565b5091505056fea2646970667358221220b07f4753f140ef3ceac626d63e3ee7ceb25826b409ce6e8a7e8392d0ff758cf364736f6c63430008140033",
}

// TxABI is the input ABI used to generate the binding from.
// Deprecated: Use TxMetaData.ABI instead.
var TxABI = TxMetaData.ABI

// TxBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use TxMetaData.Bin instead.
var TxBin = TxMetaData.Bin

// DeployTx deploys a new Ethereum contract, binding an instance of Tx to it.
func DeployTx(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Tx, error) {
	parsed, err := TxMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(TxBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Tx{TxCaller: TxCaller{contract: contract}, TxTransactor: TxTransactor{contract: contract}, TxFilterer: TxFilterer{contract: contract}}, nil
}

// Tx is an auto generated Go binding around an Ethereum contract.
type Tx struct {
	TxCaller     // Read-only binding to the contract
	TxTransactor // Write-only binding to the contract
	TxFilterer   // Log filterer for contract events
}

// TxCaller is an auto generated read-only Go binding around an Ethereum contract.
type TxCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TxTransactor is an auto generated write-only Go binding around an Ethereum contract.
type TxTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TxFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type TxFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TxSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type TxSession struct {
	Contract     *Tx               // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// TxCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type TxCallerSession struct {
	Contract *TxCaller     // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// TxTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type TxTransactorSession struct {
	Contract     *TxTransactor     // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// TxRaw is an auto generated low-level Go binding around an Ethereum contract.
type TxRaw struct {
	Contract *Tx // Generic contract binding to access the raw methods on
}

// TxCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type TxCallerRaw struct {
	Contract *TxCaller // Generic read-only contract binding to access the raw methods on
}

// TxTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type TxTransactorRaw struct {
	Contract *TxTransactor // Generic write-only contract binding to access the raw methods on
}

// NewTx creates a new instance of Tx, bound to a specific deployed contract.
func NewTx(address common.Address, backend bind.ContractBackend) (*Tx, error) {
	contract, err := bindTx(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Tx{TxCaller: TxCaller{contract: contract}, TxTransactor: TxTransactor{contract: contract}, TxFilterer: TxFilterer{contract: contract}}, nil
}

// NewTxCaller creates a new read-only instance of Tx, bound to a specific deployed contract.
func NewTxCaller(address common.Address, caller bind.ContractCaller) (*TxCaller, error) {
	contract, err := bindTx(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &TxCaller{contract: contract}, nil
}

// NewTxTransactor creates a new write-only instance of Tx, bound to a specific deployed contract.
func NewTxTransactor(address common.Address, transactor bind.ContractTransactor) (*TxTransactor, error) {
	contract, err := bindTx(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &TxTransactor{contract: contract}, nil
}

// NewTxFilterer creates a new log filterer instance of Tx, bound to a specific deployed contract.
func NewTxFilterer(address common.Address, filterer bind.ContractFilterer) (*TxFilterer, error) {
	contract, err := bindTx(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &TxFilterer{contract: contract}, nil
}

// bindTx binds a generic wrapper to an already deployed contract.
func bindTx(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := TxMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Tx *TxRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Tx.Contract.TxCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Tx *TxRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Tx.Contract.TxTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Tx *TxRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Tx.Contract.TxTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Tx *TxCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Tx.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Tx *TxTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Tx.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Tx *TxTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Tx.Contract.contract.Transact(opts, method, params...)
}

// DecodeTx is a free data retrieval call binding the contract method 0xdae029d3.
//
// Solidity: function decodeTx(bytes txRaw) pure returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address) info)
func (_Tx *TxCaller) DecodeTx(opts *bind.CallOpts, txRaw []byte) (TxTxInfo, error) {
	var out []interface{}
	err := _Tx.contract.Call(opts, &out, "decodeTx", txRaw)

	if err != nil {
		return *new(TxTxInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(TxTxInfo)).(*TxTxInfo)

	return out0, err

}

// DecodeTx is a free data retrieval call binding the contract method 0xdae029d3.
//
// Solidity: function decodeTx(bytes txRaw) pure returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address) info)
func (_Tx *TxSession) DecodeTx(txRaw []byte) (TxTxInfo, error) {
	return _Tx.Contract.DecodeTx(&_Tx.CallOpts, txRaw)
}

// DecodeTx is a free data retrieval call binding the contract method 0xdae029d3.
//
// Solidity: function decodeTx(bytes txRaw) pure returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address) info)
func (_Tx *TxCallerSession) DecodeTx(txRaw []byte) (TxTxInfo, error) {
	return _Tx.Contract.DecodeTx(&_Tx.CallOpts, txRaw)
}

// TxVerifierMetaData contains all meta data concerning the TxVerifier contract.
var TxVerifierMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_blockChunks\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"UpdateBlockChunks\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"UpdateVerifierAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"txHash\",\"type\":\"bytes32\"}],\"name\":\"VerifiedTx\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"blockChunks\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"txRaw\",\"type\":\"bytes\"}],\"name\":\"decodeTx\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"gasTipCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasFeeCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"blkHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"blkTime\",\"type\":\"uint64\"}],\"internalType\":\"structITxVerifier.TxInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_blockChunks\",\"type\":\"address\"}],\"name\":\"updateBlockChunks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_verifierAddress\",\"type\":\"address\"}],\"name\":\"updateVerifierAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"verifierAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"txRaw\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"auxiBlkVerifyInfo\",\"type\":\"bytes\"}],\"name\":\"verifyTx\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"gasTipCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasFeeCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"blkHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"blkTime\",\"type\":\"uint64\"}],\"internalType\":\"structITxVerifier.TxInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"txRaw\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"auxiBlkVerifyInfo\",\"type\":\"bytes\"}],\"name\":\"verifyTxAndLog\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"gasTipCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasFeeCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"blkNum\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"blkHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"blkTime\",\"type\":\"uint64\"}],\"internalType\":\"structITxVerifier.TxInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x6080346100a457601f611ce038819003918201601f19168301916001600160401b038311848410176100a8578084926020946040528339810103126100a457516001600160a01b0390818116908190036100a4575f5460018060a01b03199033828216175f55604051933391167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a36002541617600255611c2390816100bd8239f35b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe60806040526004361015610011575f80fd5b5f803560e01c9081631eeb86da146100a757508063361108de146100a2578063724796ed1461009d5780638da5cb5b14610098578063a8da8d6914610093578063dae029d31461008e578063ec4ffc5214610089578063f2fde38b146100845763f5cec6af1461007f575f80fd5b6105e8565b6104fe565b61045c565b610408565b6103dc565b6103b7565b610391565b610306565b34610124576020366003190112610124577f0addee9cb6aa9328bbfbe8282179a6737af344619320736b6918af70b6a94a9860206100e3610127565b6001600160a01b03906100fa82865416331461062a565b168073ffffffffffffffffffffffffffffffffffffffff196002541617600255604051908152a180f35b80fd5b600435906001600160a01b038216820361013d57565b5f80fd5b9181601f8401121561013d5782359167ffffffffffffffff831161013d576020838186019501011161013d57565b90606060031983011261013d5767ffffffffffffffff60043581811161013d578361019c91600401610141565b9390939260243583811161013d57826101b791600401610141565b9390939260443591821161013d576101d191600401610141565b9091565b5f5b8381106101e65750505f910152565b81810151838201526020016101d7565b9060209161020f815180928185528580860191016101d5565b601f01601f1916010190565b610303906020815261023a60208201845167ffffffffffffffff169052565b602083015167ffffffffffffffff1660408201526040830151606082015260608301516080820152608083015160a082015261028660a084015160c08301906001600160a01b03169052565b60c083015160e082015260e083015192610180906102b16101009583878601526101a08501906101f6565b948101516102cd61012091828601906001600160a01b03169052565b8101516102e5610140918286019063ffffffff169052565b81015161016084810191909152015167ffffffffffffffff16910152565b90565b3461013d5761038d61036f7fe1df3a08ea1a2c110c3f833d615f7e02814f32a3418b98f011888d0516669888604061035a6103403661016f565b926103529995999694969291926106fb565b50868a61097e565b9467ffffffffffffffff865116923691610783565b6020815191012082519182526020820152a16040519182918261021b565b0390f35b3461013d575f36600319011261013d5760206001600160a01b0360025416604051908152f35b3461013d575f36600319011261013d5760206001600160a01b035f5416604051908152f35b3461013d5761038d6103fc6103f03661016f565b9493909392919261097e565b6040519182918261021b565b3461013d57602036600319011261013d5760043567ffffffffffffffff811161013d576103fc61043f61038d923690600401610141565b9061117e565b6004359067ffffffffffffffff8216820361013d57565b3461013d57604036600319011261013d57610475610445565b602435906001600160a01b039182811680910361013d5767ffffffffffffffff6040926104c77ffd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f955f5416331461062a565b1690815f526001602052825f208173ffffffffffffffffffffffffffffffffffffffff1982541617905582519182526020820152a1005b3461013d57602036600319011261013d57610517610127565b5f908154906001600160a01b038083169161053333841461062a565b1691821561057d5773ffffffffffffffffffffffffffffffffffffffff1916821783557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608490fd5b3461013d57602036600319011261013d5767ffffffffffffffff61060a610445565b165f52600160205260206001600160a01b0360405f205416604051908152f35b1561063157565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b634e487b7160e01b5f52604160045260245ffd5b6040810190811067ffffffffffffffff8211176106a557604052565b610675565b90601f8019910116810190811067ffffffffffffffff8211176106a557604052565b6040519060c0820182811067ffffffffffffffff8211176106a557604052565b604051906106f982610689565b565b60405190610180820182811067ffffffffffffffff8211176106a557604052816101605f918281528260208201528260408201528260608201528260808201528260a08201528260c0820152606060e08201528261010082015282610120820152826101408201520152565b67ffffffffffffffff81116106a557601f01601f191660200190565b92919261078f82610767565b9161079d60405193846106aa565b82948184528183011161013d578281602093845f960137010152565b156107c057565b60405162461bcd60e51b815260206004820152600f60248201527f70726f6f66206e6f742076616c696400000000000000000000000000000000006044820152606490fd5b908092918237015f815290565b602090836106f993959495604051968361083589955180928880890191016101d5565b84019185830137015f838201520380855201836106aa565b1561085457565b60405162461bcd60e51b815260206004820152601260248201527f6c65616648617368206e6f74206d6174636800000000000000000000000000006044820152606490fd5b9081602091031261013d5751801515810361013d5790565b91909161018081019267ffffffffffffffff815116825260a08063ffffffff926020938085830151168587015260408201516040870152606082015160608701526080820151166080860152015192015f905b600782106109125750505050565b82806001928651815201940191019092610904565b6040513d5f823e3d90fd5b1561093957565b60405162461bcd60e51b815260206004820152600f60248201527f696e76616c696420626c6b4861736800000000000000000000000000000000006044820152606490fd5b9093919594929561098d6106fb565b50610998858361117e565b96818189516109ae9067ffffffffffffffff1690565b916109b89261154b565b6109c1906107b9565b6109ca916116be565b936080850151916109da92610812565b9182516020809401208451146109ef9061084d565b6109f891610dea565b86519293919267ffffffffffffffff169060408601938451610a1d9063ffffffff1690565b9584880196875190610a2d6106cc565b67ffffffffffffffff909616865263ffffffff16858701526040850152606084015263ffffffff16608083015260a082015260025482906001600160a01b03166001600160a01b03166001600160a01b0316604051631513dce960e21b81529283919082908190610aa190600483016108b1565b03915afa908115610b3d576106f995610b0295610ad0610ae694606094610af8975f92610b10575b5050610932565b516101408a0152015167ffffffffffffffff1690565b67ffffffffffffffff16610160870152565b5163ffffffff1690565b63ffffffff16610120840152565b610b2f9250803d10610b36575b610b2781836106aa565b810190610899565b5f80610ac9565b503d610b1d565b610927565b15610b4957565b60405162461bcd60e51b815260206004820152601b60248201527f696e636f72726563742061757869426c6b566572696679496e666f00000000006044820152606490fd5b9060201161013d5790602090565b9060241161013d5760200190600490565b906101041161013d5760e40190602090565b909291928360011161013d57831161013d57600101915f190190565b909291928360021161013d57831161013d57600201916001190190565b9060031161013d5760020190600190565b9060021161013d5790600290565b909291928360031161013d57831161013d57600301916002190190565b906101601161013d576101400190602090565b906101801161013d576101700190601090565b906101a01161013d576101800190602090565b906101c01161013d576101b00190601090565b906101e01161013d576101dc0190600490565b906102001161013d576101f80190600890565b9291926102009184831161013d57841161013d5701916101ff190190565b9093929384831161013d57841161013d578101920390565b359060208110610cea575090565b5f199060200360031b1b1690565b7fffffffff000000000000000000000000000000000000000000000000000000009035818116939260048110610d2d57505050565b60040360031b82901b16169150565b634e487b7160e01b5f52601160045260245ffd5b60ff1660ff8114610d615760010190565b610d3c565b60051b90611fe060e0831692168203610d6157565b60ff166024019060ff8211610d6157565b60ff60019116019060ff8211610d6157565b60ff166002019060ff8211610d6157565b60ff1660c0019060ff8211610d6157565b634e487b7160e01b5f52603260045260245ffd5b906007811015610de55760051b0190565b610dc0565b916040519060e0820182811067ffffffffffffffff8211176106a55760405260e036833781610e1c6101048514610b42565b610e2f610e298587610b8e565b90610cdc565b93610e4c610e46610e408389610b9c565b90610cf8565b60e01c90565b945f5b60ff808216906006821015610eb15790610ea6610e9f610e2985948d89610e80610e7b610eac9a610d66565b610d7b565b9280610e96610e7b610e918c610d8c565b610d66565b16931691610cc4565b9189610dd4565b52610d50565b610e4f565b50505095610e2960c092610ec792969496610bad565b910152565b9015610de55790565b9060011015610de55760010190565b15610eeb57565b60405162461bcd60e51b815260206004820152601660248201527f6e6f7420612044796e616d6963466565547854797065000000000000000000006044820152606490fd5b805115610de55760200190565b805160011015610de55760400190565b805160021015610de55760600190565b805160031015610de55760800190565b805160041015610de55760a00190565b805160051015610de55760c00190565b805160061015610de55760e00190565b805160071015610de5576101000190565b805160091015610de5576101400190565b8051600a1015610de5576101600190565b8051600b1015610de5576101800190565b8051821015610de55760209160051b010190565b602081519101519060208110610cea575090565b60ff60f6199116019060ff8211610d6157565b60ff6042199116019060ff8211610d6157565b6001600160f01b0319903581811693926002811061104c57505050565b60020360031b82901b16169150565b61ffff9081166042190191908211610d6157565b6001600160f81b0319903581811693926001811061108c57505050565b60010360031b82901b16169150565b604219810191908211610d6157565b60bf19810191908211610d6157565b607f19810191908211610d6157565b6020039060208211610d6157565b5f19810191908211610d6157565b60f619810191908211610d6157565b60b619810191908211610d6157565b6001600160f81b0319909116815260f960f81b60018201526001600160f01b031990911660028201526004929182908483013701015f815290565b6001600160f81b03199182168152601f60fb1b6001820152911660028201526003929182908483013701015f815290565b805160011015610de55760210190565b91906113d46106f99161118f6106fb565b9460ff906111c46002836111bd6111b76111a98887610ecc565b356001600160f81b03191690565b60f81c90565b1614610ee4565b6111e96111e46111df6111d8868086610bbf565b3691610783565b6117e8565b61184f565b9061121d61120f6112026111fc85610f30565b51611962565b67ffffffffffffffff1690565b67ffffffffffffffff168952565b61124061122f6112026111fc85610f3d565b67ffffffffffffffff1660208a0152565b61124c6111fc83610f4d565b604089015261125d6111fc83610f5d565b606089015261126e6111fc83610f6d565b608089015261129861128861128284610f7d565b51611944565b6001600160a01b031660a08a0152565b6112a46111fc83610f8d565b60c08901526112bb6112b583610f9d565b516119d0565b60e08901526112d56112cf6111fc84610fae565b60ff1690565b936112f96112ee6112b56112f36112ee6112b588610fbf565b610ff5565b95610fd0565b9361131261130d6111b76111a98587610ed5565b611009565b928184166001036114935761133e6112cf6113396111b76113338786610bf8565b9061106f565b61101c565b935b61ffff8516603781116113e55750506113ae6113c6926113a68361139861137f61136d896113be98610c09565b9390996113798161109b565b91610c17565b6113926040519a8b956020870191610805565b91610805565b03601f1981018752866106aa565b849516610daf565b60f81b6001600160f81b03191690565b5f1a9161116e565b535b602081519101206114c9565b6001600160a01b0316610100840152565b909492939084106114575761145293828261141261140c6111a96114249661144498610ecc565b98610d9e565b9261141c8261109b565b931691610cc4565b60405195869491929160f81b6001600160f81b031916906020860161113d565b03601f1981018352826106aa565b6113c8565b61145293828261141261140c6111a96114739661144498610ecc565b60405195869491929160f01b6001600160f01b0319169060208601611102565b6114c36114be6114b86114b26114ab6112cf89610d9e565b8786610bdb565b9061102f565b60f01c90565b61105b565b93611340565b919260ff8116601b811061150a575b509160209360809260ff5f9560405194855216868401526040830152606082015282805260015afa15610b3d575f5190565b601b9150929192019060ff8211610d6157919060206114d8565b90918060409360208452816020850152848401375f828201840152601f01601f1916010190565b909167ffffffffffffffff82165f5260016020526001600160a01b0360405f20541615611600576115d3926115b66115aa6115aa61159d60209667ffffffffffffffff165f52600160205260405f2090565b546001600160a01b031690565b6001600160a01b031690565b906040518095819482936322bb937360e11b845260048401611524565b03915afa908115610b3d575f916115e8575090565b610303915060203d8111610b3657610b2781836106aa565b60405162461bcd60e51b815260206004820152601660248201527f636861696e207665726966696572206e6f7420736574000000000000000000006044820152606490fd5b6fffffffffffffffffffffffffffffffff19903581811693926010811061166b57505050565b60100360031b82901b16169150565b7fffffffffffffffff00000000000000000000000000000000000000000000000090358181169392600881106116af57505050565b60080360031b82901b16169150565b604051929160a0840167ffffffffffffffff8111858210176106a5576117cc916111d8916040525f86528060208701945f86526117c7604089015f815261179d60608b01915f835260808c019960608b528c611726611720610e298a8a610c34565b60801b90565b61175a61174561173f6117398c8c610c47565b90611645565b60801c90565b6fffffffffffffffffffffffffffffffff1690565b17905261176d611720610e298989610c5a565b61178061174561173f6117398b8b610c6d565b179052611793610e46610e408888610c80565b63ffffffff169052565b6117b96117b36117ad8686610c93565b9061167a565b60c01c90565b67ffffffffffffffff169052565b610ca6565b9052565b604051906117dd82610689565b5f6020838281520152565b6117f06117d0565b5060208151916040519261180384610689565b835201602082015290565b67ffffffffffffffff81116106a55760051b60200190565b9060018201809211610d6157565b91908201809211610d6157565b5f198114610d615760010190565b61185881611920565b1561013d5761186681611a1d565b61186f8161180e565b9161187d60405193846106aa565b818352601f1961188c8361180e565b015f5b8181106119095750506118b06020809201516118aa81611b03565b90611834565b5f905b8382106118c1575050505090565b6118fd816118d161190393611a7e565b906118da6106ec565b82815281878201526118ec868a610fe1565b526118f78589610fe1565b50611834565b91611841565b906118b3565b6020906119146117d0565b8282880101520161188f565b80511561193f57602060c0910151515f1a1061193b57600190565b5f90565b505f90565b601581510361013d5761195e6001600160a01b0391611962565b1690565b80518015159081611998575b501561013d5761197d906119a4565b9051906020811061198c575090565b6020036101000a900490565b6021915011155f61196e565b9060208201916119b48351611b03565b925190838201809211610d615751928303928311610d61579190565b80511561013d576119e3610303916119a4565b6119ef81939293610767565b926119fd60405194856106aa565b818452601f19611a0c83610767565b013660208601378360200190611b70565b80511561193f575f9060208101908151611a3681611b03565b8101809111610d6157915190518101809111610d615791905b828110611a5c5750905090565b611a6581611a7e565b8101809111610d6157611a789091611841565b90611a4f565b80515f1a906080821015611a93575050600190565b60b8821015611aae5750611aa9610303916110b9565b611826565b9060c0811015611ad25760b51991600160b783602003016101000a91015104010190565b9060f8821015611ae95750611aa9610303916110aa565b60010151602082900360f7016101000a90040160f5190190565b515f1a6080811015611b1457505f90565b60b881108015611b4b575b15611b2a5750600190565b60c0811015611b3f57611aa9610303916110f3565b611aa9610303916110e4565b5060c08110158015611b1f575060f88110611b1f565b601f8111610d61576101000a90565b929091928315611be75792915b602093848410611bb25780518252848101809111610d6157938101809111610d615791601f198101908111610d615791611b7d565b9193509180611bc057505050565b611bd4611bcf611bd9926110c8565b611b61565b6110d6565b905182518216911916179052565b5091505056fea264697066735822122097da30c2dcd75a565c3afd1ba791bef4b5d8384668c492f1b770916dc96cd7dc64736f6c63430008140033",
}

// TxVerifierABI is the input ABI used to generate the binding from.
// Deprecated: Use TxVerifierMetaData.ABI instead.
var TxVerifierABI = TxVerifierMetaData.ABI

// TxVerifierBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use TxVerifierMetaData.Bin instead.
var TxVerifierBin = TxVerifierMetaData.Bin

// DeployTxVerifier deploys a new Ethereum contract, binding an instance of TxVerifier to it.
func DeployTxVerifier(auth *bind.TransactOpts, backend bind.ContractBackend, _blockChunks common.Address) (common.Address, *types.Transaction, *TxVerifier, error) {
	parsed, err := TxVerifierMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(TxVerifierBin), backend, _blockChunks)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &TxVerifier{TxVerifierCaller: TxVerifierCaller{contract: contract}, TxVerifierTransactor: TxVerifierTransactor{contract: contract}, TxVerifierFilterer: TxVerifierFilterer{contract: contract}}, nil
}

// TxVerifier is an auto generated Go binding around an Ethereum contract.
type TxVerifier struct {
	TxVerifierCaller     // Read-only binding to the contract
	TxVerifierTransactor // Write-only binding to the contract
	TxVerifierFilterer   // Log filterer for contract events
}

// TxVerifierCaller is an auto generated read-only Go binding around an Ethereum contract.
type TxVerifierCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TxVerifierTransactor is an auto generated write-only Go binding around an Ethereum contract.
type TxVerifierTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TxVerifierFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type TxVerifierFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TxVerifierSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type TxVerifierSession struct {
	Contract     *TxVerifier       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// TxVerifierCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type TxVerifierCallerSession struct {
	Contract *TxVerifierCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// TxVerifierTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type TxVerifierTransactorSession struct {
	Contract     *TxVerifierTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// TxVerifierRaw is an auto generated low-level Go binding around an Ethereum contract.
type TxVerifierRaw struct {
	Contract *TxVerifier // Generic contract binding to access the raw methods on
}

// TxVerifierCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type TxVerifierCallerRaw struct {
	Contract *TxVerifierCaller // Generic read-only contract binding to access the raw methods on
}

// TxVerifierTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type TxVerifierTransactorRaw struct {
	Contract *TxVerifierTransactor // Generic write-only contract binding to access the raw methods on
}

// NewTxVerifier creates a new instance of TxVerifier, bound to a specific deployed contract.
func NewTxVerifier(address common.Address, backend bind.ContractBackend) (*TxVerifier, error) {
	contract, err := bindTxVerifier(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &TxVerifier{TxVerifierCaller: TxVerifierCaller{contract: contract}, TxVerifierTransactor: TxVerifierTransactor{contract: contract}, TxVerifierFilterer: TxVerifierFilterer{contract: contract}}, nil
}

// NewTxVerifierCaller creates a new read-only instance of TxVerifier, bound to a specific deployed contract.
func NewTxVerifierCaller(address common.Address, caller bind.ContractCaller) (*TxVerifierCaller, error) {
	contract, err := bindTxVerifier(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &TxVerifierCaller{contract: contract}, nil
}

// NewTxVerifierTransactor creates a new write-only instance of TxVerifier, bound to a specific deployed contract.
func NewTxVerifierTransactor(address common.Address, transactor bind.ContractTransactor) (*TxVerifierTransactor, error) {
	contract, err := bindTxVerifier(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &TxVerifierTransactor{contract: contract}, nil
}

// NewTxVerifierFilterer creates a new log filterer instance of TxVerifier, bound to a specific deployed contract.
func NewTxVerifierFilterer(address common.Address, filterer bind.ContractFilterer) (*TxVerifierFilterer, error) {
	contract, err := bindTxVerifier(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &TxVerifierFilterer{contract: contract}, nil
}

// bindTxVerifier binds a generic wrapper to an already deployed contract.
func bindTxVerifier(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := TxVerifierMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TxVerifier *TxVerifierRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TxVerifier.Contract.TxVerifierCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TxVerifier *TxVerifierRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TxVerifier.Contract.TxVerifierTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TxVerifier *TxVerifierRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TxVerifier.Contract.TxVerifierTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TxVerifier *TxVerifierCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TxVerifier.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TxVerifier *TxVerifierTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TxVerifier.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TxVerifier *TxVerifierTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TxVerifier.Contract.contract.Transact(opts, method, params...)
}

// BlockChunks is a free data retrieval call binding the contract method 0x724796ed.
//
// Solidity: function blockChunks() view returns(address)
func (_TxVerifier *TxVerifierCaller) BlockChunks(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _TxVerifier.contract.Call(opts, &out, "blockChunks")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// BlockChunks is a free data retrieval call binding the contract method 0x724796ed.
//
// Solidity: function blockChunks() view returns(address)
func (_TxVerifier *TxVerifierSession) BlockChunks() (common.Address, error) {
	return _TxVerifier.Contract.BlockChunks(&_TxVerifier.CallOpts)
}

// BlockChunks is a free data retrieval call binding the contract method 0x724796ed.
//
// Solidity: function blockChunks() view returns(address)
func (_TxVerifier *TxVerifierCallerSession) BlockChunks() (common.Address, error) {
	return _TxVerifier.Contract.BlockChunks(&_TxVerifier.CallOpts)
}

// DecodeTx is a free data retrieval call binding the contract method 0xdae029d3.
//
// Solidity: function decodeTx(bytes txRaw) pure returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) info)
func (_TxVerifier *TxVerifierCaller) DecodeTx(opts *bind.CallOpts, txRaw []byte) (ITxVerifierTxInfo, error) {
	var out []interface{}
	err := _TxVerifier.contract.Call(opts, &out, "decodeTx", txRaw)

	if err != nil {
		return *new(ITxVerifierTxInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(ITxVerifierTxInfo)).(*ITxVerifierTxInfo)

	return out0, err

}

// DecodeTx is a free data retrieval call binding the contract method 0xdae029d3.
//
// Solidity: function decodeTx(bytes txRaw) pure returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) info)
func (_TxVerifier *TxVerifierSession) DecodeTx(txRaw []byte) (ITxVerifierTxInfo, error) {
	return _TxVerifier.Contract.DecodeTx(&_TxVerifier.CallOpts, txRaw)
}

// DecodeTx is a free data retrieval call binding the contract method 0xdae029d3.
//
// Solidity: function decodeTx(bytes txRaw) pure returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) info)
func (_TxVerifier *TxVerifierCallerSession) DecodeTx(txRaw []byte) (ITxVerifierTxInfo, error) {
	return _TxVerifier.Contract.DecodeTx(&_TxVerifier.CallOpts, txRaw)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TxVerifier *TxVerifierCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _TxVerifier.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TxVerifier *TxVerifierSession) Owner() (common.Address, error) {
	return _TxVerifier.Contract.Owner(&_TxVerifier.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TxVerifier *TxVerifierCallerSession) Owner() (common.Address, error) {
	return _TxVerifier.Contract.Owner(&_TxVerifier.CallOpts)
}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_TxVerifier *TxVerifierCaller) VerifierAddresses(opts *bind.CallOpts, arg0 uint64) (common.Address, error) {
	var out []interface{}
	err := _TxVerifier.contract.Call(opts, &out, "verifierAddresses", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_TxVerifier *TxVerifierSession) VerifierAddresses(arg0 uint64) (common.Address, error) {
	return _TxVerifier.Contract.VerifierAddresses(&_TxVerifier.CallOpts, arg0)
}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_TxVerifier *TxVerifierCallerSession) VerifierAddresses(arg0 uint64) (common.Address, error) {
	return _TxVerifier.Contract.VerifierAddresses(&_TxVerifier.CallOpts, arg0)
}

// VerifyTx is a free data retrieval call binding the contract method 0xa8da8d69.
//
// Solidity: function verifyTx(bytes txRaw, bytes proofData, bytes auxiBlkVerifyInfo) view returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) info)
func (_TxVerifier *TxVerifierCaller) VerifyTx(opts *bind.CallOpts, txRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (ITxVerifierTxInfo, error) {
	var out []interface{}
	err := _TxVerifier.contract.Call(opts, &out, "verifyTx", txRaw, proofData, auxiBlkVerifyInfo)

	if err != nil {
		return *new(ITxVerifierTxInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(ITxVerifierTxInfo)).(*ITxVerifierTxInfo)

	return out0, err

}

// VerifyTx is a free data retrieval call binding the contract method 0xa8da8d69.
//
// Solidity: function verifyTx(bytes txRaw, bytes proofData, bytes auxiBlkVerifyInfo) view returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) info)
func (_TxVerifier *TxVerifierSession) VerifyTx(txRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (ITxVerifierTxInfo, error) {
	return _TxVerifier.Contract.VerifyTx(&_TxVerifier.CallOpts, txRaw, proofData, auxiBlkVerifyInfo)
}

// VerifyTx is a free data retrieval call binding the contract method 0xa8da8d69.
//
// Solidity: function verifyTx(bytes txRaw, bytes proofData, bytes auxiBlkVerifyInfo) view returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) info)
func (_TxVerifier *TxVerifierCallerSession) VerifyTx(txRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (ITxVerifierTxInfo, error) {
	return _TxVerifier.Contract.VerifyTx(&_TxVerifier.CallOpts, txRaw, proofData, auxiBlkVerifyInfo)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TxVerifier *TxVerifierTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _TxVerifier.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TxVerifier *TxVerifierSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _TxVerifier.Contract.TransferOwnership(&_TxVerifier.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TxVerifier *TxVerifierTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _TxVerifier.Contract.TransferOwnership(&_TxVerifier.TransactOpts, newOwner)
}

// UpdateBlockChunks is a paid mutator transaction binding the contract method 0x1eeb86da.
//
// Solidity: function updateBlockChunks(address _blockChunks) returns()
func (_TxVerifier *TxVerifierTransactor) UpdateBlockChunks(opts *bind.TransactOpts, _blockChunks common.Address) (*types.Transaction, error) {
	return _TxVerifier.contract.Transact(opts, "updateBlockChunks", _blockChunks)
}

// UpdateBlockChunks is a paid mutator transaction binding the contract method 0x1eeb86da.
//
// Solidity: function updateBlockChunks(address _blockChunks) returns()
func (_TxVerifier *TxVerifierSession) UpdateBlockChunks(_blockChunks common.Address) (*types.Transaction, error) {
	return _TxVerifier.Contract.UpdateBlockChunks(&_TxVerifier.TransactOpts, _blockChunks)
}

// UpdateBlockChunks is a paid mutator transaction binding the contract method 0x1eeb86da.
//
// Solidity: function updateBlockChunks(address _blockChunks) returns()
func (_TxVerifier *TxVerifierTransactorSession) UpdateBlockChunks(_blockChunks common.Address) (*types.Transaction, error) {
	return _TxVerifier.Contract.UpdateBlockChunks(&_TxVerifier.TransactOpts, _blockChunks)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_TxVerifier *TxVerifierTransactor) UpdateVerifierAddress(opts *bind.TransactOpts, _chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _TxVerifier.contract.Transact(opts, "updateVerifierAddress", _chainId, _verifierAddress)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_TxVerifier *TxVerifierSession) UpdateVerifierAddress(_chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _TxVerifier.Contract.UpdateVerifierAddress(&_TxVerifier.TransactOpts, _chainId, _verifierAddress)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_TxVerifier *TxVerifierTransactorSession) UpdateVerifierAddress(_chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _TxVerifier.Contract.UpdateVerifierAddress(&_TxVerifier.TransactOpts, _chainId, _verifierAddress)
}

// VerifyTxAndLog is a paid mutator transaction binding the contract method 0x361108de.
//
// Solidity: function verifyTxAndLog(bytes txRaw, bytes proofData, bytes auxiBlkVerifyInfo) returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) info)
func (_TxVerifier *TxVerifierTransactor) VerifyTxAndLog(opts *bind.TransactOpts, txRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (*types.Transaction, error) {
	return _TxVerifier.contract.Transact(opts, "verifyTxAndLog", txRaw, proofData, auxiBlkVerifyInfo)
}

// VerifyTxAndLog is a paid mutator transaction binding the contract method 0x361108de.
//
// Solidity: function verifyTxAndLog(bytes txRaw, bytes proofData, bytes auxiBlkVerifyInfo) returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) info)
func (_TxVerifier *TxVerifierSession) VerifyTxAndLog(txRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (*types.Transaction, error) {
	return _TxVerifier.Contract.VerifyTxAndLog(&_TxVerifier.TransactOpts, txRaw, proofData, auxiBlkVerifyInfo)
}

// VerifyTxAndLog is a paid mutator transaction binding the contract method 0x361108de.
//
// Solidity: function verifyTxAndLog(bytes txRaw, bytes proofData, bytes auxiBlkVerifyInfo) returns((uint64,uint64,uint256,uint256,uint256,address,uint256,bytes,address,uint32,bytes32,uint64) info)
func (_TxVerifier *TxVerifierTransactorSession) VerifyTxAndLog(txRaw []byte, proofData []byte, auxiBlkVerifyInfo []byte) (*types.Transaction, error) {
	return _TxVerifier.Contract.VerifyTxAndLog(&_TxVerifier.TransactOpts, txRaw, proofData, auxiBlkVerifyInfo)
}

// TxVerifierOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the TxVerifier contract.
type TxVerifierOwnershipTransferredIterator struct {
	Event *TxVerifierOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TxVerifierOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TxVerifierOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TxVerifierOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TxVerifierOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TxVerifierOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TxVerifierOwnershipTransferred represents a OwnershipTransferred event raised by the TxVerifier contract.
type TxVerifierOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TxVerifier *TxVerifierFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*TxVerifierOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _TxVerifier.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &TxVerifierOwnershipTransferredIterator{contract: _TxVerifier.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TxVerifier *TxVerifierFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *TxVerifierOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _TxVerifier.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TxVerifierOwnershipTransferred)
				if err := _TxVerifier.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TxVerifier *TxVerifierFilterer) ParseOwnershipTransferred(log types.Log) (*TxVerifierOwnershipTransferred, error) {
	event := new(TxVerifierOwnershipTransferred)
	if err := _TxVerifier.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TxVerifierUpdateBlockChunksIterator is returned from FilterUpdateBlockChunks and is used to iterate over the raw logs and unpacked data for UpdateBlockChunks events raised by the TxVerifier contract.
type TxVerifierUpdateBlockChunksIterator struct {
	Event *TxVerifierUpdateBlockChunks // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TxVerifierUpdateBlockChunksIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TxVerifierUpdateBlockChunks)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TxVerifierUpdateBlockChunks)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TxVerifierUpdateBlockChunksIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TxVerifierUpdateBlockChunksIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TxVerifierUpdateBlockChunks represents a UpdateBlockChunks event raised by the TxVerifier contract.
type TxVerifierUpdateBlockChunks struct {
	NewAddress common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterUpdateBlockChunks is a free log retrieval operation binding the contract event 0x0addee9cb6aa9328bbfbe8282179a6737af344619320736b6918af70b6a94a98.
//
// Solidity: event UpdateBlockChunks(address newAddress)
func (_TxVerifier *TxVerifierFilterer) FilterUpdateBlockChunks(opts *bind.FilterOpts) (*TxVerifierUpdateBlockChunksIterator, error) {

	logs, sub, err := _TxVerifier.contract.FilterLogs(opts, "UpdateBlockChunks")
	if err != nil {
		return nil, err
	}
	return &TxVerifierUpdateBlockChunksIterator{contract: _TxVerifier.contract, event: "UpdateBlockChunks", logs: logs, sub: sub}, nil
}

// WatchUpdateBlockChunks is a free log subscription operation binding the contract event 0x0addee9cb6aa9328bbfbe8282179a6737af344619320736b6918af70b6a94a98.
//
// Solidity: event UpdateBlockChunks(address newAddress)
func (_TxVerifier *TxVerifierFilterer) WatchUpdateBlockChunks(opts *bind.WatchOpts, sink chan<- *TxVerifierUpdateBlockChunks) (event.Subscription, error) {

	logs, sub, err := _TxVerifier.contract.WatchLogs(opts, "UpdateBlockChunks")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TxVerifierUpdateBlockChunks)
				if err := _TxVerifier.contract.UnpackLog(event, "UpdateBlockChunks", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdateBlockChunks is a log parse operation binding the contract event 0x0addee9cb6aa9328bbfbe8282179a6737af344619320736b6918af70b6a94a98.
//
// Solidity: event UpdateBlockChunks(address newAddress)
func (_TxVerifier *TxVerifierFilterer) ParseUpdateBlockChunks(log types.Log) (*TxVerifierUpdateBlockChunks, error) {
	event := new(TxVerifierUpdateBlockChunks)
	if err := _TxVerifier.contract.UnpackLog(event, "UpdateBlockChunks", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TxVerifierUpdateVerifierAddressIterator is returned from FilterUpdateVerifierAddress and is used to iterate over the raw logs and unpacked data for UpdateVerifierAddress events raised by the TxVerifier contract.
type TxVerifierUpdateVerifierAddressIterator struct {
	Event *TxVerifierUpdateVerifierAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TxVerifierUpdateVerifierAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TxVerifierUpdateVerifierAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TxVerifierUpdateVerifierAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TxVerifierUpdateVerifierAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TxVerifierUpdateVerifierAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TxVerifierUpdateVerifierAddress represents a UpdateVerifierAddress event raised by the TxVerifier contract.
type TxVerifierUpdateVerifierAddress struct {
	ChainId    uint64
	NewAddress common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterUpdateVerifierAddress is a free log retrieval operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_TxVerifier *TxVerifierFilterer) FilterUpdateVerifierAddress(opts *bind.FilterOpts) (*TxVerifierUpdateVerifierAddressIterator, error) {

	logs, sub, err := _TxVerifier.contract.FilterLogs(opts, "UpdateVerifierAddress")
	if err != nil {
		return nil, err
	}
	return &TxVerifierUpdateVerifierAddressIterator{contract: _TxVerifier.contract, event: "UpdateVerifierAddress", logs: logs, sub: sub}, nil
}

// WatchUpdateVerifierAddress is a free log subscription operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_TxVerifier *TxVerifierFilterer) WatchUpdateVerifierAddress(opts *bind.WatchOpts, sink chan<- *TxVerifierUpdateVerifierAddress) (event.Subscription, error) {

	logs, sub, err := _TxVerifier.contract.WatchLogs(opts, "UpdateVerifierAddress")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TxVerifierUpdateVerifierAddress)
				if err := _TxVerifier.contract.UnpackLog(event, "UpdateVerifierAddress", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdateVerifierAddress is a log parse operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_TxVerifier *TxVerifierFilterer) ParseUpdateVerifierAddress(log types.Log) (*TxVerifierUpdateVerifierAddress, error) {
	event := new(TxVerifierUpdateVerifierAddress)
	if err := _TxVerifier.contract.UnpackLog(event, "UpdateVerifierAddress", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// TxVerifierVerifiedTxIterator is returned from FilterVerifiedTx and is used to iterate over the raw logs and unpacked data for VerifiedTx events raised by the TxVerifier contract.
type TxVerifierVerifiedTxIterator struct {
	Event *TxVerifierVerifiedTx // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TxVerifierVerifiedTxIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TxVerifierVerifiedTx)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TxVerifierVerifiedTx)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TxVerifierVerifiedTxIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TxVerifierVerifiedTxIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TxVerifierVerifiedTx represents a VerifiedTx event raised by the TxVerifier contract.
type TxVerifierVerifiedTx struct {
	ChainId uint64
	TxHash  [32]byte
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterVerifiedTx is a free log retrieval operation binding the contract event 0xe1df3a08ea1a2c110c3f833d615f7e02814f32a3418b98f011888d0516669888.
//
// Solidity: event VerifiedTx(uint64 chainId, bytes32 txHash)
func (_TxVerifier *TxVerifierFilterer) FilterVerifiedTx(opts *bind.FilterOpts) (*TxVerifierVerifiedTxIterator, error) {

	logs, sub, err := _TxVerifier.contract.FilterLogs(opts, "VerifiedTx")
	if err != nil {
		return nil, err
	}
	return &TxVerifierVerifiedTxIterator{contract: _TxVerifier.contract, event: "VerifiedTx", logs: logs, sub: sub}, nil
}

// WatchVerifiedTx is a free log subscription operation binding the contract event 0xe1df3a08ea1a2c110c3f833d615f7e02814f32a3418b98f011888d0516669888.
//
// Solidity: event VerifiedTx(uint64 chainId, bytes32 txHash)
func (_TxVerifier *TxVerifierFilterer) WatchVerifiedTx(opts *bind.WatchOpts, sink chan<- *TxVerifierVerifiedTx) (event.Subscription, error) {

	logs, sub, err := _TxVerifier.contract.WatchLogs(opts, "VerifiedTx")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TxVerifierVerifiedTx)
				if err := _TxVerifier.contract.UnpackLog(event, "VerifiedTx", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseVerifiedTx is a log parse operation binding the contract event 0xe1df3a08ea1a2c110c3f833d615f7e02814f32a3418b98f011888d0516669888.
//
// Solidity: event VerifiedTx(uint64 chainId, bytes32 txHash)
func (_TxVerifier *TxVerifierFilterer) ParseVerifiedTx(log types.Log) (*TxVerifierVerifiedTx, error) {
	event := new(TxVerifierVerifiedTx)
	if err := _TxVerifier.contract.UnpackLog(event, "VerifiedTx", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// UniswapSumVolumeMetaData contains all meta data concerning the UniswapSumVolume contract.
var UniswapSumVolumeMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"contractISMT\",\"name\":\"_smtContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"fromChain\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"volume\",\"type\":\"uint256\"}],\"name\":\"SumVolume\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contractISMT\",\"name\":\"smtContract\",\"type\":\"address\"}],\"name\":\"UpdateSmtContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"UpdateVerifierAddress\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"batchTierVkHashes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"swapper\",\"type\":\"address\"}],\"name\":\"getAttestedSwapSumVolume\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"hashes\",\"type\":\"bytes\"}],\"name\":\"setBatchTierVkHashes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"smtContract\",\"outputs\":[{\"internalType\":\"contractISMT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"}],\"name\":\"submitUniswapSumVolumeProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractISMT\",\"name\":\"_smtContract\",\"type\":\"address\"}],\"name\":\"updateSmtContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_verifierAddress\",\"type\":\"address\"}],\"name\":\"updateVerifierAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"verifierAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"volumes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x6080346100a457601f610be838819003918201601f19168301916001600160401b038311848410176100a8578084926020946040528339810103126100a457516001600160a01b0390818116908190036100a4575f5460018060a01b03199033828216175f55604051933391167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a36009541617600955610b2b90816100bd8239f35b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe60406080815260049081361015610014575f80fd5b5f91823560e01c9081631396511e146109685781633221aec6146109405781633f220b9414610914578163715018a6146108b45781638d35aa9d146104215781638da5cb5b146103fb578163950650c1146103c4578163b1ec4c40146103c4578163bd88d14614610261578163ec4ffc52146101c9578163f2fde38b146100e7575063f5cec6af146100a4575f80fd5b346100e35760203660031901126100e3576001600160a01b038160209367ffffffffffffffff6100d26109db565b168152600885522054169051908152f35b5080fd5b9050346101c55760203660031901126101c557610102610a24565b908354906001600160a01b038083169361011d338614610aaa565b1693841561015c5750506001600160a01b031916821783557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a380f35b906020608492519162461bcd60e51b8352820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152fd5b8280fd5b5050346100e357806003193601126100e3576101e36109db565b906024356001600160a01b0380821680920361025d577ffd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f9361023267ffffffffffffffff928754163314610aaa565b16908185526008602052828520816001600160a01b031982541617905582519182526020820152a180f35b8480fd5b919050346101c557602090816003193601126103c057823567ffffffffffffffff811161025d5761029590369085016109f6565b90916102ac6001600160a01b038754163314610aaa565b60059382851c9460069283871161037e5750875b8681106102cb578880f35b80821b81810484148215171561036b576001908183018084116103585780851b9080820487149015171561035857808211610354578781116103545788820135919003858110610344575b5090858310156103315782015561032c90610a88565b6102c0565b634e487b7160e01b8b5260328a5260248bfd5b5f1990860360031b1b165f610316565b8b80fd5b634e487b7160e01b8c5260118b5260248cfd5b634e487b7160e01b8a526011895260248afd5b5162461bcd60e51b8152808801839052601160248201527f65786365656473206d61782074696572730000000000000000000000000000006044820152606490fd5b8380fd5b5050346100e35760203660031901126100e357806020926001600160a01b036103eb610a24565b1681526007845220549051908152f35b5050346100e357816003193601126100e3576001600160a01b0360209254169051908152f35b9050346101c557816003193601126101c55761043b6109db565b9160249182359367ffffffffffffffff948581116108b0576104618691369085016109f6565b9690921692838852602095600887526001600160a01b039384878b2054161561086e57908891868b526008895285888c205416898c8a51928380926322bb937360e11b8252848a8301528888830152816044998a92818a85850137828201840152601f01601f191681010301915afa908115610864578c91610847575b50156108065787519460c08601908111868210176107f4578852888501998886019160a087019180610160116107f0576101408201356080890152610180918183116107e35761016c81013560601c89526101a0918083116107ec578e93820135809452806101c0116107ec576101e0928184116107e7576101d083013560801c9083013560801b178652610200928184116107e75782013560608b0152610220116107e35701358252156107a25780511561076157518b908c5b6006811061073b575b5050156106fa57858551168b5260078952878b20546106b9578886600954169151848a518094819363080cdb0b60e11b83528c8a840152878301525afa9081156106af578b91610682575b501561064157897fb7f36b9639c04a7740988446e70ac14b79468c98e600ae501a19320c9307756e60608b8b8b8b8b8b8551828251168a5260078652848a205551169351928251948552840152820152a180f35b865162461bcd60e51b81529283018890526012908301527f736d7420726f6f74206e6f742076616c6964000000000000000000000000000090820152606490fd5b6106a29150893d8b116106a8575b61069a8183610a3a565b810190610a70565b5f6105ed565b503d610690565b88513d8d823e3d90fd5b875162461bcd60e51b81528085018a9052601c818401527f616c72656164792070726f76656420666f72207468697320757365720000000081850152606490fd5b875162461bcd60e51b81528085018a90526013818401527f766b48617368206973206e6f742076616c69640000000000000000000000000081850152606490fd5b6001818101548314610756575061075190610a88565b610599565b925050505f806105a2565b885162461bcd60e51b81528086018b9052601e818501527f766b486173682073686f756c64206265206c6172676572207468616e2030000081860152606490fd5b885162461bcd60e51b81528086018b9052601e818501527f766f6c756d652073686f756c64206265206c6172676572207468616e2030000081860152606490fd5b8e80fd5b508f80fd5b8f80fd5b8d80fd5b634e487b7160e01b8c5260418552828cfd5b875162461bcd60e51b81528085018a9052600f818401527f70726f6f66206e6f742076616c6964000000000000000000000000000000000081850152606490fd5b61085e91508a3d8c116106a85761069a8183610a3a565b5f6104de565b89513d8e823e3d90fd5b865162461bcd60e51b81528084018990526016818401527f636861696e207665726966696572206e6f7420736574000000000000000000006044820152606490fd5b8680fd5b83346109115780600319360112610911578080546001600160a01b03196001600160a01b038216916108e7338414610aaa565b1682557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b80fd5b9050346101c55760203660031901126101c5573560068110156101c55760209250600101549051908152f35b5050346100e357816003193601126100e3576020906001600160a01b03600954169051908152f35b9050346101c55760203660031901126101c557356001600160a01b03908181168091036103c0577fe93557923617d976d723e8cea6746c85a3a16814eda1d638dcfb7a1fffef0042926109c16020938654163314610aaa565b816001600160a01b0319600954161760095551908152a180f35b6004359067ffffffffffffffff821682036109f257565b5f80fd5b9181601f840112156109f25782359167ffffffffffffffff83116109f257602083818601950101116109f257565b600435906001600160a01b03821682036109f257565b90601f8019910116810190811067ffffffffffffffff821117610a5c57604052565b634e487b7160e01b5f52604160045260245ffd5b908160209103126109f2575180151581036109f25790565b5f198114610a965760010190565b634e487b7160e01b5f52601160045260245ffd5b15610ab157565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fdfea2646970667358221220ddcb147d05f6f9acb5fbc3ef1476f19d4749780bb97ae27a0e648f44fa77cac564736f6c63430008140033",
}

// UniswapSumVolumeABI is the input ABI used to generate the binding from.
// Deprecated: Use UniswapSumVolumeMetaData.ABI instead.
var UniswapSumVolumeABI = UniswapSumVolumeMetaData.ABI

// UniswapSumVolumeBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use UniswapSumVolumeMetaData.Bin instead.
var UniswapSumVolumeBin = UniswapSumVolumeMetaData.Bin

// DeployUniswapSumVolume deploys a new Ethereum contract, binding an instance of UniswapSumVolume to it.
func DeployUniswapSumVolume(auth *bind.TransactOpts, backend bind.ContractBackend, _smtContract common.Address) (common.Address, *types.Transaction, *UniswapSumVolume, error) {
	parsed, err := UniswapSumVolumeMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(UniswapSumVolumeBin), backend, _smtContract)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &UniswapSumVolume{UniswapSumVolumeCaller: UniswapSumVolumeCaller{contract: contract}, UniswapSumVolumeTransactor: UniswapSumVolumeTransactor{contract: contract}, UniswapSumVolumeFilterer: UniswapSumVolumeFilterer{contract: contract}}, nil
}

// UniswapSumVolume is an auto generated Go binding around an Ethereum contract.
type UniswapSumVolume struct {
	UniswapSumVolumeCaller     // Read-only binding to the contract
	UniswapSumVolumeTransactor // Write-only binding to the contract
	UniswapSumVolumeFilterer   // Log filterer for contract events
}

// UniswapSumVolumeCaller is an auto generated read-only Go binding around an Ethereum contract.
type UniswapSumVolumeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// UniswapSumVolumeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type UniswapSumVolumeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// UniswapSumVolumeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type UniswapSumVolumeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// UniswapSumVolumeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type UniswapSumVolumeSession struct {
	Contract     *UniswapSumVolume // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// UniswapSumVolumeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type UniswapSumVolumeCallerSession struct {
	Contract *UniswapSumVolumeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts           // Call options to use throughout this session
}

// UniswapSumVolumeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type UniswapSumVolumeTransactorSession struct {
	Contract     *UniswapSumVolumeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts           // Transaction auth options to use throughout this session
}

// UniswapSumVolumeRaw is an auto generated low-level Go binding around an Ethereum contract.
type UniswapSumVolumeRaw struct {
	Contract *UniswapSumVolume // Generic contract binding to access the raw methods on
}

// UniswapSumVolumeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type UniswapSumVolumeCallerRaw struct {
	Contract *UniswapSumVolumeCaller // Generic read-only contract binding to access the raw methods on
}

// UniswapSumVolumeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type UniswapSumVolumeTransactorRaw struct {
	Contract *UniswapSumVolumeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewUniswapSumVolume creates a new instance of UniswapSumVolume, bound to a specific deployed contract.
func NewUniswapSumVolume(address common.Address, backend bind.ContractBackend) (*UniswapSumVolume, error) {
	contract, err := bindUniswapSumVolume(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &UniswapSumVolume{UniswapSumVolumeCaller: UniswapSumVolumeCaller{contract: contract}, UniswapSumVolumeTransactor: UniswapSumVolumeTransactor{contract: contract}, UniswapSumVolumeFilterer: UniswapSumVolumeFilterer{contract: contract}}, nil
}

// NewUniswapSumVolumeCaller creates a new read-only instance of UniswapSumVolume, bound to a specific deployed contract.
func NewUniswapSumVolumeCaller(address common.Address, caller bind.ContractCaller) (*UniswapSumVolumeCaller, error) {
	contract, err := bindUniswapSumVolume(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &UniswapSumVolumeCaller{contract: contract}, nil
}

// NewUniswapSumVolumeTransactor creates a new write-only instance of UniswapSumVolume, bound to a specific deployed contract.
func NewUniswapSumVolumeTransactor(address common.Address, transactor bind.ContractTransactor) (*UniswapSumVolumeTransactor, error) {
	contract, err := bindUniswapSumVolume(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &UniswapSumVolumeTransactor{contract: contract}, nil
}

// NewUniswapSumVolumeFilterer creates a new log filterer instance of UniswapSumVolume, bound to a specific deployed contract.
func NewUniswapSumVolumeFilterer(address common.Address, filterer bind.ContractFilterer) (*UniswapSumVolumeFilterer, error) {
	contract, err := bindUniswapSumVolume(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &UniswapSumVolumeFilterer{contract: contract}, nil
}

// bindUniswapSumVolume binds a generic wrapper to an already deployed contract.
func bindUniswapSumVolume(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := UniswapSumVolumeMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_UniswapSumVolume *UniswapSumVolumeRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _UniswapSumVolume.Contract.UniswapSumVolumeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_UniswapSumVolume *UniswapSumVolumeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.UniswapSumVolumeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_UniswapSumVolume *UniswapSumVolumeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.UniswapSumVolumeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_UniswapSumVolume *UniswapSumVolumeCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _UniswapSumVolume.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_UniswapSumVolume *UniswapSumVolumeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_UniswapSumVolume *UniswapSumVolumeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.contract.Transact(opts, method, params...)
}

// BatchTierVkHashes is a free data retrieval call binding the contract method 0x3f220b94.
//
// Solidity: function batchTierVkHashes(uint256 ) view returns(uint256)
func (_UniswapSumVolume *UniswapSumVolumeCaller) BatchTierVkHashes(opts *bind.CallOpts, arg0 *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _UniswapSumVolume.contract.Call(opts, &out, "batchTierVkHashes", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BatchTierVkHashes is a free data retrieval call binding the contract method 0x3f220b94.
//
// Solidity: function batchTierVkHashes(uint256 ) view returns(uint256)
func (_UniswapSumVolume *UniswapSumVolumeSession) BatchTierVkHashes(arg0 *big.Int) (*big.Int, error) {
	return _UniswapSumVolume.Contract.BatchTierVkHashes(&_UniswapSumVolume.CallOpts, arg0)
}

// BatchTierVkHashes is a free data retrieval call binding the contract method 0x3f220b94.
//
// Solidity: function batchTierVkHashes(uint256 ) view returns(uint256)
func (_UniswapSumVolume *UniswapSumVolumeCallerSession) BatchTierVkHashes(arg0 *big.Int) (*big.Int, error) {
	return _UniswapSumVolume.Contract.BatchTierVkHashes(&_UniswapSumVolume.CallOpts, arg0)
}

// GetAttestedSwapSumVolume is a free data retrieval call binding the contract method 0x950650c1.
//
// Solidity: function getAttestedSwapSumVolume(address swapper) view returns(uint256)
func (_UniswapSumVolume *UniswapSumVolumeCaller) GetAttestedSwapSumVolume(opts *bind.CallOpts, swapper common.Address) (*big.Int, error) {
	var out []interface{}
	err := _UniswapSumVolume.contract.Call(opts, &out, "getAttestedSwapSumVolume", swapper)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetAttestedSwapSumVolume is a free data retrieval call binding the contract method 0x950650c1.
//
// Solidity: function getAttestedSwapSumVolume(address swapper) view returns(uint256)
func (_UniswapSumVolume *UniswapSumVolumeSession) GetAttestedSwapSumVolume(swapper common.Address) (*big.Int, error) {
	return _UniswapSumVolume.Contract.GetAttestedSwapSumVolume(&_UniswapSumVolume.CallOpts, swapper)
}

// GetAttestedSwapSumVolume is a free data retrieval call binding the contract method 0x950650c1.
//
// Solidity: function getAttestedSwapSumVolume(address swapper) view returns(uint256)
func (_UniswapSumVolume *UniswapSumVolumeCallerSession) GetAttestedSwapSumVolume(swapper common.Address) (*big.Int, error) {
	return _UniswapSumVolume.Contract.GetAttestedSwapSumVolume(&_UniswapSumVolume.CallOpts, swapper)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_UniswapSumVolume *UniswapSumVolumeCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _UniswapSumVolume.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_UniswapSumVolume *UniswapSumVolumeSession) Owner() (common.Address, error) {
	return _UniswapSumVolume.Contract.Owner(&_UniswapSumVolume.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_UniswapSumVolume *UniswapSumVolumeCallerSession) Owner() (common.Address, error) {
	return _UniswapSumVolume.Contract.Owner(&_UniswapSumVolume.CallOpts)
}

// SmtContract is a free data retrieval call binding the contract method 0x3221aec6.
//
// Solidity: function smtContract() view returns(address)
func (_UniswapSumVolume *UniswapSumVolumeCaller) SmtContract(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _UniswapSumVolume.contract.Call(opts, &out, "smtContract")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SmtContract is a free data retrieval call binding the contract method 0x3221aec6.
//
// Solidity: function smtContract() view returns(address)
func (_UniswapSumVolume *UniswapSumVolumeSession) SmtContract() (common.Address, error) {
	return _UniswapSumVolume.Contract.SmtContract(&_UniswapSumVolume.CallOpts)
}

// SmtContract is a free data retrieval call binding the contract method 0x3221aec6.
//
// Solidity: function smtContract() view returns(address)
func (_UniswapSumVolume *UniswapSumVolumeCallerSession) SmtContract() (common.Address, error) {
	return _UniswapSumVolume.Contract.SmtContract(&_UniswapSumVolume.CallOpts)
}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_UniswapSumVolume *UniswapSumVolumeCaller) VerifierAddresses(opts *bind.CallOpts, arg0 uint64) (common.Address, error) {
	var out []interface{}
	err := _UniswapSumVolume.contract.Call(opts, &out, "verifierAddresses", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_UniswapSumVolume *UniswapSumVolumeSession) VerifierAddresses(arg0 uint64) (common.Address, error) {
	return _UniswapSumVolume.Contract.VerifierAddresses(&_UniswapSumVolume.CallOpts, arg0)
}

// VerifierAddresses is a free data retrieval call binding the contract method 0xf5cec6af.
//
// Solidity: function verifierAddresses(uint64 ) view returns(address)
func (_UniswapSumVolume *UniswapSumVolumeCallerSession) VerifierAddresses(arg0 uint64) (common.Address, error) {
	return _UniswapSumVolume.Contract.VerifierAddresses(&_UniswapSumVolume.CallOpts, arg0)
}

// Volumes is a free data retrieval call binding the contract method 0xb1ec4c40.
//
// Solidity: function volumes(address ) view returns(uint256)
func (_UniswapSumVolume *UniswapSumVolumeCaller) Volumes(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _UniswapSumVolume.contract.Call(opts, &out, "volumes", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Volumes is a free data retrieval call binding the contract method 0xb1ec4c40.
//
// Solidity: function volumes(address ) view returns(uint256)
func (_UniswapSumVolume *UniswapSumVolumeSession) Volumes(arg0 common.Address) (*big.Int, error) {
	return _UniswapSumVolume.Contract.Volumes(&_UniswapSumVolume.CallOpts, arg0)
}

// Volumes is a free data retrieval call binding the contract method 0xb1ec4c40.
//
// Solidity: function volumes(address ) view returns(uint256)
func (_UniswapSumVolume *UniswapSumVolumeCallerSession) Volumes(arg0 common.Address) (*big.Int, error) {
	return _UniswapSumVolume.Contract.Volumes(&_UniswapSumVolume.CallOpts, arg0)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_UniswapSumVolume *UniswapSumVolumeTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _UniswapSumVolume.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_UniswapSumVolume *UniswapSumVolumeSession) RenounceOwnership() (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.RenounceOwnership(&_UniswapSumVolume.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_UniswapSumVolume *UniswapSumVolumeTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.RenounceOwnership(&_UniswapSumVolume.TransactOpts)
}

// SetBatchTierVkHashes is a paid mutator transaction binding the contract method 0xbd88d146.
//
// Solidity: function setBatchTierVkHashes(bytes hashes) returns()
func (_UniswapSumVolume *UniswapSumVolumeTransactor) SetBatchTierVkHashes(opts *bind.TransactOpts, hashes []byte) (*types.Transaction, error) {
	return _UniswapSumVolume.contract.Transact(opts, "setBatchTierVkHashes", hashes)
}

// SetBatchTierVkHashes is a paid mutator transaction binding the contract method 0xbd88d146.
//
// Solidity: function setBatchTierVkHashes(bytes hashes) returns()
func (_UniswapSumVolume *UniswapSumVolumeSession) SetBatchTierVkHashes(hashes []byte) (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.SetBatchTierVkHashes(&_UniswapSumVolume.TransactOpts, hashes)
}

// SetBatchTierVkHashes is a paid mutator transaction binding the contract method 0xbd88d146.
//
// Solidity: function setBatchTierVkHashes(bytes hashes) returns()
func (_UniswapSumVolume *UniswapSumVolumeTransactorSession) SetBatchTierVkHashes(hashes []byte) (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.SetBatchTierVkHashes(&_UniswapSumVolume.TransactOpts, hashes)
}

// SubmitUniswapSumVolumeProof is a paid mutator transaction binding the contract method 0x8d35aa9d.
//
// Solidity: function submitUniswapSumVolumeProof(uint64 _chainId, bytes _proof) returns()
func (_UniswapSumVolume *UniswapSumVolumeTransactor) SubmitUniswapSumVolumeProof(opts *bind.TransactOpts, _chainId uint64, _proof []byte) (*types.Transaction, error) {
	return _UniswapSumVolume.contract.Transact(opts, "submitUniswapSumVolumeProof", _chainId, _proof)
}

// SubmitUniswapSumVolumeProof is a paid mutator transaction binding the contract method 0x8d35aa9d.
//
// Solidity: function submitUniswapSumVolumeProof(uint64 _chainId, bytes _proof) returns()
func (_UniswapSumVolume *UniswapSumVolumeSession) SubmitUniswapSumVolumeProof(_chainId uint64, _proof []byte) (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.SubmitUniswapSumVolumeProof(&_UniswapSumVolume.TransactOpts, _chainId, _proof)
}

// SubmitUniswapSumVolumeProof is a paid mutator transaction binding the contract method 0x8d35aa9d.
//
// Solidity: function submitUniswapSumVolumeProof(uint64 _chainId, bytes _proof) returns()
func (_UniswapSumVolume *UniswapSumVolumeTransactorSession) SubmitUniswapSumVolumeProof(_chainId uint64, _proof []byte) (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.SubmitUniswapSumVolumeProof(&_UniswapSumVolume.TransactOpts, _chainId, _proof)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_UniswapSumVolume *UniswapSumVolumeTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _UniswapSumVolume.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_UniswapSumVolume *UniswapSumVolumeSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.TransferOwnership(&_UniswapSumVolume.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_UniswapSumVolume *UniswapSumVolumeTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.TransferOwnership(&_UniswapSumVolume.TransactOpts, newOwner)
}

// UpdateSmtContract is a paid mutator transaction binding the contract method 0x1396511e.
//
// Solidity: function updateSmtContract(address _smtContract) returns()
func (_UniswapSumVolume *UniswapSumVolumeTransactor) UpdateSmtContract(opts *bind.TransactOpts, _smtContract common.Address) (*types.Transaction, error) {
	return _UniswapSumVolume.contract.Transact(opts, "updateSmtContract", _smtContract)
}

// UpdateSmtContract is a paid mutator transaction binding the contract method 0x1396511e.
//
// Solidity: function updateSmtContract(address _smtContract) returns()
func (_UniswapSumVolume *UniswapSumVolumeSession) UpdateSmtContract(_smtContract common.Address) (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.UpdateSmtContract(&_UniswapSumVolume.TransactOpts, _smtContract)
}

// UpdateSmtContract is a paid mutator transaction binding the contract method 0x1396511e.
//
// Solidity: function updateSmtContract(address _smtContract) returns()
func (_UniswapSumVolume *UniswapSumVolumeTransactorSession) UpdateSmtContract(_smtContract common.Address) (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.UpdateSmtContract(&_UniswapSumVolume.TransactOpts, _smtContract)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_UniswapSumVolume *UniswapSumVolumeTransactor) UpdateVerifierAddress(opts *bind.TransactOpts, _chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _UniswapSumVolume.contract.Transact(opts, "updateVerifierAddress", _chainId, _verifierAddress)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_UniswapSumVolume *UniswapSumVolumeSession) UpdateVerifierAddress(_chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.UpdateVerifierAddress(&_UniswapSumVolume.TransactOpts, _chainId, _verifierAddress)
}

// UpdateVerifierAddress is a paid mutator transaction binding the contract method 0xec4ffc52.
//
// Solidity: function updateVerifierAddress(uint64 _chainId, address _verifierAddress) returns()
func (_UniswapSumVolume *UniswapSumVolumeTransactorSession) UpdateVerifierAddress(_chainId uint64, _verifierAddress common.Address) (*types.Transaction, error) {
	return _UniswapSumVolume.Contract.UpdateVerifierAddress(&_UniswapSumVolume.TransactOpts, _chainId, _verifierAddress)
}

// UniswapSumVolumeOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the UniswapSumVolume contract.
type UniswapSumVolumeOwnershipTransferredIterator struct {
	Event *UniswapSumVolumeOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *UniswapSumVolumeOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(UniswapSumVolumeOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(UniswapSumVolumeOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *UniswapSumVolumeOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *UniswapSumVolumeOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// UniswapSumVolumeOwnershipTransferred represents a OwnershipTransferred event raised by the UniswapSumVolume contract.
type UniswapSumVolumeOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_UniswapSumVolume *UniswapSumVolumeFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*UniswapSumVolumeOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _UniswapSumVolume.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &UniswapSumVolumeOwnershipTransferredIterator{contract: _UniswapSumVolume.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_UniswapSumVolume *UniswapSumVolumeFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *UniswapSumVolumeOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _UniswapSumVolume.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(UniswapSumVolumeOwnershipTransferred)
				if err := _UniswapSumVolume.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_UniswapSumVolume *UniswapSumVolumeFilterer) ParseOwnershipTransferred(log types.Log) (*UniswapSumVolumeOwnershipTransferred, error) {
	event := new(UniswapSumVolumeOwnershipTransferred)
	if err := _UniswapSumVolume.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// UniswapSumVolumeSumVolumeIterator is returned from FilterSumVolume and is used to iterate over the raw logs and unpacked data for SumVolume events raised by the UniswapSumVolume contract.
type UniswapSumVolumeSumVolumeIterator struct {
	Event *UniswapSumVolumeSumVolume // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *UniswapSumVolumeSumVolumeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(UniswapSumVolumeSumVolume)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(UniswapSumVolumeSumVolume)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *UniswapSumVolumeSumVolumeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *UniswapSumVolumeSumVolumeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// UniswapSumVolumeSumVolume represents a SumVolume event raised by the UniswapSumVolume contract.
type UniswapSumVolumeSumVolume struct {
	User      common.Address
	FromChain uint64
	Volume    *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterSumVolume is a free log retrieval operation binding the contract event 0xb7f36b9639c04a7740988446e70ac14b79468c98e600ae501a19320c9307756e.
//
// Solidity: event SumVolume(address user, uint64 fromChain, uint256 volume)
func (_UniswapSumVolume *UniswapSumVolumeFilterer) FilterSumVolume(opts *bind.FilterOpts) (*UniswapSumVolumeSumVolumeIterator, error) {

	logs, sub, err := _UniswapSumVolume.contract.FilterLogs(opts, "SumVolume")
	if err != nil {
		return nil, err
	}
	return &UniswapSumVolumeSumVolumeIterator{contract: _UniswapSumVolume.contract, event: "SumVolume", logs: logs, sub: sub}, nil
}

// WatchSumVolume is a free log subscription operation binding the contract event 0xb7f36b9639c04a7740988446e70ac14b79468c98e600ae501a19320c9307756e.
//
// Solidity: event SumVolume(address user, uint64 fromChain, uint256 volume)
func (_UniswapSumVolume *UniswapSumVolumeFilterer) WatchSumVolume(opts *bind.WatchOpts, sink chan<- *UniswapSumVolumeSumVolume) (event.Subscription, error) {

	logs, sub, err := _UniswapSumVolume.contract.WatchLogs(opts, "SumVolume")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(UniswapSumVolumeSumVolume)
				if err := _UniswapSumVolume.contract.UnpackLog(event, "SumVolume", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSumVolume is a log parse operation binding the contract event 0xb7f36b9639c04a7740988446e70ac14b79468c98e600ae501a19320c9307756e.
//
// Solidity: event SumVolume(address user, uint64 fromChain, uint256 volume)
func (_UniswapSumVolume *UniswapSumVolumeFilterer) ParseSumVolume(log types.Log) (*UniswapSumVolumeSumVolume, error) {
	event := new(UniswapSumVolumeSumVolume)
	if err := _UniswapSumVolume.contract.UnpackLog(event, "SumVolume", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// UniswapSumVolumeUpdateSmtContractIterator is returned from FilterUpdateSmtContract and is used to iterate over the raw logs and unpacked data for UpdateSmtContract events raised by the UniswapSumVolume contract.
type UniswapSumVolumeUpdateSmtContractIterator struct {
	Event *UniswapSumVolumeUpdateSmtContract // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *UniswapSumVolumeUpdateSmtContractIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(UniswapSumVolumeUpdateSmtContract)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(UniswapSumVolumeUpdateSmtContract)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *UniswapSumVolumeUpdateSmtContractIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *UniswapSumVolumeUpdateSmtContractIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// UniswapSumVolumeUpdateSmtContract represents a UpdateSmtContract event raised by the UniswapSumVolume contract.
type UniswapSumVolumeUpdateSmtContract struct {
	SmtContract common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterUpdateSmtContract is a free log retrieval operation binding the contract event 0xe93557923617d976d723e8cea6746c85a3a16814eda1d638dcfb7a1fffef0042.
//
// Solidity: event UpdateSmtContract(address smtContract)
func (_UniswapSumVolume *UniswapSumVolumeFilterer) FilterUpdateSmtContract(opts *bind.FilterOpts) (*UniswapSumVolumeUpdateSmtContractIterator, error) {

	logs, sub, err := _UniswapSumVolume.contract.FilterLogs(opts, "UpdateSmtContract")
	if err != nil {
		return nil, err
	}
	return &UniswapSumVolumeUpdateSmtContractIterator{contract: _UniswapSumVolume.contract, event: "UpdateSmtContract", logs: logs, sub: sub}, nil
}

// WatchUpdateSmtContract is a free log subscription operation binding the contract event 0xe93557923617d976d723e8cea6746c85a3a16814eda1d638dcfb7a1fffef0042.
//
// Solidity: event UpdateSmtContract(address smtContract)
func (_UniswapSumVolume *UniswapSumVolumeFilterer) WatchUpdateSmtContract(opts *bind.WatchOpts, sink chan<- *UniswapSumVolumeUpdateSmtContract) (event.Subscription, error) {

	logs, sub, err := _UniswapSumVolume.contract.WatchLogs(opts, "UpdateSmtContract")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(UniswapSumVolumeUpdateSmtContract)
				if err := _UniswapSumVolume.contract.UnpackLog(event, "UpdateSmtContract", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdateSmtContract is a log parse operation binding the contract event 0xe93557923617d976d723e8cea6746c85a3a16814eda1d638dcfb7a1fffef0042.
//
// Solidity: event UpdateSmtContract(address smtContract)
func (_UniswapSumVolume *UniswapSumVolumeFilterer) ParseUpdateSmtContract(log types.Log) (*UniswapSumVolumeUpdateSmtContract, error) {
	event := new(UniswapSumVolumeUpdateSmtContract)
	if err := _UniswapSumVolume.contract.UnpackLog(event, "UpdateSmtContract", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// UniswapSumVolumeUpdateVerifierAddressIterator is returned from FilterUpdateVerifierAddress and is used to iterate over the raw logs and unpacked data for UpdateVerifierAddress events raised by the UniswapSumVolume contract.
type UniswapSumVolumeUpdateVerifierAddressIterator struct {
	Event *UniswapSumVolumeUpdateVerifierAddress // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *UniswapSumVolumeUpdateVerifierAddressIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(UniswapSumVolumeUpdateVerifierAddress)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(UniswapSumVolumeUpdateVerifierAddress)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *UniswapSumVolumeUpdateVerifierAddressIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *UniswapSumVolumeUpdateVerifierAddressIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// UniswapSumVolumeUpdateVerifierAddress represents a UpdateVerifierAddress event raised by the UniswapSumVolume contract.
type UniswapSumVolumeUpdateVerifierAddress struct {
	ChainId    uint64
	NewAddress common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterUpdateVerifierAddress is a free log retrieval operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_UniswapSumVolume *UniswapSumVolumeFilterer) FilterUpdateVerifierAddress(opts *bind.FilterOpts) (*UniswapSumVolumeUpdateVerifierAddressIterator, error) {

	logs, sub, err := _UniswapSumVolume.contract.FilterLogs(opts, "UpdateVerifierAddress")
	if err != nil {
		return nil, err
	}
	return &UniswapSumVolumeUpdateVerifierAddressIterator{contract: _UniswapSumVolume.contract, event: "UpdateVerifierAddress", logs: logs, sub: sub}, nil
}

// WatchUpdateVerifierAddress is a free log subscription operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_UniswapSumVolume *UniswapSumVolumeFilterer) WatchUpdateVerifierAddress(opts *bind.WatchOpts, sink chan<- *UniswapSumVolumeUpdateVerifierAddress) (event.Subscription, error) {

	logs, sub, err := _UniswapSumVolume.contract.WatchLogs(opts, "UpdateVerifierAddress")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(UniswapSumVolumeUpdateVerifierAddress)
				if err := _UniswapSumVolume.contract.UnpackLog(event, "UpdateVerifierAddress", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdateVerifierAddress is a log parse operation binding the contract event 0xfd4bb2421fdcb098a8b68c19410f433a24b805b98f148eb28b7cc384b0a0e65f.
//
// Solidity: event UpdateVerifierAddress(uint64 chainId, address newAddress)
func (_UniswapSumVolume *UniswapSumVolumeFilterer) ParseUpdateVerifierAddress(log types.Log) (*UniswapSumVolumeUpdateVerifierAddress, error) {
	event := new(UniswapSumVolumeUpdateVerifierAddress)
	if err := _UniswapSumVolume.contract.UnpackLog(event, "UpdateVerifierAddress", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// UnsafeMathMetaData contains all meta data concerning the UnsafeMath contract.
var UnsafeMathMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea26469706673582212202faab76223831163a8063e80ebcb394ac61469d94440dd9c42a2ec7b799eea3364736f6c63430008140033",
}

// UnsafeMathABI is the input ABI used to generate the binding from.
// Deprecated: Use UnsafeMathMetaData.ABI instead.
var UnsafeMathABI = UnsafeMathMetaData.ABI

// UnsafeMathBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use UnsafeMathMetaData.Bin instead.
var UnsafeMathBin = UnsafeMathMetaData.Bin

// DeployUnsafeMath deploys a new Ethereum contract, binding an instance of UnsafeMath to it.
func DeployUnsafeMath(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *UnsafeMath, error) {
	parsed, err := UnsafeMathMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(UnsafeMathBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &UnsafeMath{UnsafeMathCaller: UnsafeMathCaller{contract: contract}, UnsafeMathTransactor: UnsafeMathTransactor{contract: contract}, UnsafeMathFilterer: UnsafeMathFilterer{contract: contract}}, nil
}

// UnsafeMath is an auto generated Go binding around an Ethereum contract.
type UnsafeMath struct {
	UnsafeMathCaller     // Read-only binding to the contract
	UnsafeMathTransactor // Write-only binding to the contract
	UnsafeMathFilterer   // Log filterer for contract events
}

// UnsafeMathCaller is an auto generated read-only Go binding around an Ethereum contract.
type UnsafeMathCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// UnsafeMathTransactor is an auto generated write-only Go binding around an Ethereum contract.
type UnsafeMathTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// UnsafeMathFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type UnsafeMathFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// UnsafeMathSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type UnsafeMathSession struct {
	Contract     *UnsafeMath       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// UnsafeMathCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type UnsafeMathCallerSession struct {
	Contract *UnsafeMathCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// UnsafeMathTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type UnsafeMathTransactorSession struct {
	Contract     *UnsafeMathTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// UnsafeMathRaw is an auto generated low-level Go binding around an Ethereum contract.
type UnsafeMathRaw struct {
	Contract *UnsafeMath // Generic contract binding to access the raw methods on
}

// UnsafeMathCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type UnsafeMathCallerRaw struct {
	Contract *UnsafeMathCaller // Generic read-only contract binding to access the raw methods on
}

// UnsafeMathTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type UnsafeMathTransactorRaw struct {
	Contract *UnsafeMathTransactor // Generic write-only contract binding to access the raw methods on
}

// NewUnsafeMath creates a new instance of UnsafeMath, bound to a specific deployed contract.
func NewUnsafeMath(address common.Address, backend bind.ContractBackend) (*UnsafeMath, error) {
	contract, err := bindUnsafeMath(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &UnsafeMath{UnsafeMathCaller: UnsafeMathCaller{contract: contract}, UnsafeMathTransactor: UnsafeMathTransactor{contract: contract}, UnsafeMathFilterer: UnsafeMathFilterer{contract: contract}}, nil
}

// NewUnsafeMathCaller creates a new read-only instance of UnsafeMath, bound to a specific deployed contract.
func NewUnsafeMathCaller(address common.Address, caller bind.ContractCaller) (*UnsafeMathCaller, error) {
	contract, err := bindUnsafeMath(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &UnsafeMathCaller{contract: contract}, nil
}

// NewUnsafeMathTransactor creates a new write-only instance of UnsafeMath, bound to a specific deployed contract.
func NewUnsafeMathTransactor(address common.Address, transactor bind.ContractTransactor) (*UnsafeMathTransactor, error) {
	contract, err := bindUnsafeMath(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &UnsafeMathTransactor{contract: contract}, nil
}

// NewUnsafeMathFilterer creates a new log filterer instance of UnsafeMath, bound to a specific deployed contract.
func NewUnsafeMathFilterer(address common.Address, filterer bind.ContractFilterer) (*UnsafeMathFilterer, error) {
	contract, err := bindUnsafeMath(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &UnsafeMathFilterer{contract: contract}, nil
}

// bindUnsafeMath binds a generic wrapper to an already deployed contract.
func bindUnsafeMath(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := UnsafeMathMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_UnsafeMath *UnsafeMathRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _UnsafeMath.Contract.UnsafeMathCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_UnsafeMath *UnsafeMathRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _UnsafeMath.Contract.UnsafeMathTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_UnsafeMath *UnsafeMathRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _UnsafeMath.Contract.UnsafeMathTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_UnsafeMath *UnsafeMathCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _UnsafeMath.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_UnsafeMath *UnsafeMathTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _UnsafeMath.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_UnsafeMath *UnsafeMathTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _UnsafeMath.Contract.contract.Transact(opts, method, params...)
}

// UtilsMetaData contains all meta data concerning the Utils contract.
var UtilsMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea2646970667358221220fceb4d7157c65e692404d7914e7fa9cc44b45af9792187a73dd995b53f6bfea664736f6c63430008140033",
}

// UtilsABI is the input ABI used to generate the binding from.
// Deprecated: Use UtilsMetaData.ABI instead.
var UtilsABI = UtilsMetaData.ABI

// UtilsBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use UtilsMetaData.Bin instead.
var UtilsBin = UtilsMetaData.Bin

// DeployUtils deploys a new Ethereum contract, binding an instance of Utils to it.
func DeployUtils(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Utils, error) {
	parsed, err := UtilsMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(UtilsBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Utils{UtilsCaller: UtilsCaller{contract: contract}, UtilsTransactor: UtilsTransactor{contract: contract}, UtilsFilterer: UtilsFilterer{contract: contract}}, nil
}

// Utils is an auto generated Go binding around an Ethereum contract.
type Utils struct {
	UtilsCaller     // Read-only binding to the contract
	UtilsTransactor // Write-only binding to the contract
	UtilsFilterer   // Log filterer for contract events
}

// UtilsCaller is an auto generated read-only Go binding around an Ethereum contract.
type UtilsCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// UtilsTransactor is an auto generated write-only Go binding around an Ethereum contract.
type UtilsTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// UtilsFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type UtilsFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// UtilsSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type UtilsSession struct {
	Contract     *Utils            // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// UtilsCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type UtilsCallerSession struct {
	Contract *UtilsCaller  // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// UtilsTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type UtilsTransactorSession struct {
	Contract     *UtilsTransactor  // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// UtilsRaw is an auto generated low-level Go binding around an Ethereum contract.
type UtilsRaw struct {
	Contract *Utils // Generic contract binding to access the raw methods on
}

// UtilsCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type UtilsCallerRaw struct {
	Contract *UtilsCaller // Generic read-only contract binding to access the raw methods on
}

// UtilsTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type UtilsTransactorRaw struct {
	Contract *UtilsTransactor // Generic write-only contract binding to access the raw methods on
}

// NewUtils creates a new instance of Utils, bound to a specific deployed contract.
func NewUtils(address common.Address, backend bind.ContractBackend) (*Utils, error) {
	contract, err := bindUtils(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Utils{UtilsCaller: UtilsCaller{contract: contract}, UtilsTransactor: UtilsTransactor{contract: contract}, UtilsFilterer: UtilsFilterer{contract: contract}}, nil
}

// NewUtilsCaller creates a new read-only instance of Utils, bound to a specific deployed contract.
func NewUtilsCaller(address common.Address, caller bind.ContractCaller) (*UtilsCaller, error) {
	contract, err := bindUtils(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &UtilsCaller{contract: contract}, nil
}

// NewUtilsTransactor creates a new write-only instance of Utils, bound to a specific deployed contract.
func NewUtilsTransactor(address common.Address, transactor bind.ContractTransactor) (*UtilsTransactor, error) {
	contract, err := bindUtils(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &UtilsTransactor{contract: contract}, nil
}

// NewUtilsFilterer creates a new log filterer instance of Utils, bound to a specific deployed contract.
func NewUtilsFilterer(address common.Address, filterer bind.ContractFilterer) (*UtilsFilterer, error) {
	contract, err := bindUtils(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &UtilsFilterer{contract: contract}, nil
}

// bindUtils binds a generic wrapper to an already deployed contract.
func bindUtils(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := UtilsMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Utils *UtilsRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Utils.Contract.UtilsCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Utils *UtilsRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Utils.Contract.UtilsTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Utils *UtilsRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Utils.Contract.UtilsTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Utils *UtilsCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Utils.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Utils *UtilsTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Utils.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Utils *UtilsTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Utils.Contract.contract.Transact(opts, method, params...)
}
