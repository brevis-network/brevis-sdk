// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import "@openzeppelin/contracts/access/Ownable.sol";

import "../../lib/BrevisAppZkOnly.sol";

contract TradingVolumeExample is BrevisAppZkOnly, Ownable {
    event TradingVolumeAttested(address account, uint248 sumVolume, uint64 minBlockNum);

    bytes32 public vkHash;

    constructor(address _brevisRequest) BrevisAppZkOnly(_brevisRequest) Ownable(msg.sender) {}

    // BrevisQuery contract will call our callback once Brevis backend submits the proof.
    // This method is called with once the proof is verified.
      function handleProofResult(bytes32 _vkHash, bytes calldata _circuitOutput) internal override {
        // We need to check if the verifying key that Brevis used to verify the proof
        // generated by our circuit is indeed our designated verifying key. This proves
        // that the _circuitOutput is authentic
        require(vkHash == _vkHash, "invalid vk");
        (bytes32 _salt, uint248 sumVolume, uint64 minBlockNum, address addr) = decodeOutput(_circuitOutput);
        emit TradingVolumeAttested(addr, sumVolume, minBlockNum);
    }

    // In guest circuit we have:
    // api.OutputBytes32(Salt)
    // api.OutputUint(248, sumVolume)
    // api.OutputUint(64, minBlockNum)
    // api.OutputAddress(c.UserAddr)
    function decodeOutput(bytes calldata o) internal pure returns (bytes32, uint248, uint64, address) {
        // this variable is not used, it's only here because we wanted to show an example of outputting bytes32
        bytes32 salt = bytes32(o[0:32]);

        uint248 sumVolume = uint248(bytes31(o[32:63]));
        uint64 minBlockNum = uint64(bytes8(o[63:71]));
        address addr = address(bytes20(o[71:91]));
        return (salt, sumVolume, minBlockNum, addr);
    }

    function setVkHash(bytes32 _vkHash) external onlyOwner {
        vkHash = _vkHash;
    }
}
